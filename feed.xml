<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-24T08:29:03+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">802. Find Eventual Safe States</title><link href="https://zhengstar94.github.io//blog/2025/FindEventualSafeStates/" rel="alternate" type="text/html" title="802. Find Eventual Safe States"/><published>2025-01-24T00:00:00+00:00</published><updated>2025-01-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindEventualSafeStates</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindEventualSafeStates/"><![CDATA[<ul> <li>There is a directed graph of <code class="language-plaintext highlighter-rouge">n</code> nodes with each node labeled from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n - 1</code>. The graph is represented by a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">graph</code> where <code class="language-plaintext highlighter-rouge">graph[i]</code> is an integer array of nodes adjacent to node <code class="language-plaintext highlighter-rouge">i</code>, meaning there is an edge from node <code class="language-plaintext highlighter-rouge">i</code> to each node in <code class="language-plaintext highlighter-rouge">graph[i]</code>.</li> <li>A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong> (or another safe node).</li> <li>Return <em>an array containing all the <strong>safe nodes</strong> of the graph</em>. The answer should be sorted in <strong>ascending</strong> order.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: graph = [ [ 1,2],[2,3],[5],[0],[5],[],[ ] ]
Output: [2,4,5,6]
Explanation: The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: graph = [ [ 1,2,3,4],[1,2],[3,4],[0,4],[ ] ]
Output: [4]
Explanation:
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(V + E) time | O(V) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DFS</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindEventualSafeStates</span> <span class="o">{</span>

    <span class="cm">/**
     * Array to keep track of node states:
     * 0 = unvisited
     * 1 = currently being visited (in the current DFS path)
     * 2 = confirmed safe node
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">eventualSafeNodes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each node in the graph to check if it's safe</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">graph</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Case 1: If we encounter a node that's currently being visited,</span>
        <span class="c1">// we've found a cycle, and all nodes in this cycle are unsafe</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Case 2: If we encounter a node that's already been confirmed safe,</span>
        <span class="c1">// we can return true without further exploration</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Mark the current node as being visited (in the current DFS path)</span>
        <span class="c1">// This helps in cycle detection</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Explore all neighboring nodes</span>
        <span class="c1">// If any path from the current node leads to an unsafe node,</span>
        <span class="c1">// the current node is also unsafe</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">next</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">node</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">next</span><span class="o">,</span> <span class="n">graph</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>  <span class="c1">// Found an unsafe path</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we reach here, all paths from this node are safe</span>
        <span class="c1">// Mark the node as a confirmed safe node</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  <span class="c1">// Node is safe</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Graph with multiple safe nodes</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">5</span><span class="o">},{</span><span class="mi">0</span><span class="o">},{</span><span class="mi">5</span><span class="o">},{},{</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">eventualSafeNodes</span><span class="o">(</span><span class="n">graph1</span><span class="o">));</span> <span class="c1">// Expected output: [2,4,5,6]</span>

        <span class="c1">// Test Case 2: Graph with only one safe node</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">eventualSafeNodes</span><span class="o">(</span><span class="n">graph2</span><span class="o">));</span> <span class="c1">// Expected output: [4]</span>

        <span class="c1">// Test Case 3: Graph where all nodes are safe</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">},{</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">3</span><span class="o">},{</span><span class="mi">4</span><span class="o">},{</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">eventualSafeNodes</span><span class="o">(</span><span class="n">graph3</span><span class="o">));</span> <span class="c1">// Expected output: [0,1,2,3,4]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DFS"/><category term="Medium"/><summary type="html"><![CDATA[There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i]. A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.]]></summary></entry><entry><title type="html">(Review) 2944. Minimum Number of Coins for Fruits</title><link href="https://zhengstar94.github.io//blog/2025/MinimumNumberOfCoinsForFruits/" rel="alternate" type="text/html" title="(Review) 2944. Minimum Number of Coins for Fruits"/><published>2025-01-24T00:00:00+00:00</published><updated>2025-01-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumNumberOfCoinsForFruits</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumNumberOfCoinsForFruits/"><![CDATA[<ul> <li>You are given an <strong>1-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">prices</code> where <code class="language-plaintext highlighter-rouge">prices[i]</code> denotes the number of coins needed to purchase the <code class="language-plaintext highlighter-rouge">ith</code> fruit.</li> <li>The fruit market has the following reward for each fruit: <ul> <li>If you purchase the <code class="language-plaintext highlighter-rouge">ith</code> fruit at <code class="language-plaintext highlighter-rouge">prices[i]</code> coins, you can get any number of the next <code class="language-plaintext highlighter-rouge">i</code> fruits for free.</li> </ul> </li> <li><strong>Note</strong> that even if you <strong>can</strong> take fruit <code class="language-plaintext highlighter-rouge">j</code> for free, you can still purchase it for <code class="language-plaintext highlighter-rouge">prices[j]</code> coins to receive its reward.</li> <li>Return the <strong>minimum</strong> number of coins needed to acquire all the fruits.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [3,1,2]
Output: 4

Explanation:
Purchase the 1st fruit with prices[0] = 3 coins, you are allowed to take the 2nd fruit for free.
Purchase the 2nd fruit with prices[1] = 1 coin, you are allowed to take the 3rd fruit for free.
Take the 3rd fruit for free.

Note that even though you could take the 2nd fruit for free as a reward of buying 1st fruit, you purchase it to receive its reward, which is more optimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [1,10,1,1]
Output: 2

Explanation:
Purchase the 1st fruit with prices[0] = 1 coin, you are allowed to take the 2nd fruit for free.
Take the 2nd fruit for free.
Purchase the 3rd fruit for prices[2] = 1 coin, you are allowed to take the 4th fruit for free.
Take the 4th fruit for free.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [26,18,6,12,49,7,45,45]
Output: 39

Explanation:
Purchase the 1st fruit with prices[0] = 26 coin, you are allowed to take the 2nd fruit for free.
Take the 2nd fruit for free.
Purchase the 3rd fruit for prices[2] = 6 coin, you are allowed to take the 4th, 5th and 6th (the next three) fruits for free.
Take the 4th fruit for free.
Take the 5th fruit for free.
Purchase the 6th fruit with prices[5] = 7 coin, you are allowed to take the 8th and 9th fruit for free.
Take the 7th fruit for free.
Take the 8th fruit for free.

Note that even though you could take the 6th fruit for free as a reward of buying 3rd fruit, you purchase it to receive its reward, which is more optimal.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumNumberOfCoinsForFruits</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumCoins</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Number of fruits</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// If there are no fruits, the cost is 0</span>
        <span class="o">}</span>

        <span class="c1">// dp[i] represents the minimum cost to purchase the first (i+1) fruits</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">// Initialize all values to a large number</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// The first fruit must be purchased, so its cost is prices[0]</span>

        <span class="c1">// Iterate through each fruit starting from the second one</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// The starting point for j is i/2 because purchasing the j-th fruit</span>
            <span class="c1">// allows you to get the next j fruits for free</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Iterate through all possible j values that can cover the i-th fruit</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// prev represents the cost to purchase the first j fruits</span>
                <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>

                <span class="c1">// If prev is valid (not Integer.MAX_VALUE), update dp[i]</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum cost to purchase all fruits</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumCoins</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumCoins</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">}));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumCoins</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">26</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">49</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">45</span><span class="o">,</span> <span class="mi">45</span><span class="o">}));</span> <span class="c1">// Expected output: 39</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><category term="Review"/><summary type="html"><![CDATA[You are given an 1-indexed integer array prices where prices[i] denotes the number of coins needed to purchase the ith fruit. The fruit market has the following reward for each fruit: If you purchase the ith fruit at prices[i] coins, you can get any number of the next i fruits for free. Note that even if you can take fruit j for free, you can still purchase it for prices[j] coins to receive its reward. Return the minimum number of coins needed to acquire all the fruits.]]></summary></entry><entry><title type="html">1267. Count Servers that Communicate</title><link href="https://zhengstar94.github.io//blog/2025/CountServersThatCommunicate/" rel="alternate" type="text/html" title="1267. Count Servers that Communicate"/><published>2025-01-23T00:00:00+00:00</published><updated>2025-01-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountServersThatCommunicate</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountServersThatCommunicate/"><![CDATA[<ul> <li>You are given a map of a server center, represented as a <code class="language-plaintext highlighter-rouge">m * n</code> integer matrix <code class="language-plaintext highlighter-rouge">grid</code>, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.</li> <li>Return the number of servers that communicate with any other server.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,0],[0,1 ] ]
Output: 0
Explanation: No servers can communicate with others.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,0],[1,1 ] ]
Output: 3
Explanation: All three servers can communicate with at least one other server.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1 ] ]
Output: 4
Explanation: The two servers  in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n + m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountServersThatCommunicate</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countServers</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases for null or empty grid</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">grid</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Get grid dimensions</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>     <span class="c1">// Number of rows</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>  <span class="c1">// Number of columns</span>

        <span class="c1">// Arrays to store count of servers in each row and column</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">rowCount</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">colCount</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// First pass: Count servers in each row and column</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span> <span class="o">[</span> <span class="n">i</span> <span class="o">][</span> <span class="n">j</span> <span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">rowCount</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span> <span class="c1">// Increment server count for current row</span>
                    <span class="n">colCount</span><span class="o">[</span><span class="n">j</span><span class="o">]++;</span> <span class="c1">// Increment server count for current column</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Second pass: Count servers that can communicate</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// A server can communicate if there's another server in same row or column</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">rowCount</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">colCount</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: No servers can communicate</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">countServers</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 2: All servers can communicate</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">countServers</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 3: Some servers can communicate</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">countServers</span><span class="o">(</span><span class="n">grid3</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 4: Empty grid</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid4</span> <span class="o">=</span> <span class="o">{</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">countServers</span><span class="o">(</span><span class="n">grid4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 5: Single server (cannot communicate)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid5</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5 result: "</span> <span class="o">+</span> <span class="n">countServers</span><span class="o">(</span><span class="n">grid5</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column. Return the number of servers that communicate with any other server.]]></summary></entry><entry><title type="html">2831. Find the Longest Equal Subarray</title><link href="https://zhengstar94.github.io//blog/2025/FindTheLongestEqualSubarray/" rel="alternate" type="text/html" title="2831. Find the Longest Equal Subarray"/><published>2025-01-23T00:00:00+00:00</published><updated>2025-01-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheLongestEqualSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheLongestEqualSubarray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>A subarray is called <strong>equal</strong> if all of its elements are equal. Note that the empty subarray is an <strong>equal</strong> subarray.</li> <li>Return <em>the length of the <strong>longest</strong> possible equal subarray after deleting <strong>at most</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>elements from</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>A <strong>subarray</strong> is a contiguous, possibly empty sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,2,3,1,3], k = 3
Output: 3
Explanation: It's optimal to delete the elements at index 2 and index 4.
After deleting them, nums becomes equal to [1, 3, 3, 3].
The longest equal subarray starts at i = 1 and ends at j = 3 with length equal to 3.
It can be proven that no longer equal subarrays can be created.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2,2,1,1], k = 2
Output: 4
Explanation: It's optimal to delete the elements at index 2 and index 3.
After deleting them, nums becomes equal to [1, 1, 1, 1].
The array itself is an equal subarray, so the answer is 4.
It can be proven that no longer equal subarrays can be created.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheLongestEqualSubarray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestEqualSubarray</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="c1">// Create an array of ArrayLists to store position differences for each number</span>
        <span class="c1">// Index represents the number, and the list stores its position differences</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">posLists</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Initialize each ArrayList in posLists</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">posLists</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>

        <span class="c1">// First loop: Build the position difference lists</span>
        <span class="c1">// For each number, calculate and store its position difference</span>
        <span class="c1">// Position difference = current index - number of times this number has appeared</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">posLists</span><span class="o">[</span><span class="n">x</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">posLists</span><span class="o">[</span><span class="n">x</span><span class="o">].</span><span class="na">size</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="c1">// Initialize the answer variable to store the maximum length</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Second loop: Process each number's position difference list</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">posLists</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Optimization: Skip if current list size is not greater than current answer</span>
            <span class="c1">// Because it cannot produce a longer subsequence</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">ans</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Initialize left pointer for sliding window</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// Third loop: Slide the window to find the longest valid subsequence</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// While loop: Adjust the window size when too many elements need to be deleted</span>
                <span class="c1">// If difference between positions is greater than k,</span>
                <span class="c1">// it means we need to delete more elements than allowed (k)</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="n">pos</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Move left pointer to shrink the window</span>
                    <span class="n">left</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="c1">// Update answer with maximum window size found so far</span>
                <span class="c1">// right - left + 1 represents the current window size</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output is 3</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">longestEqualSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>

        <span class="c1">// Test case 2: Expected output is 4</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">longestEqualSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>

        <span class="c1">// Test case 3: Expected output is 4</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums3</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">longestEqualSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums and an integer k. A subarray is called equal if all of its elements are equal. Note that the empty subarray is an equal subarray. Return the length of the longest possible equal subarray after deleting at most k elements from nums. A subarray is a contiguous, possibly empty sequence of elements within an array.]]></summary></entry><entry><title type="html">2271. Maximum White Tiles Covered by a Carpet</title><link href="https://zhengstar94.github.io//blog/2025/MaximumWhiteTilesCoveredByACarpet/" rel="alternate" type="text/html" title="2271. Maximum White Tiles Covered by a Carpet"/><published>2025-01-23T00:00:00+00:00</published><updated>2025-01-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumWhiteTilesCoveredByACarpet</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumWhiteTilesCoveredByACarpet/"><![CDATA[<ul> <li>You are given a 2D integer array <code class="language-plaintext highlighter-rouge">tiles</code> where <code class="language-plaintext highlighter-rouge">tiles[i] = [li, ri]</code> represents that every tile <code class="language-plaintext highlighter-rouge">j</code> in the range <code class="language-plaintext highlighter-rouge">li &lt;= j &lt;= ri</code> is colored white.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">carpetLen</code>, the length of a single carpet that can be placed <strong>anywhere</strong>.</li> <li>Return <em>the <strong>maximum</strong> number of white tiles that can be covered by the carpet</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tiles = [ [1,5],[10,11],[12,18],[20,25],[30,32 ] ], carpetLen = 10
Output: 9
Explanation: Place the carpet starting on tile 10. 
It covers 9 white tiles, so we return 9.
Note that there may be other places where the carpet covers 9 white tiles.
It can be shown that the carpet cannot cover more than 9 white tiles.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tiles = [ [ 10,11],[1,1 ] ], carpetLen = 2
Output: 2
Explanation: Place the carpet starting on tile 10. 
It covers 2 white tiles, so we return 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumWhiteTilesCoveredByACarpet</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumWhiteTiles</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">tiles</span><span class="o">,</span> <span class="kt">int</span> <span class="n">carpetLen</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort tiles array by left endpoint in ascending order</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">tiles</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// Store the maximum number of white tiles that can be covered</span>
        <span class="kt">int</span> <span class="n">cover</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Track the current number of tiles covered</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Left pointer for the sliding window</span>

        <span class="c1">// Iterate through each tile interval</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tile</span> <span class="o">:</span> <span class="n">tiles</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">tl</span> <span class="o">=</span> <span class="n">tile</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Left endpoint of current interval</span>
            <span class="kt">int</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">tile</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// Right endpoint of current interval</span>

            <span class="c1">// Add number of tiles in current interval to cover</span>
            <span class="c1">// Formula: right - left + 1 gives the count of tiles in current interval</span>
            <span class="n">cover</span> <span class="o">+=</span> <span class="n">tr</span> <span class="o">-</span> <span class="n">tl</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// While the carpet cannot fully cover from left interval to current interval</span>
            <span class="c1">// Need to remove tiles from left side that are out of carpet's range</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">tiles</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">carpetLen</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">tr</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Remove tiles count of the leftmost interval that's out of range</span>
                <span class="n">cover</span> <span class="o">-=</span> <span class="n">tiles</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">tiles</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">left</span><span class="o">++;</span> <span class="c1">// Move left pointer to next interval</span>
            <span class="o">}</span>

            <span class="c1">// Calculate uncovered tiles within the current carpet placement</span>
            <span class="c1">// tr - carpetLen + 1: leftmost position carpet needs to start to cover tr</span>
            <span class="c1">// tiles[left][0]: actual leftmost position of current tiles</span>
            <span class="c1">// Difference gives number of tiles that cannot be covered</span>
            <span class="kt">int</span> <span class="n">uncover</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">tr</span> <span class="o">-</span> <span class="n">carpetLen</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tiles</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Update answer: maximum between current answer and (covered tiles - uncovered tiles)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">cover</span> <span class="o">-</span> <span class="n">uncover</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Complex case with multiple intervals</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">tiles1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">},</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">18</span><span class="o">},</span> <span class="o">{</span><span class="mi">20</span><span class="o">,</span> <span class="mi">25</span><span class="o">},</span> <span class="o">{</span><span class="mi">30</span><span class="o">,</span> <span class="mi">32</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">carpetLen1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">maximumWhiteTiles</span><span class="o">(</span><span class="n">tiles1</span><span class="o">,</span> <span class="n">carpetLen1</span><span class="o">));</span> <span class="c1">// Expected output: 9</span>

        <span class="c1">// Test Case 2: Consecutive intervals with small gaps</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">tiles2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">11</span><span class="o">,</span> <span class="mi">13</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">carpetLen2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">maximumWhiteTiles</span><span class="o">(</span><span class="n">tiles2</span><span class="o">,</span> <span class="n">carpetLen2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Intervals with large gaps</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">tiles3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">20</span><span class="o">},</span> <span class="o">{</span><span class="mi">25</span><span class="o">,</span> <span class="mi">30</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">carpetLen3</span> <span class="o">=</span> <span class="mi">15</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">maximumWhiteTiles</span><span class="o">(</span><span class="n">tiles3</span><span class="o">,</span> <span class="n">carpetLen3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 2D integer array tiles where tiles[i] = [li, ri] represents that every tile j in the range li &lt;= j &lt;= ri is colored white. You are also given an integer carpetLen, the length of a single carpet that can be placed anywhere. Return the maximum number of white tiles that can be covered by the carpet.]]></summary></entry><entry><title type="html">1765. Map of Highest Peak</title><link href="https://zhengstar94.github.io//blog/2025/MapOfHighestPeak/" rel="alternate" type="text/html" title="1765. Map of Highest Peak"/><published>2025-01-22T00:00:00+00:00</published><updated>2025-01-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MapOfHighestPeak</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MapOfHighestPeak/"><![CDATA[<ul> <li> <p>You are given an integer matrix <code class="language-plaintext highlighter-rouge">isWater</code> of size <code class="language-plaintext highlighter-rouge">m x n</code> that represents a map of <strong>land</strong> and <strong>water</strong> cells.</p> <ul> <li>If <code class="language-plaintext highlighter-rouge">isWater [ i ] [ j ] == 0</code>, cell <code class="language-plaintext highlighter-rouge">(i, j)</code> is a <strong>land</strong> cell.</li> <li>If <code class="language-plaintext highlighter-rouge">isWater [ i ] [ j ] == 1</code>, cell <code class="language-plaintext highlighter-rouge">(i, j)</code> is a <strong>water</strong> cell.</li> </ul> </li> <li> <p>You must assign each cell a height in a way that follows these rules:</p> <ul> <li>The height of each cell must be non-negative.</li> <li>If the cell is a <strong>water</strong> cell, its height must be <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>Any two adjacent cells must have an absolute height difference of <strong>at most</strong> <code class="language-plaintext highlighter-rouge">1</code>. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</li> </ul> </li> <li> <p>Find an assignment of heights such that the maximum height in the matrix is <strong>maximized</strong>.</p> <p>Return <em>an integer matrix</em> <code class="language-plaintext highlighter-rouge">height</code> <em>of size</em> <code class="language-plaintext highlighter-rouge">m x n</code> <em>where</em> <code class="language-plaintext highlighter-rouge">height[i][j]</code> <em>is cell</em> <code class="language-plaintext highlighter-rouge">(i, j)</code><em>’s height. If there are multiple solutions, return <strong>any</strong> of them</em>.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: isWater = [ [ 0,1],[0,0 ] ]
Output: [ [ 1,0],[2,1 ] ]
Explanation: The image shows the assigned heights of each cell.
The blue cell is the water cell, and the green cells are the land cells.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: isWater = [ [ 0,0,1],[1,0,0],[0,0,0 ] ]
Output: [ [ 1,1,0],[0,1,1],[1,2,2 ] ]
Explanation: A height of 2 is the maximum possible height of any assignment.
Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n * m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BFS</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MapOfHighestPeak</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">highestPeak</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Define directions for adjacent cells (up, down, left, right)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">directions</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>

        <span class="c1">// Initialize queue for BFS (Breadth-First Search)</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Get matrix dimensions</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">isWater</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>    <span class="c1">// Number of rows</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">isWater</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Number of columns</span>

        <span class="c1">// Initialize the height matrix</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isWater</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Add water cells to queue as starting points</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="n">isWater</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Set water height to 0</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">isWater</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// Mark land cells as unvisited</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// BFS to assign heights to land cells</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Get current cell from queue</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">point</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Current row</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// Current column</span>

            <span class="c1">// Check all four adjacent cells</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">dir:</span> <span class="n">directions</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Calculate new coordinates</span>
                <span class="kt">int</span> <span class="n">newX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">newY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// Validate new coordinates and check if cell is unvisited</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">newX</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">newY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">newY</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">isWater</span><span class="o">[</span><span class="n">newX</span><span class="o">][</span><span class="n">newY</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Set height of new cell to current cell's height + 1</span>
                    <span class="n">isWater</span><span class="o">[</span><span class="n">newX</span><span class="o">][</span><span class="n">newY</span><span class="o">]</span> <span class="o">=</span> <span class="n">isWater</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="c1">// Add new cell to queue for further processing</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">newX</span><span class="o">,</span> <span class="n">newY</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">isWater</span><span class="o">;</span> <span class="c1">// Return the completed height matrix</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 测试用例</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Simple 2x2 matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">highestPeak</span><span class="o">(</span><span class="n">isWater1</span><span class="o">));</span>
        <span class="c1">// Expected output:</span>
        <span class="c1">// [1, 0]</span>
        <span class="c1">// [2, 1]</span>

        <span class="c1">// Test Case 2: 3x3 matrix with multiple water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2 Result:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">highestPeak</span><span class="o">(</span><span class="n">isWater2</span><span class="o">));</span>
        <span class="c1">// Expected output:</span>
        <span class="c1">// [1, 1, 0]</span>
        <span class="c1">// [0, 1, 1]</span>
        <span class="c1">// [1, 2, 2]</span>

        <span class="c1">// Test Case 3: All water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater4</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3 Result:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">highestPeak</span><span class="o">(</span><span class="n">isWater4</span><span class="o">));</span>
        <span class="c1">// Expected output:</span>
        <span class="c1">// [0, 0]</span>
        <span class="c1">// [0, 0]</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BFS"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer matrix isWater of size m x n that represents a map of land and water cells.]]></summary></entry><entry><title type="html">1561. Maximum Number of Coins You Can Get</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfCoinsYouCanGet/" rel="alternate" type="text/html" title="1561. Maximum Number of Coins You Can Get"/><published>2025-01-22T00:00:00+00:00</published><updated>2025-01-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfCoinsYouCanGet</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfCoinsYouCanGet/"><![CDATA[<ul> <li> <p>There are <code class="language-plaintext highlighter-rouge">3n</code> piles of coins of varying size, you and your friends will take piles of coins as follows:</p> <ul> <li>In each step, you will choose <strong>any</strong> <code class="language-plaintext highlighter-rouge">3</code> piles of coins (not necessarily consecutive.</li> <li>Of your choice, Alice will pick the pile with the maximum number of coins.</li> <li>You will pick the next pile with the maximum number of coins.</li> <li>Your friend Bob will pick the last pile.</li> <li>Repeat until there are no more piles of coins.</li> </ul> </li> <li> <p>Given an array of integers <code class="language-plaintext highlighter-rouge">piles</code> where <code class="language-plaintext highlighter-rouge">piles[i]</code> is the number of coins in the <code class="language-plaintext highlighter-rouge">i^th</code> pile.</p> <p>Return the maximum number of coins that you can have.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: piles = [2,4,1,2,7,8]
Output: 9
Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: piles = [2,4,5]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfCoinsYouCanGet</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxCoins</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">piles</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Sort the piles array in ascending order</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">piles</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">piles</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Store the number of piles</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// Variable to store the total coins you can get</span>

        <span class="c1">// Step 2: Traverse the array in reverse to select the "second largest" piles for yourself</span>
        <span class="c1">// Start from the second last pile (since the largest pile is for Alice),</span>
        <span class="c1">// stop at index n/3 (as Bob takes n/3 smallest piles), and decrement by 2 after each round</span>
        <span class="c1">// (to skip Alice's and Bob's piles).</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">piles</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Add the second largest pile to your total</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> <span class="c1">// Return the total coins you can get</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">piles1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for Test Case 1: "</span> <span class="o">+</span> <span class="n">maxCoins</span><span class="o">(</span><span class="n">piles1</span><span class="o">));</span> <span class="c1">// Expected Output: 9</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">piles2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for Test Case 2: "</span> <span class="o">+</span> <span class="n">maxCoins</span><span class="o">(</span><span class="n">piles2</span><span class="o">));</span> <span class="c1">// Expected Output: 4</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">piles3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for Test Case 3: "</span> <span class="o">+</span> <span class="n">maxCoins</span><span class="o">(</span><span class="n">piles3</span><span class="o">));</span> <span class="c1">// Expected Output: 18</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:]]></summary></entry><entry><title type="html">2516. Take K of Each Character From Left and Right</title><link href="https://zhengstar94.github.io//blog/2025/TakeKOfEachCharacterFromLeftAndRight/" rel="alternate" type="text/html" title="2516. Take K of Each Character From Left and Right"/><published>2025-01-22T00:00:00+00:00</published><updated>2025-01-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TakeKOfEachCharacterFromLeftAndRight</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TakeKOfEachCharacterFromLeftAndRight/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> consisting of the characters <code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'b'</code>, and <code class="language-plaintext highlighter-rouge">'c'</code> and a non-negative integer <code class="language-plaintext highlighter-rouge">k</code>. Each minute, you may take either the <strong>leftmost</strong> character of <code class="language-plaintext highlighter-rouge">s</code>, or the <strong>rightmost</strong> character of <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Return <em>the <strong>minimum</strong> number of minutes needed for you to take <strong>at least</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>of each character, or return</em> <code class="language-plaintext highlighter-rouge">-1</code> <em>if it is not possible to take</em> <code class="language-plaintext highlighter-rouge">k</code> <em>of each character.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aabaaaacaabc", k = 2
Output: 8
Explanation: 
Take three characters from the left of s. You now have two 'a' characters, and one 'b' character.
Take five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.
A total of 3 + 5 = 8 minutes is needed.
It can be proven that 8 is the minimum number of minutes needed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "a", k = 1
Output: -1
Explanation: It is not possible to take one 'b' or 'c' so return -1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TakeKOfEachCharacterFromLeftAndRight</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">takeCharacters</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert string to char array for better access efficiency</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="c1">// Count the frequency of each character ('a', 'b', 'c')</span>
        <span class="c1">// cnt[0] stores count of 'a', cnt[1] for 'b', cnt[2] for 'c'</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Check if we have enough characters of each type</span>
        <span class="c1">// If any character appears less than k times, it's impossible to achieve the goal</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">||</span> <span class="n">cnt</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">||</span> <span class="n">cnt</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Find the longest valid substring (characters within window don't need to be taken)</span>
        <span class="c1">// mx: stores the maximum length of valid window</span>
        <span class="c1">// left: left boundary of sliding window</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Slide the window from left to right</span>
        <span class="c1">// right: right boundary of sliding window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Include current character in window</span>
            <span class="c1">// Convert character to index (0 for 'a', 1 for 'b', 2 for 'c')</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="c1">// Decrease count as this character is now in window (not taken)</span>
            <span class="n">cnt</span><span class="o">[</span><span class="n">c</span><span class="o">]--;</span>

            <span class="c1">// Shrink window if we don't have enough characters outside window</span>
            <span class="c1">// While count of any character outside window is less than k</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">cnt</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add back the character at left pointer (character becomes available again)</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum window length if current window is valid</span>
            <span class="c1">// Window is valid when all characters outside it appear at least k times</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Final result is total length minus longest valid substring length</span>
        <span class="c1">// This gives us minimum number of characters we need to take</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">mx</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Standard case with multiple occurrences</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"aabaaaacaabc"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">takeCharacters</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>  <span class="c1">// Expected: 8</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Impossible case (not enough characters)</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">takeCharacters</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>  <span class="c1">// Expected: -1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Minimum valid case (exact match)</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s3</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">takeCharacters</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>  <span class="c1">// Expected: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Longer string with repeated pattern</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"aabcabcabc"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s4</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">takeCharacters</span><span class="o">(</span><span class="n">s4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span>  <span class="c1">// Expected: 6</span>

        <span class="c1">// Test Case 5: Basic pattern repeated once</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abcabc"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s5</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">takeCharacters</span><span class="o">(</span><span class="n">s5</span><span class="o">,</span> <span class="n">k5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s. Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.]]></summary></entry><entry><title type="html">1838. Frequency of the Most Frequent Element</title><link href="https://zhengstar94.github.io//blog/2025/FrequencyOfTheMostFrequentElement/" rel="alternate" type="text/html" title="1838. Frequency of the Most Frequent Element"/><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FrequencyOfTheMostFrequentElement</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FrequencyOfTheMostFrequentElement/"><![CDATA[<ul> <li>The <strong>frequency</strong> of an element is the number of times it occurs in an array.</li> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>. In one operation, you can choose an index of <code class="language-plaintext highlighter-rouge">nums</code> and increment the element at that index by <code class="language-plaintext highlighter-rouge">1</code>.</li> <li>Return <em>the <strong>maximum possible frequency</strong> of an element after performing <strong>at most</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>operations</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,9,6], k = 2
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FrequencyOfTheMostFrequentElement</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxFrequency</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort array to enable sliding window approach</span>
        <span class="c1">// After sorting, we ensure that elements in any window can only be increased to match the rightmost element</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// Initialize sliding window pointers and variables</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                  <span class="c1">// Left boundary of sliding window</span>
        <span class="kt">int</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>             <span class="c1">// Sum of all elements in current window</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>                <span class="c1">// Minimum possible result is 1 (single element)</span>

        <span class="c1">// Iterate through array with right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to window sum</span>
            <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="cm">/**
             * Key Part: Window Validity Check
             * Formula: windowSum + k &lt; nums[right] * (right - left + 1)
             *
             * Left side (windowSum + k):
             * - windowSum: current sum of all elements in window
             * - k: available operations we can use
             * - Together they represent the maximum sum we can achieve with given operations
             *
             * Right side (nums[right] * (right - left + 1)):
             * - nums[right]: target value (maximum element in current window)
             * - (right - left + 1): window size
             * - Product represents total sum needed to make all elements equal to nums[right]
             *
             * If left side &lt; right side: window is invalid and needs shrinking
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">windowSum</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Shrink window by removing leftmost element</span>
                <span class="n">windowSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update result with current valid window size</span>
            <span class="c1">// Window size represents the frequency we can achieve</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with small array</span>
        <span class="c1">// We can increment 1 three times and 2 two times to get [4,4,4]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Test Case 2: Multiple optimal solutions possible</span>
        <span class="c1">// Can either make two 4s, two 8s, or two 13s</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test Case 3: Limited operations available</span>
        <span class="c1">// Can't make more than one element equal with only 2 operations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 4: Array with duplicates</span>
        <span class="c1">// Tests handling of already existing frequencies</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span> <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[The frequency of an element is the number of times it occurs in an array. You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1. Return the maximum possible frequency of an element after performing at most k operations.]]></summary></entry><entry><title type="html">2017. Grid Game</title><link href="https://zhengstar94.github.io//blog/2025/GridGame/" rel="alternate" type="text/html" title="2017. Grid Game"/><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/GridGame</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/GridGame/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D array <code class="language-plaintext highlighter-rouge">grid</code> of size <code class="language-plaintext highlighter-rouge">2 x n</code>, where <code class="language-plaintext highlighter-rouge">grid[r][c]</code> represents the number of points at position <code class="language-plaintext highlighter-rouge">(r, c)</code> on the matrix. Two robots are playing a game on this matrix.</li> <li>Both robots initially start at <code class="language-plaintext highlighter-rouge">(0, 0)</code> and want to reach <code class="language-plaintext highlighter-rouge">(1, n-1)</code>. Each robot may only move to the <strong>right</strong> (<code class="language-plaintext highlighter-rouge">(r, c)</code> to <code class="language-plaintext highlighter-rouge">(r, c + 1)</code>) or <strong>down</strong> (<code class="language-plaintext highlighter-rouge">(r, c)</code> to <code class="language-plaintext highlighter-rouge">(r + 1, c)</code>).</li> <li>At the start of the game, the <strong>first</strong> robot moves from <code class="language-plaintext highlighter-rouge">(0, 0)</code> to <code class="language-plaintext highlighter-rouge">(1, n-1)</code>, collecting all the points from the cells on its path. For all cells <code class="language-plaintext highlighter-rouge">(r, c)</code> traversed on the path, <code class="language-plaintext highlighter-rouge">grid[r][c]</code> is set to <code class="language-plaintext highlighter-rouge">0</code>. Then, the <strong>second</strong> robot moves from <code class="language-plaintext highlighter-rouge">(0, 0)</code> to <code class="language-plaintext highlighter-rouge">(1, n-1)</code>, collecting the points on its path. Note that their paths may intersect with one another.</li> <li>The <strong>first</strong> robot wants to <strong>minimize</strong> the number of points collected by the <strong>second</strong> robot. In contrast, the <strong>second</strong> robot wants to <strong>maximize</strong> the number of points it collects. If both robots play <strong>optimally</strong>, return <em>the <strong>number of points</strong> collected by the <strong>second</strong> robot.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 2,5,4],[1,5,1 ] ]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 0 + 4 + 0 = 4 points.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 3,3,1],[8,5,2 ] ]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 3 + 1 + 0 = 4 points.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,3,1,15],[1,3,3,1 ] ]
Output: 7
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GridGame</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">gridGame</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Length of each row in the grid</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Prefix sum arrays for efficient range sum calculations</span>
        <span class="c1">// preSum1: prefix sums for top row</span>
        <span class="c1">// preSum2: prefix sums for bottom row</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">preSum1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">preSum2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Calculate prefix sums for both rows</span>
        <span class="c1">// This allows O(1) time range sum queries</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">preSum1</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
            <span class="n">preSum2</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Initialize answer with maximum possible value</span>
        <span class="c1">// We will minimize this value as we find better solutions</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Try each possible turning point for Robot 1</span>
        <span class="c1">// For each column i, calculate the maximum points Robot 2 can get</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate remaining points in top row after column i</span>
            <span class="c1">// This represents one possible path for Robot 2</span>
            <span class="kt">long</span> <span class="n">top</span> <span class="o">=</span> <span class="n">preSum1</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum1</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Calculate points in bottom row before column i</span>
            <span class="c1">// This represents another possible path for Robot 2</span>
            <span class="kt">long</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">preSum2</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="c1">// Robot 2 will choose the path with maximum points</span>
            <span class="kt">long</span> <span class="n">secondRobot</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">top</span><span class="o">,</span> <span class="n">bottom</span><span class="o">);</span>

            <span class="c1">// Update answer if this is the smallest maximum we've found</span>
            <span class="c1">// We want to minimize the maximum points Robot 2 can get</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">secondRobot</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum possible maximum points for Robot 2</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 主方法，包含测试用例</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic example</span>
        <span class="c1">// Grid: [ [2,5,4],</span>
        <span class="c1">//        [1,5,1] ]</span>
        <span class="c1">// Expected output: 4</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span>

        <span class="c1">//Additional test cases can be uncommented for further testing</span>
        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">15</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: More complex example</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid4</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">20</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">15</span><span class="o">},</span>
                        <span class="o">{</span><span class="mi">20</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid4</span><span class="o">));</span>

    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix. Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)). At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another. The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.]]></summary></entry></feed>