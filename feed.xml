<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-19T05:01:50+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2266. Count Number of Texts</title><link href="https://zhengstar94.github.io//blog/2025/CountNumberOfTexts/" rel="alternate" type="text/html" title="2266. Count Number of Texts"/><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountNumberOfTexts</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountNumberOfTexts/"><![CDATA[<ul> <li>Alice is texting Bob using her phone. The <strong>mapping</strong> of digits to letters is shown in the figure below.</li> <li>In order to <strong>add</strong> a letter, Alice has to <strong>press</strong> the key of the corresponding digit <code class="language-plaintext highlighter-rouge">i</code> times, where <code class="language-plaintext highlighter-rouge">i</code> is the position of the letter in the key. <ul> <li>For example, to add the letter <code class="language-plaintext highlighter-rouge">'s'</code>, Alice has to press <code class="language-plaintext highlighter-rouge">'7'</code> four times. Similarly, to add the letter <code class="language-plaintext highlighter-rouge">'k'</code>, Alice has to press <code class="language-plaintext highlighter-rouge">'5'</code> twice.</li> <li>Note that the digits <code class="language-plaintext highlighter-rouge">'0'</code> and <code class="language-plaintext highlighter-rouge">'1'</code> do not map to any letters, so Alice <strong>does not</strong> use them.</li> </ul> </li> <li>However, due to an error in transmission, Bob did not receive Alice’s text message but received a <strong>string of pressed keys</strong> instead. <ul> <li>For example, when Alice sent the message <code class="language-plaintext highlighter-rouge">"bob"</code>, Bob received the string <code class="language-plaintext highlighter-rouge">"2266622"</code>.</li> </ul> </li> <li>Given a string <code class="language-plaintext highlighter-rouge">pressedKeys</code> representing the string received by Bob, return <em>the <strong>total number of possible text messages</strong> Alice could have sent</em>.</li> <li>Since the answer may be very large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">10^9 + 7</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: pressedKeys = "22233"
Output: 8
Explanation:
The possible text messages Alice could have sent are:
"aaadd", "abdd", "badd", "cdd", "aaae", "abe", "bae", and "ce".
Since there are 8 possible messages, we return 8.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: pressedKeys = "222222222222222222222222222222222222"
Output: 82876089
Explanation:
There are 2082876103 possible text messages Alice could have sent.
Since we need to return the answer modulo 10^9 + 7, we return 2082876103 % (10^9 + 7) = 82876089.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountNumberOfTexts</span> <span class="o">{</span>

    <span class="c1">// Define the modulus as required by the problem to avoid overflow</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1_000_000_007</span><span class="o">;</span>

    <span class="c1">// Method to calculate the total number of text messages that can be formed</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countTexts</span><span class="o">(</span><span class="nc">String</span> <span class="n">pressedKeys</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// Get the length of the input string pressedKeys</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>  <span class="c1">// Create a dp array of size n+1 to store results for subproblems</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Base case: An empty sequence has exactly one way to form it (do nothing)</span>

        <span class="c1">// Iterate from the 1st pressed key to the nth pressed key</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add the number of ways using the last single key press (always valid)</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// Single key usage, inherits from dp[i-1]</span>

            <span class="c1">// Check if the current key can combine with the previous key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If they are the same, add the values from dp[i-2] (combining two keys)</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">])</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the current key can combine with the last two keys (three keys total)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If three consecutive keys are the same, add the values from dp[i-3]</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">])</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the current key can combine with the last three keys (four keys total)</span>
            <span class="c1">// This is only valid for the keys '7' and '9', as they can form up to 4-letter combinations</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'7'</span> <span class="o">||</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'9'</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">4</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If four consecutive keys are the same and the key is 7 or 9, add the values from dp[i-4]</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">4</span><span class="o">])</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The final result is stored in dp[n], the number of ways to form messages from the entire string</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">// Main method to test the implementation with examples</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">pressedKeys1</span> <span class="o">=</span> <span class="s">"22233"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countTexts</span><span class="o">(</span><span class="n">pressedKeys1</span><span class="o">));</span> <span class="c1">// Expected output: 8</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">pressedKeys2</span> <span class="o">=</span> <span class="s">"222222222222222222222222222222222222"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countTexts</span><span class="o">(</span><span class="n">pressedKeys2</span><span class="o">));</span> <span class="c1">// Expected output: 82876089</span>

        <span class="c1">// Additional test case</span>
        <span class="nc">String</span> <span class="n">pressedKeys3</span> <span class="o">=</span> <span class="s">"2266622"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countTexts</span><span class="o">(</span><span class="n">pressedKeys3</span><span class="o">));</span> <span class="c1">// Expected output depends on the pattern</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><category term="Review"/><summary type="html"><![CDATA[Alice is texting Bob using her phone. The mapping of digits to letters is shown in the figure below. In order to add a letter, Alice has to press the key of the corresponding digit i times, where i is the position of the letter in the key. For example, to add the letter 's', Alice has to press '7' four times. Similarly, to add the letter 'k', Alice has to press '5' twice. Note that the digits '0' and '1' do not map to any letters, so Alice does not use them. However, due to an error in transmission, Bob did not receive Alice’s text message but received a string of pressed keys instead. For example, when Alice sent the message "bob", Bob received the string "2266622". Given a string pressedKeys representing the string received by Bob, return the total number of possible text messages Alice could have sent. Since the answer may be very large, return it modulo 10^9 + 7.]]></summary></entry><entry><title type="html">2024. Maximize the Confusion of an Exam</title><link href="https://zhengstar94.github.io//blog/2025/MaximizeTheConfusionOfAnExam/" rel="alternate" type="text/html" title="2024. Maximize the Confusion of an Exam"/><published>2025-01-18T00:00:00+00:00</published><updated>2025-01-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximizeTheConfusionOfAnExam</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximizeTheConfusionOfAnExam/"><![CDATA[<ul> <li>A teacher is writing a test with <code class="language-plaintext highlighter-rouge">n</code> true/false questions, with <code class="language-plaintext highlighter-rouge">'T'</code> denoting true and <code class="language-plaintext highlighter-rouge">'F'</code> denoting false. He wants to confuse the students by <strong>maximizing</strong> the number of <strong>consecutive (adj. 连续的；连贯的)</strong> questions with the <strong>same</strong> answer (multiple trues or multiple falses in a row).</li> <li>You are given a string <code class="language-plaintext highlighter-rouge">answerKey</code>, where <code class="language-plaintext highlighter-rouge">answerKey[i]</code> is the original answer to the <code class="language-plaintext highlighter-rouge">ith</code> question. In addition, you are given an integer <code class="language-plaintext highlighter-rouge">k</code>, the maximum number of times you may perform the following operation: <ul> <li>Change the answer key for any question to <code class="language-plaintext highlighter-rouge">'T'</code> or <code class="language-plaintext highlighter-rouge">'F'</code> (i.e., set <code class="language-plaintext highlighter-rouge">answerKey[i]</code> to <code class="language-plaintext highlighter-rouge">'T'</code> or <code class="language-plaintext highlighter-rouge">'F'</code>).</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> number of consecutive (adj. 连续的；连贯的)</em> <code class="language-plaintext highlighter-rouge">'T'</code>s or <code class="language-plaintext highlighter-rouge">'F'</code>s <em>in the answer key after performing the operation at most</em> <code class="language-plaintext highlighter-rouge">k</code> <em>times</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answerKey = "TTFF", k = 2
Output: 4
Explanation: We can replace both the 'F's with 'T's to make answerKey = "TTTT".
There are four consecutive 'T's.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answerKey = "TFFT", k = 1
Output: 3
Explanation: We can replace the first 'T' with an 'F' to make answerKey = "FFFT".
Alternatively, we can replace the second 'T' with an 'F' to make answerKey = "TFFF".
In both cases, there are three consecutive 'F's.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answerKey = "TTFTTFTT", k = 1
Output: 5
Explanation: We can replace the first 'F' to make answerKey = "TTTTTFTT"
Alternatively, we can replace the second 'F' to make answerKey = "TTFTTTTT". 
In both cases, there are five consecutive 'T's.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximizeTheConfusionOfAnExam</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxConsecutiveAnswers</span><span class="o">(</span><span class="nc">String</span> <span class="n">answerKey</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate max length by considering both cases: converting to 'T' and converting to 'F'</span>
        <span class="c1">// Return the maximum of these two scenarios</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">(</span><span class="n">answerKey</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="sc">'T'</span><span class="o">),</span> <span class="n">maxLength</span><span class="o">(</span><span class="n">answerKey</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="sc">'F'</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxLength</span><span class="o">(</span><span class="nc">String</span> <span class="n">answerKey</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">char</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="c1">// Track the maximum length of consecutive same characters</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>          <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>         <span class="c1">// Count of characters that need to be changed in current window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">answerKey</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Step 1: Process the current character at right pointer</span>
            <span class="c1">// If current character is different from target, increment the count</span>
            <span class="c1">// This count represents how many characters we need to change in our window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">answerKey</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Step 2: Maintain window validity</span>
            <span class="c1">// If count exceeds k, we need to shrink the window from left</span>
            <span class="c1">// Keep shrinking until we have a valid window (count &lt;= k)</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If character at left pointer is different from target</span>
                <span class="c1">// Decrease count as this character will no longer be in our window</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">answerKey</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">count</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Step 3: Update result</span>
            <span class="c1">// Current window size is (right - left + 1)</span>
            <span class="c1">// Update maxLen if current window is larger</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to verify the solution</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxConsecutiveAnswers</span><span class="o">(</span><span class="s">"TTFF"</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>     <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxConsecutiveAnswers</span><span class="o">(</span><span class="s">"TFFT"</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>     <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxConsecutiveAnswers</span><span class="o">(</span><span class="s">"TTFTTFTT"</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span> <span class="c1">// Output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive (adj. 连续的；连贯的) questions with the same answer (multiple trues or multiple falses in a row). You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation: Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F'). Return the maximum number of consecutive (adj. 连续的；连贯的) 'T's or 'F's in the answer key after performing the operation at most k times.]]></summary></entry><entry><title type="html">2779. Maximum Beauty of an Array After Applying Operation</title><link href="https://zhengstar94.github.io//blog/2025/MaximumBeautyOfAnArrayAfterApplyingOperation/" rel="alternate" type="text/html" title="2779. Maximum Beauty of an Array After Applying Operation"/><published>2025-01-18T00:00:00+00:00</published><updated>2025-01-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumBeautyOfAnArrayAfterApplyingOperation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumBeautyOfAnArrayAfterApplyingOperation/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array <code class="language-plaintext highlighter-rouge">nums</code> and a <strong>non-negative</strong> integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>In one operation, you can do the following: <ul> <li>Choose an index <code class="language-plaintext highlighter-rouge">i</code> that <strong>hasn’t been chosen before</strong> from the range <code class="language-plaintext highlighter-rouge">[0, nums.length - 1]</code>.</li> <li>Replace <code class="language-plaintext highlighter-rouge">nums[i]</code> with any integer from the range <code class="language-plaintext highlighter-rouge">[nums[i] - k, nums[i] + k]</code>.</li> </ul> </li> <li>The <strong>beauty</strong> of the array is the length of the longest subsequence consisting of equal elements.</li> <li>Return <em>the <strong>maximum</strong> possible beauty of the array</em> <code class="language-plaintext highlighter-rouge">nums</code> *after applying the operation any number of times.**</li> <li><strong>*Note</strong> that you can apply the operation to each index <strong>only once</strong>.</li> <li>A <strong>subsequence</strong> of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,6,1,2], k = 2
Output: 3
Explanation: In this example, we apply the following operations:
- Choose index 1, replace it with 4 (from range [4,8]), nums = [4,4,1,2].
- Choose index 3, replace it with 4 (from range [0,4]), nums = [4,4,1,4].
After the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).
It can be proven that 3 is the maximum possible length we can achieve.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1], k = 10
Output: 4
Explanation: In this example we don't have to apply any operations.
The beauty of the array nums is 4 (whole array).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumBeautyOfAnArrayAfterApplyingOperation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumBeauty</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Sort the array to bring close numbers together.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">maxBeauty</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Tracks the maximum beauty found.</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Left pointer of the sliding window.</span>

        <span class="c1">// Iterate through the array with the right pointer.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if the difference between nums[right] and nums[left] exceeds 2 * k.</span>
            <span class="c1">// If it does, increment the left pointer to reduce the window size.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update the maximum beauty by comparing it to the current window size.</span>
            <span class="n">maxBeauty</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxBeauty</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxBeauty</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">maximumBeauty</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">maximumBeauty</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">maximumBeauty</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test case 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100</span><span class="o">,</span> <span class="mi">101</span><span class="o">,</span> <span class="mi">102</span><span class="o">,</span> <span class="mi">103</span><span class="o">,</span> <span class="mi">104</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">maximumBeauty</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span> <span class="c1">// Expected: 5</span>

        <span class="c1">// Test case 5</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">maximumBeauty</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">k5</span><span class="o">));</span> <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed array nums and a non-negative integer k. In one operation, you can do the following: Choose an index i that hasn’t been chosen before from the range [0, nums.length - 1]. Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k]. The beauty of the array is the length of the longest subsequence consisting of equal elements. Return the maximum possible beauty of the array nums *after applying the operation any number of times.** *Note that you can apply the operation to each index only once. A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.]]></summary></entry><entry><title type="html">2958. Length of Longest Subarray With at Most K Frequency</title><link href="https://zhengstar94.github.io//blog/2025/LengthOfLongestSubarrayWithAtMostKFrequency/" rel="alternate" type="text/html" title="2958. Length of Longest Subarray With at Most K Frequency"/><published>2025-01-17T00:00:00+00:00</published><updated>2025-01-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LengthOfLongestSubarrayWithAtMostKFrequency</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LengthOfLongestSubarrayWithAtMostKFrequency/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>The <strong>frequency</strong> of an element <code class="language-plaintext highlighter-rouge">x</code> is the number of times it occurs in an array.</li> <li>An array is called <strong>good</strong> if the frequency of each element in this array is <strong>less than or equal</strong> to <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Return <em>the length of the <strong>longest</strong> <strong>good</strong> subarray of</em> <code class="language-plaintext highlighter-rouge">nums</code><em>.</em></li> <li>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1,2,3,1,2], k = 2
Output: 6
Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.
It can be shown that there are no good subarrays with length more than 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,1,2,1,2,1,2], k = 1
Output: 2
Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.
It can be shown that there are no good subarrays with length more than 2.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,5,5,5,5,5,5], k = 4
Output: 4
Explanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.
It can be shown that there are no good subarrays with length more than 4.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(min(m, n)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LengthOfLongestSubarrayWithAtMostKFrequency</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSubarrayLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store the frequency of each element in current window</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">frequency</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Variable to keep track of maximum valid subarray length</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Left pointer of the sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to frequency map and increment its count</span>
            <span class="n">frequency</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="n">frequency</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Shrink window from left while current element's frequency exceeds k</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">frequency</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Decrease frequency of element at left pointer</span>
                <span class="n">frequency</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">frequency</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum length if current window is larger</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Elements appear at most twice</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxSubarrayLength</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test Case 2: Elements appear at most once</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxSubarrayLength</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 3: Same element repeated with frequency limit 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxSubarrayLength</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer k. The frequency of an element x is the number of times it occurs in an array. An array is called good if the frequency of each element in this array is less than or equal to k. Return the length of the longest good subarray of nums. A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry><entry><title type="html">2683. Neighboring Bitwise XOR</title><link href="https://zhengstar94.github.io//blog/2025/NeighboringBitwiseXOR/" rel="alternate" type="text/html" title="2683. Neighboring Bitwise XOR"/><published>2025-01-17T00:00:00+00:00</published><updated>2025-01-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NeighboringBitwiseXOR</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NeighboringBitwiseXOR/"><![CDATA[<ul> <li>A <strong>0-indexed</strong> array <code class="language-plaintext highlighter-rouge">derived</code> with length <code class="language-plaintext highlighter-rouge">n</code> is derived by computing the <strong>bitwise XOR</strong> (⊕) of adjacent values in a <strong>binary array</strong> <code class="language-plaintext highlighter-rouge">original</code> of length <code class="language-plaintext highlighter-rouge">n</code>.</li> <li>Specifically, for each index <code class="language-plaintext highlighter-rouge">i</code> in the range <code class="language-plaintext highlighter-rouge">[0, n - 1]</code>: <ul> <li>If <code class="language-plaintext highlighter-rouge">i = n - 1</code>, then <code class="language-plaintext highlighter-rouge">derived[i] = original[i] ⊕ original[0]</code>.</li> <li>Otherwise, <code class="language-plaintext highlighter-rouge">derived[i] = original[i] ⊕ original[i + 1]</code>.</li> </ul> </li> <li>Given an array <code class="language-plaintext highlighter-rouge">derived</code>, your task is to determine whether there exists a <strong>valid binary array</strong> <code class="language-plaintext highlighter-rouge">original</code> that could have formed <code class="language-plaintext highlighter-rouge">derived</code>.</li> <li>Return <em><strong>true</strong> if such an array exists or <strong>false</strong> otherwise.</em> <ul> <li>A binary array is an array containing only <strong>0’s</strong> and <strong>1’s</strong></li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: derived = [1,1,0]
Output: true
Explanation: A valid original array that gives derived is [0,1,0].
derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 
derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1
derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: derived = [1,1]
Output: true
Explanation: A valid original array that gives derived is [0,1].
derived[0] = original[0] ⊕ original[1] = 1
derived[1] = original[1] ⊕ original[0] = 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NeighboringBitwiseXOR</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">doesValidArrayExist</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">derived</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the running XOR result, assuming original[0] = 0</span>
        <span class="c1">// This variable tracks the cumulative XOR of all elements</span>
        <span class="kt">int</span> <span class="n">original</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in derived array</span>
        <span class="c1">// For each iteration, we're essentially checking if the running XOR</span>
        <span class="c1">// maintains the necessary relationship between adjacent elements</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">derived</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// XOR current element with running result</span>
            <span class="c1">// This operation simulates building the original array and checking</span>
            <span class="c1">// if adjacent elements can satisfy the derived array's requirements</span>
            <span class="n">original</span> <span class="o">^=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Final check: if original is 0, it means:</span>
        <span class="c1">// 1. All elements in the hypothetical original array properly cancel out</span>
        <span class="c1">// 2. The circular property (last element XOR first element) is satisfied</span>
        <span class="c1">// 3. A valid original array exists</span>
        <span class="k">return</span> <span class="n">original</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: [1,1,0] - Valid case</span>
        <span class="c1">// Can be derived from original array [0,1,0]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">derived1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">doesValidArrayExist</span><span class="o">(</span><span class="n">derived1</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 2: [1,1] - Valid case</span>
        <span class="c1">// Can be derived from original array [0,1]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">derived2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">doesValidArrayExist</span><span class="o">(</span><span class="n">derived2</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 3: [1,0] - Invalid case</span>
        <span class="c1">// No possible original array can generate this derived array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">derived3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">doesValidArrayExist</span><span class="o">(</span><span class="n">derived3</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test Case 4: [0] - Valid case</span>
        <span class="c1">// Simplest possible case, can be derived from original array [0]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">derived4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">doesValidArrayExist</span><span class="o">(</span><span class="n">derived4</span><span class="o">));</span> <span class="c1">// Expected: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[A 0-indexed array derived with length n is derived by computing the bitwise XOR (⊕) of adjacent values in a binary array original of length n. Specifically, for each index i in the range [0, n - 1]: If i=n - 1, then derived[i] = original[i] ⊕ original[0]. Otherwise, derived[i] = original[i] ⊕ original[i + 1]. Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived. Return true if such an array exists or false otherwise. A binary array is an array containing only 0’s and 1’s]]></summary></entry><entry><title type="html">(Review)3097. Shortest Subarray With OR at Least K II</title><link href="https://zhengstar94.github.io//blog/2025/ShortestSubarrayWithORAtLeastKII/" rel="alternate" type="text/html" title="(Review)3097. Shortest Subarray With OR at Least K II"/><published>2025-01-17T00:00:00+00:00</published><updated>2025-01-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ShortestSubarrayWithORAtLeastKII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ShortestSubarrayWithORAtLeastKII/"><![CDATA[<ul> <li>You are given an array <code class="language-plaintext highlighter-rouge">nums</code> of <strong>non-negative</strong> integers and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>An array is called <strong>special</strong> if the bitwise <code class="language-plaintext highlighter-rouge">OR</code> of all of its elements is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">k</code></li> <li>Return <em>the length of the <strong>shortest</strong> <strong>special</strong> <strong>non-empty</strong></em> <em>subarray</em> <em>of</em> <code class="language-plaintext highlighter-rouge">nums</code>, <em>or return</em> <code class="language-plaintext highlighter-rouge">-1</code> <em>if no special subarray exists</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3], k = 2

Output: 1

Explanation:

The subarray [3] has OR value of 3. Hence, we return 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,8], k = 10

Output: 3

Explanation:

The subarray [2,1,8] has OR value of 11. Hence, we return 3.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2], k = 0

Output: 1

Explanation:

The subarray [1] has OR value of 1. Hence, we return 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestSubarrayWithORAtLeastKII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumSubarrayLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize answer with maximum value to track minimum length</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Bottom marker to track the last position where OR values were properly calculated</span>
        <span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Variable to store the running OR value of current window</span>
        <span class="kt">int</span> <span class="n">rightOr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through array with right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update running OR value by including current element</span>
            <span class="n">rightOr</span> <span class="o">|=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="c1">// Try to minimize window size while maintaining OR &gt;= k condition</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">|</span> <span class="n">rightOr</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update minimum length found so far</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Move left pointer to try finding smaller valid window</span>
                <span class="n">left</span><span class="o">++;</span>

                <span class="c1">// If left pointer moves beyond bottom marker, need to recalculate OR values</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Rebuild OR values from right to left</span>
                    <span class="c1">// This is necessary because moving left pointer affects the OR values</span>
                    <span class="c1">// We store cumulative OR values in the original array</span>
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                        <span class="c1">// Update each position with its OR value with the next element</span>
                        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">|=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
                    <span class="o">}</span>

                    <span class="c1">// Update bottom marker to current right position</span>
                    <span class="c1">// This indicates we've recalculated OR values up to this point</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                    <span class="c1">// Reset rightOr as the OR values are now stored in the array</span>
                    <span class="n">rightOr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return -1 if no valid subarray found, otherwise return minimum length</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output is 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minimumSubarrayLength</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expected output is 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minimumSubarrayLength</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expected output is 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">minimumSubarrayLength</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><category term="Review"/><summary type="html"><![CDATA[You are given an array nums of non-negative integers and an integer k. An array is called special if the bitwise OR of all of its elements is at least k Return the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.]]></summary></entry><entry><title type="html">2425. Bitwise XOR of All Pairings</title><link href="https://zhengstar94.github.io//blog/2025/BitwiseXOROfAllPairings/" rel="alternate" type="text/html" title="2425. Bitwise XOR of All Pairings"/><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BitwiseXOROfAllPairings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BitwiseXOROfAllPairings/"><![CDATA[<ul> <li>You are given two <strong>0-indexed</strong> arrays, <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>, consisting of non-negative integers. There exists another array, <code class="language-plaintext highlighter-rouge">nums3</code>, which contains the bitwise XOR of <strong>all pairings</strong> of integers between <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> (every integer in <code class="language-plaintext highlighter-rouge">nums1</code> is paired with every integer in <code class="language-plaintext highlighter-rouge">nums2</code> <strong>exactly once</strong>).</li> <li>Return <em>the <strong>bitwise XOR</strong> of all integers in</em> <code class="language-plaintext highlighter-rouge">nums3</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [2,1,3], nums2 = [10,2,5,0]
Output: 13
Explanation:
A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3].
The bitwise XOR of all these numbers is 13, so we return 13.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,2], nums2 = [3,4]
Output: 0
Explanation:
All possible pairs of bitwise XORs are nums1[0] ^ nums2[0], nums1[0] ^ nums2[1], nums1[1] ^ nums2[0],
and nums1[1] ^ nums2[1].
Thus, one possible nums3 array is [2,5,1,6].
2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BitwiseXOROfAllPairings</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">xorAllNums</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Initialize result variable to store the final XOR value</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="cm">/*
     * First Check: nums2.length % 2 == 1
     * Why this check?
     * - Each number in nums1 will appear nums2.length times in the final calculation
     * - If nums2.length is odd, each number in nums1 will appear odd times
     * - When a number appears odd times in XOR operations, it needs to be XORed once
     * - When a number appears even times, it cancels out (equals 0 in XOR)
     *
     * Example: If nums2.length is 3
     * - Each number in nums1 will appear 3 times in the pairs
     * - 3 times XOR is equivalent to XOR once
     * - Therefore, we need to XOR each number in nums1 once
     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums2</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">^=</span> <span class="n">num</span><span class="o">;</span>  <span class="c1">// XOR each number from nums1 once</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*
     * Second Check: nums1.length % 2 == 1
     * Why this check?
     * - Each number in nums2 will appear nums1.length times in the final calculation
     * - If nums1.length is odd, each number in nums2 will appear odd times
     * - When a number appears odd times in XOR operations, it needs to be XORed once
     * - When a number appears even times, it cancels out (equals 0 in XOR)
     *
     * Example: If nums1.length is 3
     * - Each number in nums2 will appear 3 times in the pairs
     * - 3 times XOR is equivalent to XOR once
     * - Therefore, we need to XOR each number in nums2 once
     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">^=</span> <span class="n">num</span><span class="o">;</span>  <span class="c1">// XOR each number from nums2 once</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Return the final XOR result</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
   * Main method to test the solution with various test cases
   */</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Test Case 1: nums1 has odd length, nums2 has even length</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1_1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2_1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">xorAllNums</span><span class="o">(</span><span class="n">nums1_1</span><span class="o">,</span> <span class="n">nums2_1</span><span class="o">));</span> <span class="c1">// Expected: 13</span>

    <span class="c1">// Test Case 2: Both arrays have even length</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1_2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2_2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">xorAllNums</span><span class="o">(</span><span class="n">nums1_2</span><span class="o">,</span> <span class="n">nums2_2</span><span class="o">));</span> <span class="c1">// Expected: 0</span>

    <span class="c1">// Test Case 3: Both arrays have odd length</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1_3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2_3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">xorAllNums</span><span class="o">(</span><span class="n">nums1_3</span><span class="o">,</span> <span class="n">nums2_3</span><span class="o">));</span> <span class="c1">// Expected: 3</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. There exists another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once). Return the bitwise XOR of all integers in nums3.]]></summary></entry><entry><title type="html">1695. Maximum Erasure Value</title><link href="https://zhengstar94.github.io//blog/2025/MaximumErasureValue/" rel="alternate" type="text/html" title="1695. Maximum Erasure Value"/><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumErasureValue</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumErasureValue/"><![CDATA[<ul> <li>You are given an array of positive integers <code class="language-plaintext highlighter-rouge">nums</code> and want to erase a subarray containing <strong>unique elements</strong>. The <strong>score</strong> you get by erasing the subarray is equal to the <strong>sum</strong> of its elements.</li> <li>Return <em>the <strong>maximum score</strong> you can get by erasing <strong>exactly one</strong> subarray.</em></li> <li>An array <code class="language-plaintext highlighter-rouge">b</code> is called to be a subarray of <code class="language-plaintext highlighter-rouge">a</code> if it forms a contiguous subsequence of <code class="language-plaintext highlighter-rouge">a</code>, that is, if it is equal to <code class="language-plaintext highlighter-rouge">a[l],a[l+1],...,a[r]</code> for some <code class="language-plaintext highlighter-rouge">(l,r)</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray here is [2,4,5,6].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,2,1,2,5,2,1,2,5]
Output: 8
Explanation: The optimal subarray here is [5,2,1] or [1,2,5].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumErasureValue</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumUniqueSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashSet to keep track of unique elements in current window</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Variable to store the maximum sum found so far</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Variable to maintain the sum of current window</span>
        <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// While current element is already in set, shrink window from left</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]))</span> <span class="o">{</span>
                <span class="c1">// Remove leftmost element from set</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>

                <span class="c1">// Subtract removed element from current window sum</span>
                <span class="n">currentSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>

                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Add current element to set</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]);</span>

            <span class="c1">// Add current element to window sum</span>
            <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="c1">// Update maximum sum if current window sum is larger</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">currentSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the maximum sum found</span>
        <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with duplicate elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maximumUniqueSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected: 17</span>

        <span class="c1">// Test Case 2: Array with multiple duplicates</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maximumUniqueSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected: 8</span>

        <span class="c1">// Test Case 3: Array with all unique elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maximumUniqueSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected: 15</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements. Return the maximum score you can get by erasing exactly one subarray. An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).]]></summary></entry><entry><title type="html">3095. Shortest Subarray With OR at Least K I</title><link href="https://zhengstar94.github.io//blog/2025/ShortestSubarrayWithORAtLeastKI/" rel="alternate" type="text/html" title="3095. Shortest Subarray With OR at Least K I"/><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ShortestSubarrayWithORAtLeastKI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ShortestSubarrayWithORAtLeastKI/"><![CDATA[<ul> <li>You are given an array <code class="language-plaintext highlighter-rouge">nums</code> of <strong>non-negative</strong> integers and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>An array is called <strong>special</strong> if the bitwise <code class="language-plaintext highlighter-rouge">OR</code> of all of its elements is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Return <em>the length of the <strong>shortest</strong> <strong>special</strong> <strong>non-empty</strong></em> <em>subarray</em> <em>of</em> <code class="language-plaintext highlighter-rouge">nums</code>, <em>or return</em> <code class="language-plaintext highlighter-rouge">-1</code> <em>if no special subarray exists</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3], k = 2

Output: 1

Explanation:

The subarray [3] has OR value of 3. Hence, we return 1.

Note that [2] is also a special subarray.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,8], k = 10

Output: 3

Explanation:

The subarray [2,1,8] has OR value of 11. Hence, we return 3.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2], k = 0

Output: 1

Explanation:

The subarray [1] has OR value of 1. Hence, we return 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestSubarrayWithORAtLeastKI</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumSubarrayLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Return -1 if array is empty</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize answer with maximum integer value</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Outer loop: iterate through all possible starting positions</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Initialize OR sum for current subarray</span>
            <span class="kt">int</span> <span class="n">orSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="c1">// Inner loop: extend subarray and calculate OR sum</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Update OR sum by including current element</span>
                <span class="n">orSum</span> <span class="o">|=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">// If OR sum reaches or exceeds k, update minimum length</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">orSum</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>  <span class="c1">// Found valid subarray, move to next starting position</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return -1 if no valid subarray found, otherwise return minimum length</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Simple case with small numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minimumSubarrayLength</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 2: Case requiring multiple elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minimumSubarrayLength</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 3: Case with k = 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">minimumSubarrayLength</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 4: Case with no valid solution</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">minimumSubarrayLength</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span> <span class="c1">// Expected output: -1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Easy"/><summary type="html"><![CDATA[You are given an array nums of non-negative integers and an integer k. An array is called special if the bitwise OR of all of its elements is at least k. Return the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.]]></summary></entry><entry><title type="html">904. Fruit Into Baskets</title><link href="https://zhengstar94.github.io//blog/2025/FruitIntoBaskets/" rel="alternate" type="text/html" title="904. Fruit Into Baskets"/><published>2025-01-15T00:00:00+00:00</published><updated>2025-01-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FruitIntoBaskets</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FruitIntoBaskets/"><![CDATA[<ul> <li>You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array <code class="language-plaintext highlighter-rouge">fruits</code> where <code class="language-plaintext highlighter-rouge">fruits[i]</code> is the <strong>type</strong> of fruit the <code class="language-plaintext highlighter-rouge">ith</code> tree produces.</li> <li>You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow: <ul> <li>You only have <strong>two</strong> baskets, and each basket can only hold a <strong>single type</strong> of fruit. There is no limit on the amount of fruit each basket can hold.</li> <li>Starting from any tree of your choice, you must pick <strong>exactly one fruit</strong> from <strong>every</strong> tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.</li> <li>Once you reach a tree with fruit that cannot fit in your baskets, you must stop.</li> </ul> </li> <li>Given the integer array <code class="language-plaintext highlighter-rouge">fruits</code>, return <em>the <strong>maximum</strong> number of fruits you can pick</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: fruits = [1,2,1]
Output: 3
Explanation: We can pick from all 3 trees.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: fruits = [0,1,2,2]
Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: fruits = [1,2,3,2,2]
Output: 4
Explanation: We can pick from trees [2,3,2,2].
If we had started at the first tree, we would only pick from trees [1,2].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitIntoBaskets</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">totalFruit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">fruits</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxFruits</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Maximum number of fruits</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Left pointer of sliding window</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">basket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// Map to track fruit types and their counts</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">fruits</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current fruit to the basket</span>
            <span class="n">basket</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">fruits</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="n">basket</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">fruits</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// While we have more than 2 types of fruits in the basket</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">basket</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">leftFruit</span> <span class="o">=</span> <span class="n">fruits</span><span class="o">[</span><span class="n">left</span><span class="o">];</span> <span class="c1">// Get the fruit type at the left pointer</span>
                <span class="n">basket</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">leftFruit</span><span class="o">,</span> <span class="n">basket</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">leftFruit</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// Decrease the count of that fruit</span>

                <span class="c1">// If the count becomes 0, remove this fruit type from the basket</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">basket</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">leftFruit</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">basket</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">leftFruit</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// Move the left pointer to shrink the window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum fruits count</span>
            <span class="n">maxFruits</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxFruits</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxFruits</span><span class="o">;</span> <span class="c1">// Return the maximum number of fruits collected</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">totalFruit</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">totalFruit</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">totalFruit</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">totalFruit</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 5</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test5</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">totalFruit</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span> <span class="c1">// Expected: 0</span>

        <span class="c1">// Test Case 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test6</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 6 Result: "</span> <span class="o">+</span> <span class="n">totalFruit</span><span class="o">(</span><span class="n">test6</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces. You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow: You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold. Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets. Once you reach a tree with fruit that cannot fit in your baskets, you must stop. Given the integer array fruits, return the maximum number of fruits you can pick.]]></summary></entry></feed>