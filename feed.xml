<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-18T06:53:53+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">3281. Maximize Score of Numbers in Ranges</title><link href="https://zhengstar94.github.io//blog/2025/MaximizeScoreOfNumbersInRanges/" rel="alternate" type="text/html" title="3281. Maximize Score of Numbers in Ranges"/><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximizeScoreOfNumbersInRanges</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximizeScoreOfNumbersInRanges/"><![CDATA[<ul> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">start</code> and an integer <code class="language-plaintext highlighter-rouge">d</code>, representing <code class="language-plaintext highlighter-rouge">n</code> intervals <code class="language-plaintext highlighter-rouge">[start[i], start[i] + d]</code>.</li> <li>You are asked to choose <code class="language-plaintext highlighter-rouge">n</code> integers where the <code class="language-plaintext highlighter-rouge">ith</code> integer must belong to the <code class="language-plaintext highlighter-rouge">ith</code> interval. The <strong>score</strong> of the chosen integers is defined as the <strong>minimum</strong> absolute difference between any two integers that have been chosen.</li> <li>Return the <strong>maximum</strong> <em>possible score</em> of the chosen integers.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: start = [6,0,3], d = 2

Output: 4

Explanation:

The maximum possible score can be obtained by choosing integers: 8, 0, and 4. The score of these chosen integers is min(|8 - 0|, |8 - 4|, |0 - 4|) which equals 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: start = [2,6,13,13], d = 5

Output: 5

Explanation:

The maximum possible score can be obtained by choosing integers: 2, 7, 13, and 18. The score of these chosen integers is min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|) which equals 5.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)+nlog(A)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MaximizeMinimum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximizeScoreOfNumbersInRanges</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxPossibleScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the start array to ensure order for greedy assignment</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="cm">/*
         * Calculate the upper bound for binary search 'right':
         * Explanation:
         * - The maximum possible difference between any two assigned numbers
         *   can be no more than the total length of the entire range divided evenly.
         * - The total range length is from the smallest start to the largest possible end:
         *   (start[n-1] + d) - start[0].
         * - Divide by (n-1) because there are (n-1) gaps between n numbers.
         * - Adding 1 ensures the upper bound is strictly greater,
         *   so the binary search range is safe.
         */</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="n">start</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Binary search loop to find the maximum minimum difference</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// mid = (left + right) / 2 without overflow</span>

            <span class="cm">/*
             * Check if it is possible to assign numbers with at least 'mid' difference
             * between adjacent assigned values while keeping each within allowed intervals.
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>   <span class="c1">// If feasible, try a larger minimum difference</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>  <span class="c1">// Otherwise, try smaller differences</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 'left' holds the largest minimum difference found</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">,</span> <span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">prevPlacedValue</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>  <span class="c1">// Initialize to very small to place first number freely</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">baseValue</span> <span class="o">:</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the assigned value for current interval:</span>
            <span class="c1">// It must be at least 'score' away from the previously assigned value,</span>
            <span class="c1">// and also no less than the interval's start value.</span>
            <span class="n">prevPlacedValue</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">prevPlacedValue</span> <span class="o">+</span> <span class="n">score</span><span class="o">,</span> <span class="n">baseValue</span><span class="o">);</span>

            <span class="c1">// If assigned value goes beyond the interval's max allowed value, fail</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prevPlacedValue</span> <span class="o">&gt;</span> <span class="n">baseValue</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// All intervals assigned successfully with at least 'score' difference</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1:</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">start1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">maxPossibleScore</span><span class="o">(</span><span class="n">start1</span><span class="o">,</span> <span class="n">d1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 1 output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span> <span class="c1">// Expected 4</span>

        <span class="c1">// Example 2:</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">start2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">maxPossibleScore</span><span class="o">(</span><span class="n">start2</span><span class="o">,</span> <span class="n">d2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 2 output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span> <span class="c1">// Expected 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MaximizeMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an array of integers start and an integer d, representing n intervals [start[i], start[i] + d]. You are asked to choose n integers where the ith integer must belong to the ith interval. The score of the chosen integers is defined as the minimum absolute difference between any two integers that have been chosen. Return the maximum possible score of the chosen integers.]]></summary></entry><entry><title type="html">2517. Maximum Tastiness of Candy Basket</title><link href="https://zhengstar94.github.io//blog/2025/MaximumTastinessOfCandyBasket/" rel="alternate" type="text/html" title="2517. Maximum Tastiness of Candy Basket"/><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumTastinessOfCandyBasket</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumTastinessOfCandyBasket/"><![CDATA[<ul> <li>You are given an array of positive integers <code class="language-plaintext highlighter-rouge">price</code> where <code class="language-plaintext highlighter-rouge">price[i]</code> denotes the price of the <code class="language-plaintext highlighter-rouge">ith</code> candy and a positive integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>The store sells baskets of <code class="language-plaintext highlighter-rouge">k</code> <strong>distinct</strong> candies. The <strong>tastiness</strong> of a candy basket is the smallest absolute difference of the <strong>prices</strong> of any two candies in the basket.</li> <li>Return <em>the <strong>maximum</strong> tastiness of a candy basket.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: price = [13,5,1,8,21,2], k = 3
Output: 8
Explanation: Choose the candies with the prices [13,5,21].
The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.
It can be proven that 8 is the maximum tastiness that can be achieved.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: price = [1,3,1], k = 2
Output: 2
Explanation: Choose the candies with the prices [1,3].
The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.
It can be proven that 2 is the maximum tastiness that can be achieved.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: price = [7,7,7,7], k = 2
Output: 0
Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)+nlog(U)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MaximizeMinimum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumTastinessOfCandyBasket</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumTastiness</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the prices to enable binary search and greedy checking</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>

        <span class="c1">// Initialize binary search boundaries:</span>
        <span class="c1">// left = 0 means minimum possible difference</span>
        <span class="c1">// right = max possible difference between prices divided by (k-1), plus 1 for upper bound</span>
        <span class="c1">// Explanation:</span>
        <span class="c1">// - The maximum minimum difference can't be larger than the total price range divided by (k-1)</span>
        <span class="c1">// - We add 1 to make sure right is an exclusive upper bound for binary search</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="n">price</span><span class="o">[</span><span class="n">price</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">price</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Binary search for the maximum minimum difference (tastiness)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if it's possible to select k candies such that</span>
            <span class="c1">// the minimum difference between any two selected candies &gt;= mid</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">price</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If possible, we try to find a larger minimum difference</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If not possible, we reduce the minimum difference</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 'left' now holds the largest minimum difference that can be achieved</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>          <span class="c1">// Already selected the first candy (smallest price)</span>
        <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">price</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// The price of the last selected candy</span>

        <span class="c1">// Iterate through prices to greedily select candies</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">price</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current candy's price is at least d away from previously selected candy</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">price</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prev</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>        <span class="c1">// Select this candy</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">price</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Update last selected candy price</span>

                <span class="c1">// If we have selected enough candies, return true immediately</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Not possible to select k candies with minimum difference d</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">price1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">13</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 1 maximum tastiness: "</span> <span class="o">+</span> <span class="n">maximumTastiness</span><span class="o">(</span><span class="n">price1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>  <span class="c1">// Expected output: 8</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">price2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 2 maximum tastiness: "</span> <span class="o">+</span> <span class="n">maximumTastiness</span><span class="o">(</span><span class="n">price2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>  <span class="c1">// Expected output: 2</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">price3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 3 maximum tastiness: "</span> <span class="o">+</span> <span class="n">maximumTastiness</span><span class="o">(</span><span class="n">price3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>  <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MaximizeMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k. The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket. Return the maximum tastiness of a candy basket.]]></summary></entry><entry><title type="html">2513. Minimize the Maximum of Two Arrays</title><link href="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumOfTwoArrays/" rel="alternate" type="text/html" title="2513. Minimize the Maximum of Two Arrays"/><published>2025-05-17T00:00:00+00:00</published><updated>2025-05-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumOfTwoArrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumOfTwoArrays/"><![CDATA[<ul> <li>We have two arrays <code class="language-plaintext highlighter-rouge">arr1</code> and <code class="language-plaintext highlighter-rouge">arr2</code> which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions: <ul> <li><code class="language-plaintext highlighter-rouge">arr1</code> contains <code class="language-plaintext highlighter-rouge">uniqueCnt1</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code class="language-plaintext highlighter-rouge">divisor1</code>.</li> <li><code class="language-plaintext highlighter-rouge">arr2</code> contains <code class="language-plaintext highlighter-rouge">uniqueCnt2</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code class="language-plaintext highlighter-rouge">divisor2</code>.</li> <li><strong>No</strong> integer is present in both <code class="language-plaintext highlighter-rouge">arr1</code> and <code class="language-plaintext highlighter-rouge">arr2</code>.</li> </ul> </li> <li>Given <code class="language-plaintext highlighter-rouge">divisor1</code>, <code class="language-plaintext highlighter-rouge">divisor2</code>, <code class="language-plaintext highlighter-rouge">uniqueCnt1</code>, and <code class="language-plaintext highlighter-rouge">uniqueCnt2</code>, return <em>the <strong>minimum possible maximum</strong> integer that can be present in either array</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
Output: 4
Explanation: 
We can distribute the first 4 natural numbers into arr1 and arr2.
arr1 = [1] and arr2 = [2,3,4].
We can see that both arrays satisfy all the conditions.
Since the maximum value is 4, we return it.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
Output: 3
Explanation: 
Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
Since the maximum value is 3, we return it.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
Output: 15
Explanation: 
Here, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].
It can be shown that it is not possible to obtain a lower maximum satisfying all conditions. 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(divisor1+divisor2)+log(uniqueCnt1+uniqueCnt2)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizeTheMaximumOfTwoArrays</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizeSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">divisor1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">divisor2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate the Least Common Multiple (LCM) of divisor1 and divisor2,</span>
        <span class="c1">// used for applying the inclusion-exclusion principle later.</span>
        <span class="kt">long</span> <span class="n">lcm</span> <span class="o">=</span> <span class="n">lcm</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">);</span>

        <span class="c1">// Initialize binary search boundaries:</span>
        <span class="c1">// left starts at 1 (smallest positive integer),</span>
        <span class="c1">// right is a safe upper bound (twice the total count of unique elements needed).</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>

        <span class="c1">// Perform binary search to find the minimal maximum integer x</span>
        <span class="c1">// such that it's possible to form arr1 and arr2 under constraints.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">// Use the check function to verify if mid can satisfy the constraints.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">,</span> <span class="n">lcm</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If possible, try smaller values to minimize the maximum integer.</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, increase the lower bound to look for a larger feasible value.</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// At the end of binary search, left == right and represents the minimal maximum integer.</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt2</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lcm</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*
         * Calculate how many integers arr1 still needs to pick after excluding
         * numbers that arr2 will take (numbers divisible by d2, except those divisible by lcm).
         * uniqueCnt1 - (x / d2) + (x / lcm) calculates the "remaining needed" count for arr1.
         *
         * Math.max(..., 0) ensures we don't get negative values when arr2 doesn't take enough to affect arr1.
         */</span>
        <span class="kt">long</span> <span class="n">left1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">uniqueCnt1</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d2</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lcm</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>

        <span class="cm">/*
         * Similarly, calculate how many integers arr2 still needs to pick after excluding
         * numbers that arr1 will take (numbers divisible by d1, except those divisible by lcm).
         */</span>
        <span class="kt">long</span> <span class="n">left2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">uniqueCnt2</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d1</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lcm</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>

        <span class="cm">/*
         * Calculate how many numbers in [1, x] are not divisible by either d1 or d2.
         * This uses the inclusion-exclusion principle:
         * - total numbers in [1,x]: x
         * - subtract numbers divisible by d1: x/d1
         * - subtract numbers divisible by d2: x/d2
         * - add back numbers divisible by both (lcm): x/lcm
         *
         * This 'common' count represents the pool of numbers that neither arr1 nor arr2
         * is restricted from using, and hence can be distributed between them.
         */</span>
        <span class="kt">long</span> <span class="n">common</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d2</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lcm</span><span class="o">);</span>

        <span class="cm">/*
         * Return true if the common pool has enough numbers to satisfy the leftover
         * needs of both arrays without conflicts.
         */</span>
        <span class="k">return</span> <span class="n">common</span> <span class="o">&gt;=</span> <span class="n">left1</span> <span class="o">+</span> <span class="n">left2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Calculate the Greatest Common Divisor (GCD) of two numbers using the Euclidean algorithm.
     *
     * @param a First number.
     * @param b Second number.
     * @return The GCD of a and b.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">gcd</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If b is zero, gcd is a; otherwise, recurse with (b, a % b).</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Calculate the Least Common Multiple (LCM) of two numbers.
     * Formula: lcm(a, b) = (a * b) / gcd(a, b)
     *
     * @param a First number.
     * @param b Second number.
     * @return The LCM of a and b.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">lcm</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span> <span class="n">divisor1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">divisor2</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span> <span class="n">uniqueCnt1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">uniqueCnt2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: divisor1 = "</span> <span class="o">+</span> <span class="n">divisor1</span> <span class="o">+</span> <span class="s">", divisor2 = "</span> <span class="o">+</span> <span class="n">divisor2</span> <span class="o">+</span>
                <span class="s">", uniqueCnt1 = "</span> <span class="o">+</span> <span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="s">", uniqueCnt2 = "</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minimizeSet</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 4"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2</span>
        <span class="n">divisor1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="n">divisor2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="n">uniqueCnt1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">uniqueCnt2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: divisor1 = "</span> <span class="o">+</span> <span class="n">divisor1</span> <span class="o">+</span> <span class="s">", divisor2 = "</span> <span class="o">+</span> <span class="n">divisor2</span> <span class="o">+</span>
                <span class="s">", uniqueCnt1 = "</span> <span class="o">+</span> <span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="s">", uniqueCnt2 = "</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minimizeSet</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 3</span>
        <span class="n">divisor1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">divisor2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="n">uniqueCnt1</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="n">uniqueCnt2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: divisor1 = "</span> <span class="o">+</span> <span class="n">divisor1</span> <span class="o">+</span> <span class="s">", divisor2 = "</span> <span class="o">+</span> <span class="n">divisor2</span> <span class="o">+</span>
                <span class="s">", uniqueCnt1 = "</span> <span class="o">+</span> <span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="s">", uniqueCnt2 = "</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minimizeSet</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 15"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions: arr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1. arr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2. No integer is present in both arr1 and arr2. Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.]]></summary></entry><entry><title type="html">LCP 12. Zhang’s Problem Solving Plan</title><link href="https://zhengstar94.github.io//blog/2025/ZhangsProblemSolvingPlan/" rel="alternate" type="text/html" title="LCP 12. Zhang’s Problem Solving Plan"/><published>2025-05-17T00:00:00+00:00</published><updated>2025-05-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ZhangsProblemSolvingPlan</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ZhangsProblemSolvingPlan/"><![CDATA[<ul> <li>To improve his coding skills, Zhang has prepared a LeetCode problem-solving plan. He selected <code class="language-plaintext highlighter-rouge">n</code> problems from the LeetCode problem database, numbered from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>, and plans to solve all problems <strong>in order of their problem numbers</strong> within <code class="language-plaintext highlighter-rouge">m</code> days (note that Zhang cannot spend multiple days on the same problem).</li> <li>In Zhang’s plan, he needs <code class="language-plaintext highlighter-rouge">time[i]</code> units of time to complete problem number <code class="language-plaintext highlighter-rouge">i</code>. Additionally, Zhang can use an external help feature by asking his good friend Yang for the solution to a problem, which saves him the time needed for that problem. To prevent “Zhang’s problem-solving plan” from becoming “Yang’s problem-solving plan,” Zhang can use this help feature at most once per day.</li> <li>We define <code class="language-plaintext highlighter-rouge">T</code> as the maximum time spent solving problems in a single day among the <code class="language-plaintext highlighter-rouge">m</code> days (problems completed by Yang do not count toward the total solving time). Please help Zhang find the minimum possible value of <code class="language-plaintext highlighter-rouge">T</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [1,2,3,3], m = 2
Output: 3
Explanation: On the first day, Zhang completes the first three problems, with Yang's help for the third problem. On the second day, he completes the fourth problem and also asks Yang for help. This way, the maximum time spent on any day is 3, and this value is minimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [999,999,999], m = 4
Output: 0
Explanation: During the first three days, Zhang asks Yang for help once each day, allowing him to complete all problems within three days without spending any time himself.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(sum(time))) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ZhangsProblemSolvingPlan</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minTime</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if input is null, empty, or days &lt;= 0, no time needed</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">time</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">time</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If days &gt;= number of problems, Zhang can do one problem per day,</span>
        <span class="c1">// use help for each to reduce time to zero</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize binary search boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">right</span> <span class="o">+=</span> <span class="n">t</span><span class="o">;</span> <span class="c1">// maximum possible time is sum of all problem times (no help used)</span>
        <span class="o">}</span>

        <span class="c1">// Binary search to find the minimal max time per day</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if Zhang can finish all problems within m days</span>
            <span class="c1">// without exceeding mid as max daily solving time (after help)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canFinish</span><span class="o">(</span><span class="n">time</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span> <span class="c1">// try smaller max time</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// need to allow more time</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">left</span><span class="o">;</span> <span class="c1">// minimum max time found</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxTime</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">days</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// currently used days</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// sum of problem times for the current day</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// maximum problem time for the current day (help will be used here)</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="o">;</span>                <span class="c1">// accumulate time for current day</span>
            <span class="n">maxVal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxVal</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>  <span class="c1">// track longest problem time in the day</span>

            <span class="c1">// Check if current day's time minus longest problem time exceeds maxTime</span>
            <span class="c1">// This simulates using help on the longest problem to reduce daily load</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">maxVal</span> <span class="o">&gt;</span> <span class="n">maxTime</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">days</span><span class="o">++;</span>        <span class="c1">// need an additional day</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>       <span class="c1">// reset sum to current problem time for new day</span>
                <span class="n">maxVal</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>    <span class="c1">// reset maxVal for new day</span>

                <span class="c1">// If number of days exceeds allowed m, return false immediately</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">days</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If all problems fit in m days under maxTime constraint, return true</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example input 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">time1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1, expected: 3, actual: "</span> <span class="o">+</span> <span class="n">minTime</span><span class="o">(</span><span class="n">time1</span><span class="o">,</span> <span class="n">m1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Example input 2, days more than problems</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">time2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">999</span><span class="o">,</span> <span class="mi">999</span><span class="o">,</span> <span class="mi">999</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2, expected: 0, actual: "</span> <span class="o">+</span> <span class="n">minTime</span><span class="o">(</span><span class="n">time2</span><span class="o">,</span> <span class="n">m2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[To improve his coding skills, Zhang has prepared a LeetCode problem-solving plan. He selected n problems from the LeetCode problem database, numbered from 0 to n-1, and plans to solve all problems in order of their problem numbers within m days (note that Zhang cannot spend multiple days on the same problem). In Zhang’s plan, he needs time[i] units of time to complete problem number i. Additionally, Zhang can use an external help feature by asking his good friend Yang for the solution to a problem, which saves him the time needed for that problem. To prevent “Zhang’s problem-solving plan” from becoming “Yang’s problem-solving plan,” Zhang can use this help feature at most once per day. We define T as the maximum time spent solving problems in a single day among the m days (problems completed by Yang do not count toward the total solving time). Please help Zhang find the minimum possible value of T.]]></summary></entry><entry><title type="html">2616. Minimize the Maximum Difference of Pairs</title><link href="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs/" rel="alternate" type="text/html" title="2616. Minimize the Maximum Difference of Pairs"/><published>2025-05-16T00:00:00+00:00</published><updated>2025-05-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">p</code>. Find <code class="language-plaintext highlighter-rouge">p</code> pairs of indices of <code class="language-plaintext highlighter-rouge">nums</code> such that the <strong>maximum</strong> difference amongst all the pairs is <strong>minimized</strong>. Also, ensure no index appears more than once amongst the <code class="language-plaintext highlighter-rouge">p</code> pairs.</li> <li>Note that for a pair of elements at the index <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>, the difference of this pair is <code class="language-plaintext highlighter-rouge">|nums[i] - nums[j]|</code>, where <code class="language-plaintext highlighter-rouge">|x|</code> represents the <strong>absolute</strong> <strong>value</strong> of <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>Return <em>the <strong>minimum</strong> <strong>maximum</strong> difference among all</em> <code class="language-plaintext highlighter-rouge">p</code> <em>pairs.</em> We define the maximum of an empty set to be zero.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,1,2,7,1,3], p = 2
Output: 1
Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,1,2], p = 1
Output: 0
Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n*log(n)+n*log(U)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizeTheMaximumDifferenceOfPairs</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizeMax</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If no pairs are needed, return 0 immediately.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort the array so we can easily find close numbers (small differences).</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Initialize binary search boundaries.</span>
        <span class="c1">// left is the smallest possible difference (0),</span>
        <span class="c1">// right is the largest possible difference (max - min).</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Perform binary search to find the minimal threshold</span>
        <span class="c1">// such that we can form at least p valid pairs.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If it's possible to form p pairs with max difference ≤ mid,</span>
            <span class="c1">// try smaller values (search left half).</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canFormPairs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">p</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, try larger threshold (search right half).</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After convergence, left is the smallest valid threshold.</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canFormPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If adjacent elements form a valid pair under the threshold</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">++;</span>  <span class="c1">// Count the valid pair</span>
                <span class="n">i</span><span class="o">++;</span>    <span class="c1">// Skip the next element, as it's already paired</span>
            <span class="o">}</span>
            <span class="c1">// If not valid, move to the next element to try a new pair</span>
        <span class="o">}</span>
        <span class="c1">// Return true if we've formed at least p pairs</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">p1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">p2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Additional test case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">p3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs. Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x. Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.]]></summary></entry><entry><title type="html">2900. Longest Unequal Adjacent Groups Subsequence I</title><link href="https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI/" rel="alternate" type="text/html" title="2900. Longest Unequal Adjacent Groups Subsequence I"/><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI/"><![CDATA[<ul> <li>You are given a string array <code class="language-plaintext highlighter-rouge">words</code> and a <strong>binary</strong> array <code class="language-plaintext highlighter-rouge">groups</code> both of length <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">words[i]</code> is associated with <code class="language-plaintext highlighter-rouge">groups[i]</code>.</li> <li>Your task is to select the <strong>longest alternating</strong> subsequence from <code class="language-plaintext highlighter-rouge">words</code>. A subsequence of <code class="language-plaintext highlighter-rouge">words</code> is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array <code class="language-plaintext highlighter-rouge">groups</code> differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the <code class="language-plaintext highlighter-rouge">groups</code> array.</li> <li>Formally, you need to find the longest subsequence of an array of indices <code class="language-plaintext highlighter-rouge">[0, 1, ..., n - 1]</code> denoted as <code class="language-plaintext highlighter-rouge">[i0, i1, ..., ik-1]</code>, such that <code class="language-plaintext highlighter-rouge">groups[ij] != groups[ij+1]</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= j &lt; k - 1</code> and then find the words corresponding to these indices.</li> <li>Return <em>the selected subsequence. If there are multiple answers, return <strong>any</strong> of them.</em>**</li> <li><strong>Note:</strong> The elements in <code class="language-plaintext highlighter-rouge">words</code> are distinct.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["e","a","b"], groups = [0,0,1]

Output: ["e","b"]

Explanation: A subsequence that can be selected is ["e","b"] because groups[0] != groups[2]. Another subsequence that can be selected is ["a","b"] because groups[1] != groups[2]. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["a","b","c","d"], groups = [1,0,1,1]

Output: ["a","b","c"]

Explanation: A subsequence that can be selected is ["a","b","c"] because groups[0] != groups[1] and groups[1] != groups[2]. Another subsequence that can be selected is ["a","b","d"] because groups[0] != groups[1] and groups[1] != groups[3]. It can be shown that the length of the longest subsequence of indices that satisfies the condition is 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(max(nums) - min(nums))) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestUnequalAdjacentGroupsSubsequenceI</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getLongestSubsequence</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">groups</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the result list to store our subsequence</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Add the first element to the result</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// Remember the group value of the last added element</span>
        <span class="kt">int</span> <span class="n">lastGroup</span> <span class="o">=</span> <span class="n">groups</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the remaining elements</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current element's group is different from the last added element's group</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">lastGroup</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add the current element to our result</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

                <span class="c1">// Update the last group value</span>
                <span class="n">lastGroup</span> <span class="o">=</span> <span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the longest subsequence</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words1</span><span class="o">,</span> <span class="n">groups1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words1</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [a, b, c] or [a, b, d]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"e"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words2</span><span class="o">,</span> <span class="n">groups2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words2</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [e, b] or [a, b]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Additional Test Case 3</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"red"</span><span class="o">,</span> <span class="s">"green"</span><span class="o">,</span> <span class="s">"blue"</span><span class="o">,</span> <span class="s">"yellow"</span><span class="o">,</span> <span class="s">"purple"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words3</span><span class="o">,</span> <span class="n">groups3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words3</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [red, green, blue, purple]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a string array words and a binary array groups both of length n, where words[i] is associated with groups[i]. Your task is to select the longest alternating subsequence from words. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array groups differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the groups array. Formally, you need to find the longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each 0 &lt;= j &lt; k - 1 and then find the words corresponding to these indices. Return the selected subsequence. If there are multiple answers, return any of them.** Note: The elements in words are distinct.]]></summary></entry><entry><title type="html">2560. House Robber IV</title><link href="https://zhengstar94.github.io//blog/2025/HouseRobberIV/" rel="alternate" type="text/html" title="2560. House Robber IV"/><published>2025-05-14T00:00:00+00:00</published><updated>2025-05-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/HouseRobberIV</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/HouseRobberIV/"><![CDATA[<ul> <li>There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he <strong>refuses to steal from adjacent homes</strong>.</li> <li>The <strong>capability</strong> of the robber is the maximum amount of money he steals from one house of all the houses he robbed.</li> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> representing how much money is stashed in each house. More formally, the <code class="language-plaintext highlighter-rouge">ith</code> house from the left has <code class="language-plaintext highlighter-rouge">nums[i]</code> dollars.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">k</code>, representing the <strong>minimum</strong> number of houses the robber will steal from. It is always possible to steal at least <code class="language-plaintext highlighter-rouge">k</code> houses.</li> <li>Return <em>the <strong>minimum</strong> capability of the robber out of all the possible ways to steal at least</em> <code class="language-plaintext highlighter-rouge">k</code> <em>houses</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,5,9], k = 2
Output: 5
Explanation: 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,7,9,3,1], k = 2
Output: 2
Explanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(max(nums) - min(nums))) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HouseRobberIV</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minCapability</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the binary search boundaries</span>
        <span class="c1">// Left boundary is the minimum value in the array (minimum possible capability)</span>
        <span class="c1">// Right boundary is the maximum value in the array (maximum possible capability)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Find the minimum and maximum values in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Binary search process to find the minimum capability</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle point to check</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if with capability 'mid', the robber can steal at least k houses</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canRob</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If it's possible to rob k houses with current capability,</span>
                <span class="c1">// try to lower the capability to find the minimum</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If it's not possible to rob k houses with current capability,</span>
                <span class="c1">// we need to increase the capability</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After binary search, 'left' will be the minimum capability required</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canRob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">capability</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Count of houses that have been robbed</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Current index in the array</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the money in the current house is less than or equal to the capability,</span>
            <span class="c1">// the robber can steal from this house</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">capability</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>  <span class="c1">// Increment the count of robbed houses</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>   <span class="c1">// Skip the next house (can't rob adjacent houses)</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>      <span class="c1">// Can't rob this house, move to the next one</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Check if the robber has stolen from at least k houses</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minCapability</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>  <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minCapability</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>  <span class="c1">// Expected output: 2</span>

        <span class="c1">// Additional test case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minCapability</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>  <span class="c1">// Expected output: 7</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes. The capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed. You are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars. You are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses. Return the minimum capability of the robber out of all the possible ways to steal at least k houses.]]></summary></entry><entry><title type="html">2094. Finding 3-Digit Even Numbers</title><link href="https://zhengstar94.github.io//blog/2025/Finding3DigitEvenNumbers/" rel="alternate" type="text/html" title="2094. Finding 3-Digit Even Numbers"/><published>2025-05-12T00:00:00+00:00</published><updated>2025-05-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/Finding3DigitEvenNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/Finding3DigitEvenNumbers/"><![CDATA[<ul> <li> <p>You are given an integer array <code class="language-plaintext highlighter-rouge">digits</code>, where each element is a digit. The array may contain duplicates.</p> </li> <li> <p>You need to find <strong>all</strong> the <strong>unique</strong> integers that follow the given requirements:</p> <ul> <li>The integer consists of the <strong>concatenation</strong> of <strong>three</strong> elements from <code class="language-plaintext highlighter-rouge">digits</code> in <strong>any</strong> arbitrary order.</li> <li>The integer does not have <strong>leading zeros</strong>.</li> <li>The integer is <strong>even</strong>.</li> </ul> </li> <li> <p>For example, if the given <code class="language-plaintext highlighter-rouge">digits</code> were <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>, integers <code class="language-plaintext highlighter-rouge">132</code> and <code class="language-plaintext highlighter-rouge">312</code> follow the requirements.</p> <p>Return <em>a <strong>sorted</strong> array of the unique integers.</em></p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: digits = [2,1,3,0]
Output: [102,120,130,132,210,230,302,310,312,320]
Explanation: All the possible integers that follow the requirements are in the output array. 
Notice that there are no odd integers or integers with leading zeros.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: digits = [2,2,8,8,2]
Output: [222,228,282,288,822,828,882]
Explanation: The same digit can be used as many times as it appears in digits. 
In this example, the digit 8 is used twice each time in 288, 828, and 882. 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: digits = [3,7,5]
Output: []
Explanation: No even integers can be formed using the given digits.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Finding3DigitEvenNumbers</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findEvenNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create an array to count the frequency of each digit (0-9) in the input array</span>
        <span class="c1">// This allows us to track how many times each digit appears in the input</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">digit</span> <span class="o">:</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">digit</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// List to store the valid 3-digit even numbers we find</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through all possible 3-digit even numbers</span>
        <span class="c1">// Start from 100 (smallest 3-digit number)</span>
        <span class="c1">// End at 998 (largest 3-digit even number)</span>
        <span class="c1">// Increment by 2 to only check even numbers (numbers ending with 0,2,4,6,8)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">998</span><span class="o">;</span> <span class="n">num</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Extract each digit from the current number</span>
            <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">100</span><span class="o">;</span>         <span class="c1">// Hundreds place (first digit)</span>
            <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>   <span class="c1">// Tens place (second digit)</span>
            <span class="kt">int</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>          <span class="c1">// Ones place (third digit)</span>

            <span class="c1">// Temporarily decrement the count for each digit we want to use</span>
            <span class="c1">// This simulates "using" these digits to form our number</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d1</span><span class="o">]--;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d2</span><span class="o">]--;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d3</span><span class="o">]--;</span>

            <span class="c1">// Check if we can form this number with the available digits</span>
            <span class="c1">// For each digit, if count &gt;= 0 after decrementing, it means:</span>
            <span class="c1">// 1. If count = 0: We've used exactly all occurrences of this digit</span>
            <span class="c1">// 2. If count &gt; 0: We still have more occurrences of this digit available</span>
            <span class="c1">// </span>
            <span class="c1">// If any count &lt; 0, it means we tried to use more occurrences of a digit</span>
            <span class="c1">// than what's available in the original array, which is invalid</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">d1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">d2</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">d3</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If all counts are valid (&gt;= 0), we can form this number</span>
                <span class="c1">// so add it to our result list</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Restore the counts for the next iteration</span>
            <span class="c1">// This is critical because we're only "simulating" using these digits</span>
            <span class="c1">// and need to reset for checking the next number</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d1</span><span class="o">]++;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d2</span><span class="o">]++;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d3</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Convert the ArrayList to a primitive int array and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Mixed digits with an even digit and zero</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">digits1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findEvenNumbers</span><span class="o">(</span><span class="n">digits1</span><span class="o">)));</span>

        <span class="c1">// Test case 2: Repeated digits</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">digits2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findEvenNumbers</span><span class="o">(</span><span class="n">digits2</span><span class="o">)));</span>

        <span class="c1">// Test case 3: Only odd digits, no even numbers possible</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">digits3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findEvenNumbers</span><span class="o">(</span><span class="n">digits3</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array digits, where each element is a digit. The array may contain duplicates.]]></summary></entry><entry><title type="html">2064. Minimized Maximum of Products Distributed to Any Store</title><link href="https://zhengstar94.github.io//blog/2025/MinimizedMaximumOfProductsDistributedToAnyStore/" rel="alternate" type="text/html" title="2064. Minimized Maximum of Products Distributed to Any Store"/><published>2025-05-12T00:00:00+00:00</published><updated>2025-05-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizedMaximumOfProductsDistributedToAnyStore</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizedMaximumOfProductsDistributedToAnyStore/"><![CDATA[<ul> <li>You are given an integer <code class="language-plaintext highlighter-rouge">n</code> indicating there are <code class="language-plaintext highlighter-rouge">n</code> specialty retail stores. There are <code class="language-plaintext highlighter-rouge">m</code> product types of varying amounts, which are given as a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">quantities</code>, where <code class="language-plaintext highlighter-rouge">quantities[i]</code> represents the number of products of the <code class="language-plaintext highlighter-rouge">ith</code> product type.</li> <li>You need to distribute <strong>all products</strong> to the retail stores following these rules: <ul> <li>A store can only be given <strong>at most one product type</strong> but can be given <strong>any</strong> amount of it.</li> <li>After distribution, each store will have been given some number of products (possibly <code class="language-plaintext highlighter-rouge">0</code>). Let <code class="language-plaintext highlighter-rouge">x</code> represent the maximum number of products given to any store. You want <code class="language-plaintext highlighter-rouge">x</code> to be as small as possible, i.e., you want to <strong>minimize</strong> the <strong>maximum</strong> number of products that are given to any store.</li> </ul> </li> <li>Return <em>the minimum possible</em> <code class="language-plaintext highlighter-rouge">x</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 6, quantities = [11,6]
Output: 3
Explanation: One optimal way is:
- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3
- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3
The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.

</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 7, quantities = [15,10,10]
Output: 5
Explanation: One optimal way is:
- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5
- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5
- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5
The maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1, quantities = [100000]
Output: 100000
Explanation: The only optimal way is:
- The 100000 products of type 0 are distributed to the only store.
The maximum number of products given to any store is max(100000) = 100000.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(k * log(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizedMaximumOfProductsDistributedToAnyStore</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizedMaximum</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// The minimum possible maxProducts is 1 (each store gets at least 1 product)</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Will hold the maximum of all quantities to initialize upper bound</span>

        <span class="c1">// Find the maximum product quantity among all types to set the upper bound</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">quantity</span> <span class="o">:</span> <span class="n">quantities</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">quantity</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Binary search for the smallest feasible maxProducts value</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// Avoids overflow</span>

            <span class="c1">// Check if it's possible to distribute all products with maxProducts = mid</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canDistribute</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">quantities</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If it's possible, try a smaller max value to minimize the maximum</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If not possible, we need to increase the allowed max per store</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After the loop, left == right and it's the smallest feasible maxProducts value</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canDistribute</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxProducts</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">storesNeeded</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Total number of stores needed under current maxProducts constraint</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">quantity</span> <span class="o">:</span> <span class="n">quantities</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each product type, calculate how many stores are needed</span>
            <span class="c1">// Formula: ceil(quantity / maxProducts)</span>
            <span class="n">storesNeeded</span> <span class="o">+=</span> <span class="o">(</span><span class="n">quantity</span> <span class="o">+</span> <span class="n">maxProducts</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">maxProducts</span><span class="o">;</span>

            <span class="c1">// If more stores are needed than we have, the distribution fails</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">storesNeeded</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we can serve all products within n stores, return true</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">11</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Output: "</span> <span class="o">+</span> <span class="n">minimizedMaximum</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">quantities1</span><span class="o">));</span>
        <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Output: "</span> <span class="o">+</span> <span class="n">minimizedMaximum</span><span class="o">(</span><span class="n">n2</span><span class="o">,</span> <span class="n">quantities2</span><span class="o">));</span>
        <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100000</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Output: "</span> <span class="o">+</span> <span class="n">minimizedMaximum</span><span class="o">(</span><span class="n">n3</span><span class="o">,</span> <span class="n">quantities3</span><span class="o">));</span>
        <span class="c1">// Expected output: 100000</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type. You need to distribute all products to the retail stores following these rules: A store can only be given at most one product type but can be given any amount of it. After distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store. Return the minimum possible x.]]></summary></entry><entry><title type="html">1550. Three Consecutive Odds</title><link href="https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds/" rel="alternate" type="text/html" title="1550. Three Consecutive Odds"/><published>2025-05-11T00:00:00+00:00</published><updated>2025-05-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">arr</code>, return <code class="language-plaintext highlighter-rouge">true</code> if there are three consecutive odd numbers in the array. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeConsecutiveOdds</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">threeConsecutiveOdds</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: If array length is less than 3, it's impossible to have three consecutive elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Counter to track the number of consecutive odd integers encountered</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if the current number is odd (remainder when divided by 2 is 1)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="c1">// Increment the counter for consecutive odd numbers</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="c1">// If we've found three consecutive odd numbers, return true</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we encounter an even number, reset the counter</span>
                <span class="c1">// as it breaks the consecutive sequence of odd numbers</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we've traversed the entire array without finding three consecutive odd numbers, return false</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with no three consecutive odd numbers</span>
        <span class="c1">// Expected output: false</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 2: Array with three consecutive odd numbers (5, 7, 23)</span>
        <span class="c1">// Expected output: true</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">12</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 3: Array with exactly three elements, all odd</span>
        <span class="c1">// Expected output: true</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 4: Array with consecutive odd numbers scattered throughout</span>
        <span class="c1">// Expected output: true (could be because of 7, 3, 1 or 3, 1, 9 or 1, 9, 5)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr4</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 5: Array with only even numbers</span>
        <span class="c1">// Expected output: false</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr5</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.]]></summary></entry></feed>