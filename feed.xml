<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-26T06:59:34+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1010. Pairs of Songs With Total Durations Divisible by 60</title><link href="https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs/" rel="alternate" type="text/html" title="1010. Pairs of Songs With Total Durations Divisible by 60"/><published>2024-11-26T00:00:00+00:00</published><updated>2024-11-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs/"><![CDATA[<h1 id="447-number-of-boomerangs">447. Number of Boomerangs</h1> <ul> <li>You are given <code class="language-plaintext highlighter-rouge">n</code> <code class="language-plaintext highlighter-rouge">points</code> in the plane that are all <strong>distinct</strong>, where <code class="language-plaintext highlighter-rouge">points[i] = [xi, yi]</code>. A <strong>boomerang</strong> is a tuple of points <code class="language-plaintext highlighter-rouge">(i, j, k)</code> such that the distance between <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> equals the distance between <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">k</code> <strong>(the order of the tuple matters)</strong>.</li> <li>Return <em>the number of boomerangs</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [0,0],[1,0],[2,0] ]
Output: 2
Explanation: The two boomerangs are [ [1,0],[0,0],[2,0] ] and [ [1,0],[2,0],[0,0] ].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [1,1],[2,2],[3,3] ]
Output: 2
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [ 1,1 ] ]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfBoomerangs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfBoomerangs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Variable to store the total boomerang count</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each point as the potential central point</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// HashMap to store distances and their point frequencies</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">distanceMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// Calculate distances from current point to all other points</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Skip calculating distance to the same point</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Calculate squared distance between points</span>
                    <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">calculateDistance</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>

                    <span class="c1">// Update frequency of this distance in the map</span>
                    <span class="c1">// If distance not exists, set count to 1; otherwise, increment</span>
                    <span class="n">distanceMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">distanceMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Calculate boomerang combinations for each distance group</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="n">distanceMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                <span class="cm">/*
                 * Boomerang Calculation Logic:
                 * - 'count' represents points at the same distance from central point
                 * - For each distance group, calculate possible boomerang arrangements
                 *
                 * Mathematical Combination Explanation:
                 * 1. Total points at same distance: count
                 * 2. Choose first point: count options
                 * 3. Choose second point: (count - 1) options
                 * 4. Calculation: count * (count - 1)
                 *
                 * Example:
                 * If 4 points are at same distance:
                 * - First point selection: 4 ways
                 * - Second point selection: 3 ways
                 * - Total boomerang arrangements: 4 * 3 = 12
                 */</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculateDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">point1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">point2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate x and y coordinate differences</span>
        <span class="kt">int</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">point1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">point2</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">point1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">point2</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Return squared distance (Pythagorean theorem without square root)</span>
        <span class="k">return</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Points in a diagonal line</span>
        <span class="c1">// Expected to have some boomerang arrangements</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Points in a horizontal line</span>
        <span class="c1">// High likelihood of boomerang formations</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Single point</span>
        <span class="c1">// No boomerangs possible</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[447. Number of Boomerangs]]></summary></entry><entry><title type="html">1010. Pairs of Songs With Total Durations Divisible by 60</title><link href="https://zhengstar94.github.io//blog/2024/NumPairsDivisibleBy60/" rel="alternate" type="text/html" title="1010. Pairs of Songs With Total Durations Divisible by 60"/><published>2024-11-25T00:00:00+00:00</published><updated>2024-11-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NumPairsDivisibleBy60</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NumPairsDivisibleBy60/"><![CDATA[<ul> <li>You are given a list of songs where the <code class="language-plaintext highlighter-rouge">ith</code> song has a duration of <code class="language-plaintext highlighter-rouge">time[i]</code> seconds.</li> <li>Return <em>the number of pairs of songs for which their total duration in seconds is divisible by</em> <code class="language-plaintext highlighter-rouge">60</code>. Formally, we want the number of indices <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">j</code> such that <code class="language-plaintext highlighter-rouge">i &lt; j</code> with <code class="language-plaintext highlighter-rouge">(time[i] + time[j]) % 60 == 0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumPairsDivisibleBy60</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numPairsDivisibleBy60</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the count of remainders when divided by 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">remainders</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">60</span><span class="o">];</span>
        <span class="c1">// Counter for valid pairs</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">t:</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the remainder of current number when divided by 60</span>
            <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">60</span><span class="o">;</span>

            <span class="c1">// Calculate the complementary remainder</span>
            <span class="c1">// If remainder is 0, complement should be 0</span>
            <span class="c1">// If remainder is 30, complement should be 30</span>
            <span class="c1">// For all other cases, complement is (60 - remainder)</span>
            <span class="c1">// Using % 60 to handle the case when remainder is 0</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="o">(</span><span class="mi">60</span> <span class="o">-</span> <span class="n">remainder</span><span class="o">)</span> <span class="o">%</span> <span class="mi">60</span><span class="o">;</span>

            <span class="c1">// Key logic explanation:</span>
            <span class="c1">// 1. remainders[complement] stores the count of numbers previously seen</span>
            <span class="c1">//    that have a remainder equal to complement when divided by 60</span>
            <span class="c1">// 2. Current number t can form a valid pair with any number that has</span>
            <span class="c1">//    a remainder of complement, as their sum will be divisible by 60</span>
            <span class="c1">// 3. Therefore, add remainders[complement] to count, representing</span>
            <span class="c1">//    the number of valid pairs that can be formed with current number</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">remainders</span><span class="o">[</span><span class="n">complement</span><span class="o">];</span>

            <span class="c1">// Update the count of current remainder</span>
            <span class="c1">// This prepares for future numbers that might pair with this one</span>
            <span class="n">remainders</span><span class="o">[</span><span class="n">remainder</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Regular case with multiple possible pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">30</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">150</span><span class="o">,</span><span class="mi">100</span><span class="o">,</span><span class="mi">40</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: [ 30,20,150,100,40 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: All numbers are multiples of 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">60</span><span class="o">,</span><span class="mi">60</span><span class="o">,</span><span class="mi">60</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: [ 60,60,60 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: No pairs sum up to multiple of 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: [ 1,2,3,4 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 0"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Contains 0 and multiples of 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">60</span><span class="o">,</span><span class="mi">120</span><span class="o">,</span><span class="mi">180</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: [ 0,60,120,180 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Testing complementary remainders</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">50</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">40</span><span class="o">};</span>  <span class="c1">// 10+50=60, 20+40=60</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: [ 10,50,20,40 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60== 0.]]></summary></entry><entry><title type="html">523. Continuous Subarray Sum</title><link href="https://zhengstar94.github.io//blog/2024/ContinuousSubarraySum/" rel="alternate" type="text/html" title="523. Continuous Subarray Sum"/><published>2024-11-24T00:00:00+00:00</published><updated>2024-11-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ContinuousSubarraySum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ContinuousSubarraySum/"><![CDATA[<ul> <li>Given an integer array nums and an integer k, return <code class="language-plaintext highlighter-rouge">true</code> <em>if</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>has a <strong>good subarray</strong> or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> <li>A <strong>good subarray</strong> is a subarray where: <ul> <li>its length is <strong>at least two</strong>, and</li> <li>the sum of the elements of the subarray is a multiple of <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> </li> <li><strong>Note</strong> that: <ul> <li>A <strong>subarray</strong> is a contiguous part of the array.</li> <li>An integer <code class="language-plaintext highlighter-rouge">x</code> is a multiple of <code class="language-plaintext highlighter-rouge">k</code> if there exists an integer <code class="language-plaintext highlighter-rouge">n</code> such that <code class="language-plaintext highlighter-rouge">x = n * k</code>. <code class="language-plaintext highlighter-rouge">0</code> is <strong>always</strong> a multiple of <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [23,2,6,4,7], k = 13
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(min(n, k)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContinuousSubarraySum</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkSubarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store remainder as key and index as value</span>
        <span class="c1">// Key: running sum % k, Value: index where this remainder was first seen</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">preSumMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Initialize map with 0 remainder at index -1</span>
        <span class="c1">// This handles the case where the subarray starts from index 0</span>
        <span class="n">preSumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Running sum variable to keep track of cumulative sum % k</span>
        <span class="kt">int</span> <span class="n">curSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update running sum and take modulo to keep remainder</span>
            <span class="c1">// Using property: (a + b) % k = ((a % k) + (b % k)) % k</span>
            <span class="n">curSum</span> <span class="o">=</span> <span class="o">(</span><span class="n">curSum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">%</span> <span class="n">k</span><span class="o">;</span>

            <span class="c1">// If we've seen this remainder before</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">preSumMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">curSum</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Check if the subarray length is at least 2</span>
                <span class="c1">// Current index - Previous index where we saw the same remainder</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">preSumMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curSum</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Found a valid subarray whose sum is divisible by k</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// First time seeing this remainder, store it with current index</span>
                <span class="n">preSumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">curSum</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// No valid subarray found</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output: true</span>
        <span class="c1">// Subarray [2,4] has sum 6, which is divisible by 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expected output: true</span>
        <span class="c1">// The entire array sum is 42, which is divisible by 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expected output: false</span>
        <span class="c1">// No subarray with sum divisible by 13</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">13</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Edge case - single element array</span>
        <span class="c1">// Expected output: false (subarray must have length &gt;= 2)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Expected output: true</span>
        <span class="c1">// Contains subarray with sum divisible by 7</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">k5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise. A good subarray is a subarray where: its length is at least two, and the sum of the elements of the subarray is a multiple of k. Note that: A subarray is a contiguous part of the array. An integer x is a multiple of k if there exists an integer n such that x=n * k. 0 is always a multiple of k.]]></summary></entry><entry><title type="html">791. Custom Sort String</title><link href="https://zhengstar94.github.io//blog/2024/CustomSortString/" rel="alternate" type="text/html" title="791. Custom Sort String"/><published>2024-11-23T00:00:00+00:00</published><updated>2024-11-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CustomSortString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CustomSortString/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">order</code> and <code class="language-plaintext highlighter-rouge">s</code>. All the characters of <code class="language-plaintext highlighter-rouge">order</code> are <strong>unique</strong> and were sorted in some custom order previously.</li> <li>Permute the characters of <code class="language-plaintext highlighter-rouge">s</code> so that they match the order that <code class="language-plaintext highlighter-rouge">order</code> was sorted. More specifically, if a character <code class="language-plaintext highlighter-rouge">x</code> occurs before a character <code class="language-plaintext highlighter-rouge">y</code> in <code class="language-plaintext highlighter-rouge">order</code>, then <code class="language-plaintext highlighter-rouge">x</code> should occur before <code class="language-plaintext highlighter-rouge">y</code> in the permuted string.</li> <li>Return <em>any permutation of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that satisfies this property</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: order = "cba", s = "abcd"

Output: "cbad"

Explanation: "a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a".

Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: order = "bcafg", s = "abcd"

Output: "bcad"

Explanation: The characters "b", "c", and "a" from order dictate  the order for the characters in s. The character "d" in s does not appear in order, so its position is flexible.

Following the order of appearance in order, "b", "c", and "a" from s should be arranged as "b", "c", "a". "d" can be placed at any position since it's not in order. The output "bcad" correctly follows this rule. Other arrangements like "dbca" or "bcda" would also be valid, as long as "b", "c", "a" maintain their order.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomSortString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">customSortString</span><span class="o">(</span><span class="nc">String</span> <span class="n">order</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a frequency array to store count of each character in s</span>
        <span class="c1">// Index 0 represents 'a', 1 represents 'b', and so on</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Count frequency of each character in string s</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// StringBuilder to construct the result efficiently</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// First, append characters according to the order string</span>
        <span class="c1">// For each character in order, append it to result as many times as it appears in s</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">order</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="c1">// Decrement count after appending each character</span>
                <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Finally, append any remaining characters that weren't in order</span>
        <span class="c1">// This ensures all characters from s are included in the result</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span> <span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic test</span>
        <span class="nc">String</span> <span class="n">order1</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order1</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order1</span><span class="o">,</span> <span class="n">s1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Order string longer than s</span>
        <span class="nc">String</span> <span class="n">order2</span> <span class="o">=</span> <span class="s">"bcafg"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order2</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order2</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: String s contains duplicate characters</span>
        <span class="nc">String</span> <span class="n">order3</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aabcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (contains duplicate characters):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order3</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order3</span><span class="o">,</span> <span class="n">s3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Order contains characters not in s</span>
        <span class="nc">String</span> <span class="n">order4</span> <span class="o">=</span> <span class="s">"cbafg"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 (order contains characters not in s):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order4</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order4</span><span class="o">,</span> <span class="n">s4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: String s contains characters not in order</span>
        <span class="nc">String</span> <span class="n">order5</span> <span class="o">=</span> <span class="s">"cb"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 (s contains characters not in order):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order5</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order5</span><span class="o">,</span> <span class="n">s5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously. Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string. Return any permutation of s that satisfies this property.]]></summary></entry><entry><title type="html">525. Contiguous Array</title><link href="https://zhengstar94.github.io//blog/2024/ContiguousArray/" rel="alternate" type="text/html" title="525. Contiguous Array"/><published>2024-11-22T00:00:00+00:00</published><updated>2024-11-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ContiguousArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ContiguousArray/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the maximum length of a contiguous subarray with an equal number of</em> <code class="language-plaintext highlighter-rouge">0</code> <em>and</em> <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContiguousArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Map to store the first occurrence of each count</span>
        <span class="c1">// Key: running sum (count), Value: index where this count first appeared</span>
        <span class="c1">// Initialize with 0 at index -1 to handle cases where valid subarray starts from index 0</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// maxLen: tracks the length of the longest valid subarray found so far</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// count: running sum (treating 0 as -1 and 1 as 1)</span>
        <span class="c1">// When count remains unchanged between two positions, the subarray between them has equal 0s and 1s</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update running sum: add 1 for 1s, subtract 1 for 0s</span>
            <span class="c1">// This helps track the balance between 0s and 1s</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

            <span class="c1">// If we've seen this count before, we've found a valid subarray</span>
            <span class="c1">// Example: if count becomes 0 again, it means we have equal 0s and 1s from the start</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">count</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Calculate length of current valid subarray (current position - previous position with same count)</span>
                <span class="c1">// Update maxLen if current valid subarray is longer</span>
                <span class="c1">// Example: if count = 1 appears at index 2 and 5, then indexes 3,4,5 form a valid subarray</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">count</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If this is the first time we see this count, record its position</span>
                <span class="c1">// We only store the first occurrence to find the longest possible subarray</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic case with alternating values</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 2: Minimal case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 3: Grouped zeros and ones</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.]]></summary></entry><entry><title type="html">278. First Bad Version</title><link href="https://zhengstar94.github.io//blog/2024/FirstBadVersion/" rel="alternate" type="text/html" title="278. First Bad Version"/><published>2024-11-21T00:00:00+00:00</published><updated>2024-11-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/FirstBadVersion</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/FirstBadVersion/"><![CDATA[<ul> <li>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</li> <li>Suppose you have <code class="language-plaintext highlighter-rouge">n</code> versions <code class="language-plaintext highlighter-rouge">[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</li> <li>You are given an API <code class="language-plaintext highlighter-rouge">bool isBadVersion(version)</code> which returns whether <code class="language-plaintext highlighter-rouge">version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -&gt; false
call isBadVersion(5) -&gt; true
call isBadVersion(4) -&gt; true
Then 4 is the first bad version.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1, bad = 1
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(logn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstBadVersion</span> <span class="kd">extends</span> <span class="nc">VersionControl</span><span class="o">{</span>
    <span class="c1">// Reference to the VersionControl instance</span>
    <span class="nc">VersionControl</span> <span class="n">versionControl</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstBadVersion</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Use binary search to find the first bad version</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate mid point to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If mid is a bad version, search in the left half</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">versionControl</span><span class="o">.</span><span class="na">isBadVersion</span><span class="o">(</span><span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If mid is a good version, search in the right half</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the first bad version</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">VersionControl</span> <span class="o">{</span>
    <span class="c1">// The first bad version number</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">firstBadVersion</span><span class="o">;</span>

    <span class="c1">// Constructor with specified first bad version</span>
    <span class="kd">public</span> <span class="nf">VersionControl</span><span class="o">(</span><span class="kt">int</span> <span class="n">firstBadVersion</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">firstBadVersion</span> <span class="o">=</span> <span class="n">firstBadVersion</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Default constructor with first bad version set to 4</span>
    <span class="kd">public</span> <span class="nf">VersionControl</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">firstBadVersion</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// API method to check if a version is bad</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBadVersion</span><span class="o">(</span><span class="kt">int</span> <span class="n">version</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Return true if version is greater than or equal to first bad version</span>
        <span class="k">return</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="n">firstBadVersion</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test method to validate the solution</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Bad version is 4</span>
        <span class="nc">VersionControl</span> <span class="n">vc1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VersionControl</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="nc">FirstBadVersion</span> <span class="nc">FirstBadVersion1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FirstBadVersion</span><span class="o">();</span>
        <span class="nc">FirstBadVersion1</span><span class="o">.</span><span class="na">versionControl</span> <span class="o">=</span> <span class="n">vc1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 (Bad Version 4): "</span> <span class="o">+</span> <span class="nc">FirstBadVersion1</span><span class="o">.</span><span class="na">firstBadVersion</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2: Bad version is 1</span>
        <span class="nc">VersionControl</span> <span class="n">vc2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VersionControl</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">FirstBadVersion</span> <span class="nc">FirstBadVersion2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FirstBadVersion</span><span class="o">();</span>
        <span class="nc">FirstBadVersion2</span><span class="o">.</span><span class="na">versionControl</span> <span class="o">=</span> <span class="n">vc2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 (Bad Version 1): "</span> <span class="o">+</span> <span class="nc">FirstBadVersion2</span><span class="o">.</span><span class="na">firstBadVersion</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 3: Bad version is 2</span>
        <span class="nc">VersionControl</span> <span class="n">vc3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VersionControl</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">FirstBadVersion</span> <span class="nc">FirstBadVersion3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FirstBadVersion</span><span class="o">();</span>
        <span class="nc">FirstBadVersion3</span><span class="o">.</span><span class="na">versionControl</span> <span class="o">=</span> <span class="n">vc3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Bad Version 2): "</span> <span class="o">+</span> <span class="nc">FirstBadVersion3</span><span class="o">.</span><span class="na">firstBadVersion</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch"/><summary type="html"><![CDATA[You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.]]></summary></entry><entry><title type="html">219. Contains Duplicate II</title><link href="https://zhengstar94.github.io//blog/2024/ContainsDuplicateII/" rel="alternate" type="text/html" title="219. Contains Duplicate II"/><published>2024-11-20T00:00:00+00:00</published><updated>2024-11-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ContainsDuplicateII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ContainsDuplicateII/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if there are two <strong>distinct indices</strong></em> <code class="language-plaintext highlighter-rouge">i</code> <em>and</em> <code class="language-plaintext highlighter-rouge">j</code> <em>in the array such that</em> <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code> <em>and</em> <code class="language-plaintext highlighter-rouge">abs(i - j) &lt;= k</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1], k = 3
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,0,1,1], k = 1
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContainsDuplicateII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to store the value and its last occurrence index.</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if the current number already exists in the map.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="c1">// Retrieve the index of the previous occurrence of nums[i].</span>
                <span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

                <span class="c1">// If the difference between the current and previous indices is &lt;= k, return true.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">prevIndex</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Update the map with the current index of nums[i].</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// If no such pair is found, return false.</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Duplicate "1" within distance 3 -&gt; Expected: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span> <span class="o">},</span> <span class="mi">3</span> <span class="o">));</span> <span class="c1">// true</span>

        <span class="c1">// Test case 2: Duplicate "1" within distance 1 -&gt; Expected: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="o">},</span> <span class="mi">1</span> <span class="o">));</span> <span class="c1">// true</span>

        <span class="c1">// Test case 3: No duplicates within the required distance -&gt; Expected: false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">},</span> <span class="mi">2</span> <span class="o">));</span> <span class="c1">// false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.]]></summary></entry><entry><title type="html">14. Longest Common Prefix</title><link href="https://zhengstar94.github.io//blog/2024/LongestCommonPrefix/" rel="alternate" type="text/html" title="14. Longest Common Prefix"/><published>2024-11-19T00:00:00+00:00</published><updated>2024-11-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestCommonPrefix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestCommonPrefix/"><![CDATA[<ul> <li>Write a function to find the longest common prefix string amongst an array of strings.</li> <li>If there is no common prefix, return an empty string <code class="language-plaintext highlighter-rouge">""</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: strs = [ "flower","flow","flight" ]
Output: "fl"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: strs = [ "dog","racecar","car" ]
Output: ""
Explanation: There is no common prefix among the input strings.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(S) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestCommonPrefix</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: return empty string if array is null or empty</span>
        <span class="k">if</span><span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If array contains only one string, return that string as the prefix</span>
        <span class="k">if</span><span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Initialize prefix with the first string</span>
        <span class="nc">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the remaining strings in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="cm">/**
             * The indexOf(prefix) method returns the position where the prefix starts in the string
             * If prefix is found at the beginning of the string, indexOf returns 0
             * If prefix is not found at the beginning:
             * - Either prefix is not in the string at all (returns -1)
             * - Or prefix is found but not at the start (returns &gt; 0)
             * In both cases, we need to shorten the prefix
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">indexOf</span><span class="o">(</span><span class="n">prefix</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/**
                 * Shorten the prefix by removing its last character:
                 * - substring(0, prefix.length() - 1) creates a new string
                 * - Starting from index 0 (inclusive)
                 * - Ending at prefix.length() - 1 (exclusive)
                 * Example:
                 * If prefix = "flower", new prefix will be "flowe"
                 * This process continues until either:
                 * 1. The shortened prefix is found at the start of current string
                 * 2. Or prefix becomes empty string
                 */</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

                <span class="c1">// If prefix becomes empty, there is no common prefix</span>
                <span class="k">if</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the final common prefix found</span>
        <span class="k">return</span> <span class="n">prefix</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: strings with common prefix "fl"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"flower"</span><span class="o">,</span> <span class="s">"flow"</span><span class="o">,</span> <span class="s">"flight"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>  <span class="c1">// Expected output: "fl"</span>

        <span class="c1">// Test case 2: strings with no common prefix</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"racecar"</span><span class="o">,</span> <span class="s">"car"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>  <span class="c1">// Expected output: ""</span>

        <span class="c1">// Test case 3: empty array</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>  <span class="c1">// Expected output: ""</span>

        <span class="c1">// Test case 4: array with single string</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"single"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>  <span class="c1">// Expected output: "single"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><summary type="html"><![CDATA[Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".]]></summary></entry><entry><title type="html">1768. Merge Strings Alternately</title><link href="https://zhengstar94.github.io//blog/2024/MergeStringsAlternately/" rel="alternate" type="text/html" title="1768. Merge Strings Alternately"/><published>2024-11-18T00:00:00+00:00</published><updated>2024-11-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MergeStringsAlternately</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MergeStringsAlternately/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">word1</code> and <code class="language-plaintext highlighter-rouge">word2</code>. Merge the strings by adding letters in alternating order, starting with <code class="language-plaintext highlighter-rouge">word1</code>. If a string is longer than the other, append the additional letters onto the end of the merged string.</li> <li>Return <em>the merged string.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "abc", word2 = "pqr"
Output: "apbqcr"
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "ab", word2 = "pqrs"
Output: "apbqrs"
Explanation: Notice that as word2 is longer, "rs" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "abcd", word2 = "pq"
Output: "apbqcd"
Explanation: Notice that as word1 is longer, "cd" is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m + n) time | O(m + n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeStringsAlternately</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">mergeAlternately</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// StringBuilder is used for efficient string concatenation</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="c1">// Two pointers to track current position in each string</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// pointer for word1</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// pointer for word2</span>

        <span class="c1">// Process both strings until we reach the end of either string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="c1">// Append current character from word1 and increment pointer</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">++));</span>
            <span class="c1">// Append current character from word2 and increment pointer</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">++));</span>
        <span class="o">}</span>

        <span class="c1">// Append remaining characters from word1 (if any)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">++));</span>
        <span class="o">}</span>

        <span class="c1">// Append remaining characters from word2 (if any)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">++));</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Equal length strings</span>
        <span class="nc">String</span> <span class="n">word1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"pqr"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 - Equal length strings:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: apbqcr"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Second string is longer</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"pqrs"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 - Second string is longer:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: apbqrs"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: First string is longer</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"pq"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 - First string is longer:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: apbqcd"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Empty string case</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"pqr"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 - First string is empty:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: pqr"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string.]]></summary></entry><entry><title type="html">986. Interval List Intersections</title><link href="https://zhengstar94.github.io//blog/2024/IntervalListIntersections/" rel="alternate" type="text/html" title="986. Interval List Intersections"/><published>2024-11-17T00:00:00+00:00</published><updated>2024-11-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/IntervalListIntersections</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/IntervalListIntersections/"><![CDATA[<ul> <li>You are given two lists of closed intervals, <code class="language-plaintext highlighter-rouge">firstList</code> and <code class="language-plaintext highlighter-rouge">secondList</code>, where <code class="language-plaintext highlighter-rouge">firstList[i] = [starti, endi]</code> and <code class="language-plaintext highlighter-rouge">secondList[j] = [startj, endj]</code>. Each list of intervals is pairwise <strong>disjoint</strong> and in <strong>sorted order</strong>.</li> <li>Return <em>the intersection of these two interval lists</em>.</li> <li>A <strong>closed interval</strong> <code class="language-plaintext highlighter-rouge">[a, b]</code> (with <code class="language-plaintext highlighter-rouge">a &lt;= b</code>) denotes the set of real numbers <code class="language-plaintext highlighter-rouge">x</code> with <code class="language-plaintext highlighter-rouge">a &lt;= x &lt;= b</code>.</li> <li>The <strong>intersection</strong> of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of <code class="language-plaintext highlighter-rouge">[1, 3]</code> and <code class="language-plaintext highlighter-rouge">[2, 4]</code> is <code class="language-plaintext highlighter-rouge">[2, 3]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: firstList = [ [0,2],[5,10],[13,23],[24,25] ], secondList = [ [1,5],[8,12],[15,24],[25,26] ]
Output: [ [1,2],[5,5],[8,10],[15,23],[24,24],[25,25] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: firstList = [ [1,3],[5,9] ], secondList = []
Output: []
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(n + m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntervalListIntersections</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">intervalIntersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ArrayList to store intersection intervals</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Two pointers to traverse both lists</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for firstList</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for secondList</span>

        <span class="c1">// Continue until we reach the end of either list</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">firstList</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">secondList</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Extract start and end points of current intervals</span>
            <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">firstList</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>   <span class="c1">// start of interval from first list</span>
            <span class="kt">int</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">firstList</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>     <span class="c1">// end of interval from first list</span>

            <span class="kt">int</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">secondList</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>   <span class="c1">// start of interval from second list</span>
            <span class="kt">int</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">secondList</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>     <span class="c1">// end of interval from second list</span>

            <span class="c1">// Find the intersection points</span>
            <span class="c1">// Intersection start is the maximum of both starts</span>
            <span class="kt">int</span> <span class="n">intersectStart</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">start1</span><span class="o">,</span> <span class="n">start2</span><span class="o">);</span>
            <span class="c1">// Intersection end is the minimum of both ends</span>
            <span class="kt">int</span> <span class="n">intersectEnd</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">end1</span><span class="o">,</span> <span class="n">end2</span><span class="o">);</span>

            <span class="c1">// If we have a valid intersection (start &lt;= end)</span>
            <span class="c1">// add it to our result list</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intersectStart</span> <span class="o">&lt;=</span> <span class="n">intersectEnd</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">intersectStart</span><span class="o">,</span> <span class="n">intersectEnd</span><span class="o">});</span>
            <span class="o">}</span>

            <span class="c1">// Move the pointer of the interval that ends first</span>
            <span class="c1">// This is crucial for not missing any potential intersections</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">end1</span> <span class="o">&lt;</span> <span class="n">end2</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>  <span class="c1">// first interval ends earlier, move to next interval in first list</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>  <span class="c1">// second interval ends earlier or at same time, move to next interval in second list</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert ArrayList to array and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple intersections</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">13</span><span class="o">,</span><span class="mi">23</span><span class="o">},</span> <span class="o">{</span><span class="mi">24</span><span class="o">,</span><span class="mi">25</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span><span class="mi">24</span><span class="o">},</span> <span class="o">{</span><span class="mi">25</span><span class="o">,</span><span class="mi">26</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList1</span><span class="o">,</span> <span class="n">secondList1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Empty list scenario</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">9</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList2</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList2</span><span class="o">,</span> <span class="n">secondList2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Complete overlap scenario</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Complete Overlap):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList3</span><span class="o">,</span> <span class="n">secondList3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].]]></summary></entry></feed>