<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-15T08:40:32+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2429. Minimize XOR</title><link href="https://zhengstar94.github.io//blog/2025/MinimizeXOR/" rel="alternate" type="text/html" title="2429. Minimize XOR"/><published>2025-01-15T00:00:00+00:00</published><updated>2025-01-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizeXOR</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizeXOR/"><![CDATA[<ul> <li>Given two positive integers <code class="language-plaintext highlighter-rouge">num1</code> and <code class="language-plaintext highlighter-rouge">num2</code>, find the positive integer <code class="language-plaintext highlighter-rouge">x</code> such that: <ul> <li><code class="language-plaintext highlighter-rouge">x</code> has the same number of set bits as <code class="language-plaintext highlighter-rouge">num2</code>, and</li> <li>The value <code class="language-plaintext highlighter-rouge">x XOR num1</code> is <strong>minimal</strong>.</li> </ul> </li> <li>Note that <code class="language-plaintext highlighter-rouge">XOR</code> is the bitwise XOR operation.</li> <li>Return <em>the integer</em> <code class="language-plaintext highlighter-rouge">x</code>. The test cases are generated such that <code class="language-plaintext highlighter-rouge">x</code> is <strong>uniquely determined</strong>.</li> <li>The number of <strong>set bits</strong> of an integer is the number of <code class="language-plaintext highlighter-rouge">1</code>’s in its binary representation.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 3, num2 = 5
Output: 3
Explanation:
The binary representations of num1 and num2 are 0011 and 0101, respectively.
The integer 3 has the same number of set bits as num2, and the value 3 XOR 3 = 0 is minimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 1, num2 = 12
Output: 3
Explanation:
The binary representations of num1 and num2 are 0001 and 1100, respectively.
The integer 3 has the same number of set bits as num2, and the value 3 XOR 1 = 2 is minimal.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizeXOR</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizeXor</span><span class="o">(</span><span class="kt">int</span> <span class="n">num1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Count the number of set bits (1's) in both numbers using built-in function</span>
        <span class="kt">int</span> <span class="n">cnt1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">num1</span><span class="o">);</span> <span class="c1">// Count of 1's in num1's binary representation</span>
        <span class="kt">int</span> <span class="n">cnt2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">num2</span><span class="o">);</span> <span class="c1">// Count of 1's in num2's binary representation</span>

        <span class="c1">// If num1 has more 1's than needed, remove excess 1's from lowest positions</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">cnt1</span> <span class="o">&gt;</span> <span class="n">cnt2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Bitwise operation: num1 &amp; (num1 - 1)</span>
            <span class="c1">// Example: if num1 = 1100 (12), then num1 - 1 = 1011</span>
            <span class="c1">// 1100 &amp; 1011 = 1000 (removes the lowest 1)</span>
            <span class="n">num1</span> <span class="o">&amp;=</span> <span class="n">num1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Clear the lowest set bit (1) in num1</span>
            <span class="n">cnt1</span><span class="o">--;</span>            <span class="c1">// Decrement the count of 1's</span>
        <span class="o">}</span>

        <span class="c1">// If num1 has fewer 1's than needed, add 1's starting from lowest positions</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">cnt1</span> <span class="o">&lt;</span> <span class="n">cnt2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Bitwise operation: num1 | (num1 + 1)</span>
            <span class="c1">// Example: if num1 = 1000, then num1 + 1 = 1001</span>
            <span class="c1">// 1000 | 1001 = 1001 (sets the lowest 0 to 1)</span>
            <span class="n">num1</span> <span class="o">|=</span> <span class="n">num1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Set the lowest unset bit (0) to 1</span>
            <span class="n">cnt1</span><span class="o">++;</span>            <span class="c1">// Increment the count of 1's</span>
        <span class="o">}</span>

        <span class="c1">// Return the adjusted num1 which now has the same number of 1's as num2</span>
        <span class="c1">// and minimizes XOR with the original num1</span>
        <span class="k">return</span> <span class="n">num1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span> <span class="n">num1_1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">num2_1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minimizeXor</span><span class="o">(</span><span class="n">num1_1</span><span class="o">,</span> <span class="n">num2_1</span><span class="o">));</span> <span class="c1">// Expected Output: 3</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span> <span class="n">num1_2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">num2_2</span> <span class="o">=</span> <span class="mi">12</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minimizeXor</span><span class="o">(</span><span class="n">num1_2</span><span class="o">,</span> <span class="n">num2_2</span><span class="o">));</span> <span class="c1">// Expected Output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[Given two positive integers num1 and num2, find the positive integer x such that: x has the same number of set bits as num2, and The value x XOR num1 is minimal. Note that XOR is the bitwise XOR operation. Return the integer x. The test cases are generated such that x is uniquely determined. The number of set bits of an integer is the number of 1’s in its binary representation.]]></summary></entry><entry><title type="html">3066. Minimum Operations to Exceed Threshold Value II</title><link href="https://zhengstar94.github.io//blog/2025/MinimumOperationsToExceedThresholdValueII/" rel="alternate" type="text/html" title="3066. Minimum Operations to Exceed Threshold Value II"/><published>2025-01-15T00:00:00+00:00</published><updated>2025-01-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumOperationsToExceedThresholdValueII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumOperationsToExceedThresholdValueII/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>, and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>In one operation, you will: <ul> <li>Take the two smallest integers <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Remove <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> from <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Add <code class="language-plaintext highlighter-rouge">min(x, y) * 2 + max(x, y)</code> anywhere in the array.</li> </ul> </li> <li><strong>Note</strong> that you can only apply the described operation if <code class="language-plaintext highlighter-rouge">nums</code> contains at least two elements.</li> <li>Return <em>the <strong>minimum</strong> number of operations needed so that all elements of the array are greater than or equal to</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,11,10,1,3], k = 10
Output: 2
Explanation: In the first operation, we remove elements 1 and 2, then add 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3].
In the second operation, we remove elements 3 and 4, then add 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10].
At this stage, all the elements of nums are greater than or equal to 10 so we can stop.
It can be shown that 2 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2,4,9], k = 20
Output: 4
Explanation: After one operation, nums becomes equal to [2, 4, 9, 3].
After two operations, nums becomes equal to [7, 4, 9].
After three operations, nums becomes equal to [15, 9].
After four operations, nums becomes equal to [33].
At this stage, all the elements of nums are greater than 20 so we can stop.
It can be shown that 4 is the minimum number of operations needed so that all elements of the array are greater than or equal to 20.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumOperationsToExceedThresholdValueII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a min heap priority queue to always get the smallest elements</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Convert all elements to long and add them to the priority queue</span>
        <span class="c1">// This prevents integer overflow in calculations</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Counter for the number of operations performed</span>
        <span class="kt">int</span> <span class="n">operation</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue while we have at least 2 elements and smallest element &lt; k</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">pq</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Remove the two smallest elements</span>
            <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">long</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

            <span class="c1">// Calculate new value according to the problem's formula</span>
            <span class="kt">long</span> <span class="n">newVal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

            <span class="c1">// Add the new value back to the priority queue</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">newVal</span><span class="o">);</span>
            <span class="n">operation</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Return the number of operations if successful (smallest element &gt;= k)</span>
        <span class="c1">// Otherwise return -1 indicating it's impossible to reach the threshold</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">?</span> <span class="n">operation</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="c1">// Expected result: 2 operations needed to make all elements &gt;= 10</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>

        <span class="c1">// Test Case 2</span>
        <span class="c1">// Expected result: 4 operations needed to make all elements &gt;= 20</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums, and an integer k. In one operation, you will: Take the two smallest integers x and y in nums. Remove x and y from nums. Add min(x, y) * 2 + max(x, y) anywhere in the array. Note that you can only apply the described operation if nums contains at least two elements. Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.]]></summary></entry><entry><title type="html">2657. Find the Prefix Common Array of Two Arrays</title><link href="https://zhengstar94.github.io//blog/2025/FindThePrefixCommonArrayOfTwoArrays/" rel="alternate" type="text/html" title="2657. Find the Prefix Common Array of Two Arrays"/><published>2025-01-14T00:00:00+00:00</published><updated>2025-01-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindThePrefixCommonArrayOfTwoArrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindThePrefixCommonArrayOfTwoArrays/"><![CDATA[<ul> <li>You are given two <strong>0-indexed</strong> integer permutations <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> of length <code class="language-plaintext highlighter-rouge">n</code>.</li> <li>A <strong>prefix common array</strong> of <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> is an array <code class="language-plaintext highlighter-rouge">C</code> such that <code class="language-plaintext highlighter-rouge">C[i]</code> is equal to the count of numbers that are present at or before the index <code class="language-plaintext highlighter-rouge">i</code> in both <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>.</li> <li>Return <em>the <strong>prefix common array</strong> of</em> <code class="language-plaintext highlighter-rouge">A</code> <em>and</em> <code class="language-plaintext highlighter-rouge">B</code>.</li> <li>A sequence of <code class="language-plaintext highlighter-rouge">n</code> integers is called a <strong>permutation</strong> if it contains all integers from <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">n</code> exactly once.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: A = [1,3,2,4], B = [3,1,2,4]
Output: [0,2,3,4]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: A = [2,3,1], B = [3,1,2]
Output: [0,1,3]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: only 3 is common in A and B, so C[1] = 1.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindThePrefixCommonArrayOfTwoArrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findThePrefixCommonArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">// Result array</span>
        <span class="kt">long</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Bitmaps representing elements in a and b</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span> <span class="o">|=</span> <span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>     <span class="c1">// Set the bit corresponding to a[i] in p</span>
            <span class="n">q</span> <span class="o">|=</span> <span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>     <span class="c1">// Set the bit corresponding to b[i] in q</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">q</span><span class="o">);</span> <span class="c1">// Count common set bits (common elements)</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findThePrefixCommonArray</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">)));</span> <span class="c1">// Output: [0, 2, 3, 4]</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findThePrefixCommonArray</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">)));</span> <span class="c1">// Output: [0, 1, 3]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given two 0-indexed integer permutations A and B of length n. A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B. Return the prefix common array of A and B. A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.]]></summary></entry><entry><title type="html">2730. Find the Longest Semi-Repetitive Substring</title><link href="https://zhengstar94.github.io//blog/2025/FindTheLongestSemiRepetitiveSubstring/" rel="alternate" type="text/html" title="2730. Find the Longest Semi-Repetitive Substring"/><published>2025-01-13T00:00:00+00:00</published><updated>2025-01-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheLongestSemiRepetitiveSubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheLongestSemiRepetitiveSubstring/"><![CDATA[<ul> <li>You are given a digit string <code class="language-plaintext highlighter-rouge">s</code> that consists of digits from 0 to 9.</li> <li>A string is called <strong>semi-repetitive</strong> if there is <strong>at most</strong> one adjacent pair of the same digit. For example, <code class="language-plaintext highlighter-rouge">"0010"</code>, <code class="language-plaintext highlighter-rouge">"002020"</code>, <code class="language-plaintext highlighter-rouge">"0123"</code>, <code class="language-plaintext highlighter-rouge">"2002"</code>, and <code class="language-plaintext highlighter-rouge">"54944"</code> are semi-repetitive while the following are not: <code class="language-plaintext highlighter-rouge">"00101022"</code> (adjacent same digit pairs are 00 and 22), and <code class="language-plaintext highlighter-rouge">"1101234883"</code> (adjacent same digit pairs are 11 and 88).</li> <li>Return the length of the <strong>longest semi-repetitive substring</strong> of <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "52233"
Output: 4

Explanation:

The longest semi-repetitive substring is "5223". Picking the whole string "52233" has two adjacent same digit pairs 22 and 33, but at most one is allowed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "5494"
Output: 4

Explanation:

s is a semi-repetitive string.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1111111"
Output: 2

Explanation:

The longest semi-repetitive substring is "11". Picking the substring "111" has two adjacent same digit pairs, but at most one is allowed.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheLongestSemiRepetitiveSubstring</span> <span class="o">{</span>

    <span class="cm">/**
     * This function finds the length of the longest "semi-repetitive" substring.
     * A "semi-repetitive" substring allows at most one pair of consecutive, identical characters.
     *
     * @param s The input string consisting of alphanumeric characters.
     * @return The length of the longest semi-repetitive substring.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestSemiRepetitiveSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the input string length is less than or equal to 2, the substring will always have the same length</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Variable to store the maximum length of the semi-repetitive substring we have found so far</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// `start` is the beginning index of the current substring that satisfies the condition</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// `lastPair` stores the index of the first element of the most recent pair of consecutive identical characters</span>
        <span class="kt">int</span> <span class="n">lastPair</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// Initially set to -1 because no pair has been found yet</span>

        <span class="c1">// Traverse the string from the second character to the last character</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if the current character is equal to the previous character</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>

                <span class="cm">/**
                 * If this is the second occurrence of a consecutive pair (i.e., we already encountered a pair before):
                 * - We adjust `start` to the second element of the first consecutive pair (i.e., `lastPair + 1`).
                 * - This ensures the new substring being processed doesn't include more than one pair.
                 */</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">lastPair</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">lastPair</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Update `lastPair` to the current location of the first element in the new pair</span>
                <span class="n">lastPair</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Calculate the length of the current semi-repetitive substring:
             * - It's the distance from `start` to the current index `i` (inclusive).
             * Update `maxLength` if this substring is longer.
             */</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the length of the longest semi-repetitive substring found</span>
        <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Input string contains two pairs of consecutive identical characters</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"5224336"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 4"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">longestSemiRepetitiveSubstring</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>

        <span class="c1">// Uncomment other test cases to validate the implementation:</span>
        <span class="c1">// Test case 2</span>
        <span class="c1">// String s2 = "5494";</span>
        <span class="c1">// System.out.println("\nTest Case 2: " + s2);</span>
        <span class="c1">// System.out.println("Expected Output: 4");</span>
        <span class="c1">// System.out.println("Actual Output: " + longestSemiRepetitiveSubstring(s2));</span>
        <span class="c1">//</span>
        <span class="c1">// // Test case 3</span>
        <span class="c1">// String s3 = "1111111";</span>
        <span class="c1">// System.out.println("\nTest Case 3: " + s3);</span>
        <span class="c1">// System.out.println("Expected Output: 2");</span>
        <span class="c1">// System.out.println("Actual Output: " + longestSemiRepetitiveSubstring(s3));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given a digit string s that consists of digits from 0 to 9. A string is called semi-repetitive if there is at most one adjacent pair of the same digit. For example, "0010", "002020", "0123", "2002", and "54944" are semi-repetitive while the following are not: "00101022" (adjacent same digit pairs are 00 and 22), and "1101234883" (adjacent same digit pairs are 11 and 88). Return the length of the longest semi-repetitive substring of s.]]></summary></entry><entry><title type="html">1208. Get Equal Substrings Within Budget</title><link href="https://zhengstar94.github.io//blog/2025/GetEqualSubstringsWithinBudget/" rel="alternate" type="text/html" title="1208. Get Equal Substrings Within Budget"/><published>2025-01-13T00:00:00+00:00</published><updated>2025-01-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/GetEqualSubstringsWithinBudget</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/GetEqualSubstringsWithinBudget/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> of the same length and an integer <code class="language-plaintext highlighter-rouge">maxCost</code>.</li> <li>You want to change <code class="language-plaintext highlighter-rouge">s</code> to <code class="language-plaintext highlighter-rouge">t</code>. Changing the <code class="language-plaintext highlighter-rouge">ith</code> character of <code class="language-plaintext highlighter-rouge">s</code> to <code class="language-plaintext highlighter-rouge">ith</code> character of <code class="language-plaintext highlighter-rouge">t</code> costs <code class="language-plaintext highlighter-rouge">|s[i] - t[i]|</code> (i.e., the absolute difference between the ASCII values of the characters).</li> <li>Return <em>the maximum length of a substring of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that can be changed to be the same as the corresponding substring of</em> <code class="language-plaintext highlighter-rouge">t</code> <em>with a cost less than or equal to</em> <code class="language-plaintext highlighter-rouge">maxCost</code>. If there is no substring from <code class="language-plaintext highlighter-rouge">s</code> that can be changed to its corresponding substring from <code class="language-plaintext highlighter-rouge">t</code>, return <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd".
That costs 3, so the maximum length is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", t = "cdef", maxCost = 3
Output: 1
Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You cannot make any change, so the maximum length is 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GetEqualSubstringsWithinBudget</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">equalSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxCost</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// Array to store the conversion cost for each character</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Calculate the cost of changing each character from s to t</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">costs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Track the maximum valid substring length</span>
        <span class="kt">int</span> <span class="n">currentCost</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Track the current window's total cost</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>         <span class="c1">// Left pointer of the window</span>

        <span class="c1">// Iterate through the string with right pointer (end)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Enter Window: Add cost of current character to window</span>
            <span class="n">currentCost</span> <span class="o">+=</span> <span class="n">costs</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>

            <span class="c1">// 2. Exit Window: Shrink window while cost exceeds budget</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">currentCost</span> <span class="o">&gt;</span> <span class="n">maxCost</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">currentCost</span> <span class="o">-=</span> <span class="n">costs</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
                <span class="n">start</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// 3. Update Answer: Update maximum length of valid substring</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple characters can be changed within budget</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t1</span> <span class="o">=</span> <span class="s">"bcdf"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxCost1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">equalSubstring</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">maxCost1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 2: High conversion cost limits substring length</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t2</span> <span class="o">=</span> <span class="s">"cdef"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxCost2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">equalSubstring</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">t2</span><span class="o">,</span> <span class="n">maxCost2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 3: Zero budget allows only identical characters</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t3</span> <span class="o">=</span> <span class="s">"acde"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxCost3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">equalSubstring</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">t3</span><span class="o">,</span> <span class="n">maxCost3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given two strings s and t of the same length and an integer maxCost. You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters). Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.]]></summary></entry><entry><title type="html">3223. Minimum Length of String After Operations</title><link href="https://zhengstar94.github.io//blog/2025/MinimumLengthOfStringAfterOperations/" rel="alternate" type="text/html" title="3223. Minimum Length of String After Operations"/><published>2025-01-13T00:00:00+00:00</published><updated>2025-01-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumLengthOfStringAfterOperations</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumLengthOfStringAfterOperations/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>You can perform the following process on <code class="language-plaintext highlighter-rouge">s</code> <strong>any</strong> number of times: <ul> <li>Choose an index <code class="language-plaintext highlighter-rouge">i</code> in the string such that there is <strong>at least</strong> one character to the left of index <code class="language-plaintext highlighter-rouge">i</code> that is equal to <code class="language-plaintext highlighter-rouge">s[i]</code>, and <strong>at least</strong> one character to the right that is also equal to <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> <li>Delete the <strong>closest</strong> character to the <strong>left</strong> of index <code class="language-plaintext highlighter-rouge">i</code> that is equal to <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> <li>Delete the <strong>closest</strong> character to the <strong>right</strong> of index <code class="language-plaintext highlighter-rouge">i</code> that is equal to <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> </ul> </li> <li>Return the <strong>minimum</strong> length of the final string <code class="language-plaintext highlighter-rouge">s</code> that you can achieve.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abaacbcbb"

Output: 5

Explanation:
We do the following operations:

Choose index 2, then remove the characters at indices 0 and 3. The resulting string is s = "bacbcbb".
Choose index 3, then remove the characters at indices 0 and 5. The resulting string is s = "acbcb".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aa"

Output: 2

Explanation:
We cannot perform any operations, so we return the length of the original string.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumLengthOfStringAfterOperations</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumLength</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to count frequency of each lowercase letter (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Count the frequency of each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">ch:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>  <span class="c1">// Convert char to index (e.g., 'a'-&gt;0, 'b'-&gt;1, etc.)</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Process each character's frequency to determine its contribution to final length</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">count:</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/* Mathematical formula explanation:
                 * (count - 1) % 2 + 1 determines how many characters will remain:
                 *
                 * For count = 1: (1-1)%2 + 1 = 0%2 + 1 = 1  (one char remains)
                 * For count = 2: (2-1)%2 + 1 = 1%2 + 1 = 2  (two chars remain)
                 * For count = 3: (3-1)%2 + 1 = 2%2 + 1 = 1  (one char remains)
                 * For count = 4: (4-1)%2 + 1 = 3%2 + 1 = 2  (two chars remain)
                 *
                 * Pattern:
                 * - Odd counts (1,3,5,...)  -&gt; 1 char remains
                 * - Even counts (2,4,6,...) -&gt; 2 chars remain
                 *
                 * This works because:
                 * 1. We can delete 3 chars at a time
                 * 2. For odd counts, we can delete all but one char
                 * 3. For even counts, we must leave two chars
                 */</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abaacbcbb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected output: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual output: "</span> <span class="o">+</span> <span class="n">minimumLength</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"aa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2: "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual output: "</span> <span class="o">+</span> <span class="n">minimumLength</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aaaaa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3: "</span> <span class="o">+</span> <span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected output: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual output: "</span> <span class="o">+</span> <span class="n">minimumLength</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s. You can perform the following process on s any number of times: Choose an index i in the string such that there is at least one character to the left of index i that is equal to s[i], and at least one character to the right that is also equal to s[i]. Delete the closest character to the left of index i that is equal to s[i]. Delete the closest character to the right of index i that is equal to s[i]. Return the minimum length of the final string s that you can achieve.]]></summary></entry><entry><title type="html">2116. Check if a Parentheses String Can Be Valid</title><link href="https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid/" rel="alternate" type="text/html" title="2116. Check if a Parentheses String Can Be Valid"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid/"><![CDATA[<ul> <li>A parentheses string is a <strong>non-empty</strong> string consisting only of <code class="language-plaintext highlighter-rouge">'('</code> and <code class="language-plaintext highlighter-rouge">')'</code>. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>: <ul> <li>It is <code class="language-plaintext highlighter-rouge">()</code>.</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">AB</code> (<code class="language-plaintext highlighter-rouge">A</code> concatenated with <code class="language-plaintext highlighter-rouge">B</code>), where <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are valid parentheses strings.</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">(A)</code>, where <code class="language-plaintext highlighter-rouge">A</code> is a valid parentheses string.</li> </ul> </li> <li>You are given a parentheses string <code class="language-plaintext highlighter-rouge">s</code> and a string <code class="language-plaintext highlighter-rouge">locked</code>, both of length <code class="language-plaintext highlighter-rouge">n</code>. <code class="language-plaintext highlighter-rouge">locked</code> is a binary string consisting only of <code class="language-plaintext highlighter-rouge">'0'</code>s and <code class="language-plaintext highlighter-rouge">'1'</code>s. For <strong>each</strong> index <code class="language-plaintext highlighter-rouge">i</code> of <code class="language-plaintext highlighter-rouge">locked</code>, <ul> <li>If <code class="language-plaintext highlighter-rouge">locked[i]</code> is <code class="language-plaintext highlighter-rouge">'1'</code>, you <strong>cannot</strong> change <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> <li>But if <code class="language-plaintext highlighter-rouge">locked[i]</code> is <code class="language-plaintext highlighter-rouge">'0'</code>, you <strong>can</strong> change <code class="language-plaintext highlighter-rouge">s[i]</code> to either <code class="language-plaintext highlighter-rouge">'('</code> or <code class="language-plaintext highlighter-rouge">')'</code>.</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if you can make <code class="language-plaintext highlighter-rouge">s</code> a valid parentheses string</em>. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " ) ) ( ) ) ) ", locked = "010100"
Output: true
Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].
We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " ( ) ( ) ", locked = "0000"
Output: true
Explanation: We do not need to make any changes because s is already valid.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = ")", locked = "0"
Output: false
Explanation: locked permits  us to change s[0]. 
Changing s[0] to either '(' or ')' will not make s valid.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckIfAParenthesesStringCanBeValid</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canBeValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">locked</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the length is odd, it's impossible to form valid parentheses</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// First pass: Left to right scan to check for excess right parentheses</span>
        <span class="c1">// balance: tracks the difference between left and right parentheses for locked positions</span>
        <span class="c1">// wild: counts the number of modifiable positions that can be used to fix imbalances</span>
        <span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">wild</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Scan from left to right to ensure we never have too many right parentheses</span>
        <span class="c1">// This pass ensures that at each position, we can convert enough characters</span>
        <span class="c1">// to left parentheses to match any right parentheses we've seen</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">locked</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Position is modifiable, increment wild counter</span>
                <span class="n">wild</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Locked left parenthesis, increment balance</span>
                <span class="n">balance</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Locked right parenthesis, decrement balance</span>
                <span class="n">balance</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// If balance + wild &lt; 0, we have too many right parentheses</span>
            <span class="c1">// that cannot be fixed even using all modifiable positions</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">+</span> <span class="n">wild</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Second pass: Right to left scan to check for excess left parentheses</span>
        <span class="c1">// Reset counters for the reverse scan</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">wild</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Scan from right to left to ensure we never have too many left parentheses</span>
        <span class="c1">// This pass ensures that at each position (working backwards),</span>
        <span class="c1">// we can convert enough characters to right parentheses to match any left</span>
        <span class="c1">// parentheses we've seen</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">locked</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Position is modifiable, increment wild counter</span>
                <span class="n">wild</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Locked right parenthesis, increment balance</span>
                <span class="n">balance</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Locked left parenthesis, decrement balance</span>
                <span class="n">balance</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// If balance + wild &lt; 0, we have too many left parentheses</span>
            <span class="c1">// that cannot be fixed even using all modifiable positions</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">+</span> <span class="n">wild</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If both passes succeed, the string can be made valid</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String can be made valid by modifying unlocked positions</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">" ) ) ( ) ) )"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked1</span> <span class="o">=</span> <span class="s">"010100"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">locked1</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 2: Already valid string with all positions modifiable</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">" ( ) ( ) "</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked2</span> <span class="o">=</span> <span class="s">"0000"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">locked2</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 3: Single character cannot form valid parentheses</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">")"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked3</span> <span class="o">=</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">locked3</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 4: Additional test case with all positions modifiable</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">" ( ) ) "</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked4</span> <span class="o">=</span> <span class="s">"000"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s4</span><span class="o">,</span> <span class="n">locked4</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Medium"/><summary type="html"><![CDATA[A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true: It is (). It can be written as AB (A concatenated with B), where A and B are valid parentheses strings. It can be written as (A), where A is a valid parentheses string. You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked, If locked[i] is '1', you cannot change s[i]. But if locked[i] is '0', you can change s[i] to either '(' or ')'. Return true if you can make s a valid parentheses string. Otherwise, return false.]]></summary></entry><entry><title type="html">Dynamic-Length Sliding Window</title><link href="https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow/" rel="alternate" type="text/html" title="Dynamic-Length Sliding Window"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow/"><![CDATA[<p>The sliding window is a powerful and efficient algorithmic technique for solving problems involving subarrays or substrings. It is particularly useful for problems requiring dynamic adjustments to window size, moving away from brute-force solutions. With sliding window techniques, the time complexity is reduced from O(n^2) to O(n)by avoiding unnecessary recalculations.</p> <p>This document provides a detailed explanation of the core concept, step-by-step implementation, and practical applications of dynamic-length sliding windows.</p> <h2 id="core-concept">Core Concept</h2> <p>The sliding window technique helps efficiently compute subarray (or substring) properties by <strong>dynamically adjusting window boundaries (start and end points)</strong>. The general process involves three key steps:</p> <ol> <li><strong>Window Expansion</strong>: Expand the window by moving the right boundary to include more elements while updating required properties dynamically (e.g., frequency, sum, or count).</li> <li><strong>Condition Validation</strong>: After every expansion, check whether the current window satisfies the required conditions.</li> <li><strong>Window Contraction</strong>: If the condition is violated, shrink the window from the left while recalculating the required properties until the condition is restored.</li> </ol> <p>By focusing only on valid windows, this methodology avoids redundant calculations, significantly improving efficiency.</p> <h2 id="example-problem">Example Problem</h2> <p><strong>Problem</strong>:</p> <p>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code> containing only <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code>, delete <strong>exactly one element</strong>, and return the length of the longest subarray that consists only of <code class="language-plaintext highlighter-rouge">1</code>.</p> <p><strong>Input</strong>: nums = [1, 1, 0, 1]</p> <p><strong>output</strong>: 3</p> <h2 id="dynamic-sliding-window-steps">Dynamic Sliding Window Steps</h2> <p>For this problem, we apply the sliding window pattern as follows:</p> <ol> <li><strong>Enter Window</strong>: Track the count of zeros as we expand the window.</li> <li><strong>Validate Condition</strong>: Ensure we don’t have more than one zero in our window.</li> <li><strong>Exit Window</strong>: Shrink the window when we exceed our zero limit.</li> </ol> <h3 id="example-walkthrough">Example Walkthrough</h3> <p>Using <code class="language-plaintext highlighter-rouge">nums = [1, 1, 0, 1]</code>:</p> <ol> <li><strong>Initialize</strong>: <ul> <li>Window start: <code class="language-plaintext highlighter-rouge">start = 0</code></li> <li>Zero counter: <code class="language-plaintext highlighter-rouge">zeroCount = 0</code></li> <li>Maximum length: <code class="language-plaintext highlighter-rouge">maxLength = 0</code></li> </ul> </li> <li><strong>Process Array</strong>: <ul> <li><strong>At end = 0</strong> (<code class="language-plaintext highlighter-rouge">nums[0] = 1</code>): Window: <code class="language-plaintext highlighter-rouge">[1]</code>, zeros = 0, <code class="language-plaintext highlighter-rouge">maxLength = 1</code></li> <li><strong>At end = 1</strong> (<code class="language-plaintext highlighter-rouge">nums[1] = 1</code>): Window: <code class="language-plaintext highlighter-rouge">[1, 1]</code>, zeros = 0, <code class="language-plaintext highlighter-rouge">maxLength = 2</code></li> <li><strong>At end = 2</strong> (<code class="language-plaintext highlighter-rouge">nums[2] = 0</code>): Window: <code class="language-plaintext highlighter-rouge">[1, 1, 0]</code>, zeros = 1, <code class="language-plaintext highlighter-rouge">maxLength = 3</code></li> <li><strong>At end = 3</strong> (<code class="language-plaintext highlighter-rouge">nums[3] = 1</code>): Window: <code class="language-plaintext highlighter-rouge">[1, 1, 0, 1]</code>, zeros = 1, <code class="language-plaintext highlighter-rouge">maxLength = 4</code></li> </ul> </li> </ol> <h2 id="implementation">Implementation</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">zeroCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Count of zeros in current window</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Length of longest valid subarray</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Start of current window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Expand window: Add current element</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zeroCount</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// 2. Contract window: Remove elements when condition violated</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">zeroCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">zeroCount</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="n">start</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// 3. Update result: Calculate current valid window length</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Handle edge case: all ones array</span>
        <span class="k">return</span> <span class="n">maxLength</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">maxLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <h3 id="explanation-of-key-steps">Explanation of Key Steps</h3> <ol> <li><strong>Enter Window</strong>: Add the current element to the window and update the zero count.</li> <li><strong>Exit Window</strong>: When the number of zeros exceeds 1, shrink the window from the left while reducing the zero count.</li> <li><strong>Update Answer</strong>: Continuously calculate the size of the valid window and keep track of the maximum length.</li> </ol> <h2 id="complexity-analysis">Complexity Analysis</h2> <ol> <li><strong>Time Complexity</strong>: <ul> <li>O(n): Each element is processed at most twice—once when entering the window and once when exiting.</li> </ul> </li> <li><strong>Space Complexity</strong>: <ul> <li>O(1): Only a few extra variables are used to track the window’s start and end, with no additional data structures.</li> </ul> </li> </ol> <h2 id="applications-and-scenarios">Applications and Scenarios</h2> <p>Dynamic sliding windows are highly versatile and applicable across a wide range of problems. Some common scenarios include:</p> <ol> <li><strong>Longest Subarray Problems</strong>: <ul> <li>Example: Finding the longest substring with at most K distinct characters.</li> </ul> </li> <li><strong>Frequency or Condition Checks</strong>: <ul> <li>Example: Tracking the frequency of a specific element within a window, ensuring it does not exceed a certain limit.</li> </ul> </li> <li><strong>Subarray/Substring Property Calculation</strong>: <ul> <li>Example: Dynamically calculating sums, products, or maximum/minimum values within sliding windows.</li> </ul> </li> <li><strong>Pattern Matching</strong>: <ul> <li>Example: Detecting valid substrings or subarrays that meet complex pattern requirements.</li> </ul> </li> </ol> <p>Mastering the dynamic sliding window technique allows you to efficiently solve various problems with changing constraints, optimizing your algorithmic performance.</p> <h2 id="edge-cases">Edge Cases</h2> <p>When utilizing the sliding window technique, it’s essential to consider edge cases to avoid errors in extreme scenarios. Key edge cases for this problem include:</p> <ol> <li><strong>All Ones</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[1, 1, 1]</code></li> <li>Output: Must subtract one, resulting in length <code class="language-plaintext highlighter-rouge">len(nums) - 1</code>.</li> </ul> </li> <li><strong>All Zeros</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[0, 0, 0]</code></li> <li>Output: No valid subarrays exist, resulting in output <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> </li> <li><strong>Empty Input</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[]</code></li> <li>Output: Should return <code class="language-plaintext highlighter-rouge">0</code> as there are no valid subarrays.</li> </ul> </li> <li><strong>Single Element</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[1]</code> or <code class="language-plaintext highlighter-rouge">[0]</code></li> <li>Output: Results in <code class="language-plaintext highlighter-rouge">0</code> due to the removal leaving no elements.</li> </ul> </li> </ol> <h2 id="summary">Summary</h2> <p>By mastering the dynamic sliding window approach, you can efficiently solve a wide variety of problems that require handling variable-sized subarrays or substrings. Its flexibility and high efficiency make it a crucial technique for algorithmic problem-solving.</p>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[The sliding window is a powerful and efficient algorithmic technique for solving problems involving subarrays or substrings. It is particularly useful for problems requiring dynamic adjustments to window size, moving away from brute-force solutions. With sliding window techniques, the time complexity is reduced from O(n^2) to O(n)by avoiding unnecessary recalculations.]]></summary></entry><entry><title type="html">2275. Largest Combination With Bitwise AND Greater Than Zero</title><link href="https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero/" rel="alternate" type="text/html" title="2275. Largest Combination With Bitwise AND Greater Than Zero"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero/"><![CDATA[<ul> <li>The <strong>bitwise AND</strong> of an array <code class="language-plaintext highlighter-rouge">nums</code> is the bitwise AND of all integers in <code class="language-plaintext highlighter-rouge">nums</code>. <ul> <li>For example, for <code class="language-plaintext highlighter-rouge">nums = [1, 5, 3]</code>, the bitwise AND is equal to <code class="language-plaintext highlighter-rouge">1 &amp; 5 &amp; 3 = 1</code>.</li> <li>Also, for <code class="language-plaintext highlighter-rouge">nums = [7]</code>, the bitwise AND is <code class="language-plaintext highlighter-rouge">7</code>.</li> </ul> </li> <li>You are given an array of positive integers <code class="language-plaintext highlighter-rouge">candidates</code>. Compute the <strong>bitwise AND</strong> for all possible <strong>combinations</strong> of elements in the <code class="language-plaintext highlighter-rouge">candidates</code> array.</li> <li>Return <em>the size of the <strong>largest</strong> combination of</em> <code class="language-plaintext highlighter-rouge">candidates</code> <em>with a bitwise AND <strong>greater</strong> than</em> <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [16,17,71,62,12,24,14]
Output: 4
Explanation: The combination [16,17,62,24] has a bitwise AND of 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0.
The size of the combination is 4.
It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.
Note that more than one combination may have the largest size.
For example, the combination [62,12,24,14] has a bitwise AND of 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [8,8]
Output: 2
Explanation: The largest combination [8,8] has a bitwise AND of 8 &amp; 8 = 8 &gt; 0.
The size of the combination is 2, so we return 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogU) time | O(logU) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LargestCombinationWithBitwiseANDGreaterThanZero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">largestCombination</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create an array to store the count of 1s at each binary position (0-23)</span>
        <span class="c1">// Size is 24 because the constraint states candidates[i] &lt;= 10^7 &lt; 2^24</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">24</span><span class="o">];</span>

        <span class="c1">// Iterate through each number in the candidates array</span>
        <span class="c1">// For each number, we'll count how many 1s appear at each binary position</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Process each bit of the current number until it becomes 0</span>
            <span class="c1">// i represents the current bit position (0-based, from right to left)</span>
            <span class="c1">// The loop continues as long as there are 1s remaining in x</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// x &amp; 1 extracts the rightmost bit (0 or 1)</span>
                <span class="c1">// Add this bit to the count at position i</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Right shift x by 1 to process the next bit in the next iteration</span>
                <span class="c1">// This effectively removes the rightmost bit we just processed</span>
                <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Find the maximum count across all bit positions</span>
        <span class="c1">// This represents the size of the largest possible combination</span>
        <span class="c1">// where all numbers have 1 at the same position</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">cnt</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example with multiple valid combinations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">16</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">71</span><span class="o">,</span><span class="mi">62</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">24</span><span class="o">,</span><span class="mi">14</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2: Example with identical numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 3: Example with large numbers using bit shifting</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates3</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[The bitwise AND of an array nums is the bitwise AND of all integers in nums. For example, for nums=[1, 5, 3], the bitwise AND is equal to 1 &amp; 5 &amp; 3=1. Also, for nums=[7], the bitwise AND is 7. You are given an array of positive integers candidates. Compute the bitwise AND for all possible combinations of elements in the candidates array. Return the size of the largest combination of candidates with a bitwise AND greater than 0.]]></summary></entry><entry><title type="html">1493. Longest Subarray of 1’s After Deleting One Element</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement/" rel="alternate" type="text/html" title="1493. Longest Subarray of 1’s After Deleting One Element"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code>, you should delete one element from it.</li> <li>Return <em>the size of the longest non-empty subarray containing only</em> <code class="language-plaintext highlighter-rouge">1</code><em>’s in the resulting array</em>. Return <code class="language-plaintext highlighter-rouge">0</code> if there is no such subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubarrayOf1sAfteDeletingOneElement</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">zeroCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Keeps track of the number of zeros in the current window</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Tracks the length of the longest subarray found</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Left boundary of the sliding window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Enter window: The current element is added to the window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zeroCount</span><span class="o">++;</span> <span class="c1">// Increment zero count if the current element is 0</span>
            <span class="o">}</span>

            <span class="c1">// 2. Exit window: Adjust the window to ensure the condition (at most one zero) is satisfied</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">zeroCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// If there are more than one zero in the window</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">zeroCount</span><span class="o">--;</span> <span class="c1">// Decrement zero count if the leftmost element is 0</span>
                <span class="o">}</span>
                <span class="n">start</span><span class="o">++;</span> <span class="c1">// Move the left boundary of the window to the right</span>
            <span class="o">}</span>

            <span class="c1">// 3. Update answer: Update the maximum length for a valid subarray</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span> <span class="c1">// Calculate the current valid window size</span>
        <span class="o">}</span>

        <span class="c1">// Special case: If the array consists entirely of 1s, the result should exclude one element</span>
        <span class="k">return</span> <span class="n">maxLength</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">maxLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Additional test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Additional test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a binary array nums, you should delete one element from it. Return the size of the longest non-empty subarray containing only 1’s in the resulting array. Return 0 if there is no such subarray.]]></summary></entry></feed>