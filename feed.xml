<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-07-07T14:06:19+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">253.Meeting Rooms II</title><link href="https://zhengstar94.github.io//blog/2024/MeetingRoomsII/" rel="alternate" type="text/html" title="253.Meeting Rooms II"/><published>2024-07-07T00:00:00+00:00</published><updated>2024-07-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MeetingRoomsII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MeetingRoomsII/"><![CDATA[<h1 id="253-meeting-rooms-ii">253. Meeting Rooms II</h1> <ul> <li>Given an array of meeting time intervals consisting of start and end times<code class="language-plaintext highlighter-rouge">[[s1,e1],[s2,e2],...]</code>(si&lt; ei), find the minimum number of conference rooms required.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
[[0, 30],[5, 10],[15, 20]]
Output:
 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
 [[7,10],[2,4]]

Output:
 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>

<span class="cm">/**
 * Given an array of meeting time intervals consisting of start and end times, find the minimum number of conference rooms required.
 *
 * @author zhengstars
 * @date 2024/07/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MeetingRoomsII</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculate the minimum number of conference rooms required for the given meeting time intervals.
     *
     * @param intervals an array of meeting time intervals
     * @return the minimum number of conference rooms required
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minMeetingRooms</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort the intervals by start time</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">minHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
        <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">minHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MeetingRoomsII</span> <span class="n">meetingRoomsII</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MeetingRoomsII</span><span class="o">();</span>

        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">30</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span><span class="mi">20</span><span class="o">}};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">meetingRoomsII</span><span class="o">.</span><span class="na">minMeetingRooms</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">}};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">meetingRoomsII</span><span class="o">.</span><span class="na">minMeetingRooms</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[253. Meeting Rooms II]]></summary></entry><entry><title type="html">435.Non-overlapping Intervals</title><link href="https://zhengstar94.github.io//blog/2024/Non-OverlappingIntervals/" rel="alternate" type="text/html" title="435.Non-overlapping Intervals"/><published>2024-06-28T00:00:00+00:00</published><updated>2024-06-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/Non-OverlappingIntervals</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/Non-OverlappingIntervals/"><![CDATA[<h1 id="435-non-overlapping-intervals">435. Non-overlapping Intervals</h1> <ul> <li>Given an array of intervals <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengstars
 * Date: 2024/06/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NonOverlappingIntervals</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort the intervals by their ending times</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>

        <span class="c1">// Initialize the count of non-overlapping intervals</span>
        <span class="kt">int</span> <span class="n">nonOverlapCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Record the end time of the first interval</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the start time of the current interval is greater than or equal to</span>
            <span class="c1">// the end time of the last recorded non-overlapping interval</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nonOverlapCount</span><span class="o">++;</span>
                <span class="c1">// Update the end time to the end time of the current interval</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The number of intervals to be removed is the total number of intervals</span>
        <span class="c1">// minus the count of non-overlapping intervals</span>
        <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">nonOverlapCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">eraseOverlapIntervals</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">eraseOverlapIntervals</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">eraseOverlapIntervals</span><span class="o">(</span><span class="n">intervals3</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[435. Non-overlapping Intervals]]></summary></entry><entry><title type="html">56.Merge Intervals</title><link href="https://zhengstar94.github.io//blog/2024/MergeIntervals/" rel="alternate" type="text/html" title="56.Merge Intervals"/><published>2024-06-25T00:00:00+00:00</published><updated>2024-06-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MergeIntervals</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MergeIntervals/"><![CDATA[<h1 id="56-merge-intervals">56. Merge Intervals</h1> <ul> <li>Given an array of <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * This class provides functionality to merge overlapping intervals.
 * Given a collection of intervals, it merges all overlapping intervals and
 * returns the result as a list of non-overlapping intervals.
 *
 * Author: zhengstars
 * Date: 2024/06/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeIntervals</span> <span class="o">{</span>
    <span class="cm">/**
     * Merges overlapping intervals in the given array.
     *
     * @param intervals The array of intervals to merge.
     * @return A 2D array of merged intervals.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check for the special case where the intervals array is empty</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Sort the intervals based on their start times</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

        <span class="c1">// List to store the merged intervals</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Initialize the current interval to be merged</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">currentInterval</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentInterval</span><span class="o">);</span>

        <span class="c1">// Iterate over the sorted intervals and merge where necessary</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">currentEnd</span> <span class="o">=</span> <span class="n">currentInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// If the current interval overlaps with the next interval</span>
            <span class="k">if</span><span class="o">(</span><span class="n">currentEnd</span> <span class="o">&gt;=</span> <span class="n">interval</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="c1">// Update the end of the current interval to the maximum end time</span>
                <span class="n">currentInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">currentEnd</span><span class="o">,</span> <span class="n">interval</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// There is no overlap, so add the next interval as a new entry</span>
                <span class="n">currentInterval</span> <span class="o">=</span> <span class="n">interval</span><span class="o">;</span>
                <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentInterval</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert the list of merged intervals to a 2D array and return</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">merged</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">18</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals1: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">merge</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 6], [8, 10], [15, 18]]</span>

        <span class="c1">// Example 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals2: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">merge</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 5]]</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to print a 2D array of intervals.
     *
     * @param intervals The array of intervals to print.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printResult</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"] "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[56. Merge Intervals]]></summary></entry><entry><title type="html">57.Insert Interval</title><link href="https://zhengstar94.github.io//blog/2024/InsertInterval/" rel="alternate" type="text/html" title="57.Insert Interval"/><published>2024-06-16T00:00:00+00:00</published><updated>2024-06-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/InsertInterval</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/InsertInterval/"><![CDATA[<h1 id="57-insert-interval">57. Insert Interval</h1> <ul> <li>You are given an array of non-overlapping intervals <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code> represent the start and the end of the <code class="language-plaintext highlighter-rouge">ith</code> interval and <code class="language-plaintext highlighter-rouge">intervals</code> is sorted in ascending order by <code class="language-plaintext highlighter-rouge">starti</code>. You are also given an interval <code class="language-plaintext highlighter-rouge">newInterval = [start, end]</code> that represents the start and end of another interval.</li> <li>Insert <code class="language-plaintext highlighter-rouge">newInterval</code> into <code class="language-plaintext highlighter-rouge">intervals</code> such that <code class="language-plaintext highlighter-rouge">intervals</code> is still sorted in ascending order by <code class="language-plaintext highlighter-rouge">starti</code> and <code class="language-plaintext highlighter-rouge">intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</li> <li>Return <code class="language-plaintext highlighter-rouge">intervals</code> <em>after the insertion</em>.</li> <li><strong>Note</strong> that you don’t need to modify <code class="language-plaintext highlighter-rouge">intervals</code> in-place. You can make a new array and return it.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengstars
 * Date: 2024/06/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InsertInterval</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// List to store the final result after merging intervals</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Length of the input intervals array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Index for iterating through the intervals array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Add all intervals that end before the new interval starts</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>  <span class="c1">// These intervals do not overlap with the new interval</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Merge all intervals that overlap with the new interval</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="c1">// Update the new interval to encompass the overlapping intervals</span>
            <span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
            <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Add the merged new interval to the result</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newInterval</span><span class="o">);</span>

        <span class="c1">// Add all remaining intervals that start after the new interval ends</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Convert the result list to a two-dimensional array</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals1: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">insert</span><span class="o">(</span><span class="n">intervals1</span><span class="o">,</span> <span class="n">newInterval1</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 5], [6, 9]]</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">16</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals2: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">insert</span><span class="o">(</span><span class="n">intervals2</span><span class="o">,</span> <span class="n">newInterval2</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 2], [3, 10], [12, 16]]</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to print a two-dimensional array of intervals.
     *
     * @param intervals The array of intervals to be printed.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printResult</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"] "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[57. Insert Interval]]></summary></entry><entry><title type="html">252.Meeting Rooms</title><link href="https://zhengstar94.github.io//blog/2024/MeetingRooms/" rel="alternate" type="text/html" title="252.Meeting Rooms"/><published>2024-06-15T00:00:00+00:00</published><updated>2024-06-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MeetingRooms</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MeetingRooms/"><![CDATA[<h1 id="252-meeting-rooms">252. Meeting Rooms</h1> <ul> <li>Given an array of meeting time intervals consisting of start and end times<code class="language-plaintext highlighter-rouge">[[s1,e1],[s2,e2],...]</code>(si&lt; ei), determine if a person could attend all meetings.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
[[0,30],[5,10],[15,20]]
Output:
 false
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
 [[7,10],[2,4]]

Output:
 true
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MeetingRooms</span> <span class="o">{</span>
    <span class="cm">/**
     * Method to check if a person can attend all given meetings without any overlap.
     *
     * @param intervals 2D array where each sub-array contains two integers denoting the start and end time of a meeting.
     * @return boolean value - true if a person can attend all meetings, false otherwise.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canAttendMeetings</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the meeting intervals based on their start time.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// Iterate through the sorted intervals to check for any overlaps.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the start time of the current meeting is less than the end time of the previous meeting,</span>
            <span class="c1">// there is an overlap, and it's not possible to attend all meetings.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Found an overlapping meeting, return false</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no overlaps found, return true meaning all meetings can be attended.</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Overlapping meetings</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">30</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">20</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can attend all meetings for intervals1: "</span> <span class="o">+</span> <span class="n">canAttendMeetings</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test case 2: No overlapping meetings</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can attend all meetings for intervals2: "</span> <span class="o">+</span> <span class="n">canAttendMeetings</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Expected output: true</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[252. Meeting Rooms]]></summary></entry><entry><title type="html">55.Jump Game</title><link href="https://zhengstar94.github.io//blog/2024/JumpGame/" rel="alternate" type="text/html" title="55.Jump Game"/><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/JumpGame</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/JumpGame/"><![CDATA[<h1 id="55-jump-game">55. Jump Game</h1> <ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if you can reach the last index, or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JumpGame</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the farthest position that can be reached</span>
        <span class="kt">int</span> <span class="n">maxReach</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Traverse the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current position is beyond the maxReach, it is not possible to continue</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">maxReach</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Update maxReach</span>
            <span class="n">maxReach</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxReach</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// If maxReach is enough to reach the last position or beyond, return true</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">maxReach</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After traversing, if still not able to reach the last position, return false</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can jump for nums1: "</span> <span class="o">+</span> <span class="n">canJump</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can jump for nums2: "</span> <span class="o">+</span> <span class="n">canJump</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><summary type="html"><![CDATA[55. Jump Game]]></summary></entry><entry><title type="html">53.Maximum Subarray</title><link href="https://zhengstar94.github.io//blog/2024/MaximumSubarray/" rel="alternate" type="text/html" title="53.Maximum Subarray"/><published>2024-06-01T00:00:00+00:00</published><updated>2024-06-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumSubarray/"><![CDATA[<h1 id="53-maximum-subarray">53. Maximum Subarray</h1> <ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, find the subarray with the largest sum, and return <em>its sum</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumSubarray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize current subarray sum and maximum subarray sum with the first element of the array.</span>
        <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Traverse the array starting from the second element.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update currentSum to be either the current element or the largest sum of the current subarray sum plus the current element.</span>
            <span class="n">currentSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">currentSum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// Update maxSum to be the maximum subarray sum.</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">currentSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Max subarray sum for nums1: "</span> <span class="o">+</span> <span class="n">maxSubArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Max subarray sum for nums2: "</span> <span class="o">+</span> <span class="n">maxSubArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Max subarray sum for nums3: "</span> <span class="o">+</span> <span class="n">maxSubArray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 23</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><summary type="html"><![CDATA[53. Maximum Subarray]]></summary></entry><entry><title type="html">371.Sum of Two Integers</title><link href="https://zhengstar94.github.io//blog/2024/SumOfTwoIntegers/" rel="alternate" type="text/html" title="371.Sum of Two Integers"/><published>2024-05-05T00:00:00+00:00</published><updated>2024-05-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/SumOfTwoIntegers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/SumOfTwoIntegers/"><![CDATA[<h1 id="371-sum-of-two-integers">371. Sum of Two Integers</h1> <ul> <li>Given two integers <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, return <em>the sum of the two integers without using the operators</em> <code class="language-plaintext highlighter-rouge">+</code> <em>and</em> <code class="language-plaintext highlighter-rouge">-</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = 1, b = 2
Output: 3
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = 2, b = 3
Output: 5
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BitManipulation</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SumOfTwoIntegers</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Iterate until there is no carry left</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the carry</span>
            <span class="c1">// (common set bits of a and b)</span>
            <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">;</span>

            <span class="c1">// Compute the sum without considering the carry</span>
            <span class="c1">// XOR operation gives the sum of bits where at least one of the bits is not set</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="o">;</span>

            <span class="c1">// Shift the carry left by one</span>
            <span class="c1">// The carry needs to be added to the sum in the next iteration</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// When b is 0, there is no carry left and a contains the final sum</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: 1 + 2 = 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum of 1 and 2: "</span> <span class="o">+</span> <span class="n">getSum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Should output 3</span>

        <span class="c1">// Test case 2: 2 + 3 = 5</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum of 2 and 3: "</span> <span class="o">+</span> <span class="n">getSum</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Should output 5</span>

        <span class="c1">// Test case 3: 11 + 13 = 24</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum of 11 and 13: "</span> <span class="o">+</span> <span class="n">getSum</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="o">));</span> <span class="c1">// Should output 24</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BitManipulation"/><summary type="html"><![CDATA[371. Sum of Two Integers]]></summary></entry><entry><title type="html">268.Missing Number</title><link href="https://zhengstar94.github.io//blog/2024/MissingNumber/" rel="alternate" type="text/html" title="268.Missing Number"/><published>2024-05-04T00:00:00+00:00</published><updated>2024-05-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MissingNumber</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MissingNumber/"><![CDATA[<h1 id="268-missing-number">268. Missing Number</h1> <ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code> containing <code class="language-plaintext highlighter-rouge">n</code> distinct numbers in the range <code class="language-plaintext highlighter-rouge">[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BitManipulation</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MissingNumber</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMissingNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Calculate the expected sum of numbers from 0 to n using the formula</span>
        <span class="kt">int</span> <span class="n">totalSum</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// Calculate the sum of elements in the given array</span>
        <span class="kt">int</span> <span class="n">arraySum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arraySum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// The missing number is the difference between the totalSum and the arraySum</span>
        <span class="k">return</span> <span class="n">totalSum</span> <span class="o">-</span> <span class="n">arraySum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Expected output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Missing number: "</span> <span class="o">+</span> <span class="n">findMissingNumber</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Expected output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Missing number: "</span> <span class="o">+</span> <span class="n">findMissingNumber</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Expected output: 8</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Missing number: "</span> <span class="o">+</span> <span class="n">findMissingNumber</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BitManipulation"/><summary type="html"><![CDATA[268. Missing Number]]></summary></entry><entry><title type="html">190.Reverse Bits</title><link href="https://zhengstar94.github.io//blog/2024/ReverseBits/" rel="alternate" type="text/html" title="190.Reverse Bits"/><published>2024-05-03T00:00:00+00:00</published><updated>2024-05-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ReverseBits</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ReverseBits/"><![CDATA[<h1 id="190-reverse-bits">190. Reverse Bits</h1> <ul> <li> <p>Reverse bits of a given 32 bits unsigned integer.</p> <p><strong>Note:</strong></p> <ul> <li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li> <li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two's_complement">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code class="language-plaintext highlighter-rouge">-3</code> and the output represents the signed integer <code class="language-plaintext highlighter-rouge">-1073741825</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 00000010100101000001111010011100
Output:    964176192 (00111001011110000010100101000000)
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 11111111111111111111111111111101
Output:   3221225471 (10111111111111111111111111111111)
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BitManipulation</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReverseBits</span> <span class="o">{</span>

    <span class="cm">/**
     * Reverse the bits of a given 32 bits unsigned integer.
     *
     * @param n the input 32 bits unsigned integer
     * @return the integer resulting from reversing the bits of {@code n}
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">reverseBits</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate over the 32 bits of the integer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Left shift the result to make space for the next bit</span>
            <span class="c1">// This shifts all bits of result one place to the left</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Extract the lowest bit of n using bitwise AND with 1</span>
            <span class="c1">// If n's current lowest bit is 1, it returns 1; otherwise, it returns 0</span>
            <span class="kt">int</span> <span class="n">lowestBit</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Combine the shifted result with the lowest bit of n using bitwise OR</span>
            <span class="c1">// This is equivalent to adding the lowest bit of n to result's lowest place</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|</span> <span class="n">lowestBit</span><span class="o">;</span>

            <span class="c1">// Right shift n to discard the bit we just processed</span>
            <span class="c1">// This moves the next bit of n into the lowest place for the next iteration</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Reverse the bits of a given 32 bits unsigned integer using Java's built-in method.
     *
     * @param n the input 32 bits unsigned integer
     * @return the integer resulting from reversing the bits of {@code n}
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">reverseBits2</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Use the Integer.reverse method which is a built-in utility to reverse bits</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mb">0b00000010100101000001111010011100</span><span class="o">;</span>
        <span class="c1">// expected output: 964176192 (0b00111001011110000010100101000000)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">reverseBits</span><span class="o">(</span><span class="n">n1</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mb">0b11111111111111111111111111111101</span><span class="o">;</span>
        <span class="c1">// expected output: 3221225471 (0b10111111111111111111111111111111)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">reverseBits</span><span class="o">(</span><span class="n">n2</span><span class="o">));</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BitManipulation"/><summary type="html"><![CDATA[190. Reverse Bits]]></summary></entry></feed>