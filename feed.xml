<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-30T04:30:08+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">3371. Identify the Largest Outlier in an Array</title><link href="https://zhengstar94.github.io//blog/2025/IdentifyTheLargestOutlierInAnArray/" rel="alternate" type="text/html" title="3371. Identify the Largest Outlier in an Array"/><published>2025-07-30T00:00:00+00:00</published><updated>2025-07-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/IdentifyTheLargestOutlierInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/IdentifyTheLargestOutlierInAnArray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. This array contains <code class="language-plaintext highlighter-rouge">n</code> elements, where <strong>exactly</strong> <code class="language-plaintext highlighter-rouge">n - 2</code> elements are <strong>special</strong> <strong>numbers</strong>. One of the remaining <strong>two</strong> elements is the <em>sum</em> of these <strong>special numbers</strong>, and the other is an <strong>outlier</strong>.</li> <li>An <strong>outlier</strong> is defined as a number that is <em>neither</em> one of the original special numbers <em>nor</em> the element representing the sum of those numbers.</li> <li><strong>Note</strong> that special numbers, the sum element, and the outlier must have <strong>distinct</strong> indices, but <em>may</em> share the <strong>same</strong> value.</li> <li>Return the <strong>largest</strong> potential <strong>outlier</strong> in <code class="language-plaintext highlighter-rouge">nums</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,5,10]

Output: 10

Explanation:

The special numbers could be 2 and 3, thus making their sum 5 and the outlier 10.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-2,-1,-3,-6,4]

Output: 4

Explanation:

The special numbers could be -2, -1, and -3, thus making their sum -6 and the outlier 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1,1,5,5]

Output: 5

Explanation:

The special numbers could be 1, 1, 1, 1, and 1, thus making their sum 5 and the other 5 as the outlier.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IdentifyTheLargestOutlierInAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getLargestOutlier</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to count the occurrences of each number in the array.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Calculate the total sum of the array and populate the count map.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span> <span class="c1">// Equivalent to cnt[num]++</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="c1">// Iterate through each element, treating it as a possible outlier.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// (total - x) must be even for y to be an integer.</span>
            <span class="c1">// This ensures that y = (total - x) / 2 is a valid integer.</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">total</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="n">total</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="cm">/*
                 * Explanation of this block:
                 * - We are considering x as the possible outlier.
                 * - According to the problem, the sum of all numbers is: total = 2 * y + x,
                 *   where y is the sum of all "special numbers".
                 * - Rearranging gives y = (total - x) / 2.
                 * - We need to check if y exists in the array (cnt.containsKey(y)).
                 * - Additionally, if y == x, we must ensure that there are at least two occurrences
                 *   (so that x and y are at different indices).
                 * - If these conditions are met, x is a valid outlier candidate.
                 * - We update ans to be the maximum outlier found so far.
                 */</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">x</span> <span class="o">||</span> <span class="n">cnt</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getLargestOutlier</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 10</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getLargestOutlier</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getLargestOutlier</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums. This array contains n elements, where exactly n - 2 elements are special numbers. One of the remaining two elements is the sum of these special numbers, and the other is an outlier. An outlier is defined as a number that is neither one of the original special numbers nor the element representing the sum of those numbers. Note that special numbers, the sum element, and the outlier must have distinct indices, but may share the same value. Return the largest potential outlier in nums.]]></summary></entry><entry><title type="html">2419. Longest Subarray With Maximum Bitwise AND</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubarrayWithMaximumBitwiseAND/" rel="alternate" type="text/html" title="2419. Longest Subarray With Maximum Bitwise AND"/><published>2025-07-30T00:00:00+00:00</published><updated>2025-07-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubarrayWithMaximumBitwiseAND</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubarrayWithMaximumBitwiseAND/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code>.</li> <li>Consider a <strong>non-empty</strong> subarray from <code class="language-plaintext highlighter-rouge">nums</code> that has the <strong>maximum</strong> possible <strong>bitwise AND</strong>. <ul> <li>In other words, let <code class="language-plaintext highlighter-rouge">k</code> be the maximum value of the bitwise AND of <strong>any</strong> subarray of <code class="language-plaintext highlighter-rouge">nums</code>. Then, only subarrays with a bitwise AND equal to <code class="language-plaintext highlighter-rouge">k</code> should be considered.</li> </ul> </li> <li>Return <em>the length of the <strong>longest</strong> such subarray</em>.</li> <li>The bitwise AND of an array is the bitwise AND of all the numbers in it.</li> <li>A <strong>subarray</strong> is a contiguous sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,3,2,2]
Output: 2
Explanation:
The maximum possible bitwise AND of a subarray is 3.
The longest subarray with that value is [3,3], so we return 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4]
Output: 1
Explanation:
The maximum possible bitwise AND of a subarray is 4.
The longest subarray with that value is [4], so we return 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubarrayWithMaximumBitwiseAND</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Find the maximum value in the array.</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">maxVal</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">maxVal</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Find the longest sequence of consecutive elements equal to maxVal.</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// To store the maximum length found.</span>
        <span class="kt">int</span> <span class="n">currLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// To store the current length of consecutive maxVal elements.</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">maxVal</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current element equals maxVal, increment the current length.</span>
                <span class="n">currLen</span><span class="o">++;</span>
                <span class="c1">// Update maxLen if the current sequence is longer.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">currLen</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">maxLen</span> <span class="o">=</span> <span class="n">currLen</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If the current element is not maxVal, reset the current length.</span>
                <span class="n">currLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the length of the longest subarray found.</span>
        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: The longest subarray with maximum bitwise AND is [3, 3], length is 2.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="c1">// Example 2: The longest subarray with maximum bitwise AND is [4], length is 1.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums of size n. Consider a non-empty subarray from nums that has the maximum possible bitwise AND. In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered. Return the length of the longest such subarray. The bitwise AND of an array is the bitwise AND of all the numbers in it. A subarray is a contiguous sequence of elements within an array.]]></summary></entry><entry><title type="html">16.24. Pairs With Sum LCCI</title><link href="https://zhengstar94.github.io//blog/2025/PairsWithSumLCCI/" rel="alternate" type="text/html" title="16.24. Pairs With Sum LCCI"/><published>2025-07-28T00:00:00+00:00</published><updated>2025-07-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PairsWithSumLCCI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PairsWithSumLCCI/"><![CDATA[<ul> <li>Design an algorithm to find all pairs of integers within an array which sum to a specified value.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,6,5], target = 11
Output: [ [ 5,6 ] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,6,5,6], target = 11
Output: [ [ 5,6],[5,6 ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PairsWithSumLCCI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">pairSums</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// This map records how many times each number appears in the array.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Count the occurrences of each number in the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Iterate through the array to find valid pairs.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">num</span><span class="o">;</span> <span class="c1">// The number needed to form the target sum with 'num'.</span>

            <span class="c1">// Check if both 'num' and its complement are still available (not used up in previous pairs).</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">complement</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Special case: when num == complement, we need at least two of this number to form a pair.</span>
                <span class="c1">// For example, if target=10 and num=5, we need two 5's to form [5,5].</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">complement</span> <span class="o">&amp;&amp;</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// If there is only one occurrence left, we cannot form a pair [num, num].</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Add the pair [num, complement] to the result list.</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">complement</span><span class="o">));</span>
                <span class="c1">// Decrement the count for both numbers, since they have been used in a pair.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">complement</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// If either number is not available, skip to the next.</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="c1">// Output: [ [5, 6] ]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pairSums</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="c1">// Output: [ [5, 6], [5, 6] ]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pairSums</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="c1">// Output: [ [1, 5], [2, 4] ]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pairSums</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[Design an algorithm to find all pairs of integers within an array which sum to a specified value.]]></summary></entry><entry><title type="html">2210. Count Hills and Valleys in an Array</title><link href="https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray/" rel="alternate" type="text/html" title="2210. Count Hills and Valleys in an Array"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>. An index <code class="language-plaintext highlighter-rouge">i</code> is part of a <strong>hill</strong> in <code class="language-plaintext highlighter-rouge">nums</code> if the closest non-equal neighbors of <code class="language-plaintext highlighter-rouge">i</code> are smaller than <code class="language-plaintext highlighter-rouge">nums[i]</code>. Similarly, an index <code class="language-plaintext highlighter-rouge">i</code> is part of a <strong>valley</strong> in <code class="language-plaintext highlighter-rouge">nums</code> if the closest non-equal neighbors of <code class="language-plaintext highlighter-rouge">i</code> are larger than <code class="language-plaintext highlighter-rouge">nums[i]</code>. Adjacent indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> are part of the <strong>same</strong> hill or valley if <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code>.</li> <li>Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on <strong>both</strong> the left and right of the index.</li> <li>Return <em>the number of hills and valleys in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 &gt; 2 and 4 &gt; 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 &gt; 1 and 6 &gt; 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 &lt; 5 and 4 &gt; 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountHillsAndValleysInAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countPeaksAndValleys</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the total number of peaks and valleys found.</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Start from the second element, since the first element cannot be a peak or valley.</span>

        <span class="c1">// Loop through the array, but skip the first and last elements,</span>
        <span class="c1">// because they cannot be peaks or valleys (they don't have both neighbors).</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
            <span class="c1">// If the current element is equal to the previous one,</span>
            <span class="c1">// skip it to avoid counting the same peak/valley multiple times.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Find the closest non-equal neighbor to the left of nums[i].</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Move left pointer to the left until a different value is found or the start of the array is reached.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">left</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Find the closest non-equal neighbor to the right of nums[i].</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Move right pointer to the right until a different value is found or the end of the array is reached.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">right</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Only check for peak/valley if both left and right non-equal neighbors exist.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
                <span class="c1">// Check if nums[i] is a peak:</span>
                <span class="c1">// It is a peak if it is greater than both its closest non-equal neighbors.</span>
                <span class="c1">// Check if nums[i] is a valley:</span>
                <span class="c1">// It is a valley if it is less than both its closest non-equal neighbors.</span>
                <span class="k">if</span><span class="o">((</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])){</span>
                    <span class="n">count</span><span class="o">++;</span> <span class="c1">// Found a peak or valley, increment the counter.</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Move i to the next different element to avoid counting the same peak/valley multiple times.</span>
            <span class="c1">// This is important for handling consecutive equal elements as a single peak or valley.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j]. Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index. Return the number of hills and valleys in nums.]]></summary></entry><entry><title type="html">1679. Max Number of K-Sum Pairs</title><link href="https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs/" rel="alternate" type="text/html" title="1679. Max Number of K-Sum Pairs"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>In one operation, you can pick two numbers from the array whose sum equals <code class="language-plaintext highlighter-rouge">k</code> and remove them from the array.</li> <li>Return <em>the maximum number of operations you can perform on the array</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [112,131,411]

Output: -1

Explanation:

Each numbers largest digit in order is [2,3,4].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2536,1613,3366,162]

Output: 5902

Explanation:

All the numbers have 6 as their largest digit, so the answer is 2536 + 3366 = 5902.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [51,71,17,24,42]

Output: 88

Explanation:

Each number's largest digit in order is [5,7,7,4,4].

So we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxNumberOfKSumPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This HashMap will store the count of each number that has not yet been paired.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable counts the number of valid pairs found.</span>

        <span class="c1">// Iterate through each number in the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">num</span><span class="o">;</span> <span class="c1">// The number we need to pair with 'num' to sum to k.</span>

            <span class="c1">// Check if there is an available 'target' number that has not been paired yet.</span>
            <span class="c1">// countMap.getOrDefault(target, 0) &gt; 0 means there is at least one 'target' left to pair.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">result</span><span class="o">++;</span> <span class="c1">// We found a valid pair (num + target == k), so increment the result.</span>

                <span class="c1">// Since we've used one 'target' for pairing, decrease its count by 1.</span>
                <span class="c1">// This ensures each number is used at most once.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If there is no available 'target' to pair with 'num',</span>
                <span class="c1">// record 'num' in the map for possible pairing with future numbers.</span>
                <span class="c1">// Increase the count of 'num' by 1.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After processing all numbers, 'result' contains the maximum number of valid pairs.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">6</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span> <span class="c1">// Output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array.]]></summary></entry><entry><title type="html">2815. Max Pair Sum in an Array</title><link href="https://zhengstar94.github.io//blog/2025/MaxPairSumInAnArray/" rel="alternate" type="text/html" title="2815. Max Pair Sum in an Array"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxPairSumInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxPairSumInAnArray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. You have to find the <strong>maximum</strong> sum of a pair of numbers from <code class="language-plaintext highlighter-rouge">nums</code> such that the <strong>largest digit</strong> in both numbers is equal.</li> <li>For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them.</li> <li>Return the <strong>maximum</strong> sum or -1 if no such pair exists.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [112,131,411]

Output: -1

Explanation:

Each numbers largest digit in order is [2,3,4].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2536,1613,3366,162]

Output: 5902

Explanation:

All the numbers have 6 as their largest digit, so the answer is 2536 + 3366 = 5902.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [51,71,17,24,42]

Output: 88

Explanation:

Each number's largest digit in order is [5,7,7,4,4].

So we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * k) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPairSumInAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This map stores, for each possible max digit (0~9), the largest number seen so far with that digit.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">maxNumForDigit</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">result</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// Initialize result as -1, which will be returned if no valid pair is found.</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">maxDigit</span> <span class="o">=</span> <span class="n">getMaxDigit</span><span class="o">(</span><span class="n">num</span><span class="o">);</span> <span class="c1">// Find the largest digit in the current number.</span>

            <span class="c1">// --- Key logic with detailed comments ---</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">)){</span>
                <span class="c1">// If there is already a number in the map with the same max digit,</span>
                <span class="c1">// it means we have found at least one previous number that can form a valid pair with the current number.</span>
                <span class="kt">int</span> <span class="n">pairSum</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">);</span> <span class="c1">// Calculate the sum of the current number and the previous max number with the same max digit.</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">pairSum</span><span class="o">);</span> <span class="c1">// Update the result if this pairSum is greater than the current result.</span>

                <span class="c1">// Update the stored number for this max digit in the map.</span>
                <span class="c1">// We always want to keep the largest number seen so far for each max digit,</span>
                <span class="c1">// because a larger number may form a larger sum with future numbers.</span>
                <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">)));</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If this is the first time we see this max digit,</span>
                <span class="c1">// just store the current number as the largest number for this digit.</span>
                <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getMaxDigit</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxDigit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxDigit</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">,</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">// Compare the current digit with maxDigit.</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// Move to the next digit.</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxDigit</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">51</span><span class="o">,</span> <span class="mi">71</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">42</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">39</span><span class="o">,</span> <span class="mi">93</span><span class="o">,</span> <span class="mi">99</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 88</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: -1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 192</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the largest digit in both numbers is equal. For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them. Return the maximum sum or -1 if no such pair exists.]]></summary></entry><entry><title type="html">2260. Minimum Consecutive Cards to Pick Up</title><link href="https://zhengstar94.github.io//blog/2025/MinimumConsecutiveCardsToPickUp/" rel="alternate" type="text/html" title="2260. Minimum Consecutive Cards to Pick Up"/><published>2025-07-26T00:00:00+00:00</published><updated>2025-07-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumConsecutiveCardsToPickUp</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumConsecutiveCardsToPickUp/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">cards</code> where <code class="language-plaintext highlighter-rouge">cards[i]</code> represents the <strong>value</strong> of the <code class="language-plaintext highlighter-rouge">ith</code> card. A pair of cards are <strong>matching</strong> if the cards have the <strong>same</strong> value.</li> <li>Return <em>the <strong>minimum</strong> number of <strong>consecutive</strong> cards you have to pick up to have a pair of <strong>matching</strong> cards among the picked cards.</em> If it is impossible to have matching cards, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cards = [3,4,2,3,4,7]
Output: 4
Explanation: We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cards = [1,0,5,3]
Output: -1
Explanation: There is no way to pick up a set of consecutive cards that contain a pair of matching cards.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumConsecutiveCardsToPickUp</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumCardPickup</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">cards</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store the last index where each card value appeared</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">lastIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Initialize the minimum length to a very large value</span>
        <span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Iterate through the cards array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cards</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current card value has appeared before</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastIndex</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">cards</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="c1">// Get the previous index where this card value appeared</span>
                <span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">=</span> <span class="n">lastIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cards</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="c1">// Calculate the length of the subarray between the two matching cards (inclusive)</span>
                <span class="n">minLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">prevIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Update the last seen index for the current card value</span>
            <span class="n">lastIndex</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cards</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// If minLen was not updated, return -1 (no matching pair found)</span>
        <span class="c1">// Otherwise, return the minimum length found</span>
        <span class="k">return</span> <span class="n">minLen</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">minLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: There is a matching pair (3 appears twice)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cards1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="c1">// Test case 2: No matching pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cards2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="c1">// Output the results for both test cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumCardPickup</span><span class="o">(</span><span class="n">cards1</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumCardPickup</span><span class="o">(</span><span class="n">cards2</span><span class="o">));</span> <span class="c1">// Output: -1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value. Return the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.]]></summary></entry><entry><title type="html">2001. Number of Pairs of Interchangeable Rectangles</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles/" rel="alternate" type="text/html" title="2001. Number of Pairs of Interchangeable Rectangles"/><published>2025-07-26T00:00:00+00:00</published><updated>2025-07-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles/"><![CDATA[<ul> <li>You are given <code class="language-plaintext highlighter-rouge">n</code> rectangles represented by a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">rectangles</code>, where <code class="language-plaintext highlighter-rouge">rectangles[i] = [widthi, heighti]</code> denotes the width and height of the <code class="language-plaintext highlighter-rouge">ith</code> rectangle.</li> <li>Two rectangles <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> (<code class="language-plaintext highlighter-rouge">i &lt; j</code>) are considered <strong>interchangeable</strong> if they have the <strong>same</strong> width-to-height ratio. More formally, two rectangles are <strong>interchangeable</strong> if <code class="language-plaintext highlighter-rouge">widthi/heighti == widthj/heightj</code> (using decimal division, not integer division).</li> <li>Return <em>the <strong>number</strong> of pairs of <strong>interchangeable</strong> rectangles in</em> <code class="language-plaintext highlighter-rouge">rectangles</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rectangles = [ [ 4,8],[3,6],[10,20],[15,30 ] ]
Output: 6
Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed):
- Rectangle 0 with rectangle 1: 4/8 == 3/6.
- Rectangle 0 with rectangle 2: 4/8 == 10/20.
- Rectangle 0 with rectangle 3: 4/8 == 15/30.
- Rectangle 1 with rectangle 2: 3/6 == 10/20.
- Rectangle 1 with rectangle 3: 3/6 == 15/30.
- Rectangle 2 with rectangle 3: 10/20 == 15/30.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rectangles = [ [ 4,5],[7,8 ] ]
Output: 0
Explanation: There are no interchangeable pairs of rectangles.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfPairsOfInterchangeableRectangles</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">interchangeableRectangles</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the final answer: the total number of interchangeable pairs.</span>

        <span class="c1">// This HashMap will store, for each unique ratio, how many times it has appeared so far.</span>
        <span class="c1">// Key: the ratio (width / height) as a double.</span>
        <span class="c1">// Value: the count of rectangles seen so far with this ratio.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each rectangle in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">rect:</span> <span class="n">rectangles</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the ratio of width to height for the current rectangle.</span>
            <span class="c1">// Multiplying by 1.0 ensures the division is floating-point, not integer division.</span>
            <span class="kt">double</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">rect</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rect</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// For the current rectangle, check how many rectangles with the same ratio have already been seen.</span>
            <span class="c1">// Each such rectangle can form a unique pair with the current one.</span>
            <span class="c1">// So, add the count of rectangles with this ratio to the answer.</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Update the map: increment the count for this ratio by 1,</span>
            <span class="c1">// because we've now seen one more rectangle with this ratio.</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After processing all rectangles, return the total number of interchangeable pairs found.</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: rectangles with the same ratio (4/8 = 3/6 = 10/20 = 15/30 = 0.5)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">},{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">},{</span><span class="mi">15</span><span class="o">,</span><span class="mi">30</span> <span class="o">}</span> <span class="o">};</span>
        <span class="c1">// Example 2: rectangles with different ratios (4/5 != 7/8)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">},{</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span> <span class="o">}</span> <span class="o">};</span>

        <span class="c1">// Output the results for both examples.</span>
        <span class="c1">// For rectangles1, the output should be 6 (all rectangles are interchangeable).</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">interchangeableRectangles</span><span class="o">(</span><span class="n">rectangles1</span><span class="o">));</span> <span class="c1">// Output: 6</span>

        <span class="c1">// For rectangles2, the output should be 0 (no interchangeable pairs).</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">interchangeableRectangles</span><span class="o">(</span><span class="n">rectangles2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle. Two rectangles i and j (i &lt; j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division). Return the number of pairs of interchangeable rectangles in rectangles.]]></summary></entry><entry><title type="html">3487. Maximum Unique Subarray Sum After Deletion</title><link href="https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion/" rel="alternate" type="text/html" title="3487. Maximum Unique Subarray Sum After Deletion"/><published>2025-07-25T00:00:00+00:00</published><updated>2025-07-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>You are allowed to delete any number of elements from <code class="language-plaintext highlighter-rouge">nums</code> without making it <strong>empty</strong>. After performing the deletions, select a subarray of <code class="language-plaintext highlighter-rouge">nums</code> such that: <ul> <li>All elements in the subarray are <strong>unique</strong>.</li> <li>The sum of the elements in the subarray is <strong>maximized</strong>.</li> </ul> </li> <li>Return the <strong>maximum sum</strong> of such a subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,5]
Output: 15

Explanation:

Select the entire array without deleting any element to obtain the maximum sum.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,1,1]
Output: 1

Explanation:

Delete the element nums[0] == 1, nums[1] == 1, nums[2] == 0, and nums[3] == 1. Select the entire array [1] to obtain the maximum sum.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,-1,-2,1,0,-1]
Output: 3

Explanation:

Delete the elements nums[2] == -1 and nums[3] == -2, and select the subarray [2, 1] from [1, 2, 1, 0, -1] to obtain the maximum sum.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumUniqueSubarraySumAfterDeletion</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This set is used to store unique positive numbers encountered in the array.</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// This variable accumulates the sum of all unique positive numbers.</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// This variable keeps track of the largest negative number in the array.</span>
        <span class="c1">// It is initialized to the smallest possible integer value.</span>
        <span class="kt">int</span> <span class="n">maxNegative</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="c1">// Traverse each element in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current number is negative, update maxNegative if this number is larger.</span>
                <span class="c1">// This is important for the case where all numbers are negative.</span>
                <span class="n">maxNegative</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxNegative</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If the current number is non-negative and not already in the set (i.e., unique),</span>
                <span class="c1">// add it to the set and add its value to the sum.</span>
                <span class="c1">// Only the first occurrence of each positive number is counted.</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If the number is non-negative but already in the set, it is skipped (no duplicate allowed).</span>
        <span class="o">}</span>

        <span class="c1">// If the set is empty, it means there were no non-negative numbers in the array.</span>
        <span class="c1">// In this case, return the largest negative number found.</span>
        <span class="c1">// Otherwise, return the sum of all unique positive numbers.</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="n">maxNegative</span> <span class="o">:</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">};</span>

        <span class="c1">// Test case 1: All unique positive numbers, should return 15 (1+2+3+4+5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 15</span>

        <span class="c1">// Test case 2: Only one unique non-negative number (1), should return 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 3: Mixed numbers, unique non-negative numbers are 1, 2, 0, sum is 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 3</span>

        <span class="c1">// Test case 4: All negative numbers, should return the largest one (-2)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Output: -2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums. You are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that: All elements in the subarray are unique. The sum of the elements in the subarray is maximized. Return the maximum sum of such a subarray.]]></summary></entry><entry><title type="html">2441. Largest Positive Integer That Exists With Its Negative</title><link href="https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative/" rel="alternate" type="text/html" title="2441. Largest Positive Integer That Exists With Its Negative"/><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> that <strong>does not contain</strong> any zeros, find <strong>the largest positive</strong> integer <code class="language-plaintext highlighter-rouge">k</code> such that <code class="language-plaintext highlighter-rouge">-k</code> also exists in the array.</li> <li>Return <em>the positive integer</em> <code class="language-plaintext highlighter-rouge">k</code>. If there is no such integer, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,2,-3,3]
Output: 3
Explanation: 3 is the only valid k we can find in the array.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,10,6,7,-7,1]
Output: 7
Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-10,8,6,7,-2,-3]
Output: -1
Explanation: There is no a single valid k, we return -1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LargestPositiveIntegerThatExistsWithItsNegative</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashSet to store all numbers seen so far for quick lookup</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Initialize maxK to -1, which will be returned if no valid k is found</span>
        <span class="kt">int</span> <span class="n">maxK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if the opposite number (-num) has already been seen</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(-</span><span class="n">num</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If so, update maxK to the larger value between current maxK and |num|</span>
                <span class="c1">// Math.abs(num) ensures we always consider the positive value</span>
                <span class="n">maxK</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxK</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="c1">// Add the current number to the set for future lookups</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After checking all numbers, return the result</span>
        <span class="k">return</span> <span class="n">maxK</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: Both 3 and -3 exist, so the answer is 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="c1">// Example 2: Both 7 and -7 exist, so the answer is 7</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Example 3: No number has its negative, so the answer is -1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">10</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">};</span>

        <span class="c1">// Print the results of each test case</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 7</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: -1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array. Return the positive integer k. If there is no such integer, return -1.]]></summary></entry></feed>