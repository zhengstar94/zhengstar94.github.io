<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-06T10:47:43+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">999. Available Captures for Rook</title><link href="https://zhengstar94.github.io//blog/2024/AvailableCapturesForRook/" rel="alternate" type="text/html" title="999. Available Captures for Rook"/><published>2024-12-06T00:00:00+00:00</published><updated>2024-12-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/AvailableCapturesForRook</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/AvailableCapturesForRook/"><![CDATA[<ul> <li>You are given an <code class="language-plaintext highlighter-rouge">8 x 8</code> <strong>matrix</strong> representing a chessboard. There is <strong>exactly one</strong> white rook represented by <code class="language-plaintext highlighter-rouge">'R'</code>, some number of white bishops <code class="language-plaintext highlighter-rouge">'B'</code>, and some number of black pawns <code class="language-plaintext highlighter-rouge">'p'</code>. Empty squares are represented by <code class="language-plaintext highlighter-rouge">'.'</code>.</li> <li>A rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece <em>or</em> the edge of the board. A rook is <strong>attacking</strong> a pawn if it can move to the pawn’s square in one move.</li> <li>Note: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path.</li> <li>Return the <strong>number of pawns</strong> the white rook is <strong>attacking</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [ [ ".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","." ] ]

Output: 3

Explanation:

In this example, the rook is attacking all the pawns.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [ [ ".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","." ] ]

Output: 0

Explanation:

The bishops are blocking the rook from attacking any of the pawns.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [ [ ".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","." ] ]

Output: 3

Explanation:

The rook is attacking the pawns at positions b5, d6, and f5.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AvailableCapturesForRook</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numRookCaptures</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">captures</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Counter for captured pawns</span>
    <span class="kt">int</span> <span class="n">rookRow</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">rookCol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// Initial rook position coordinates</span>

    <span class="c1">// Find the rook's position on the chessboard</span>
    <span class="c1">// Nested loops iterate through each square to locate the rook</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'R'</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// When rook is found, store its row and column coordinates</span>
          <span class="n">rookRow</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
          <span class="n">rookCol</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
          <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="c1">// If the rook's row has been found (rookRow is no longer -1), </span>
      <span class="c1">// immediately exit the outer loop to optimize the search process. </span>
      <span class="c1">// This prevents unnecessary iterations through the remaining rows </span>
      <span class="c1">// after the rook's position has already been located, </span>
      <span class="c1">// improving the time efficiency of finding the rook on the chessboard.</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">rookRow</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Check capture possibilities in four directions from rook's position</span>

    <span class="c1">// Upward direction capture check</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rookRow</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">rookCol</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'B'</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop if a bishop blocks the path</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">rookCol</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'p'</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">captures</span><span class="o">++;</span> <span class="c1">// Capture the pawn</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop checking this direction after capturing</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Downward direction capture check</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rookRow</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">rookCol</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'B'</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop if a bishop blocks the path</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">rookCol</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'p'</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">captures</span><span class="o">++;</span> <span class="c1">// Capture the pawn</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop checking this direction after capturing</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Left direction capture check</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">rookCol</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">rookRow</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'B'</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop if a bishop blocks the path</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">rookRow</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'p'</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">captures</span><span class="o">++;</span> <span class="c1">// Capture the pawn</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop checking this direction after capturing</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Right direction capture check</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">rookCol</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">rookRow</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'B'</span><span class="o">){</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop if a bishop blocks the path</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">rookRow</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'p'</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">captures</span><span class="o">++;</span> <span class="c1">// Capture the pawn</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// Stop checking this direction after capturing</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">captures</span><span class="o">;</span> <span class="c1">// Return total number of captured pawns</span>
  <span class="o">}</span>


  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Test Case 1: Pawns available in multiple directions</span>
    <span class="kt">char</span><span class="o">[][]</span> <span class="n">board1</span> <span class="o">=</span> <span class="o">{</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'R'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,}</span>
    <span class="o">};</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numRookCaptures</span><span class="o">(</span><span class="n">board1</span><span class="o">));</span>

    <span class="c1">// Test Case 2: Bishops blocking all pawns</span>
    <span class="kt">char</span><span class="o">[][]</span> <span class="n">board2</span> <span class="o">=</span> <span class="o">{</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'B'</span><span class="o">,</span><span class="sc">'R'</span><span class="o">,</span><span class="sc">'B'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,}</span>
    <span class="o">};</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numRookCaptures</span><span class="o">(</span><span class="n">board2</span><span class="o">));</span>

    <span class="c1">// Test Case 3: Pawns available in some directions</span>
    <span class="kt">char</span><span class="o">[][]</span> <span class="n">board3</span> <span class="o">=</span> <span class="o">{</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'B'</span><span class="o">,</span><span class="sc">'R'</span><span class="o">,</span><span class="sc">'p'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,},</span>
            <span class="o">{</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,</span><span class="sc">'.'</span><span class="o">,}</span>
    <span class="o">};</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numRookCaptures</span><span class="o">(</span><span class="n">board3</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are given an 8 x 8 matrix representing a chessboard. There is exactly one white rook represented by 'R', some number of white bishops 'B', and some number of black pawns 'p'. Empty squares are represented by '.'. A rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece or the edge of the board. A rook is attacking a pawn if it can move to the pawn’s square in one move. Note: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path. Return the number of pawns the white rook is attacking.]]></summary></entry><entry><title type="html">498. Diagonal Traverse</title><link href="https://zhengstar94.github.io//blog/2024/DiagonalTraverse/" rel="alternate" type="text/html" title="498. Diagonal Traverse"/><published>2024-12-06T00:00:00+00:00</published><updated>2024-12-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DiagonalTraverse</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DiagonalTraverse/"><![CDATA[<ul> <li>Given an <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: mat = [ [1,2,3],[4,5,6],[7,8,9] ]
Output: [1,2,4,7,5,3,6,8,9]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: mat = [ [ 1,2],[3,4 ] ]
Output: [1,2,3,4]

</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiagonalTraverse</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findDiagonalOrder</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Number of rows in the matrix</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Number of columns in the matrix</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Result array to store diagonal traversal</span>
        <span class="c1">// Size is total number of elements in the matrix</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">];</span>

        <span class="c1">// Index to track current position in the result array</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Total number of diagonals is (m + n - 1)</span>
        <span class="c1">// We iterate through each diagonal</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Even-indexed diagonals: Bottom-left to Top-right direction</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Determine the starting point for the current diagonal</span>

                <span class="c1">// Row starting point calculation:</span>
                <span class="c1">// If current diagonal index is less than number of rows,</span>
                <span class="c1">// start from that row index</span>
                <span class="c1">// Otherwise, start from the last row</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Column starting point calculation:</span>
                <span class="c1">// If current diagonal index is less than number of rows,</span>
                <span class="c1">// start from first column (0)</span>
                <span class="c1">// Otherwise, calculate the starting column based on diagonal index</span>
                <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">i</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Traverse the diagonal while within matrix bounds</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Add current matrix element to result</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>

                    <span class="c1">// Move upwards in the matrix</span>
                    <span class="n">x</span><span class="o">--;</span>

                    <span class="c1">// Move to the right in the matrix</span>
                    <span class="n">y</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Odd-indexed diagonals: Top-right to Bottom-left direction</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Determine the starting point for the current diagonal</span>

                <span class="c1">// Row starting point calculation:</span>
                <span class="c1">// If current diagonal index is less than number of columns,</span>
                <span class="c1">// start from first row</span>
                <span class="c1">// Otherwise, calculate the starting row based on diagonal index</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Column starting point calculation:</span>
                <span class="c1">// If current diagonal index is less than number of columns,</span>
                <span class="c1">// start from that column index</span>
                <span class="c1">// Otherwise, start from the last column</span>
                <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Traverse the diagonal while within matrix bounds</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Add current matrix element to result</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>

                    <span class="c1">// Move downwards in the matrix</span>
                    <span class="n">x</span><span class="o">++;</span>

                    <span class="c1">// Move to the left in the matrix</span>
                    <span class="n">y</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the array with diagonal traversal order</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Utility method to print an array
     *
     * @param arr Input array to be printed
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Iterate through each element and print with space</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Print a new line after array elements</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to demonstrate diagonal traversal with different matrix types
     *
     * @param args Command line arguments (not used)
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: 3x3 Square Matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x3 Matrix Traversal Result:"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">findDiagonalOrder</span><span class="o">(</span><span class="n">mat1</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test Case 2: 4x4 Square Matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>  <span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">5</span><span class="o">,</span>  <span class="mi">6</span><span class="o">,</span>  <span class="mi">7</span><span class="o">,</span>  <span class="mi">8</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">13</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">16</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"4x4 Matrix Traversal Result:"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">findDiagonalOrder</span><span class="o">(</span><span class="n">mat2</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test Case 3: Rectangular Matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat3</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x4 Matrix Traversal Result:"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">findDiagonalOrder</span><span class="o">(</span><span class="n">mat3</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">result3</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.]]></summary></entry><entry><title type="html">434. Number of Segments in a String</title><link href="https://zhengstar94.github.io//blog/2024/NumberOfSegmentsInAString/" rel="alternate" type="text/html" title="434. Number of Segments in a String"/><published>2024-12-06T00:00:00+00:00</published><updated>2024-12-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NumberOfSegmentsInAString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NumberOfSegmentsInAString/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the number of segments in the string</em>.</li> <li>A <strong>segment</strong> is defined to be a contiguous sequence of <strong>non-space characters</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "Hello, my name is John"
Output: 5
Explanation: The five segments are ["Hello,", "my", "name", "is", "John"]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "Hello"
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSegmentsInAString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countSegments</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Initialize the segment counter.</span>

        <span class="c1">// Loop through the characters in the string.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="cm">/**
             * Key condition:
             * 1. Check if the current character is NOT a space: s.charAt(i) != ' '
             *    - Ensures we are only processing non-space characters.
             * 2. Check if it's the start of a new segment:
             *    - It's the first character in the string (i == 0), OR
             *    - The previous character is a space (s.charAt(i - 1) == ' ').
             *    - This ensures that we only count the beginning of a new word.
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">' '</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">' '</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">sum</span><span class="o">++;</span> <span class="c1">// Increment the segment counter for a new word.</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span> <span class="c1">// Return the total number of segments found.</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"Hello world"</span><span class="o">;</span> <span class="c1">// Two words.</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"   Leading spaces"</span><span class="o">;</span> <span class="c1">// Two words with leading spaces.</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"Trailing spaces   "</span><span class="o">;</span> <span class="c1">// Two words with trailing spaces.</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"  Multiple   spaces  between words  "</span><span class="o">;</span> <span class="c1">// Four words with multiple spaces.</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span> <span class="c1">// Empty string, should return 0.</span>
        <span class="nc">String</span> <span class="n">test6</span> <span class="o">=</span> <span class="s">"      "</span><span class="o">;</span> <span class="c1">// String with only spaces, should return 0.</span>
        <span class="nc">String</span> <span class="n">test7</span> <span class="o">=</span> <span class="s">"OneWord"</span><span class="o">;</span> <span class="c1">// Single word, should return 1.</span>

        <span class="c1">// Print results for each test case.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test1: "</span> <span class="o">+</span> <span class="n">test1</span> <span class="o">+</span> <span class="s">" -&gt; Segments: "</span> <span class="o">+</span> <span class="n">countSegments</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test2: "</span> <span class="o">+</span> <span class="n">test2</span> <span class="o">+</span> <span class="s">" -&gt; Segments: "</span> <span class="o">+</span> <span class="n">countSegments</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test3: "</span> <span class="o">+</span> <span class="n">test3</span> <span class="o">+</span> <span class="s">" -&gt; Segments: "</span> <span class="o">+</span> <span class="n">countSegments</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test4: "</span> <span class="o">+</span> <span class="n">test4</span> <span class="o">+</span> <span class="s">" -&gt; Segments: "</span> <span class="o">+</span> <span class="n">countSegments</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test5: "</span> <span class="o">+</span> <span class="n">test5</span> <span class="o">+</span> <span class="s">" -&gt; Segments: "</span> <span class="o">+</span> <span class="n">countSegments</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span> <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test6: "</span> <span class="o">+</span> <span class="n">test6</span> <span class="o">+</span> <span class="s">" -&gt; Segments: "</span> <span class="o">+</span> <span class="n">countSegments</span><span class="o">(</span><span class="n">test6</span><span class="o">));</span> <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test7: "</span> <span class="o">+</span> <span class="n">test7</span> <span class="o">+</span> <span class="s">" -&gt; Segments: "</span> <span class="o">+</span> <span class="n">countSegments</span><span class="o">(</span><span class="n">test7</span><span class="o">));</span> <span class="c1">// Output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[Given a string s, return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters.]]></summary></entry><entry><title type="html">9. Palindrome Number</title><link href="https://zhengstar94.github.io//blog/2024/PalindromeNumber/" rel="alternate" type="text/html" title="9. Palindrome Number"/><published>2024-12-06T00:00:00+00:00</published><updated>2024-12-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PalindromeNumber</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PalindromeNumber/"><![CDATA[<ul> <li>Given an integer <code class="language-plaintext highlighter-rouge">x</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if</em> <code class="language-plaintext highlighter-rouge">x</code> <em>is a</em> <strong><em>palindrome</em></strong><em>, and</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PalindromeNumber</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Negative numbers are not palindromes (e.g., -121).</span>
        <span class="c1">// Numbers ending in 0 are not palindromes unless the number is 0 itself.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">reversedHalf</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Stores the reversed second half of the number.</span>

        <span class="c1">// Reverses digits until half of the number is processed.</span>
        <span class="c1">// The loop continues as long as the original number is greater than the reversed half.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">reversedHalf</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Extract the last digit of x and add it to reversedHalf.</span>
            <span class="n">reversedHalf</span> <span class="o">=</span> <span class="n">reversedHalf</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
            <span class="c1">// Remove the last digit from x.</span>
            <span class="n">x</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Compare the two halves of the number:</span>
        <span class="c1">// - If the number of digits is even, both halves should be equal (x == reversedHalf).</span>
        <span class="c1">// - If the number of digits is odd, the middle digit can be ignored by dividing reversedHalf by 10.</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">reversedHalf</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">reversedHalf</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to validate the solution</span>
        <span class="kt">int</span> <span class="n">test1</span> <span class="o">=</span> <span class="mi">121</span><span class="o">;</span>        <span class="c1">// Palindrome</span>
        <span class="kt">int</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">121</span><span class="o">;</span>       <span class="c1">// Negative number, not a palindrome</span>
        <span class="kt">int</span> <span class="n">test3</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>         <span class="c1">// Ends in 0, not a palindrome</span>
        <span class="kt">int</span> <span class="n">test4</span> <span class="o">=</span> <span class="mi">12321</span><span class="o">;</span>      <span class="c1">// Odd-length palindrome</span>
        <span class="kt">int</span> <span class="n">test5</span> <span class="o">=</span> <span class="mi">123321</span><span class="o">;</span>     <span class="c1">// Even-length palindrome</span>
        <span class="kt">int</span> <span class="n">test6</span> <span class="o">=</span> <span class="mi">12345</span><span class="o">;</span>      <span class="c1">// Not a palindrome</span>
        <span class="kt">int</span> <span class="n">test7</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>          <span class="c1">// Palindrome, single digit</span>
        <span class="kt">int</span> <span class="n">test8</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>          <span class="c1">// Palindrome, single digit</span>

        <span class="c1">// Print test results</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test1</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test2</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test3</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test4</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test5</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test6</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test6</span><span class="o">));</span> <span class="c1">// false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test7</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test7</span><span class="o">));</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test8</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">test8</span><span class="o">));</span> <span class="c1">// true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer x, return true if x is a palindrome, and false otherwise.]]></summary></entry><entry><title type="html">2022. Convert 1D Array Into 2D Array</title><link href="https://zhengstar94.github.io//blog/2024/Convert1DArrayInto2DArray/" rel="alternate" type="text/html" title="2022. Convert 1D Array Into 2D Array"/><published>2024-12-05T00:00:00+00:00</published><updated>2024-12-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/Convert1DArrayInto2DArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/Convert1DArrayInto2DArray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 1-dimensional (1D) integer array <code class="language-plaintext highlighter-rouge">original</code>, and two integers, <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code>. You are tasked with creating a 2-dimensional (2D) array with ` m<code class="language-plaintext highlighter-rouge"> rows and </code>n<code class="language-plaintext highlighter-rouge"> columns using **all** the elements from </code>original`.</li> <li>The elements from indices <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n - 1</code> (<strong>inclusive</strong>) of <code class="language-plaintext highlighter-rouge">original</code> should form the first row of the constructed 2D array, the elements from indices <code class="language-plaintext highlighter-rouge">n</code> to <code class="language-plaintext highlighter-rouge">2 * n - 1</code> (<strong>inclusive</strong>) should form the second row of the constructed 2D array, and so on.</li> <li>Return <em>an</em> <code class="language-plaintext highlighter-rouge">m x n</code> <em>2D array constructed according to the above procedure, or an empty 2D array if it is impossible</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: original = [1,2,3,4], m = 2, n = 2
Output: [[1,2],[3,4]]
Explanation: The constructed 2D array should contain 2 rows and 2 columns.
The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: original = [1,2,3], m = 1, n = 3
Output: [[1,2,3]]
Explanation: The constructed 2D array should contain 1 row and 3 columns.
Put all three elements in original into the first row of the constructed 2D array.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: original = [1,2], m = 1, n = 1
Output: []
Explanation: There are 2 elements in original.
It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Convert1DArrayInto2DArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">construct2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">original</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check if the size of the original array matches the required dimensions.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Return an empty 2D array if the dimensions do not match.</span>
        <span class="o">}</span>

        <span class="c1">// Initialize a 2D array with m rows and n columns.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Fill the 2D array using elements from the original 1D array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// Loop through each row.</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// Loop through each column.</span>
                <span class="c1">// Map the 1D array index to the 2D array:</span>
                <span class="c1">// - i * n calculates the starting index for the current row in the 1D array.</span>
                <span class="c1">// - j adds the column offset within the current row.</span>
                <span class="c1">// Example: For i = 1 (2nd row) and n = 3 (3 columns), the row starts at index 3 in the 1D array.</span>
                <span class="c1">// Adding j = 0, 1, 2 fills the 2nd row of the 2D array.</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">original</span><span class="o">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> <span class="c1">// Return the constructed 2D array.</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Valid input with 2 rows and 3 columns.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original1</span><span class="o">,</span> <span class="n">m1</span><span class="o">,</span> <span class="n">n1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Invalid input where the size does not match m * n.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original2</span><span class="o">,</span> <span class="n">m2</span><span class="o">,</span> <span class="n">n2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Edge case with 1 row and 4 columns.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original3</span><span class="o">,</span> <span class="n">m3</span><span class="o">,</span> <span class="n">n3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Edge case with 4 rows and 1 column.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m4</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="n">n4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original4</span><span class="o">,</span> <span class="n">m4</span><span class="o">,</span> <span class="n">n4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Empty input.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original5</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span> <span class="n">m5</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n5</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original5</span><span class="o">,</span> <span class="n">m5</span><span class="o">,</span> <span class="n">n5</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Check if the array is empty.</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[]"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Iterate through each row and print it.</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with ` m rows and n columns using **all** the elements from original`. The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on. Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.]]></summary></entry><entry><title type="html">3001. Minimum Moves to Capture The Queen</title><link href="https://zhengstar94.github.io//blog/2024/MinimumMovesToCaptureTheQueen/" rel="alternate" type="text/html" title="3001. Minimum Moves to Capture The Queen"/><published>2024-12-05T00:00:00+00:00</published><updated>2024-12-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MinimumMovesToCaptureTheQueen</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MinimumMovesToCaptureTheQueen/"><![CDATA[<ul> <li>There is a <strong>1-indexed</strong> <code class="language-plaintext highlighter-rouge">8 x 8</code> chessboard containing <code class="language-plaintext highlighter-rouge">3</code> pieces.</li> <li>You are given <code class="language-plaintext highlighter-rouge">6</code> integers <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">e</code>, and <code class="language-plaintext highlighter-rouge">f</code> where: <ul> <li><code class="language-plaintext highlighter-rouge">(a, b)</code> denotes the position of the white rook.</li> <li><code class="language-plaintext highlighter-rouge">(c, d)</code> denotes the position of the white bishop.</li> <li><code class="language-plaintext highlighter-rouge">(e, f)</code> denotes the position of the black queen.</li> </ul> </li> <li>Given that you can only move the white pieces, return <em>the <strong>minimum</strong> number of moves required to capture the black queen</em>.</li> <li><strong>Note</strong> that: <ul> <li>Rooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.</li> <li>Bishops can move any number of squares diagonally, but cannot jump over other pieces.</li> <li>A rook or a bishop can capture the queen if it is located in a square that they can move to.</li> <li>The queen does not move.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = 1, b = 1, c = 8, d = 8, e = 2, f = 3
Output: 2
Explanation: We can capture the black queen in two moves by moving the white rook to (1, 3) then to (2, 3).
It is impossible to capture the black queen in less than two moves since it is not being attacked by any of the pieces at the beginning.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = 5, b = 3, c = 3, d = 4, e = 5, f = 2
Output: 1
Explanation: We can capture the black queen in a single move by doing one of the following: 
- Move the white rook to (5, 2).
- Move the white bishop to (5, 2).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumMovesToCaptureTheQueen</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="kt">int</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span>
            <span class="c1">// Rook is in the same column as the queen</span>
                <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">e</span> <span class="o">&amp;&amp;</span>
                        <span class="c1">// Two possible scenarios:</span>
                        <span class="c1">// 1. Rook and bishop are not in the same column, or</span>
                        <span class="c1">// 2. Bishop is positioned in a way that doesn't block the capture path</span>
                        <span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">c</span> <span class="o">||</span> <span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">b</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="o">)</span> <span class="o">||</span>
                        <span class="c1">// Alternative scenario: rook is in the same row as the queen</span>
                        <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">f</span> <span class="o">&amp;&amp;</span>
                                <span class="c1">// Two possible scenarios:</span>
                                <span class="c1">// 1. Rook and bishop are not in the same row, or</span>
                                <span class="c1">// 2. Bishop is positioned in a way that doesn't block the capture path</span>
                                <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">d</span> <span class="o">||</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                        <span class="o">)</span>
        <span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If any of the above conditions are true, the queen can be captured in one move</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Second condition: checking if the bishop can capture the queen in one move</span>
        <span class="k">if</span><span class="o">(</span>
            <span class="c1">// Bishop and queen are on the same diagonal</span>
                <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="o">))</span> <span class="o">&amp;&amp;</span>
                        <span class="o">(</span>
                                <span class="c1">// Two additional conditions to ensure the rook doesn't block the capture:</span>
                                <span class="c1">// 1. Rook is not on the same diagonal line, or</span>
                                <span class="c1">// 2. Rook is completely outside the diagonal line between bishop and queen</span>
                                <span class="o">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">f</span><span class="o">)</span> <span class="o">!=</span> <span class="o">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="o">))</span> <span class="o">||</span>
                                        <span class="n">a</span> <span class="o">&lt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">||</span>
                                        <span class="n">a</span> <span class="o">&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
                        <span class="o">)</span>
        <span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the conditions are true, the queen can be captured in one move</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Rook is in the same column as the queen</span>
        <span class="c1">// Rook at (1,1), Bishop at (2,2), Queen at (1,3)</span>
        <span class="c1">// Verifies if the rook can capture the queen in 1 move, avoiding the bishop</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 1: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Rook is in the same row as the queen</span>
        <span class="c1">// Rook at (1,1), Bishop at (2,2), Queen at (3,1)</span>
        <span class="c1">// Checks if the rook can capture the queen in 1 move, with no bishop interference</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 2: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 3: Rook and bishop are on the diagonal with the queen</span>
        <span class="c1">// Rook at (2,2), Bishop at (1,1), Queen at (3,3)</span>
        <span class="c1">// Demonstrates a scenario requiring 2 moves to capture the queen</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 3: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 4: Bishop is on the diagonal, rook can capture from outside</span>
        <span class="c1">// Rook at (1,1), Bishop at (3,3), Queen at (5,5)</span>
        <span class="c1">// Shows a scenario where the rook can capture in 1 move</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 4: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 5: Another scenario with diagonal positioning</span>
        <span class="c1">// Rook at (4,2), Bishop at (6,4), Queen at (7,5)</span>
        <span class="c1">// Demonstrates another case of 1-move capture</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 5: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[There is a 1-indexed 8 x 8 chessboard containing 3 pieces. You are given 6 integers a, b, c, d, e, and f where: (a, b) denotes the position of the white rook. (c, d) denotes the position of the white bishop. (e, f) denotes the position of the black queen. Given that you can only move the white pieces, return the minimum number of moves required to capture the black queen. Note that: Rooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces. Bishops can move any number of squares diagonally, but cannot jump over other pieces. A rook or a bishop can capture the queen if it is located in a square that they can move to. The queen does not move.]]></summary></entry><entry><title type="html">766. Toeplitz Matrix</title><link href="https://zhengstar94.github.io//blog/2024/ToeplitzMatrix/" rel="alternate" type="text/html" title="766. Toeplitz Matrix"/><published>2024-12-04T00:00:00+00:00</published><updated>2024-12-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ToeplitzMatrix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ToeplitzMatrix/"><![CDATA[<ul> <li>Given an <code class="language-plaintext highlighter-rouge">m x n</code> <code class="language-plaintext highlighter-rouge">matrix</code>, return <em><code class="language-plaintext highlighter-rouge">true</code> if the matrix is Toeplitz. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</em></li> <li>A matrix is <strong>Toeplitz</strong> if every diagonal from top-left to bottom-right has the same elements.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
Output: true
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
In each diagonal all elements are the same, so the answer is True.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [[1,2],[2,2]]
Output: false
Explanation:
The diagonal "[1, 2]" has different elements.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ToeplitzMatrix</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isToeplitzMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Iterate through rows starting from the second row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Iterate through columns starting from the second column</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Check if current element is equal to its top-left diagonal predecessor</span>
                <span class="c1">// If not equal, the matrix is not a Toeplitz matrix</span>
                <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If all elements pass the diagonal consistency check</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: A valid Toeplitz matrix</span>
        <span class="c1">// In this matrix, each descending diagonal contains identical elements</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 is a Toeplitz matrix: "</span> <span class="o">+</span> <span class="n">isToeplitzMatrix</span><span class="o">(</span><span class="n">matrix1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: A non-Toeplitz matrix</span>
        <span class="c1">// This matrix does not satisfy the Toeplitz matrix condition</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 is a Toeplitz matrix: "</span> <span class="o">+</span> <span class="n">isToeplitzMatrix</span><span class="o">(</span><span class="n">matrix2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.]]></summary></entry><entry><title type="html">224. Basic Calculator</title><link href="https://zhengstar94.github.io//blog/2024/BasicCalculator/" rel="alternate" type="text/html" title="224. Basic Calculator"/><published>2024-12-03T00:00:00+00:00</published><updated>2024-12-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/BasicCalculator</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/BasicCalculator/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</li> <li><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code class="language-plaintext highlighter-rouge">eval()</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1 + 1"
Output: 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " 2-1 + 2 "
Output: 3
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BasicCalculator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculate</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Stack to store intermediate results and signs for nested expressions</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Current number being parsed from the input string</span>
        <span class="kt">int</span> <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Running total of the calculation</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Sign of the current number (1 for positive, -1 for negative)</span>
        <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="c1">// Digit Handling: Build multi-digit numbers</span>
            <span class="c1">// If the character is a digit, update currentNum</span>
            <span class="c1">// Explanation:</span>
            <span class="c1">// - 10 * currentNum shifts existing digits left</span>
            <span class="c1">// - (ch - '0') converts char digit to its integer value</span>
            <span class="c1">// Example:</span>
            <span class="c1">//   If currentNum is 12 and ch is '3'</span>
            <span class="c1">//   12 * 10 = 120</span>
            <span class="c1">//   '3' - '0' = 3</span>
            <span class="c1">//   Result: 123</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">currentNum</span> <span class="o">+</span> <span class="o">(</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Positive Sign '+' Handling</span>
            <span class="c1">// When '+' is encountered:</span>
            <span class="c1">// 1. Add current number to result with its sign</span>
            <span class="c1">// 2. Reset currentNum for next number</span>
            <span class="c1">// 3. Set sign to positive (1)</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'+'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Negative Sign '-' Handling</span>
            <span class="c1">// When '-' is encountered:</span>
            <span class="c1">// 1. Add current number to result with its sign</span>
            <span class="c1">// 2. Reset currentNum for next number</span>
            <span class="c1">// 3. Set sign to negative (-1)</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Opening Parenthesis '(' Handling</span>
            <span class="c1">// When '(' is encountered:</span>
            <span class="c1">// 1. Push current result to stack (to be restored later)</span>
            <span class="c1">// 2. Push current sign to stack</span>
            <span class="c1">// 3. Reset result and sign for nested expression</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>    <span class="c1">// Store previous result</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">sign</span><span class="o">);</span>      <span class="c1">// Store previous sign</span>

                <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// Reset for nested calculation</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// Reset sign to positive</span>
            <span class="o">}</span>

            <span class="c1">// Closing Parenthesis ')' Handling</span>
            <span class="c1">// When ')' is encountered:</span>
            <span class="c1">// 1. Add current number to result with its sign</span>
            <span class="c1">// 2. Reset currentNum</span>
            <span class="c1">// 3. Multiply result by previous sign from stack</span>
            <span class="c1">// 4. Add previous result from stack</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                <span class="c1">// Restore previous sign and multiply current result</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="c1">// Add back the previous result from before the parenthesis</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Handle the last number if it exists</span>
        <span class="c1">// This is necessary because the last number might not be followed by an operator</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentNum</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Cases demonstrating various scenarios</span>
        <span class="c1">// Test Case 1: Simple addition and subtraction</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"1+2-3"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test1: "</span> <span class="o">+</span> <span class="n">test1</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expression with simple parentheses</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"1+(2-3)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test2: "</span> <span class="o">+</span> <span class="n">test2</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expression with nested parentheses</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"1+(2- (3 - 4) + 1)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test3: "</span> <span class="o">+</span> <span class="n">test3</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Complex parentheses nesting</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"2-(5-6)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test4: "</span> <span class="o">+</span> <span class="n">test4</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Negative number scenario</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"-(3-1)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test5: "</span> <span class="o">+</span> <span class="n">test5</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Hard"/><summary type="html"><![CDATA[Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().]]></summary></entry><entry><title type="html">3274. Check if Two Chessboard Squares Have the Same Color</title><link href="https://zhengstar94.github.io//blog/2024/CheckSameColor/" rel="alternate" type="text/html" title="3274. Check if Two Chessboard Squares Have the Same Color"/><published>2024-12-03T00:00:00+00:00</published><updated>2024-12-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CheckSameColor</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CheckSameColor/"><![CDATA[<ul> <li>You are given two strings, <code class="language-plaintext highlighter-rouge">coordinate1</code> and <code class="language-plaintext highlighter-rouge">coordinate2</code>, representing the coordinates of a square on an <code class="language-plaintext highlighter-rouge">8 x 8</code> chessboard.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if these two squares have the same color and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li> <li>The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coordinate1 = "a1", coordinate2 = "c3"
Output: true
Explanation:
Both squares are black.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coordinate1 = "a1", coordinate2 = "h3"
Output: false
Explanation:
Square "a1" is black and "h3" is white.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckSameColor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkTwoChessboards</span><span class="o">(</span><span class="nc">String</span> <span class="n">coordinate1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">coordinate2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert the first character (column) to numeric index</span>
        <span class="c1">// 'a' becomes 1, 'b' becomes 2, etc.</span>
        <span class="kt">int</span> <span class="n">col1</span> <span class="o">=</span> <span class="n">coordinate1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Convert the second character (row) to numeric index</span>
        <span class="c1">// '1' becomes 1, '2' becomes 2, etc.</span>
        <span class="kt">int</span> <span class="n">row1</span> <span class="o">=</span> <span class="n">coordinate1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>

        <span class="c1">// Repeat the same for the second coordinate</span>
        <span class="kt">int</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">coordinate2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">row2</span> <span class="o">=</span> <span class="n">coordinate2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>

        <span class="c1">// Core color determination logic:</span>
        <span class="c1">// 1. Sum the row and column indexes of both squares</span>
        <span class="c1">// 2. Check if the total sum is even or odd</span>
        <span class="c1">// 3. Even sum means both squares are the same color (black)</span>
        <span class="c1">// 4. Odd sum means the squares have different colors</span>
        <span class="c1">//</span>
        <span class="c1">// Mathematical explanation:</span>
        <span class="c1">// - In a chessboard, square color depends on row + column sum</span>
        <span class="c1">// - If row + column is even, the square is black</span>
        <span class="c1">// - If row + column is odd, the square is white</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">row1</span> <span class="o">+</span> <span class="n">col1</span> <span class="o">+</span> <span class="n">row2</span> <span class="o">+</span> <span class="n">col2</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Same color squares (both black)</span>
        <span class="nc">String</span> <span class="n">coordinate1</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate2</span> <span class="o">=</span> <span class="s">"c3"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate1</span><span class="o">,</span> <span class="n">coordinate2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate1</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate2</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test case 2: Different color squares</span>
        <span class="nc">String</span> <span class="n">coordinate3</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate4</span> <span class="o">=</span> <span class="s">"h3"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate3</span><span class="o">,</span> <span class="n">coordinate4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate3</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate4</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test case 3: Border test - first row and last column</span>
        <span class="nc">String</span> <span class="n">coordinate5</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate6</span> <span class="o">=</span> <span class="s">"h1"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate5</span><span class="o">,</span> <span class="n">coordinate6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate5</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate6</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>

        <span class="c1">// Test case 4: Middle area test</span>
        <span class="nc">String</span> <span class="n">coordinate7</span> <span class="o">=</span> <span class="s">"d4"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate8</span> <span class="o">=</span> <span class="s">"e5"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate7</span><span class="o">,</span> <span class="n">coordinate8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate7</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate8</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard. Return true if these two squares have the same color and false otherwise. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).]]></summary></entry><entry><title type="html">636. Exclusive Time of Functions</title><link href="https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions/" rel="alternate" type="text/html" title="636. Exclusive Time of Functions"/><published>2024-12-02T00:00:00+00:00</published><updated>2024-12-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions/"><![CDATA[<ul> <li>On a <strong>single-threaded</strong> CPU, we execute a program containing <code class="language-plaintext highlighter-rouge">n</code> functions. Each function has a unique ID between <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">n-1</code>.</li> <li>Function calls are <strong>stored in a <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a></strong>: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is <strong>the current function being executed</strong>. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.</li> <li>You are given a list <code class="language-plaintext highlighter-rouge">logs</code>, where <code class="language-plaintext highlighter-rouge">logs[i]</code> represents the <code class="language-plaintext highlighter-rouge">ith</code> log message formatted as a string <code class="language-plaintext highlighter-rouge">"{function_id}:{"start" | "end"}:{timestamp}"</code>. For example, <code class="language-plaintext highlighter-rouge">"0:start:3"</code> means a function call with function ID <code class="language-plaintext highlighter-rouge">0</code> <strong>started at the beginning</strong> of timestamp <code class="language-plaintext highlighter-rouge">3</code>, and <code class="language-plaintext highlighter-rouge">"1:end:2"</code> means a function call with function ID <code class="language-plaintext highlighter-rouge">1</code> <strong>ended at the end</strong> of timestamp <code class="language-plaintext highlighter-rouge">2</code>. Note that a function can be called <strong>multiple times, possibly recursively</strong>.</li> <li>A function’s <strong>exclusive time</strong> is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for <code class="language-plaintext highlighter-rouge">2</code> time units and another call executing for <code class="language-plaintext highlighter-rouge">1</code> time unit, the <strong>exclusive time</strong> is <code class="language-plaintext highlighter-rouge">2 + 1 = 3</code>.</li> <li>Return <em>the <strong>exclusive time</strong> of each function in an array, where the value at the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>index represents the exclusive time for the function with ID</em> <code class="language-plaintext highlighter-rouge">i</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3,4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
Output: [8]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls itself again.
Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.
Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.
So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
Output: [7,1]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls function 1.
Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.
Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.
So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(L) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExclusiveTimeOfFunctions</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">exclusiveTime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">// Initialize the result array to store the exclusive time for each function</span>

        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span> <span class="c1">// Stack to simulate the call stack of functions</span>

        <span class="kt">int</span> <span class="n">prevTime</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Variable to keep track of the previous timestamp for calculating time intervals</span>

        <span class="c1">// Loop through each log entry</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">log</span> <span class="o">:</span> <span class="n">logs</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">);</span> <span class="c1">// Split each log entry into parts</span>
            <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// Get the function ID from the log entry</span>
            <span class="nc">String</span> <span class="n">type</span> <span class="o">=</span> <span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// Get the type of the log (either "start" or "end")</span>
            <span class="kt">int</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span> <span class="c1">// Get the timestamp from the log entry</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"start"</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// If the log indicates the start of a function</span>
                <span class="c1">// Before pushing the new function onto the stack, update the execution time of the function currently at the top of the stack</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">+=</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="n">prevTime</span><span class="o">;</span> <span class="c1">// Update the exclusive time of the function currently on top of the stack</span>
                <span class="o">}</span>

                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">id</span><span class="o">);</span> <span class="c1">// Push the current function's ID onto the stack (this function is now running)</span>
                <span class="n">prevTime</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">;</span> <span class="c1">// Update prevTime to the current timestamp, as we now know when the function started</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// If the log indicates the end of a function</span>
                <span class="c1">// Pop the current function from the stack (this function has finished execution)</span>
                <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()]</span> <span class="o">+=</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="n">prevTime</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Calculate the exclusive time of the function that has finished and update the result array</span>
                <span class="n">prevTime</span> <span class="o">=</span> <span class="n">timestamp</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Update prevTime to the next timestamp after the current function ends, for the next operation</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="c1">// Return the result array, containing the exclusive times for all functions</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> 
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"1:start:2"</span><span class="o">,</span><span class="s">"1:end:5"</span><span class="o">,</span><span class="s">"0:end:6"</span><span class="o">);</span>
        <span class="c1">// Function 0 runs for 3 units of time (from 0 to 1 and from 6 to 7), and function 1 runs for 4 units of time (from 2 to 5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">logs1</span><span class="o">)));</span> <span class="c1">// Output: [3, 4]</span>

        <span class="c1">// Example 2:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"0:start:2"</span><span class="o">,</span><span class="s">"0:end:5"</span><span class="o">,</span><span class="s">"0:start:6"</span><span class="o">,</span><span class="s">"0:end:6"</span><span class="o">,</span><span class="s">"0:end:7"</span><span class="o">);</span>
        <span class="c1">// Function 0 is recursively called. It runs for 2 units of time, then calls itself, runs for 4 units, and then continues</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">logs2</span><span class="o">)));</span> <span class="c1">// Output: [8]</span>

        <span class="c1">// Example 3:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs3</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"0:start:2"</span><span class="o">,</span><span class="s">"0:end:5"</span><span class="o">,</span><span class="s">"1:start:6"</span><span class="o">,</span><span class="s">"1:end:6"</span><span class="o">,</span><span class="s">"0:end:7"</span><span class="o">);</span>
        <span class="c1">// Function 0 runs for 7 units of time (from 0 to 5, then from 6 to 7), and function 1 runs for 1 unit of time (from 6 to 6)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">logs3</span><span class="o">)));</span> <span class="c1">// Output: [7, 1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1. Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list logs, where logs[i] represents the ith log message formatted as a string "{function_id}:{"start" | "end"}:{timestamp}". For example, "0:start:3" means a function call with function ID 0 started at the beginning of timestamp 3, and "1:end:2" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively. A function’s exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1=3. Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.]]></summary></entry></feed>