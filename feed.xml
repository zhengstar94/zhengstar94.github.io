<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-05T04:51:28+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2022. Convert 1D Array Into 2D Array</title><link href="https://zhengstar94.github.io//blog/2024/Convert1DArrayInto2DArray/" rel="alternate" type="text/html" title="2022. Convert 1D Array Into 2D Array"/><published>2024-12-05T00:00:00+00:00</published><updated>2024-12-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/Convert1DArrayInto2DArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/Convert1DArrayInto2DArray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 1-dimensional (1D) integer array <code class="language-plaintext highlighter-rouge">original</code>, and two integers, <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code>. You are tasked with creating a 2-dimensional (2D) array with ` m<code class="language-plaintext highlighter-rouge"> rows and </code>n<code class="language-plaintext highlighter-rouge"> columns using **all** the elements from </code>original`.</li> <li>The elements from indices <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n - 1</code> (<strong>inclusive</strong>) of <code class="language-plaintext highlighter-rouge">original</code> should form the first row of the constructed 2D array, the elements from indices <code class="language-plaintext highlighter-rouge">n</code> to <code class="language-plaintext highlighter-rouge">2 * n - 1</code> (<strong>inclusive</strong>) should form the second row of the constructed 2D array, and so on.</li> <li>Return <em>an</em> <code class="language-plaintext highlighter-rouge">m x n</code> <em>2D array constructed according to the above procedure, or an empty 2D array if it is impossible</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: original = [1,2,3,4], m = 2, n = 2
Output: [[1,2],[3,4]]
Explanation: The constructed 2D array should contain 2 rows and 2 columns.
The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: original = [1,2,3], m = 1, n = 3
Output: [[1,2,3]]
Explanation: The constructed 2D array should contain 1 row and 3 columns.
Put all three elements in original into the first row of the constructed 2D array.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: original = [1,2], m = 1, n = 1
Output: []
Explanation: There are 2 elements in original.
It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Convert1DArrayInto2DArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">construct2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">original</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check if the size of the original array matches the required dimensions.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Return an empty 2D array if the dimensions do not match.</span>
        <span class="o">}</span>

        <span class="c1">// Initialize a 2D array with m rows and n columns.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Fill the 2D array using elements from the original 1D array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// Loop through each row.</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// Loop through each column.</span>
                <span class="c1">// Map the 1D array index to the 2D array:</span>
                <span class="c1">// - i * n calculates the starting index for the current row in the 1D array.</span>
                <span class="c1">// - j adds the column offset within the current row.</span>
                <span class="c1">// Example: For i = 1 (2nd row) and n = 3 (3 columns), the row starts at index 3 in the 1D array.</span>
                <span class="c1">// Adding j = 0, 1, 2 fills the 2nd row of the 2D array.</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">original</span><span class="o">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> <span class="c1">// Return the constructed 2D array.</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Valid input with 2 rows and 3 columns.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original1</span><span class="o">,</span> <span class="n">m1</span><span class="o">,</span> <span class="n">n1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Invalid input where the size does not match m * n.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original2</span><span class="o">,</span> <span class="n">m2</span><span class="o">,</span> <span class="n">n2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Edge case with 1 row and 4 columns.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original3</span><span class="o">,</span> <span class="n">m3</span><span class="o">,</span> <span class="n">n3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Edge case with 4 rows and 1 column.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m4</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="n">n4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original4</span><span class="o">,</span> <span class="n">m4</span><span class="o">,</span> <span class="n">n4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Empty input.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original5</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span> <span class="n">m5</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n5</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">construct2DArray</span><span class="o">(</span><span class="n">original5</span><span class="o">,</span> <span class="n">m5</span><span class="o">,</span> <span class="n">n5</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Check if the array is empty.</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[]"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Iterate through each row and print it.</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with ` m rows and n columns using **all** the elements from original`. The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on. Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.]]></summary></entry><entry><title type="html">3001. Minimum Moves to Capture The Queen</title><link href="https://zhengstar94.github.io//blog/2024/MinimumMovesToCaptureTheQueen/" rel="alternate" type="text/html" title="3001. Minimum Moves to Capture The Queen"/><published>2024-12-05T00:00:00+00:00</published><updated>2024-12-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MinimumMovesToCaptureTheQueen</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MinimumMovesToCaptureTheQueen/"><![CDATA[<ul> <li>There is a <strong>1-indexed</strong> <code class="language-plaintext highlighter-rouge">8 x 8</code> chessboard containing <code class="language-plaintext highlighter-rouge">3</code> pieces.</li> <li>You are given <code class="language-plaintext highlighter-rouge">6</code> integers <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">e</code>, and <code class="language-plaintext highlighter-rouge">f</code> where: <ul> <li><code class="language-plaintext highlighter-rouge">(a, b)</code> denotes the position of the white rook.</li> <li><code class="language-plaintext highlighter-rouge">(c, d)</code> denotes the position of the white bishop.</li> <li><code class="language-plaintext highlighter-rouge">(e, f)</code> denotes the position of the black queen.</li> </ul> </li> <li>Given that you can only move the white pieces, return <em>the <strong>minimum</strong> number of moves required to capture the black queen</em>.</li> <li><strong>Note</strong> that: <ul> <li>Rooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.</li> <li>Bishops can move any number of squares diagonally, but cannot jump over other pieces.</li> <li>A rook or a bishop can capture the queen if it is located in a square that they can move to.</li> <li>The queen does not move.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = 1, b = 1, c = 8, d = 8, e = 2, f = 3
Output: 2
Explanation: We can capture the black queen in two moves by moving the white rook to (1, 3) then to (2, 3).
It is impossible to capture the black queen in less than two moves since it is not being attacked by any of the pieces at the beginning.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = 5, b = 3, c = 3, d = 4, e = 5, f = 2
Output: 1
Explanation: We can capture the black queen in a single move by doing one of the following: 
- Move the white rook to (5, 2).
- Move the white bishop to (5, 2).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumMovesToCaptureTheQueen</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="kt">int</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span>
            <span class="c1">// Rook is in the same column as the queen</span>
                <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">e</span> <span class="o">&amp;&amp;</span>
                        <span class="c1">// Two possible scenarios:</span>
                        <span class="c1">// 1. Rook and bishop are not in the same column, or</span>
                        <span class="c1">// 2. Bishop is positioned in a way that doesn't block the capture path</span>
                        <span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">c</span> <span class="o">||</span> <span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">b</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="o">)</span> <span class="o">||</span>
                        <span class="c1">// Alternative scenario: rook is in the same row as the queen</span>
                        <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">f</span> <span class="o">&amp;&amp;</span>
                                <span class="c1">// Two possible scenarios:</span>
                                <span class="c1">// 1. Rook and bishop are not in the same row, or</span>
                                <span class="c1">// 2. Bishop is positioned in a way that doesn't block the capture path</span>
                                <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">d</span> <span class="o">||</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                        <span class="o">)</span>
        <span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If any of the above conditions are true, the queen can be captured in one move</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Second condition: checking if the bishop can capture the queen in one move</span>
        <span class="k">if</span><span class="o">(</span>
            <span class="c1">// Bishop and queen are on the same diagonal</span>
                <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="o">))</span> <span class="o">&amp;&amp;</span>
                        <span class="o">(</span>
                                <span class="c1">// Two additional conditions to ensure the rook doesn't block the capture:</span>
                                <span class="c1">// 1. Rook is not on the same diagonal line, or</span>
                                <span class="c1">// 2. Rook is completely outside the diagonal line between bishop and queen</span>
                                <span class="o">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">f</span><span class="o">)</span> <span class="o">!=</span> <span class="o">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">e</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="o">))</span> <span class="o">||</span>
                                        <span class="n">a</span> <span class="o">&lt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">||</span>
                                        <span class="n">a</span> <span class="o">&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
                        <span class="o">)</span>
        <span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the conditions are true, the queen can be captured in one move</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Rook is in the same column as the queen</span>
        <span class="c1">// Rook at (1,1), Bishop at (2,2), Queen at (1,3)</span>
        <span class="c1">// Verifies if the rook can capture the queen in 1 move, avoiding the bishop</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 1: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Rook is in the same row as the queen</span>
        <span class="c1">// Rook at (1,1), Bishop at (2,2), Queen at (3,1)</span>
        <span class="c1">// Checks if the rook can capture the queen in 1 move, with no bishop interference</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 2: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 3: Rook and bishop are on the diagonal with the queen</span>
        <span class="c1">// Rook at (2,2), Bishop at (1,1), Queen at (3,3)</span>
        <span class="c1">// Demonstrates a scenario requiring 2 moves to capture the queen</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 3: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 4: Bishop is on the diagonal, rook can capture from outside</span>
        <span class="c1">// Rook at (1,1), Bishop at (3,3), Queen at (5,5)</span>
        <span class="c1">// Shows a scenario where the rook can capture in 1 move</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 4: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>

        <span class="c1">// Test Case 5: Another scenario with diagonal positioning</span>
        <span class="c1">// Rook at (4,2), Bishop at (6,4), Queen at (7,5)</span>
        <span class="c1">// Demonstrates another case of 1-move capture</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 5: "</span> <span class="o">+</span> <span class="n">minMovesToCaptureTheQueen</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="o">+</span> <span class="s">" moves"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[There is a 1-indexed 8 x 8 chessboard containing 3 pieces. You are given 6 integers a, b, c, d, e, and f where: (a, b) denotes the position of the white rook. (c, d) denotes the position of the white bishop. (e, f) denotes the position of the black queen. Given that you can only move the white pieces, return the minimum number of moves required to capture the black queen. Note that: Rooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces. Bishops can move any number of squares diagonally, but cannot jump over other pieces. A rook or a bishop can capture the queen if it is located in a square that they can move to. The queen does not move.]]></summary></entry><entry><title type="html">766. Toeplitz Matrix</title><link href="https://zhengstar94.github.io//blog/2024/ToeplitzMatrix/" rel="alternate" type="text/html" title="766. Toeplitz Matrix"/><published>2024-12-04T00:00:00+00:00</published><updated>2024-12-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ToeplitzMatrix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ToeplitzMatrix/"><![CDATA[<ul> <li>Given an <code class="language-plaintext highlighter-rouge">m x n</code> <code class="language-plaintext highlighter-rouge">matrix</code>, return <em><code class="language-plaintext highlighter-rouge">true</code> if the matrix is Toeplitz. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</em></li> <li>A matrix is <strong>Toeplitz</strong> if every diagonal from top-left to bottom-right has the same elements.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
Output: true
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
In each diagonal all elements are the same, so the answer is True.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [[1,2],[2,2]]
Output: false
Explanation:
The diagonal "[1, 2]" has different elements.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ToeplitzMatrix</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isToeplitzMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Iterate through rows starting from the second row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Iterate through columns starting from the second column</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Check if current element is equal to its top-left diagonal predecessor</span>
                <span class="c1">// If not equal, the matrix is not a Toeplitz matrix</span>
                <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If all elements pass the diagonal consistency check</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: A valid Toeplitz matrix</span>
        <span class="c1">// In this matrix, each descending diagonal contains identical elements</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 is a Toeplitz matrix: "</span> <span class="o">+</span> <span class="n">isToeplitzMatrix</span><span class="o">(</span><span class="n">matrix1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: A non-Toeplitz matrix</span>
        <span class="c1">// This matrix does not satisfy the Toeplitz matrix condition</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 is a Toeplitz matrix: "</span> <span class="o">+</span> <span class="n">isToeplitzMatrix</span><span class="o">(</span><span class="n">matrix2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.]]></summary></entry><entry><title type="html">224. Basic Calculator</title><link href="https://zhengstar94.github.io//blog/2024/BasicCalculator/" rel="alternate" type="text/html" title="224. Basic Calculator"/><published>2024-12-03T00:00:00+00:00</published><updated>2024-12-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/BasicCalculator</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/BasicCalculator/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</li> <li><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code class="language-plaintext highlighter-rouge">eval()</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1 + 1"
Output: 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " 2-1 + 2 "
Output: 3
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BasicCalculator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculate</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Stack to store intermediate results and signs for nested expressions</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Current number being parsed from the input string</span>
        <span class="kt">int</span> <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Running total of the calculation</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Sign of the current number (1 for positive, -1 for negative)</span>
        <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="c1">// Digit Handling: Build multi-digit numbers</span>
            <span class="c1">// If the character is a digit, update currentNum</span>
            <span class="c1">// Explanation:</span>
            <span class="c1">// - 10 * currentNum shifts existing digits left</span>
            <span class="c1">// - (ch - '0') converts char digit to its integer value</span>
            <span class="c1">// Example:</span>
            <span class="c1">//   If currentNum is 12 and ch is '3'</span>
            <span class="c1">//   12 * 10 = 120</span>
            <span class="c1">//   '3' - '0' = 3</span>
            <span class="c1">//   Result: 123</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">currentNum</span> <span class="o">+</span> <span class="o">(</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Positive Sign '+' Handling</span>
            <span class="c1">// When '+' is encountered:</span>
            <span class="c1">// 1. Add current number to result with its sign</span>
            <span class="c1">// 2. Reset currentNum for next number</span>
            <span class="c1">// 3. Set sign to positive (1)</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'+'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Negative Sign '-' Handling</span>
            <span class="c1">// When '-' is encountered:</span>
            <span class="c1">// 1. Add current number to result with its sign</span>
            <span class="c1">// 2. Reset currentNum for next number</span>
            <span class="c1">// 3. Set sign to negative (-1)</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Opening Parenthesis '(' Handling</span>
            <span class="c1">// When '(' is encountered:</span>
            <span class="c1">// 1. Push current result to stack (to be restored later)</span>
            <span class="c1">// 2. Push current sign to stack</span>
            <span class="c1">// 3. Reset result and sign for nested expression</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>    <span class="c1">// Store previous result</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">sign</span><span class="o">);</span>      <span class="c1">// Store previous sign</span>

                <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// Reset for nested calculation</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// Reset sign to positive</span>
            <span class="o">}</span>

            <span class="c1">// Closing Parenthesis ')' Handling</span>
            <span class="c1">// When ')' is encountered:</span>
            <span class="c1">// 1. Add current number to result with its sign</span>
            <span class="c1">// 2. Reset currentNum</span>
            <span class="c1">// 3. Multiply result by previous sign from stack</span>
            <span class="c1">// 4. Add previous result from stack</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
                <span class="n">currentNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                <span class="c1">// Restore previous sign and multiply current result</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="c1">// Add back the previous result from before the parenthesis</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Handle the last number if it exists</span>
        <span class="c1">// This is necessary because the last number might not be followed by an operator</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentNum</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">currentNum</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Cases demonstrating various scenarios</span>
        <span class="c1">// Test Case 1: Simple addition and subtraction</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"1+2-3"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test1: "</span> <span class="o">+</span> <span class="n">test1</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expression with simple parentheses</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"1+(2-3)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test2: "</span> <span class="o">+</span> <span class="n">test2</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expression with nested parentheses</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"1+(2- (3 - 4) + 1)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test3: "</span> <span class="o">+</span> <span class="n">test3</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Complex parentheses nesting</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"2-(5-6)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test4: "</span> <span class="o">+</span> <span class="n">test4</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Negative number scenario</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"-(3-1)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test5: "</span> <span class="o">+</span> <span class="n">test5</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Hard"/><summary type="html"><![CDATA[Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().]]></summary></entry><entry><title type="html">3274. Check if Two Chessboard Squares Have the Same Color</title><link href="https://zhengstar94.github.io//blog/2024/CheckSameColor/" rel="alternate" type="text/html" title="3274. Check if Two Chessboard Squares Have the Same Color"/><published>2024-12-03T00:00:00+00:00</published><updated>2024-12-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CheckSameColor</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CheckSameColor/"><![CDATA[<ul> <li>You are given two strings, <code class="language-plaintext highlighter-rouge">coordinate1</code> and <code class="language-plaintext highlighter-rouge">coordinate2</code>, representing the coordinates of a square on an <code class="language-plaintext highlighter-rouge">8 x 8</code> chessboard.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if these two squares have the same color and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li> <li>The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coordinate1 = "a1", coordinate2 = "c3"
Output: true
Explanation:
Both squares are black.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coordinate1 = "a1", coordinate2 = "h3"
Output: false
Explanation:
Square "a1" is black and "h3" is white.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckSameColor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkTwoChessboards</span><span class="o">(</span><span class="nc">String</span> <span class="n">coordinate1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">coordinate2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert the first character (column) to numeric index</span>
        <span class="c1">// 'a' becomes 1, 'b' becomes 2, etc.</span>
        <span class="kt">int</span> <span class="n">col1</span> <span class="o">=</span> <span class="n">coordinate1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Convert the second character (row) to numeric index</span>
        <span class="c1">// '1' becomes 1, '2' becomes 2, etc.</span>
        <span class="kt">int</span> <span class="n">row1</span> <span class="o">=</span> <span class="n">coordinate1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>

        <span class="c1">// Repeat the same for the second coordinate</span>
        <span class="kt">int</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">coordinate2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">row2</span> <span class="o">=</span> <span class="n">coordinate2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>

        <span class="c1">// Core color determination logic:</span>
        <span class="c1">// 1. Sum the row and column indexes of both squares</span>
        <span class="c1">// 2. Check if the total sum is even or odd</span>
        <span class="c1">// 3. Even sum means both squares are the same color (black)</span>
        <span class="c1">// 4. Odd sum means the squares have different colors</span>
        <span class="c1">//</span>
        <span class="c1">// Mathematical explanation:</span>
        <span class="c1">// - In a chessboard, square color depends on row + column sum</span>
        <span class="c1">// - If row + column is even, the square is black</span>
        <span class="c1">// - If row + column is odd, the square is white</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">row1</span> <span class="o">+</span> <span class="n">col1</span> <span class="o">+</span> <span class="n">row2</span> <span class="o">+</span> <span class="n">col2</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Same color squares (both black)</span>
        <span class="nc">String</span> <span class="n">coordinate1</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate2</span> <span class="o">=</span> <span class="s">"c3"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate1</span><span class="o">,</span> <span class="n">coordinate2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate1</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate2</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test case 2: Different color squares</span>
        <span class="nc">String</span> <span class="n">coordinate3</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate4</span> <span class="o">=</span> <span class="s">"h3"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate3</span><span class="o">,</span> <span class="n">coordinate4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate3</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate4</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test case 3: Border test - first row and last column</span>
        <span class="nc">String</span> <span class="n">coordinate5</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate6</span> <span class="o">=</span> <span class="s">"h1"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate5</span><span class="o">,</span> <span class="n">coordinate6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate5</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate6</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>

        <span class="c1">// Test case 4: Middle area test</span>
        <span class="nc">String</span> <span class="n">coordinate7</span> <span class="o">=</span> <span class="s">"d4"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate8</span> <span class="o">=</span> <span class="s">"e5"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate7</span><span class="o">,</span> <span class="n">coordinate8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate7</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate8</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard. Return true if these two squares have the same color and false otherwise. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).]]></summary></entry><entry><title type="html">636. Exclusive Time of Functions</title><link href="https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions/" rel="alternate" type="text/html" title="636. Exclusive Time of Functions"/><published>2024-12-02T00:00:00+00:00</published><updated>2024-12-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions/"><![CDATA[<ul> <li>On a <strong>single-threaded</strong> CPU, we execute a program containing <code class="language-plaintext highlighter-rouge">n</code> functions. Each function has a unique ID between <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">n-1</code>.</li> <li>Function calls are <strong>stored in a <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a></strong>: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is <strong>the current function being executed</strong>. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.</li> <li>You are given a list <code class="language-plaintext highlighter-rouge">logs</code>, where <code class="language-plaintext highlighter-rouge">logs[i]</code> represents the <code class="language-plaintext highlighter-rouge">ith</code> log message formatted as a string <code class="language-plaintext highlighter-rouge">"{function_id}:{"start" | "end"}:{timestamp}"</code>. For example, <code class="language-plaintext highlighter-rouge">"0:start:3"</code> means a function call with function ID <code class="language-plaintext highlighter-rouge">0</code> <strong>started at the beginning</strong> of timestamp <code class="language-plaintext highlighter-rouge">3</code>, and <code class="language-plaintext highlighter-rouge">"1:end:2"</code> means a function call with function ID <code class="language-plaintext highlighter-rouge">1</code> <strong>ended at the end</strong> of timestamp <code class="language-plaintext highlighter-rouge">2</code>. Note that a function can be called <strong>multiple times, possibly recursively</strong>.</li> <li>A function’s <strong>exclusive time</strong> is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for <code class="language-plaintext highlighter-rouge">2</code> time units and another call executing for <code class="language-plaintext highlighter-rouge">1</code> time unit, the <strong>exclusive time</strong> is <code class="language-plaintext highlighter-rouge">2 + 1 = 3</code>.</li> <li>Return <em>the <strong>exclusive time</strong> of each function in an array, where the value at the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>index represents the exclusive time for the function with ID</em> <code class="language-plaintext highlighter-rouge">i</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3,4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
Output: [8]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls itself again.
Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.
Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.
So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
Output: [7,1]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls function 1.
Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.
Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.
So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(L) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExclusiveTimeOfFunctions</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">exclusiveTime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">// Initialize the result array to store the exclusive time for each function</span>

        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span> <span class="c1">// Stack to simulate the call stack of functions</span>

        <span class="kt">int</span> <span class="n">prevTime</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Variable to keep track of the previous timestamp for calculating time intervals</span>

        <span class="c1">// Loop through each log entry</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">log</span> <span class="o">:</span> <span class="n">logs</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">);</span> <span class="c1">// Split each log entry into parts</span>
            <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// Get the function ID from the log entry</span>
            <span class="nc">String</span> <span class="n">type</span> <span class="o">=</span> <span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// Get the type of the log (either "start" or "end")</span>
            <span class="kt">int</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span> <span class="c1">// Get the timestamp from the log entry</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"start"</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// If the log indicates the start of a function</span>
                <span class="c1">// Before pushing the new function onto the stack, update the execution time of the function currently at the top of the stack</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">+=</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="n">prevTime</span><span class="o">;</span> <span class="c1">// Update the exclusive time of the function currently on top of the stack</span>
                <span class="o">}</span>

                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">id</span><span class="o">);</span> <span class="c1">// Push the current function's ID onto the stack (this function is now running)</span>
                <span class="n">prevTime</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">;</span> <span class="c1">// Update prevTime to the current timestamp, as we now know when the function started</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// If the log indicates the end of a function</span>
                <span class="c1">// Pop the current function from the stack (this function has finished execution)</span>
                <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()]</span> <span class="o">+=</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="n">prevTime</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Calculate the exclusive time of the function that has finished and update the result array</span>
                <span class="n">prevTime</span> <span class="o">=</span> <span class="n">timestamp</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Update prevTime to the next timestamp after the current function ends, for the next operation</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="c1">// Return the result array, containing the exclusive times for all functions</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> 
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"1:start:2"</span><span class="o">,</span><span class="s">"1:end:5"</span><span class="o">,</span><span class="s">"0:end:6"</span><span class="o">);</span>
        <span class="c1">// Function 0 runs for 3 units of time (from 0 to 1 and from 6 to 7), and function 1 runs for 4 units of time (from 2 to 5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">logs1</span><span class="o">)));</span> <span class="c1">// Output: [3, 4]</span>

        <span class="c1">// Example 2:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"0:start:2"</span><span class="o">,</span><span class="s">"0:end:5"</span><span class="o">,</span><span class="s">"0:start:6"</span><span class="o">,</span><span class="s">"0:end:6"</span><span class="o">,</span><span class="s">"0:end:7"</span><span class="o">);</span>
        <span class="c1">// Function 0 is recursively called. It runs for 2 units of time, then calls itself, runs for 4 units, and then continues</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">logs2</span><span class="o">)));</span> <span class="c1">// Output: [8]</span>

        <span class="c1">// Example 3:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs3</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"0:start:2"</span><span class="o">,</span><span class="s">"0:end:5"</span><span class="o">,</span><span class="s">"1:start:6"</span><span class="o">,</span><span class="s">"1:end:6"</span><span class="o">,</span><span class="s">"0:end:7"</span><span class="o">);</span>
        <span class="c1">// Function 0 runs for 7 units of time (from 0 to 5, then from 6 to 7), and function 1 runs for 1 unit of time (from 6 to 6)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">logs3</span><span class="o">)));</span> <span class="c1">// Output: [7, 1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1. Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list logs, where logs[i] represents the ith log message formatted as a string "{function_id}:{"start" | "end"}:{timestamp}". For example, "0:start:3" means a function call with function ID 0 started at the beginning of timestamp 3, and "1:end:2" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively. A function’s exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1=3. Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.]]></summary></entry><entry><title type="html">52. N-Queens II</title><link href="https://zhengstar94.github.io//blog/2024/NQueens/" rel="alternate" type="text/html" title="52. N-Queens II"/><published>2024-12-02T00:00:00+00:00</published><updated>2024-12-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NQueens%7C%7C</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NQueens/"><![CDATA[<ul> <li>The <strong>n-queens</strong> puzzle is the problem of placing <code class="language-plaintext highlighter-rouge">n</code> queens on an <code class="language-plaintext highlighter-rouge">n x n</code> chessboard such that no two queens attack each other.</li> <li>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, return <em>the number of distinct solutions to the <strong>n-queens puzzle</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n!) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NQueensII</span> <span class="o">{</span>
    <span class="c1">// This method is the entry point. It calls the recursive solve method to find the number of solutions.</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">totalNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>  <span class="c1">// Initial call with row = 0 and all bitmasks set to 0.</span>
    <span class="o">}</span>

    <span class="c1">// Recursive backtracking method to solve N-Queens problem</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">columns</span><span class="o">,</span> <span class="kt">int</span> <span class="n">diagonals</span><span class="o">,</span> <span class="kt">int</span> <span class="n">antiDiagonals</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// If we've placed queens in all rows, return 1 as we've found a valid solution.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">solutions</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Variable to count the number of valid solutions</span>

        <span class="c1">// Try placing a queen in every column of the current row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate the bitmask for the current column (only i-th column in the row).</span>
            <span class="kt">int</span> <span class="n">currColumn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Calculate the bitmask for the current main diagonal.</span>
            <span class="c1">// The main diagonal can be uniquely identified by (row - col), and we add (n-1) to ensure it stays positive.</span>
            <span class="kt">int</span> <span class="n">currDiagonal</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Calculate the bitmask for the current anti-diagonal (row + col).</span>
            <span class="kt">int</span> <span class="n">currAntiDiagonal</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>

            <span class="c1">// Check if placing the queen at (row, i) conflicts with any previously placed queens.</span>
            <span class="c1">// We check each of the three potential conflicts (column, diagonal, anti-diagonal) using bitwise AND.</span>
            <span class="c1">// If the result is not 0, it means that a queen already exists in that column, diagonal, or anti-diagonal.</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">columns</span> <span class="o">&amp;</span> <span class="n">currColumn</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">diagonals</span> <span class="o">&amp;</span> <span class="n">currDiagonal</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">antiDiagonals</span> <span class="o">&amp;</span> <span class="n">currAntiDiagonal</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>  <span class="c1">// If there's a conflict, skip this column.</span>
            <span class="o">}</span>

            <span class="c1">// If no conflicts, place the queen at (row, i) and move to the next row (row + 1).</span>
            <span class="c1">// We update the bitmasks (columns, diagonals, and antiDiagonals) by setting the corresponding bits to 1.</span>
            <span class="n">solutions</span> <span class="o">+=</span> <span class="n">solve</span><span class="o">(</span>
                    <span class="n">n</span><span class="o">,</span>
                    <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span>  <span class="c1">// Move to the next row</span>
                    <span class="n">columns</span> <span class="o">|</span> <span class="n">currColumn</span><span class="o">,</span>  <span class="c1">// Mark the current column as occupied</span>
                    <span class="n">diagonals</span> <span class="o">|</span> <span class="n">currDiagonal</span><span class="o">,</span>  <span class="c1">// Mark the current main diagonal as occupied</span>
                    <span class="n">antiDiagonals</span> <span class="o">|</span> <span class="n">currAntiDiagonal</span>  <span class="c1">// Mark the current anti-diagonal as occupied</span>
            <span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of solutions found for this configuration</span>
        <span class="k">return</span> <span class="n">solutions</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Main method to test the N-Queens solution</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// You can modify n to test different board sizes</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total solutions for N="</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">" Queens: "</span> <span class="o">+</span> <span class="n">totalNQueens</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><category term="Hard"/><summary type="html"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle.]]></summary></entry><entry><title type="html">394. Decode String</title><link href="https://zhengstar94.github.io//blog/2024/DecodeString/" rel="alternate" type="text/html" title="394. Decode String"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DecodeString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DecodeString/"><![CDATA[<ul> <li>Given an encoded string, return its decoded string.</li> <li>The encoding rule is: <code class="language-plaintext highlighter-rouge">k[encoded_string]</code>, where the <code class="language-plaintext highlighter-rouge">encoded_string</code> inside the square brackets is being repeated exactly <code class="language-plaintext highlighter-rouge">k</code> times. Note that <code class="language-plaintext highlighter-rouge">k</code> is guaranteed to be a positive integer.</li> <li>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code class="language-plaintext highlighter-rouge">k</code>. For example, there will not be input like <code class="language-plaintext highlighter-rouge">3a</code> or <code class="language-plaintext highlighter-rouge">2[4]</code>.</li> <li>The test cases are generated so that the length of the output will never exceed <code class="language-plaintext highlighter-rouge">10^5</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "3[a]2[bc]"
Output: "aaabcbc"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "3[a2[c]]"
Output: "accaccacc"
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
</code></pre></div></div> <p><strong>Example 4</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc3[cd]xyz"
Output: "abccdcdcdxyz"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * k) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecodeString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">decodeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Stack to track the repeat counts for each nested level</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Stack to track previous strings at each nested level</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Current number being processed (supports multi-digit numbers)</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Current string being built at the current processing level</span>
        <span class="nc">StringBuilder</span> <span class="n">currentString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// Process each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 1. Number Processing: Build multi-digit numbers</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// Convert character to digit and accumulate</span>
                <span class="c1">// Handles multi-digit numbers like 10, 23 etc.</span>
                <span class="c1">// Example: '1' -&gt; num = 0*10 + 1 = 1</span>
                <span class="c1">//          '23' -&gt; num = 1*10 + 3 = 13</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 2. Left Bracket: Start of a new encoding block</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span><span class="sc">'['</span><span class="o">){</span>
                <span class="c1">// Push current number of repeats to count stack</span>
                <span class="c1">// This allows tracking nested repeat counts</span>
                <span class="n">countStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>

                <span class="c1">// Push current string to string stack</span>
                <span class="c1">// Preserves previous string context before entering new block</span>
                <span class="n">stringStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">currentString</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

                <span class="c1">// Reset for new block processing</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">currentString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 3. Right Bracket: End of an encoding block, time to decode</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">']'</span><span class="o">){</span>
                <span class="c1">// Retrieve repeat count for current block</span>
                <span class="kt">int</span> <span class="n">repeatTimes</span> <span class="o">=</span> <span class="n">countStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="c1">// Retrieve previous string context</span>
                <span class="c1">// This handles nested and sequential encodings</span>
                <span class="nc">StringBuilder</span> <span class="n">previousString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">stringStack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>

                <span class="c1">// Create a new string to store repeated content</span>
                <span class="nc">StringBuilder</span> <span class="n">repeatedString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

                <span class="c1">// Repeat current block string specified number of times</span>
                <span class="c1">// Example: If currentString is "abc" and repeatTimes is 3</span>
                <span class="c1">// repeatedString becomes "abcabcabc"</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">repeatTimes</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">repeatedString</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">currentString</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// Combine previous context with repeated string</span>
                <span class="c1">// This resolves nested and sequential encodings</span>
                <span class="n">currentString</span> <span class="o">=</span> <span class="n">previousString</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">repeatedString</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 4. Letter Processing: Accumulate characters in current string</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">currentString</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the fully decoded string</span>
        <span class="k">return</span> <span class="n">currentString</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Comprehensive test cases covering various scenarios</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"3[a]2[bc]"</span><span class="o">,</span>           <span class="c1">// Simple repetition</span>
                <span class="s">"3[a2[c]]"</span><span class="o">,</span>             <span class="c1">// Nested repetition</span>
                <span class="s">"2[abc]3[cd]ef"</span><span class="o">,</span>        <span class="c1">// Multi-level repetition</span>
                <span class="s">"abc3[cd]xyz"</span><span class="o">,</span>          <span class="c1">// Repetition with prefix/suffix</span>
                <span class="s">"10[a]"</span><span class="o">,</span>                <span class="c1">// Multi-digit number</span>
                <span class="s">""</span>                      <span class="c1">// Empty string</span>
        <span class="o">};</span>

        <span class="c1">// Execute and print results for each test case</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">testCase</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original Encoded String: "</span> <span class="o">+</span> <span class="n">testCase</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">decodeString</span><span class="o">(</span><span class="n">testCase</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Decoded Result: "</span> <span class="o">+</span> <span class="n">decoded</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Decoding Error: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-------------------"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4]. The test cases are generated so that the length of the output will never exceed 10^5.]]></summary></entry><entry><title type="html">51. N-Queens</title><link href="https://zhengstar94.github.io//blog/2024/NQueens/" rel="alternate" type="text/html" title="51. N-Queens"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NQueens</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NQueens/"><![CDATA[<ul> <li>The <strong>n-queens</strong> puzzle is the problem of placing <code class="language-plaintext highlighter-rouge">n</code> queens on an <code class="language-plaintext highlighter-rouge">n x n</code> chessboard such that no two queens attack each other.</li> <li>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</li> <li>Each solution contains a distinct board configuration of the n-queens’ placement, where <code class="language-plaintext highlighter-rouge">'Q'</code> and <code class="language-plaintext highlighter-rouge">'.'</code> both indicate a queen and an empty space, respectively.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 4
Output: [ [ ".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.." ] ]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: [ [ "Q" ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n!) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NQueens</span> <span class="o">{</span>
    <span class="cm">/**
     * Main method to solve the N-Queens problem for a given board size.
     *
     * This method initializes the solving process and returns all valid queen arrangements.
     *
     * @param n The size of the chessboard (number of queens to place)
     * @return A list of all possible queen arrangements, where each arrangement
     *         is represented as a list of string representations of board rows
     *
     * Key Steps:
     * 1. Create an empty result list to store solutions
     * 2. Initialize a queens array to track queen positions
     * 3. Start the backtracking process from the first row
     * 4. Return all found solutions
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// List to store all valid solutions</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Array to track queen positions (index = row, value = column)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// Initialize all positions as unoccupied</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Start backtracking from the first row</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Recursive backtracking method to explore all possible queen placements.
     *
     * This is the core algorithm that systematically tries to place queens
     * on the board while maintaining the N-Queens constraints.
     *
     * @param queens Array representing current queen positions
     * @param row Current row being processed
     * @param n Total board size
     * @param result List to store all valid solutions
     *
     * Detailed Algorithm:
     * 1. Base Case: If all rows are processed, add current solution to results
     * 2. For each column in the current row:
     *    - Check if placing a queen is valid
     *    - If valid, place the queen
     *    - Recursively process the next row
     *    - Implicitly backtrack by trying next column positions
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If we've successfully placed queens in all rows, we've found a solution</span>
        <span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">constructSolution</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">n</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Try placing a queen in each column of the current row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if placing a queen at this position is valid</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">)){</span>
                <span class="c1">// Place the queen</span>
                <span class="n">queens</span><span class="o">[</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>

                <span class="c1">// Recursively process the next row</span>
                <span class="n">backtrack</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="cm">/**
     * Validates whether a queen can be placed at the given position.
     *
     * Checks two key constraints:
     * 1. No queen in the same column
     * 2. No queen on the same diagonal
     *
     * @param queens Current queen positions
     * @param row Row of the new queen
     * @param col Column of the new queen
     * @return true if queen placement is valid, false otherwise
     *
     * Validation Logic:
     * - Column Check: Ensure no queen in the same column
     * - Diagonal Check: Use absolute value difference to detect diagonal conflicts
     *   - Diagonal conflict occurs when |row1 - row2| == |col1 - col2|
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check all previous rows</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check column conflict</span>
            <span class="k">if</span><span class="o">(</span><span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">col</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check diagonal conflicts using absolute value difference</span>
            <span class="c1">// If |row distance| == |column distance|, queens are on the same diagonal</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Converts the internal queens array representation to a visual board layout.
     *
     * Transforms the queens array into a list of strings where:
     * - 'Q' represents a queen
     * - '.' represents an empty square
     *
     * @param queens Array representing queen positions
     * @param n Board size
     * @return A list of strings representing the board configuration
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">constructSolution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Create a row filled with '.' initially</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="sc">'.'</span><span class="o">);</span>

            <span class="c1">// Place queen at the correct column</span>
            <span class="n">row</span><span class="o">[</span><span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="o">;</span>

            <span class="c1">// Convert row to string and add to solution</span>
            <span class="n">solution</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">solution</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases for different board sizes</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"N = "</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">" Queens Problem Solutions:"</span><span class="o">);</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">solutions</span> <span class="o">=</span> <span class="n">solveNQueens</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

            <span class="c1">// Print number of solutions</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of Solutions: "</span> <span class="o">+</span> <span class="n">solutions</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

            <span class="c1">// Print each solution's board layout</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">solutions</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Solution "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">":"</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">row</span> <span class="o">:</span> <span class="n">solutions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span> <span class="c1">// Separator between solutions</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-------------------"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><category term="Hard"/><summary type="html"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.]]></summary></entry><entry><title type="html">71. Simplify Path</title><link href="https://zhengstar94.github.io//blog/2024/SimplifyPath/" rel="alternate" type="text/html" title="71. Simplify Path"/><published>2024-11-29T00:00:00+00:00</published><updated>2024-11-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/SimplifyPath</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/SimplifyPath/"><![CDATA[<ul> <li>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code class="language-plaintext highlighter-rouge">'/'</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</li> <li>The <em>rules</em> of a Unix-style file system are as follows: <ul> <li>A single period <code class="language-plaintext highlighter-rouge">'.'</code> represents the current directory.</li> <li>A double period <code class="language-plaintext highlighter-rouge">'..'</code> represents the previous/parent directory.</li> <li>Multiple consecutive slashes such as <code class="language-plaintext highlighter-rouge">'//'</code> and <code class="language-plaintext highlighter-rouge">'///'</code> are treated as a single slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file</strong> <strong>name</strong>. For example, <code class="language-plaintext highlighter-rouge">'...' </code>and <code class="language-plaintext highlighter-rouge">'....'</code> are valid directory or file names.</li> </ul> </li> <li>The simplified canonical path should follow these <em>rules</em>: <ul> <li>The path must start with a single slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Directories within the path must be separated by exactly one slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>The path must not end with a slash <code class="language-plaintext highlighter-rouge">'/'</code>, unless it is the root directory.</li> <li>The path must not have any single or double periods (<code class="language-plaintext highlighter-rouge">'.'</code> and <code class="language-plaintext highlighter-rouge">'..'</code>) used to denote current or parent directories.</li> </ul> </li> <li>Return the <strong>simplified canonical path</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home/"
Output: "/home"
Explanation:
The trailing slash should be removed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home//foo/"
Output: "/home/foo"
Explanation:
Multiple consecutive slashes are replaced by a single one.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home/user/Documents/../Pictures"
Output: "/home/user/Pictures"
Explanation:
A double period ".." refers to the directory up a level (the parent directory).
</code></pre></div></div> <p><strong>Example 4</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/../"
Output: "/"
Explanation:
Going one level up from the root directory is not possible.
</code></pre></div></div> <p><strong>Example 5</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/.../a/../b/c/../d/./"
Output: "/.../b/d"
Explanation:
"..." is a valid name for a directory in this problem.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimplifyPath</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">simplifyPath</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a double-ended queue (stack) to store valid directory components</span>
        <span class="c1">// Using ArrayDeque provides more efficient stack operations compared to traditional Stack</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Split the path into components using "/" as the delimiter</span>
        <span class="c1">// This handles multiple scenarios like consecutive slashes, leading/trailing slashes</span>
        <span class="c1">// Example: "/a//b" → ["", "a", "", "b"]</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">components</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>

        <span class="c1">// Iterate through each path component to process and simplify</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">component</span> <span class="o">:</span> <span class="n">components</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Skip empty strings and current directory markers (".")</span>
            <span class="c1">// This handles cases like "//" or "./"</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">component</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">component</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"."</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Handle parent directory navigation ("..")</span>
            <span class="c1">// If the stack is not empty, remove the last directory (go up one level)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">component</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">".."</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Prevents going above root directory</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Add valid directory names to the stack</span>
            <span class="c1">// This includes special directory names like "..."</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Reconstruct the simplified canonical path</span>
        <span class="c1">// Start with a root slash "/"</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>

        <span class="c1">// Append each directory from the stack</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">dir</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Remove the trailing slash for non-root paths</span>
        <span class="c1">// Ensures the path follows canonical format</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic path with trailing slash</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"/home/"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 1: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Multiple consecutive slashes</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"/home//foo/"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 2: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Path with parent directory navigation</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"/home/user/Documents/../Pictures"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 3: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Trying to navigate above root directory</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"/../"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 4: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Complex path with multiple scenarios</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"/.../a/../b/c/../d/./"</span><span class="o">;;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 5: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path. The rules of a Unix-style file system are as follows: A single period '.' represents the current directory. A double period '..' represents the previous/parent directory. Multiple consecutive slashes such as '//' and '///' are treated as a single slash '/'. Any sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, '...' and '....' are valid directory or file names. The simplified canonical path should follow these rules: The path must start with a single slash '/'. Directories within the path must be separated by exactly one slash '/'. The path must not end with a slash '/', unless it is the root directory. The path must not have any single or double periods ('.' and '..') used to denote current or parent directories. Return the simplified canonical path.]]></summary></entry></feed>