<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-05T03:00:35+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1790. Check if One String Swap Can Make Strings Equal</title><link href="https://zhengstar94.github.io//blog/2025/CheckIfOneStringSwapCanMakeStringsEqual/" rel="alternate" type="text/html" title="1790. Check if One String Swap Can Make Strings Equal"/><published>2025-02-05T00:00:00+00:00</published><updated>2025-02-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CheckIfOneStringSwapCanMakeStringsEqual</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CheckIfOneStringSwapCanMakeStringsEqual/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code> of equal length. A <strong>string swap</strong> is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to make both strings equal by performing <strong>at most one string swap</strong> on <strong>exactly one</strong> of the strings.</em> Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "bank", s2 = "kanb"
Output: true
Explanation: For example, swap the first character with the last character of s2 to make "bank".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "attack", s2 = "defend"
Output: false
Explanation: It is impossible to make them equal with one string swap.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "kelb", s2 = "kelb"
Output: true
Explanation: The two strings are already equal, so no string swap operation is required.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckIfOneStringSwapCanMakeStringsEqual</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">areAlmostEqual</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the lengths of the two strings are not equal, return false</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Variables to store indices of different characters</span>
        <span class="c1">// i1 will store the index of the first differing character</span>
        <span class="c1">// i2 will store the index of the second differing character</span>
        <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each character of both strings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If characters at the current index are the same, continue to the next index</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If we already found two differences and another one is found,</span>
            <span class="c1">// then we need more than one swap, hence return false</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If this is the first differing character, store its index</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// This is the second differing character, store its index</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no differing characters were found, it means both strings are already equal</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If we found only one differing character, return false</span>
        <span class="c1">// Because a single swap can only fix two differing characters</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Finally, check if swapping the characters at these two indices</span>
        <span class="c1">// would make the two strings equal</span>
        <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i1</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i2</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"bank"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"kanb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 2</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"attack"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"defend"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test case 3</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"kelb"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"kelb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 4 (where there's a possible swap)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"badc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test case 5 (where too many differences)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"xyz"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.]]></summary></entry><entry><title type="html">3325. Count Substrings With K-Frequency Characters I</title><link href="https://zhengstar94.github.io//blog/2025/CountSubstringsWithKFrequencyCharactersI/" rel="alternate" type="text/html" title="3325. Count Substrings With K-Frequency Characters I"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubstringsWithKFrequencyCharactersI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubstringsWithKFrequencyCharactersI/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return the total number of substrings of <code class="language-plaintext highlighter-rouge">s</code> where <strong>at least one</strong> character appears <strong>at least</strong> <code class="language-plaintext highlighter-rouge">k</code> times.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abacb", k = 2

Output: 4

Explanation:

The valid substrings are:

"aba" (character 'a' appears 2 times).
"abac" (character 'a' appears 2 times).
"abacb" (character 'a' appears 2 times).
"bacb" (character 'b' appears 2 times).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcde", k = 1

Output: 15

Explanation:

All substrings are valid because every character appears at least once.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubstringsWithKFrequencyCharactersI</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store frequency of each character (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">charFreq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Right pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the final result</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Expand window by moving right pointer</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Increment frequency of current character at right pointer</span>
            <span class="c1">// charFreq[0] represents 'a', charFreq[1] represents 'b', and so on</span>
            <span class="n">charFreq</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>

            <span class="c1">// When frequency of current character equals k,</span>
            <span class="c1">// contract window from left until its frequency becomes less than k</span>
            <span class="c1">// This is because we want to count substrings where character appears exactly k times</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">charFreq</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Decrement frequency of character at left pointer</span>
                <span class="c1">// as we're removing it from our window</span>
                <span class="n">charFreq</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
                <span class="c1">// Move left pointer ahead to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Add left pointer value to result</span>
            <span class="c1">// This counts all valid substrings ending at right pointer</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">left</span><span class="o">;</span>
            <span class="c1">// Move right pointer ahead to expand window</span>
            <span class="n">right</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abacb"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected output: 15</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aaa"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s and an integer k, return the total number of substrings of s where at least one character appears at least k times.]]></summary></entry><entry><title type="html">1800. Maximum Ascending Subarray Sum</title><link href="https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum/" rel="alternate" type="text/html" title="1800. Maximum Ascending Subarray Sum"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum/"><![CDATA[<ul> <li>Given an array of positive integers <code class="language-plaintext highlighter-rouge">nums</code>, return the <em>maximum possible sum of an <strong>ascending</strong> subarray in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>A subarray is defined as a contiguous sequence of numbers in an array.</li> <li>A subarray <code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> is <strong>ascending</strong> if for all <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">l &lt;= i &lt; r</code>, <code class="language-plaintext highlighter-rouge">numsi &lt; numsi+1</code>. Note that a subarray of size <code class="language-plaintext highlighter-rouge">1</code> is <strong>ascending</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumAscendingSubarraySum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxAscendingSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or empty array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables:</span>
        <span class="c1">// maxSum: keeps track of the maximum sum found so far</span>
        <span class="c1">// currentSum: keeps track of the current ascending sequence sum</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the array starting from second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If current element is greater than previous element</span>
            <span class="c1">// Continue building the ascending sequence</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If sequence breaks, start a new sequence from current element</span>
                <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// Update maxSum if currentSum is greater</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">currentSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with mixed ascending and non-ascending sequences</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">50</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 65</span>

        <span class="c1">// Test Case 2: Completely ascending array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">40</span><span class="o">,</span><span class="mi">50</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 150</span>

        <span class="c1">// Test Case 3: Array with multiple small ascending sequences</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">12</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 33</span>

        <span class="c1">// Test Case 4: Array with single element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums. A subarray is defined as a contiguous sequence of numbers in an array. A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l &lt;= i &lt; r, numsi &lt; numsi+1. Note that a subarray of size 1 is ascending.]]></summary></entry><entry><title type="html">922. Sort Array By Parity II</title><link href="https://zhengstar94.github.io//blog/2025/SortArrayByParityII/" rel="alternate" type="text/html" title="922. Sort Array By Parity II"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SortArrayByParityII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SortArrayByParityII/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>, half of the integers in <code class="language-plaintext highlighter-rouge">nums</code> are <strong>odd</strong>, and the other half are <strong>even</strong>.</li> <li>Sort the array so that whenever <code class="language-plaintext highlighter-rouge">nums[i]</code> is odd, <code class="language-plaintext highlighter-rouge">i</code> is <strong>odd</strong>, and whenever <code class="language-plaintext highlighter-rouge">nums[i]</code> is even, <code class="language-plaintext highlighter-rouge">i</code> is <strong>even</strong>.</li> <li>Return <em>any answer array that satisfies this condition</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3]
Output: [2,3]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SortArrayByParityII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParityII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize pointer for even indices starting from 0</span>
        <span class="kt">int</span> <span class="n">evenIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Initialize pointer for odd indices starting from 1</span>
        <span class="kt">int</span> <span class="n">oddIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create a new array to store the result</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Iterate through each number in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If number is even, place it at even index</span>
                <span class="n">result</span><span class="o">[</span><span class="n">evenIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="c1">// Move even index pointer by 2 positions</span>
                <span class="n">evenIndex</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If number is odd, place it at odd index</span>
                <span class="n">result</span><span class="o">[</span><span class="n">oddIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="c1">// Move odd index pointer by 2 positions</span>
                <span class="n">oddIndex</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the sorted array</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with multiple elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">sortArrayByParityII</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Array with minimum elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">sortArrayByParityII</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even. Return any answer array that satisfies this condition.]]></summary></entry><entry><title type="html">2962. Count Subarrays Where Max Element Appears at Least K Times</title><link href="https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes/" rel="alternate" type="text/html" title="2962. Count Subarrays Where Max Element Appears at Least K Times"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and a <strong>positive</strong> integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Return <em>the number of subarrays where the <strong>maximum</strong> element of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>appears <strong>at least</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>times in that subarray.</em></li> <li>A <strong>subarray</strong> is a contiguous sequence of elements within (prep. 在…之内 adv. 在内部) an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,2,3,3], k = 2
Output: 6
Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,2,1], k = 3
Output: 0
Explanation: No subarray contains the element 4 at least 3 times.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubarraysWhereMaxElementAppearsAtLeastKTimes</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1. Find the maximum value in the array</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 2. Process using sliding window technique</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Store the final count of valid subarrays</span>
        <span class="kt">int</span> <span class="n">cntMx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Count of maximum value occurrences in current window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Left pointer of the sliding window</span>

        <span class="c1">// Iterate through array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If current element is the maximum value, increment the counter</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cntMx</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Key Part 1: Window Adjustment
             * When we find exactly k occurrences of maximum value in the window:
             * 1. We need to shrink the window from left until cntMx &lt; k
             * 2. This helps us find the leftmost valid position for the current right pointer
             *
             * For example, in [1,3,2,3,3] with k=2:
             * When right=3 (fourth position), window contains [1,3,2,3]
             * We move left pointer until we have less than k max values
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">cntMx</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If we remove a maximum value from the left, decrease the counter</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">++]</span> <span class="o">==</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">cntMx</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Key Part 2: Counting Valid Subarrays
             * After the while loop:
             * - 'left' represents the position where window becomes invalid
             * - All positions before 'left' can be valid starting points
             *
             * For example, when right=3 in [1,3,2,3]:
             * If left=2, we can start subarrays from:
             * - position 0: [1,3,2,3]
             * - position 1: [3,2,3]
             * So we add 'left' (2) to answer
             *
             * This is why ans += left works:
             * - It counts all possible valid starting positions
             * - Each starting position forms exactly one valid subarray with current right pointer
             */</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with maximum value appearing multiple times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
        <span class="c1">// Valid subarrays are: [1,3,2,3], [3,2,3], [1,3,2,3,3], [3,2,3,3], [2,3,3], [3,3]</span>

        <span class="c1">// Test Case 2: Array where maximum value appears less than k times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
        <span class="c1">// No valid subarrays as maximum value (4) appears less than 3 times</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and a positive integer k. Return the number of subarrays where the maximum element of nums appears at least k times in that subarray. A subarray is a contiguous sequence of elements within (prep. 在…之内 adv. 在内部) an array.]]></summary></entry><entry><title type="html">3105. Longest Strictly Increasing or Strictly Decreasing Subarray</title><link href="https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray/" rel="alternate" type="text/html" title="3105. Longest Strictly Increasing or Strictly Decreasing Subarray"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray/"><![CDATA[<ul> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>. Return <em>the length of the <strong>longest</strong> subarray of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>which is either <strong>strictly increasing</strong> or <strong>strictly decreasing</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,3,3,2]

Output: 2

Explanation:

The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].

The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].

Hence, we return 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,3,3]

Output: 1

Explanation:

The strictly increasing subarrays of nums are [3], [3], [3], and [3].

The strictly decreasing subarrays of nums are [3], [3], [3], and [3].

Hence, we return 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1]

Output: 3

Explanation:

The strictly increasing subarrays of nums are [3], [2], and [1].

The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].

Hence, we return 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestStrictlyIncreasingOrStrictlyDecreasingSubarray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestMonotonicSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Return 0 for null or empty array</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Return 1 for single element array</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables:</span>
        <span class="c1">// inc: length of current increasing sequence</span>
        <span class="c1">// dec: length of current decreasing sequence</span>
        <span class="c1">// maxLen: maximum length found so far</span>
        <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through the array starting from second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>  <span class="c1">// If current element is greater than previous</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Extend increasing sequence</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset decreasing sequence</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>  <span class="c1">// If current element is less than previous</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="n">dec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Extend decreasing sequence</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset increasing sequence</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>  <span class="c1">// If current element equals previous</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset both sequences</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum length found</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">inc</span><span class="o">,</span> <span class="n">dec</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>  <span class="c1">// Return the final result</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the implementation with various test cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 2: Equal elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 3: Strictly decreasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 4: Strictly increasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 5: Strictly decreasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.]]></summary></entry><entry><title type="html">1358. Number of Substrings Containing All Three Characters</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfSubstringsContainingAllThreeCharacters/" rel="alternate" type="text/html" title="1358. Number of Substrings Containing All Three Characters"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfSubstringsContainingAllThreeCharacters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfSubstringsContainingAllThreeCharacters/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> consisting only of characters <em>a</em>, <em>b</em> and <em>c</em>.</li> <li>Return the number of substrings containing <strong>at least</strong> one occurrence of all these characters <em>a</em>, <em>b</em> and <em>c</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaacb"
Output: 3
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "aaacb", "aacb" and "acb". 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc"
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSubstringsContainingAllThreeCharacters</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to keep track of frequency of each character (a, b, c) in current window</span>
        <span class="c1">// count[0] for 'a', count[1] for 'b', count[2] for 'c'</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>

        <span class="c1">// Left pointer of sliding window, used for window contraction</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Variable to store the final result (total count of valid substrings)</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through string using right pointer to expand window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Increment count for current character</span>
            <span class="c1">// Subtract 'a' to convert character to index (0 for 'a', 1 for 'b', 2 for 'c')</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>

            <span class="c1">// While window contains all three characters</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// For current valid window, add number of possible substrings</span>
                <span class="c1">// s.length() - right represents number of possible extensions of current valid window</span>
                <span class="c1">// Example: for "abcabc", when right=2 ("abc"), possible substrings are:</span>
                <span class="c1">// "abc", "abca", "abcab", "abcabc"</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">right</span><span class="o">;</span>

                <span class="c1">// Contract window from left by decreasing count of leftmost character</span>
                <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>

                <span class="c1">// Move left pointer to continue checking smaller windows</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return total count of valid substrings</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Regular case with repeated pattern</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcabc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>

        <span class="c1">// Test Case 2: Uneven distribution of characters</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"aaacb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 3: Minimal case with exactly one occurrence of each</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 4: Invalid case with missing characters</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"aaaa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 5: Longer string with multiple valid substrings</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abcabcabc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s5</span><span class="o">));</span> <span class="c1">// Expected output: 28</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s consisting only of characters a, b and c. Return the number of substrings containing at least one occurrence of all these characters a, b and c.]]></summary></entry><entry><title type="html">1752. Check if Array Is Sorted and Rotated</title><link href="https://zhengstar94.github.io//blog/2025/CheckIfArrayIsSortedAndRotated/" rel="alternate" type="text/html" title="1752. Check if Array Is Sorted and Rotated"/><published>2025-02-02T00:00:00+00:00</published><updated>2025-02-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CheckIfArrayIsSortedAndRotated</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CheckIfArrayIsSortedAndRotated/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if the array was originally sorted in non-decreasing order, then rotated <strong>some</strong> number of positions (including zero)</em>. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> <li>There may be <strong>duplicates</strong> in the original array.</li> <li><strong>Note:</strong> An array <code class="language-plaintext highlighter-rouge">A</code> rotated by <code class="language-plaintext highlighter-rouge">x</code> positions results in an array <code class="language-plaintext highlighter-rouge">B</code> of the same length such that <code class="language-plaintext highlighter-rouge">A[i] == B[(i+x) % A.length]</code>, where <code class="language-plaintext highlighter-rouge">%</code> is the modulo operation.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: true
Explanation: [1,2,3] is the original sorted array.
You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckIfArrayIsSortedAndRotated</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Count the number of inversions (where current element &gt; next element)</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Check adjacent elements including first and last (circular check)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">n</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// If more than one inversion is found, array cannot be sorted and rotated</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array that is sorted and rotated</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Should output true</span>

        <span class="c1">// Test Case 2: Array that cannot be sorted by rotation</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Should output false</span>

        <span class="c1">// Test Case 3: Already sorted array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Should output true</span>

        <span class="c1">// Test Case 4: Array with duplicate elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Should output true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.]]></summary></entry><entry><title type="html">598. Range Addition II</title><link href="https://zhengstar94.github.io//blog/2025/RangeAdditionII/" rel="alternate" type="text/html" title="598. Range Addition II"/><published>2025-02-02T00:00:00+00:00</published><updated>2025-02-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RangeAdditionII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RangeAdditionII/"><![CDATA[<ul> <li>You are given an <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">M</code> initialized with all <code class="language-plaintext highlighter-rouge">0</code>’s and an array of operations <code class="language-plaintext highlighter-rouge">ops</code>, where <code class="language-plaintext highlighter-rouge">ops[i] = [ai, bi]</code> means <code class="language-plaintext highlighter-rouge">M[x][y]</code> should be incremented by one for all <code class="language-plaintext highlighter-rouge">0 &lt;= x &lt; ai</code> and <code class="language-plaintext highlighter-rouge">0 &lt;= y &lt; bi</code></li> <li>Count and return <em>the number of maximum integers in the matrix after performing all the operations</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, ops = [ [2,2],[3,3] ]
Output: 4
Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, ops = [ [2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3] ]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, ops = []
Output: 9
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(k) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RangeAdditionII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If operations array is empty or null, return the total area of matrix</span>
        <span class="c1">// as all elements will be 0 (maximum value) in this case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ops</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ops</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables to track minimum rows and columns</span>
        <span class="c1">// The overlapping area will be determined by these minimums</span>
        <span class="kt">int</span> <span class="n">minRow</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">minCol</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Iterate through each operation to find the smallest affected area</span>
        <span class="c1">// This will be the area where all operations overlap</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">op</span> <span class="o">:</span> <span class="n">ops</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">minRow</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minRow</span><span class="o">,</span> <span class="n">op</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>  <span class="c1">// Find minimum row bound</span>
            <span class="n">minCol</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minCol</span><span class="o">,</span> <span class="n">op</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>  <span class="c1">// Find minimum column bound</span>
        <span class="o">}</span>

        <span class="c1">// Return the area of overlap (number of maximum elements)</span>
        <span class="c1">// This is the product of minimum rows and columns</span>
        <span class="k">return</span> <span class="n">minRow</span> <span class="o">*</span> <span class="n">minCol</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with two operations</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxCount</span><span class="o">(</span><span class="n">m1</span><span class="o">,</span> <span class="n">n1</span><span class="o">,</span> <span class="n">ops1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test Case 2: Multiple operations with same pattern</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxCount</span><span class="o">(</span><span class="n">m2</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">ops2</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test Case 3: Empty operations array</span>
        <span class="kt">int</span> <span class="n">m3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxCount</span><span class="o">(</span><span class="n">m3</span><span class="o">,</span> <span class="n">n3</span><span class="o">,</span> <span class="n">ops3</span><span class="o">));</span> <span class="c1">// Expected output: 9</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an m x n matrix M initialized with all 0’s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &lt;= x &lt; ai and 0 &lt;= y &lt; bi Count and return the number of maximum integers in the matrix after performing all the operations.]]></summary></entry><entry><title type="html">1234. Replace the Substring for Balanced String</title><link href="https://zhengstar94.github.io//blog/2025/ReplaceTheSubstringForBalancedString/" rel="alternate" type="text/html" title="1234. Replace the Substring for Balanced String"/><published>2025-02-01T00:00:00+00:00</published><updated>2025-02-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ReplaceTheSubstringForBalancedString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ReplaceTheSubstringForBalancedString/"><![CDATA[<ul> <li>You are given a string s of length <code class="language-plaintext highlighter-rouge">n</code> containing only four kinds of characters: <code class="language-plaintext highlighter-rouge">'Q'</code>, <code class="language-plaintext highlighter-rouge">'W'</code>, <code class="language-plaintext highlighter-rouge">'E'</code>, and <code class="language-plaintext highlighter-rouge">'R'</code>.</li> <li>A string is said to be <strong>balanced</strong> if each of its characters appears <code class="language-plaintext highlighter-rouge">n / 4</code> times where <code class="language-plaintext highlighter-rouge">n</code> is the length of the string.</li> <li>Return <em>the minimum length of the substring that can be replaced with <strong>any</strong> other string of the same length to make</em> <code class="language-plaintext highlighter-rouge">s</code> <strong><em>balanced</em></strong>. If s is already <strong>balanced</strong>, return <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "QWER"
Output: 0
Explanation: s is already balanced.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER". 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowMin</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReplaceTheSubstringForBalancedString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">balancedString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store character frequency</span>
        <span class="c1">// Using ASCII array instead of HashMap for better performance</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

        <span class="c1">// Count initial frequency of each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Calculate target frequency for each character</span>
        <span class="c1">// For a balanced string, each character should appear exactly n/4 times</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>

        <span class="c1">// Check if string is already balanced</span>
        <span class="c1">// If each character appears exactly target times, return 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="sc">'Q'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="sc">'W'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span>
                <span class="n">count</span><span class="o">[</span><span class="sc">'E'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="sc">'R'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize minimum length as string length</span>
        <span class="c1">// This is the maximum possible length we might need to replace</span>
        <span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Initialize left pointer for sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Sliding window implementation</span>
        <span class="c1">// Right pointer moves through the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Decrease count of current character</span>
            <span class="c1">// This character is now inside our window</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)]--;</span>

            <span class="c1">// Try to minimize window size while maintaining valid condition</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="c1">// Ensure window is valid</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'Q'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="c1">// Check if Q outside window &lt;= target</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'W'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="c1">// Check if W outside window &lt;= target</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'E'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="c1">// Check if E outside window &lt;= target</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'R'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Check if R outside window &lt;= target</span>

                <span class="c1">// Update minimum length if current window is smaller</span>
                <span class="c1">// right - left + 1 gives current window size</span>
                <span class="n">minLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minLen</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

                <span class="c1">// Move left pointer by one position</span>
                <span class="c1">// Add the character at left pointer back to count</span>
                <span class="c1">// (it's now outside the window)</span>
                <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)]++;</span>

                <span class="c1">// Move left pointer to try to find smaller valid window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">minLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution with various test cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Already balanced string</span>
        <span class="c1">// Expected output: 0 (no replacement needed)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QWER"</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Need to replace one character</span>
        <span class="c1">// String "QQWE" needs one character replacement to be balanced</span>
        <span class="c1">// Expected output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQWE"</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Need to replace two characters</span>
        <span class="c1">// Expected output: 2 (replace "QQ" with "ER")</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQQW"</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Longer string test</span>
        <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQQWEERR"</span><span class="o">));</span>

        <span class="c1">// Test Case 5: All same characters</span>
        <span class="c1">// Expected output: 3 (need to replace three Q's)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQQQ"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowMin"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'. A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string. Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. If s is already balanced, return 0.]]></summary></entry></feed>