<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-17T11:02:42+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2176. Count Equal and Divisible Pairs in an Array</title><link href="https://zhengstar94.github.io//blog/2025/CountEqualAndDivisiblePairsInAnArray/" rel="alternate" type="text/html" title="2176. Count Equal and Divisible Pairs in an Array"/><published>2025-04-17T00:00:00+00:00</published><updated>2025-04-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountEqualAndDivisiblePairsInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountEqualAndDivisiblePairsInAnArray/"><![CDATA[<ul> <li>Given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the <strong>number of pairs</strong></em> <code class="language-plaintext highlighter-rouge">(i, j)</code> <em>where</em> <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; n</code>, <em>such that</em> <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code> <em>and</em> <code class="language-plaintext highlighter-rouge">(i * j)</code> <em>is divisible by</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,1,2,2,2,1,3], k = 2
Output: 4
Explanation:
There are 4 pairs that meet all the requirements:
- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4], k = 1
Output: 0
Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n²) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountEqualAndDivisiblePairsInAnArray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store indices for each number</span>
        <span class="c1">// Key: number from array</span>
        <span class="c1">// Value: list of indices where this number appears</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array to find valid pairs</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="c1">// Check all previous indices of the current number</span>
                <span class="c1">// to find valid pairs</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="c1">// Use long to prevent integer overflow</span>
                    <span class="c1">// Check if product of indices is divisible by k</span>
                    <span class="k">if</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="n">i</span> <span class="o">*</span> <span class="n">prevIndex</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">count</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Initialize new ArrayList for first occurrence of a number</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">// Add current index to the list of indices for this number</span>
            <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple valid pairs</span>
        <span class="c1">// Expected output: 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: No valid pairs</span>
        <span class="c1">// Expected output: 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 &lt;= i &lt; j &lt; n, such that nums[i] == nums[j] and (i * j) is divisible by k.]]></summary></entry><entry><title type="html">1759. Count Number of Homogenous Substrings</title><link href="https://zhengstar94.github.io//blog/2025/CountNumberOfHomogenousSubstrings/" rel="alternate" type="text/html" title="1759. Count Number of Homogenous Substrings"/><published>2025-04-16T00:00:00+00:00</published><updated>2025-04-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountNumberOfHomogenousSubstrings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountNumberOfHomogenousSubstrings/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the number of <strong>homogenous</strong> substrings of</em> <code class="language-plaintext highlighter-rouge">s</code><em>.</em> Since the answer may be too large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">109 + 7</code>.</li> <li>A string is <strong>homogenous</strong> if all the characters of the string are the same.</li> <li>A <strong>substring</strong> is a contiguous sequence of characters within a string.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abbcccaa"
Output: 13
Explanation: The homogenous substrings are listed as below:
"a"   appears 3 times.
"aa"  appears 1 time.
"b"   appears 2 times.
"bb"  appears 1 time.
"c"   appears 3 times.
"cc"  appears 2 times.
"ccc" appears 1 time.
3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "xy"
Output: 2
Explanation: The homogenous substrings are "x" and "y".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "zzzzz"
Output: 15
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountNumberOfHomogenousSubstrings</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countHomogenous</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Define modulo constant to handle large numbers</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1_000_000_007</span><span class="o">;</span>

        <span class="c1">// Result variable to store the total count</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Length of input string</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// Current position in string</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Outer loop: process each group of same characters</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Mark the start of current group</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="c1">// Get the character for current group</span>
            <span class="kt">char</span> <span class="n">currChar</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>

            <span class="c1">// Inner loop: find the end of current group of same characters</span>
            <span class="c1">// Continue while we haven't reached end and characters are same</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">currChar</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current group of same characters</span>
            <span class="kt">long</span> <span class="n">groupLength</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>

            <span class="c1">// Calculate contribution of current group using formula: n*(n+1)/2</span>
            <span class="c1">// This formula gives sum of numbers from 1 to n</span>
            <span class="c1">// Apply modulo to handle large numbers</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">groupLength</span> <span class="o">*</span> <span class="o">(</span><span class="n">groupLength</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">))</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Convert long to int for final result</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: String with multiple groups</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countHomogenous</span><span class="o">(</span><span class="s">"abbcccaa"</span><span class="o">));</span> <span class="c1">// Expected: 13</span>

        <span class="c1">// Test case 2: String with no consecutive same characters</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countHomogenous</span><span class="o">(</span><span class="s">"xy"</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test case 3: String with all same characters</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countHomogenous</span><span class="o">(</span><span class="s">"zzzzz"</span><span class="o">));</span> <span class="c1">// Expected: 15</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7. A string is homogenous if all the characters of the string are the same. A substring is a contiguous sequence of characters within a string.]]></summary></entry><entry><title type="html">1534. Count Good Triplets</title><link href="https://zhengstar94.github.io//blog/2025/CountGoodTriplets/" rel="alternate" type="text/html" title="1534. Count Good Triplets"/><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountGoodTriplets</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountGoodTriplets/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">arr</code>, and three integers <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">c</code>. You need to find the number of good triplets.</li> <li>A triplet <code class="language-plaintext highlighter-rouge">(arr[i], arr[j], arr[k ] )</code> is <strong>good</strong> if the following conditions are true: <ul> <li><code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li> <li><code class="language-plaintext highlighter-rouge">|arr[i] - arr[j ] | &lt;= a</code></li> <li><code class="language-plaintext highlighter-rouge">|arr[j] - arr[k ] | &lt;= b</code></li> <li><code class="language-plaintext highlighter-rouge">|arr[i] - arr[k ] | &lt;= c</code></li> </ul> </li> <li>Where <code class="language-plaintext highlighter-rouge">|x|</code> denotes the absolute value of <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>Return <em>the number of good triplets</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
Output: 4
Explanation: There are 4 good triplets: [ ( 3,0,1), (3,0,1), (3,1,1), (0,1,1 ) ].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1
Output: 0
Explanation: No triplet satisfies all conditions.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>3) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BruteForce</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountGoodTriplets</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countGoodTriplets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Counter to keep track of valid triplets</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// First loop for index i</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Second loop for index j, starting after i</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Early check for first condition to avoid unnecessary iterations</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">){</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Third loop for index k, starting after j</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="c1">// Check if triplet satisfies all remaining conditions</span>
                    <span class="k">if</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">])</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">])</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">){</span>
                        <span class="n">count</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output is 4</span>
        <span class="c1">// Example where multiple good triplets exist</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countGoodTriplets</span><span class="o">(</span><span class="n">arr1</span><span class="o">,</span> <span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">,</span> <span class="n">c1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expected output is 0</span>
        <span class="c1">// Example where no good triplets exist</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">a2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countGoodTriplets</span><span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">,</span> <span class="n">c2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BruteForce"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets. A triplet (arr[i], arr[j], arr[k ] ) is good if the following conditions are true: 0 &lt;= i &lt; j &lt; k &lt; arr.length |arr[i] - arr[j ] | &lt;= a |arr[j] - arr[k ] | &lt;= b |arr[i] - arr[k ] | &lt;= c Where |x| denotes the absolute value of x. Return the number of good triplets.]]></summary></entry><entry><title type="html">845. Longest Mountain in Array</title><link href="https://zhengstar94.github.io//blog/2025/LongestMountainInArray/" rel="alternate" type="text/html" title="845. Longest Mountain in Array"/><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestMountainInArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestMountainInArray/"><![CDATA[<ul> <li>You may recall that an array <code class="language-plaintext highlighter-rouge">arr</code> is a <strong>mountain array</strong> if and only if:</li> <li><code class="language-plaintext highlighter-rouge">arr.length &gt;= 3</code></li> <li>There exists some index <code class="language-plaintext highlighter-rouge">i</code> (<strong>0-indexed</strong>) with <code class="language-plaintext highlighter-rouge">0 &lt; i &lt; arr.length - 1</code> such that: <ul> <li><code class="language-plaintext highlighter-rouge">arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code>`</li> <li>``arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]`</li> </ul> </li> <li>Given an integer array <code class="language-plaintext highlighter-rouge">arr</code>, return <em>the length of the longest subarray, which is a mountain</em>. Return <code class="language-plaintext highlighter-rouge">0</code> if there is no mountain subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,1,4,7,3,2,5]
Output: 5
Explanation: The largest mountain is [1,4,7,3,2] which has length 5.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,2,2]
Output: 0
Explanation: There is no mountain.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestMountainInArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestMountain</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Variable to store the maximum length of mountain found</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Length of the input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Current position in the array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Main loop: continues until we can't form a mountain (needs at least 3 elements)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Skip non-mountain starts: move forward until we find a potential mountain start</span>
            <span class="c1">// A mountain start is where the next element is smaller than current element</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Mark the start position of potential mountain</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Find the ascending sequence of the mountain</span>
            <span class="c1">// Continue moving forward while elements are strictly increasing</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If no ascending sequence found, skip this position and continue</span>
            <span class="c1">// This happens when i hasn't moved from start position</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Mark the peak position</span>
            <span class="kt">int</span> <span class="n">peak</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Find the descending sequence of the mountain</span>
            <span class="c1">// Continue moving forward while elements are strictly decreasing</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If we found both ascending and descending sequences (i moved past peak)</span>
            <span class="c1">// Calculate the length of this mountain and update maximum length if necessary</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">peak</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the length of the longest mountain found</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Standard mountain array</span>
        <span class="c1">// Expected output: 5 (subarray [1,4,7,3,2] forms a mountain)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">longestMountain</span><span class="o">(</span><span class="n">arr1</span><span class="o">)</span> <span class="o">);</span>

        <span class="c1">// Test Case 2: No mountain exists</span>
        <span class="c1">// Expected output: 0 (no increasing then decreasing sequence)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">longestMountain</span><span class="o">(</span><span class="n">arr2</span><span class="o">)</span> <span class="o">);</span>

        <span class="c1">// Test Case 3: Multiple mountains</span>
        <span class="c1">// Expected output: 5 (largest mountain length among multiple mountains)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">longestMountain</span><span class="o">(</span><span class="n">arr3</span><span class="o">)</span> <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[You may recall that an array arr is a mountain array if and only if: arr.length &gt;= 3 There exists some index i (0-indexed) with 0 &lt; i &lt; arr.length - 1 such that: arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]` ``arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]` Given an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.]]></summary></entry><entry><title type="html">2038. Remove Colored Pieces if Both Neighbors are the Same Color</title><link href="https://zhengstar94.github.io//blog/2025/RemoveColoredPiecesIfBothNeighborsAreTheSameColor/" rel="alternate" type="text/html" title="2038. Remove Colored Pieces if Both Neighbors are the Same Color"/><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RemoveColoredPiecesIfBothNeighborsAreTheSameColor</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RemoveColoredPiecesIfBothNeighborsAreTheSameColor/"><![CDATA[<ul> <li>There are <code class="language-plaintext highlighter-rouge">n</code> pieces arranged in a line, and each piece is colored either by <code class="language-plaintext highlighter-rouge">'A'</code> or by <code class="language-plaintext highlighter-rouge">'B'</code>. You are given a string <code class="language-plaintext highlighter-rouge">colors</code> of length <code class="language-plaintext highlighter-rouge">n</code> where <code class="language-plaintext highlighter-rouge">colors[i]</code> is the color of the <code class="language-plaintext highlighter-rouge">ith</code> piece.</li> <li>Alice and Bob are playing a game where they take <strong>alternating turns</strong> removing pieces from the line. In this game, Alice moves <strong>first</strong>. <ul> <li>Alice is only allowed to remove a piece colored <code class="language-plaintext highlighter-rouge">'A'</code> if <strong>both its neighbors</strong> are also colored <code class="language-plaintext highlighter-rouge">'A'</code>. She is <strong>not allowed</strong> to remove pieces that are colored <code class="language-plaintext highlighter-rouge">'B'</code>.</li> <li>Bob is only allowed to remove a piece colored <code class="language-plaintext highlighter-rouge">'B'</code> if <strong>both its neighbors</strong> are also colored <code class="language-plaintext highlighter-rouge">'B'</code>. He is <strong>not allowed</strong> to remove pieces that are colored <code class="language-plaintext highlighter-rouge">'A'</code>.</li> <li>Alice and Bob <strong>cannot</strong> remove pieces from the edge of the line.</li> <li>If a player cannot make a move on their turn, that player <strong>loses</strong> and the other player <strong>wins</strong>.</li> </ul> </li> <li>Assuming Alice and Bob play optimally, return <code class="language-plaintext highlighter-rouge">true</code> <em>if Alice wins, or return</em> <code class="language-plaintext highlighter-rouge">false</code> <em>if Bob wins</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: colors = "AAABABB"
Output: true
Explanation:
AAABABB -&gt; AABABB
Alice moves first.
She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.

Now it's Bob's turn.
Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.
Thus, Alice wins, so return true.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: colors = "AA"
Output: false
Explanation:
Alice has her turn first.
There are only two 'A's and both are on the edge of the line, so she cannot move on her turn.
Thus, Bob wins, so return false.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: colors = "ABBBBBBBAAA"
Output: false
Explanation:
ABBBBBBBAAA -&gt; ABBBBBBBAA
Alice moves first.
Her only option is to remove the second to last 'A' from the right.

ABBBBBBBAA -&gt; ABBBBBBAA
Next is Bob's turn.
He has many options for which 'B' piece to remove. He can pick any.

On Alice's second turn, she has no more pieces that she can remove.
Thus, Bob wins, so return false.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveColoredPiecesIfBothNeighborsAreTheSameColor</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">winnerOfGame</span><span class="o">(</span><span class="nc">String</span> <span class="n">colors</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: if string is null or length &lt; 3, no valid moves possible</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">colors</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">colors</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Counter for number of possible moves for each player</span>
        <span class="c1">// alice: represents how many 'A' pieces Alice can remove</span>
        <span class="c1">// bob: represents how many 'B' pieces Bob can remove</span>
        <span class="kt">int</span> <span class="n">alice</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">bob</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Convert string to char array for easier processing</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Current position in the array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>  <span class="c1">// Length of the input string</span>

        <span class="c1">// Use grouped loop to process consecutive same-colored pieces</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  <span class="c1">// Start position of current group</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// Current color being processed</span>

            <span class="c1">// Count consecutive pieces of the same color</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">c</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current group</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>

            <span class="c1">// If group length &gt;= 3, calculate number of possible moves</span>
            <span class="c1">// For each group of length n, number of possible moves is (n-2)</span>
            <span class="c1">// because end pieces cannot be removed</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'A'</span><span class="o">){</span>
                    <span class="n">alice</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>  <span class="c1">// Add possible moves for Alice</span>
                <span class="o">}</span> <span class="k">else</span><span class="o">{</span>
                    <span class="n">bob</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>   <span class="c1">// Add possible moves for Bob</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Alice wins if she has more possible moves than Bob</span>
        <span class="c1">// This works because:</span>
        <span class="c1">// 1. Alice goes first</span>
        <span class="c1">// 2. Each player will always make a move if possible</span>
        <span class="c1">// 3. The player with more moves will be the last to make a move</span>
        <span class="k">return</span> <span class="n">alice</span> <span class="o">&gt;</span> <span class="n">bob</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Alice should win</span>
        <span class="nc">String</span> <span class="n">colors1</span> <span class="o">=</span> <span class="s">"AAABABB"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">winnerOfGame</span><span class="o">(</span><span class="n">colors1</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 2: Bob should win (Alice has no valid moves)</span>
        <span class="nc">String</span> <span class="n">colors2</span> <span class="o">=</span> <span class="s">"AA"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">winnerOfGame</span><span class="o">(</span><span class="n">colors2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test case 3: Bob should win (Bob has more possible moves)</span>
        <span class="nc">String</span> <span class="n">colors3</span> <span class="o">=</span> <span class="s">"ABBBBBBBAAA"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">winnerOfGame</span><span class="o">(</span><span class="n">colors3</span><span class="o">));</span> <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece. Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first. Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'. Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'. Alice and Bob cannot remove pieces from the edge of the line. If a player cannot make a move on their turn, that player loses and the other player wins. Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.]]></summary></entry><entry><title type="html">1887. Reduction Operations to Make the Array Elements Equal</title><link href="https://zhengstar94.github.io//blog/2025/ReductionOperationsToMakeTheArrayElementsEqual/" rel="alternate" type="text/html" title="1887. Reduction Operations to Make the Array Elements Equal"/><published>2025-04-13T00:00:00+00:00</published><updated>2025-04-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ReductionOperationsToMakeTheArrayElementsEqual</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ReductionOperationsToMakeTheArrayElementsEqual/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, your goal is to make all elements in <code class="language-plaintext highlighter-rouge">nums</code> equal. To complete one operation, follow these steps: <ol> <li>Find the <strong>largest</strong> value in <code class="language-plaintext highlighter-rouge">nums</code>. Let its index be <code class="language-plaintext highlighter-rouge">i</code> (<strong>0-indexed</strong>) and its value be <code class="language-plaintext highlighter-rouge">largest</code>. If there are multiple elements with the largest value, pick the smallest <code class="language-plaintext highlighter-rouge">i</code>.</li> <li>Find the <strong>next largest</strong> value in <code class="language-plaintext highlighter-rouge">nums</code> <strong>strictly smaller</strong> than <code class="language-plaintext highlighter-rouge">largest</code>. Let its value be <code class="language-plaintext highlighter-rouge">nextLargest</code>.</li> <li>Reduce <code class="language-plaintext highlighter-rouge">nums[i]</code> to <code class="language-plaintext highlighter-rouge">nextLargest</code>.</li> </ol> </li> <li>Return <em>the number of operations to make all elements in</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>equal</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,1,3]
Output: 3
Explanation: It takes 3 operations to make all elements in nums equal:
1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]
Output: 0
Explanation: All elements in nums are already equal.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2,2,3]
Output: 4
Explanation: It takes 4 operations to make all elements in nums equal:
1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReductionOperationsToMakeTheArrayElementsEqual</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">reductionOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the array to group identical elements together</span>
        <span class="c1">// This makes it easier to process elements from largest to smallest</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// Initialize variables</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>              <span class="c1">// Length of the array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>                    <span class="c1">// Start from the last element (largest value)</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                   <span class="c1">// Counter for total operations needed</span>

        <span class="c1">// Main loop continues while we have elements to process</span>
        <span class="c1">// We need at least two different values to perform operations</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">// Store the starting index of current group</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Inner loop: Find all elements with the same value</span>
            <span class="c1">// This loop groups identical elements together</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                <span class="c1">// Move backward while we find same values</span>
                <span class="c1">// This helps us identify the size of current group</span>
                <span class="n">i</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Process current group if it's not the smallest value group</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="c1">// Calculate operations needed for current group</span>
                <span class="c1">// n - i represents the number of elements that need to be reduced</span>
                <span class="c1">// For each element larger than the next distinct value,</span>
                <span class="c1">// we need one operation to reduce it</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Move to the next group</span>
            <span class="c1">// We decrement i here because the current position has been processed</span>
            <span class="n">i</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with distinct elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">reductionOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="c1">// Expected output: 3 (requires 3 operations to make all elements equal)</span>

        <span class="c1">// Test Case 2: Array with all equal elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">reductionOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="c1">// Expected output: 0 (no operations needed as elements are already equal)</span>

        <span class="c1">// Test Case 3: Array with mixed repeated elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">reductionOperations</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="c1">// Expected output: 4 (requires 4 operations to make all elements equal)</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps: Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i. Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest. Reduce nums[i] to nextLargest. Return the number of operations to make all elements in nums equal.]]></summary></entry><entry><title type="html">228. Summary Ranges</title><link href="https://zhengstar94.github.io//blog/2025/SummaryRanges/" rel="alternate" type="text/html" title="228. Summary Ranges"/><published>2025-04-13T00:00:00+00:00</published><updated>2025-04-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SummaryRanges</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SummaryRanges/"><![CDATA[<ul> <li>You are given a <strong>sorted unique</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>A <strong>range</strong> <code class="language-plaintext highlighter-rouge">[a,b]</code> is the set of all integers from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code> (inclusive).</li> <li>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code class="language-plaintext highlighter-rouge">nums</code> is covered by exactly one of the ranges, and there is no integer <code class="language-plaintext highlighter-rouge">x</code> such that <code class="language-plaintext highlighter-rouge">x</code> is in one of the ranges but not in <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Each range <code class="language-plaintext highlighter-rouge">[a,b]</code> in the list should be output as: <ul> <li><code class="language-plaintext highlighter-rouge">"a-&gt;b"</code> if <code class="language-plaintext highlighter-rouge">a != b</code></li> <li><code class="language-plaintext highlighter-rouge">"a"</code> if <code class="language-plaintext highlighter-rouge">a == b</code></li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,2,4,5,7]
Output: ["0-&gt;2","4-&gt;5","7"]
Explanation: The ranges are:
[0,2] --&gt; "0-&gt;2"
[4,5] --&gt; "4-&gt;5"
[7,7] --&gt; "7"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2-&gt;4","6","8-&gt;9"]
Explanation: The ranges are:
[0,0] --&gt; "0"
[2,4] --&gt; "2-&gt;4"
[6,6] --&gt; "6"
[8,9] --&gt; "8-&gt;9"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SummaryRanges</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">summaryRanges</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize result list to store range strings</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Handle edge cases: null array or empty array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Get array length for iteration</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Initialize index for traversal</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Main loop to process the entire array</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="c1">// Mark the start of current group/range</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Inner loop to find the end of current continuous sequence</span>
            <span class="c1">// Continue while next number is consecutive</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Process the found range</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">i</span><span class="o">){</span>
                <span class="c1">// Case 1: Single number range (start equals end)</span>
                <span class="c1">// Format: "number"</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]));</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// Case 2: Multiple number range (start to end)</span>
                <span class="c1">// Format: "start-&gt;end"</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">+</span> <span class="s">"-&gt;"</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="c1">// Move to the start of next potential range</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Regular case with multiple ranges</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">summaryRanges</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="c1">// Expected output: ["0-&gt;2","4-&gt;5","7"]</span>

        <span class="c1">// Test Case 2: Mixed single numbers and ranges</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">summaryRanges</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="c1">// Expected output: ["0","2-&gt;4","6","8-&gt;9"]</span>

        <span class="c1">// Test Case 3: Empty array edge case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">summaryRanges</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="c1">// Expected output: []</span>

        <span class="c1">// Test Case 4: Single element array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">summaryRanges</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="c1">// Expected output: ["1"]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Easy"/><summary type="html"><![CDATA[You are given a sorted unique integer array nums. A range [a,b] is the set of all integers from a to b (inclusive). Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums. Each range [a,b] in the list should be output as: "a-&gt;b" if a != b "a" if a== b]]></summary></entry><entry><title type="html">978. Longest Turbulent Subarray</title><link href="https://zhengstar94.github.io//blog/2025/LongestTurbulentSubarray/" rel="alternate" type="text/html" title="978. Longest Turbulent Subarray"/><published>2025-04-12T00:00:00+00:00</published><updated>2025-04-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestTurbulentSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestTurbulentSubarray/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">arr</code>, return <em>the length of a maximum size turbulent subarray of</em> <code class="language-plaintext highlighter-rouge">arr</code>.</li> <li>A subarray is <strong>turbulent</strong> if the comparison sign flips between each adjacent pair of elements in the subarray.</li> <li>More formally, a subarray <code class="language-plaintext highlighter-rouge">[arr[i], arr[i + 1], ..., arr[j]]</code> of <code class="language-plaintext highlighter-rouge">arr</code> is said to be turbulent if and only if: <ul> <li>For <code class="language-plaintext highlighter-rouge">i &lt;= k &lt; j</code>: <ul> <li><code class="language-plaintext highlighter-rouge">arr[k] &gt; arr[k + 1]</code> when <code class="language-plaintext highlighter-rouge">k</code> is odd, and</li> <li><code class="language-plaintext highlighter-rouge">arr[k] &lt; arr[k + 1]</code> when <code class="language-plaintext highlighter-rouge">k</code> is even.</li> </ul> </li> <li>Or, for <code class="language-plaintext highlighter-rouge">i &lt;= k &lt; j</code>: <ul> <li><code class="language-plaintext highlighter-rouge">arr[k] &gt; arr[k + 1]</code> when <code class="language-plaintext highlighter-rouge">k</code> is even, and</li> <li><code class="language-plaintext highlighter-rouge">arr[k] &lt; arr[k + 1]</code> when <code class="language-plaintext highlighter-rouge">k</code> is odd.</li> </ul> </li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [4,8,12,16]
Output: 2
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [100]
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestTurbulentSubarray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxTurbulenceSize</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or empty array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Handle single element array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Initialize max length to 1 (minimum possible length)</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Index to traverse the array</span>

        <span class="c1">// Outer loop: process each potential starting point of turbulent subarray</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  <span class="c1">// Mark the start of current potential turbulent subarray</span>

            <span class="c1">// Skip adjacent equal elements as they break turbulence</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]){</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Record the relationship between first pair of elements</span>
            <span class="c1">// This boolean will help maintain alternating pattern</span>
            <span class="c1">// true if current element is greater than next element</span>
            <span class="c1">// false if current element is less than next element</span>
            <span class="kt">boolean</span> <span class="n">isFirstGreater</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Inner loop: extend the turbulent subarray as far as possible</span>
            <span class="c1">// Condition breakdown:</span>
            <span class="c1">// 1. i &lt; n - 1: ensure we don't go out of bounds</span>
            <span class="c1">// 2. ((isFirstGreater &amp;&amp; arr[i] &gt; arr[i + 1]) || (!isFirstGreater &amp;&amp; arr[i] &lt; arr[i + 1]))</span>
            <span class="c1">//    - if isFirstGreater is true, we need current &gt; next</span>
            <span class="c1">//    - if isFirstGreater is false, we need current &lt; next</span>
            <span class="c1">//    This ensures alternating pattern</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">isFirstGreater</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">||</span>
                    <span class="o">(!</span><span class="n">isFirstGreater</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]))){</span>
                <span class="c1">// Flip the comparison sign for next pair</span>
                <span class="n">isFirstGreater</span> <span class="o">=</span> <span class="o">!</span><span class="n">isFirstGreater</span><span class="o">;</span>
                <span class="n">i</span><span class="o">++;</span>  <span class="c1">// Move to next element</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current turbulent subarray and update max length if necessary</span>
            <span class="c1">// i - start + 1 gives the length of current subarray</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output 5</span>
        <span class="c1">// Turbulent subarray: [4,2,10,7,8] because 4&gt;2&lt;10&gt;7&lt;8</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">maxTurbulenceSize</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Expected output 2</span>
        <span class="c1">// All elements increasing, only adjacent pairs can be turbulent</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">16</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">maxTurbulenceSize</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span>

        <span class="c1">// Test case 3: Expected output 1</span>
        <span class="c1">// Single element array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">maxTurbulenceSize</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span>

        <span class="c1">// Test case 4: Expected output 1</span>
        <span class="c1">// Equal adjacent elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">maxTurbulenceSize</span><span class="o">(</span><span class="n">arr4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[Given an integer array arr, return the length of a maximum size turbulent subarray of arr. A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray. More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if: For i &lt;= k &lt; j: arr[k] &gt; arr[k + 1] when k is odd, and arr[k] &lt; arr[k + 1] when k is even. Or, for i &lt;= k &lt; j: arr[k] &gt; arr[k + 1] when k is even, and arr[k] &lt; arr[k + 1] when k is odd.]]></summary></entry><entry><title type="html">2110. Number of Smooth Descent Periods of a Stock</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfSmoothDescentPeriodsOfAStock/" rel="alternate" type="text/html" title="2110. Number of Smooth Descent Periods of a Stock"/><published>2025-04-12T00:00:00+00:00</published><updated>2025-04-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfSmoothDescentPeriodsOfAStock</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfSmoothDescentPeriodsOfAStock/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">prices</code> representing the daily price history of a stock, where <code class="language-plaintext highlighter-rouge">prices[i]</code> is the stock price on the <code class="language-plaintext highlighter-rouge">ith</code> day.</li> <li>A <strong>smooth descent period</strong> of a stock consists of <strong>one or more contiguous</strong> days such that the price on each day is <strong>lower</strong> than the price on the <strong>preceding day</strong> by <strong>exactly</strong> <code class="language-plaintext highlighter-rouge">1</code>. The first day of the period is exempted from this rule.</li> <li>Return <em>the number of <strong>smooth descent periods</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [3,2,1,4]
Output: 7
Explanation: There are 7 smooth descent periods:
[3], [2], [1], [4], [3,2], [2,1], and [3,2,1]
Note that a period with one day is a smooth descent period by the definition.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [8,6,7,7]
Output: 4
Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7]
Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [1]
Output: 1
Explanation: There is 1 smooth descent period: [1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSmoothDescentPeriodsOfAStock</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">getDescentPeriods</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: if array is null or empty</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prices</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>          <span class="c1">// Length of the price array</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                <span class="c1">// Total count of smooth descent periods</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                      <span class="c1">// Current index in the array</span>

        <span class="c1">// Process the array using grouped loop pattern</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="c1">// Mark the start of current smooth descent sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Extend the current smooth descent sequence as far as possible</span>
            <span class="c1">// A smooth descent requires each price to be exactly 1 less than the previous price</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate the length of current smooth descent sequence</span>
            <span class="kt">long</span> <span class="n">length</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="cm">/**
             * Calculate number of smooth descent periods in current sequence using arithmetic sequence sum
             * For a sequence of length k, we can form:
             * - k sequences of length 1
             * - (k-1) sequences of length 2
             * - (k-2) sequences of length 3
             * ... and so on
             *
             * Total number of sequences = k + (k-1) + (k-2) + ... + 1
             * This is equivalent to k * (k+1) / 2
             *
             * Example: For sequence [3,2,1] (length = 3)
             * Length 1 sequences: [3], [2], [1]                    (count: 3)
             * Length 2 sequences: [3,2], [2,1]                     (count: 2)
             * Length 3 sequences: [3,2,1]                          (count: 1)
             * Total = 3 + 2 + 1 = 6 = 3 * (3+1) / 2
             */</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">(</span><span class="n">length</span> <span class="o">*</span> <span class="o">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Move to the next element after current sequence</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Demonstrates a perfect smooth descent sequence</span>
        <span class="c1">// [3,2,1,4] contains following smooth descent periods:</span>
        <span class="c1">// Single day: [3], [2], [1], [4]</span>
        <span class="c1">// Two days: [3,2], [2,1]</span>
        <span class="c1">// Three days: [3,2,1]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">prices1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">getDescentPeriods</span><span class="o">(</span><span class="n">prices1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Demonstrates non-smooth descent sequence</span>
        <span class="c1">// [8,6,7,7] only contains single-day periods as no consecutive days form smooth descent</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">prices2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">getDescentPeriods</span><span class="o">(</span><span class="n">prices2</span><span class="o">));</span>

        <span class="c1">// Test case 3: Demonstrates single element case</span>
        <span class="c1">// [1] contains only one smooth descent period</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">prices3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">getDescentPeriods</span><span class="o">(</span><span class="n">prices3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array prices representing the daily price history of a stock, where prices[i] is the stock price on the ith day. A smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is exempted from this rule. Return the number of smooth descent periods.]]></summary></entry><entry><title type="html">2843. Count Symmetric Integers</title><link href="https://zhengstar94.github.io//blog/2025/CountSymmetricIntegers/" rel="alternate" type="text/html" title="2843. Count Symmetric Integers"/><published>2025-04-11T00:00:00+00:00</published><updated>2025-04-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSymmetricIntegers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSymmetricIntegers/"><![CDATA[<ul> <li>You are given two positive integers <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code>.</li> <li>An integer <code class="language-plaintext highlighter-rouge">x</code> consisting of <code class="language-plaintext highlighter-rouge">2 * n</code> digits is <strong>symmetric</strong> if the sum of the first <code class="language-plaintext highlighter-rouge">n</code> digits of <code class="language-plaintext highlighter-rouge">x</code> is equal to the sum of the last <code class="language-plaintext highlighter-rouge">n</code> digits of <code class="language-plaintext highlighter-rouge">x</code>. Numbers with an odd number of digits are never symmetric.</li> <li>Return <em>the <strong>number of symmetric</strong> integers in the range</em> <code class="language-plaintext highlighter-rouge">[low, high]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: low = 1, high = 100
Output: 9
Explanation: There are 9 symmetric integers between 1 and 100: 11, 22, 33, 44, 55, 66, 77, 88, and 99.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: low = 1200, high = 1230
Output: 4
Explanation: There are 4 symmetric integers between 1200 and 1230: 1203, 1212, 1221, and 1230.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O((high - low) * d) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BruteForce</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSymmetricIntegers</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countSymmetricIntegers</span><span class="o">(</span><span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Counter for symmetric integers</span>

        <span class="c1">// Iterate through each number in the range</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">low</span><span class="o">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">;</span> <span class="n">num</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">numStr</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>  <span class="c1">// Convert number to string for digit manipulation</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">numStr</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>  <span class="c1">// Get length of the number</span>

            <span class="c1">// Skip numbers with odd number of digits as they can't be symmetric</span>
            <span class="k">if</span><span class="o">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate half length for splitting the number</span>
            <span class="kt">int</span> <span class="n">halfLen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">leftSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Sum of digits in first half</span>
            <span class="kt">int</span> <span class="n">rightSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Sum of digits in second half</span>

            <span class="c1">// Calculate sums of both halves</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">halfLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">leftSum</span> <span class="o">+=</span> <span class="n">numStr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>  <span class="c1">// Add digit from first half</span>
                <span class="n">rightSum</span> <span class="o">+=</span> <span class="n">numStr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfLen</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>  <span class="c1">// Add digit from second half</span>
            <span class="o">}</span>

            <span class="c1">// If sums are equal, increment counter</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftSum</span> <span class="o">==</span> <span class="n">rightSum</span><span class="o">){</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Numbers from 1 to 100</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">low1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">high1</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: low = "</span> <span class="o">+</span> <span class="n">low1</span> <span class="o">+</span> <span class="s">", high = "</span> <span class="o">+</span> <span class="n">high1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">countSymmetricIntegers</span><span class="o">(</span><span class="n">low1</span><span class="o">,</span> <span class="n">high1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Numbers from 1200 to 1230</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">low2</span> <span class="o">=</span> <span class="mi">1200</span><span class="o">,</span> <span class="n">high2</span> <span class="o">=</span> <span class="mi">1230</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: low = "</span> <span class="o">+</span> <span class="n">low2</span> <span class="o">+</span> <span class="s">", high = "</span> <span class="o">+</span> <span class="n">high2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">countSymmetricIntegers</span><span class="o">(</span><span class="n">low2</span><span class="o">,</span> <span class="n">high2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BruteForce"/><category term="Easy"/><summary type="html"><![CDATA[You are given two positive integers low and high. An integer x consisting of 2 * n digits is symmetric if the sum of the first n digits of x is equal to the sum of the last n digits of x. Numbers with an odd number of digits are never symmetric. Return the number of symmetric integers in the range [low, high].]]></summary></entry></feed>