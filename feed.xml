<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-05T15:52:45+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">(Review)2563. Count the Number of Fair Pairs</title><link href="https://zhengstar94.github.io//blog/2025/CountTheNumberOfFairPairs/" rel="alternate" type="text/html" title="(Review)2563. Count the Number of Fair Pairs"/><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountTheNumberOfFairPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountTheNumberOfFairPairs/"><![CDATA[<ul> <li>Given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code> and two integers <code class="language-plaintext highlighter-rouge">lower</code> and <code class="language-plaintext highlighter-rouge">upper</code>, return <em>the number of fair pairs</em>.</li> <li>A pair <code class="language-plaintext highlighter-rouge">(i, j)</code> is <strong>fair</strong> if: <ul> <li><code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; n</code>, and</li> <li><code class="language-plaintext highlighter-rouge">lower &lt;= nums[i] + nums[j] &lt;= upper</code></li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
Output: 6
Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,7,9,2,5], lower = 11, upper = 11
Output: 1
Explanation: There is a single fair pair: (2,3).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.ThreePointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountTheNumberOfFairPairs</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countFairPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort array to handle pairs in order</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Initialize pointers to end of array</span>
        <span class="c1">// left: tracks the leftmost position where nums[j] + nums[i] &gt;= lower</span>
        <span class="c1">// right: tracks the leftmost position where nums[j] + nums[i] &gt; upper</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// For each number as the second element of the pair</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Move right pointer left while sum is too large</span>
            <span class="c1">// Find rightmost position where nums[right-1] + nums[i] &lt;= upper</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Move left pointer left while sum is large enough</span>
            <span class="c1">// Find rightmost position where nums[left-1] + nums[i] &gt;= lower</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">lower</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Calculate valid pairs for current nums[i]:
             *
             * Math.min(right, i) - Math.min(left, i) counts pairs where:
             * 1. The first number (nums[j]) must be to the left of nums[i] (j &lt; i)
             * 2. The sum must be &lt;= upper (controlled by right pointer)
             * 3. The sum must be &gt;= lower (controlled by left pointer)
             *
             * Example: for i = 2 (nums[2] = 5):
             * - If right = 3 and left = 0:
             * - Math.min(3, 2) = 2 (can only use positions up to i)
             * - Math.min(0, 2) = 0 (start from position 0)
             * - 2 - 0 = 2 pairs possible (using positions 0 and 1)
             *
             * We use Math.min because:
             * - We can't use positions beyond i (need j &lt; i)
             * - right gives upper bound of valid positions
             * - left gives lower bound of valid positions
             * - The difference gives count of valid positions
             */</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Multiple fair pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">countFairPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">lower1</span><span class="o">,</span> <span class="n">upper1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2: Single fair pair</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower2</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper2</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [1,7,9,2,5], lower = 11, upper = 11"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">countFairPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">lower2</span><span class="o">,</span> <span class="n">upper2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode ThreePointers"/><category term="Medium"/><category term="TwoPointers"/><category term="Review"/><summary type="html"><![CDATA[Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs. A pair (i, j) is fair if: 0 &lt;= i &lt; j &lt; n, and lower &lt;= nums[i] + nums[j] &lt;= upper]]></summary></entry><entry><title type="html">1123. Lowest Common Ancestor of Deepest Leaves</title><link href="https://zhengstar94.github.io//blog/2025/LowestCommonAncestorOfDeepestLeaves/" rel="alternate" type="text/html" title="1123. Lowest Common Ancestor of Deepest Leaves"/><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LowestCommonAncestorOfDeepestLeaves</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LowestCommonAncestorOfDeepestLeaves/"><![CDATA[<ul> <li>Given the <code class="language-plaintext highlighter-rouge">root</code> of a binary tree, return <em>the lowest common ancestor of its deepest leaves</em>.</li> <li>Recall that: <ul> <li>The node of a binary tree is a leaf if and only if it has no children</li> <li>The depth of the root of the tree is <code class="language-plaintext highlighter-rouge">0</code>. if the depth of a node is <code class="language-plaintext highlighter-rouge">d</code>, the depth of each of its children is <code class="language-plaintext highlighter-rouge">d + 1</code>.</li> <li>The lowest common ancestor of a set <code class="language-plaintext highlighter-rouge">S</code> of nodes, is the node <code class="language-plaintext highlighter-rouge">A</code> with the largest depth such that every node in <code class="language-plaintext highlighter-rouge">S</code> is in the subtree with root <code class="language-plaintext highlighter-rouge">A</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest leaf-nodes of the tree.
Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree, and it's the lca of itself.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest leaf node in the tree is 2, the lca of one node is itself.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LowestCommonAncestorOfDeepestLeaves</span> <span class="o">{</span>
    <span class="c1">// Store the result node (lowest common ancestor)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="n">ans</span><span class="o">;</span>
    <span class="c1">// Track the maximum depth in the entire tree</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">maxDepth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="nf">lcaDeepestLeaves</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Reset static variables for multiple test cases</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">maxDepth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Start DFS from root with initial depth 0</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: reached null node</span>
        <span class="c1">// Update maxDepth and return current depth</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxDepth</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDepth</span><span class="o">,</span> <span class="n">depth</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">depth</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Recursively process left and right subtrees</span>
        <span class="kt">int</span> <span class="n">leftMaxDepth</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rightMaxDepth</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// If both subtrees reach the same maximum depth</span>
        <span class="c1">// and this depth equals the tree's maximum depth,</span>
        <span class="c1">// current node is a candidate for LCA</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leftMaxDepth</span> <span class="o">==</span> <span class="n">rightMaxDepth</span> <span class="o">&amp;&amp;</span> <span class="n">leftMaxDepth</span> <span class="o">==</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Return the maximum depth reached in this subtree</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftMaxDepth</span><span class="o">,</span> <span class="n">rightMaxDepth</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Balanced tree</span>
        <span class="c1">//       1</span>
        <span class="c1">//      / \</span>
        <span class="c1">//     2   3</span>
        <span class="c1">//    /     \</span>
        <span class="c1">//   4       5</span>
        <span class="nc">TreeNode</span> <span class="n">test1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>

        <span class="nc">TreeNode</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">lcaDeepestLeaves</span><span class="o">(</span><span class="n">test1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 - Expected: 1, Actual: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Unbalanced tree</span>
        <span class="c1">//       1</span>
        <span class="c1">//      / \</span>
        <span class="c1">//     2   3</span>
        <span class="c1">//    / \</span>
        <span class="c1">//   4   5</span>
        <span class="c1">//  /   /</span>
        <span class="c1">// 6   7</span>
        <span class="nc">TreeNode</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>

        <span class="nc">TreeNode</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">lcaDeepestLeaves</span><span class="o">(</span><span class="n">test2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 - Expected: 2, Actual: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="c1">// Test Case 3: Single node tree</span>
        <span class="nc">TreeNode</span> <span class="n">test3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">lcaDeepestLeaves</span><span class="o">(</span><span class="n">test3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 - Expected: 1, Actual: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><category term="Medium"/><summary type="html"><![CDATA[Given the root of a binary tree, return the lowest common ancestor of its deepest leaves. Recall that: The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1. The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.]]></summary></entry><entry><title type="html">2367. Number of Arithmetic Triplets</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfArithmeticTriplets/" rel="alternate" type="text/html" title="2367. Number of Arithmetic Triplets"/><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfArithmeticTriplets</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfArithmeticTriplets/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong>, <strong>strictly increasing</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> and a positive integer <code class="language-plaintext highlighter-rouge">diff</code>. A triplet <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is an <strong>arithmetic triplet</strong> if the following conditions are met: <ul> <li><code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code>,</li> <li><code class="language-plaintext highlighter-rouge">nums[j] - nums[i] == diff</code>, and</li> <li><code class="language-plaintext highlighter-rouge">nums[k] - nums[j] == diff</code>.</li> </ul> </li> <li>Return <em>the number of unique <strong>arithmetic triplets</strong>.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,4,6,7,10], diff = 3
Output: 2
Explanation:
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,5,6,7,8,9], diff = 2
Output: 2
Explanation:
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.ThreePointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfArithmeticTriplets</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">arithmeticTriplets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Counter for arithmetic triplets</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Pointer i for the first number in the triplet</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Pointer j for the second number in the triplet</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through the array, treating each element as the third number (x)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Move pointer j until we find a potential second number</span>
            <span class="c1">// We want: nums[j] + diff &gt;= x</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">){</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If nums[j] + diff &gt; x, no valid triplet possible with current x</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Move pointer i until we find a potential first number</span>
            <span class="c1">// We want: nums[i] + 2*diff &gt;= x</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If we found a perfect match where nums[i] + 2*diff = x,</span>
            <span class="c1">// we've found an arithmetic triplet</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">x</span><span class="o">){</span>
                <span class="n">ans</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple arithmetic triplets</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">diff1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [0,1,4,6,7,10], diff = 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">arithmeticTriplets</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">diff1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Consecutive arithmetic triplets</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">diff2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [4,5,6,7,8,9], diff = 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">arithmeticTriplets</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">diff2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode ThreePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met: i &lt; j &lt; k, nums[j] - nums[i] == diff, and nums[k] - nums[j] == diff. Return the number of unique arithmetic triplets.]]></summary></entry><entry><title type="html">2874. Maximum Value of an Ordered Triplet II</title><link href="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII/" rel="alternate" type="text/html" title="2874. Maximum Value of an Ordered Triplet II"/><published>2025-04-03T00:00:00+00:00</published><updated>2025-04-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <strong><em>the maximum value over all triplets of indices</em></strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code><em>.</em> If all such triplets have a negative value, return <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>The <strong>value of a triplet of indices</strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is equal to <code class="language-plaintext highlighter-rouge">(nums[i] - nums[j]) * nums[k]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumValueOfAnOrderedTripletII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumTripletValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                <span class="c1">// Stores maximum triplet value</span>
        <span class="kt">int</span> <span class="n">maxDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>            <span class="c1">// Tracks maximum difference between any two previous elements</span>
        <span class="kt">int</span> <span class="n">preMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>             <span class="c1">// Keeps track of maximum element seen so far</span>

        <span class="c1">// Iterate through each element in array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Update maximum triplet value using current element as nums[k]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">maxDiff</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span>

            <span class="c1">// Update maximum difference considering current element as nums[j]</span>
            <span class="n">maxDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDiff</span><span class="o">,</span> <span class="n">preMax</span> <span class="o">-</span> <span class="n">x</span><span class="o">);</span>

            <span class="c1">// Update maximum value seen so far (potential nums[i])</span>
            <span class="n">preMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">preMax</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases array with example inputs</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span>    <span class="c1">// Expected output: 77  ( ( 12-1)*7)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">19</span><span class="o">},</span>   <span class="c1">// Expected output: 133 ( ( 10-3)*19)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>            <span class="c1">// Expected output: 0   (no valid positive value possible)</span>
        <span class="o">};</span>

        <span class="c1">// Run all test cases and print results</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maximumTripletValue</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i &lt; j &lt; k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].]]></summary></entry><entry><title type="html">2873. Maximum Value of an Ordered Triplet I</title><link href="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI/" rel="alternate" type="text/html" title="2873. Maximum Value of an Ordered Triplet I"/><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <strong><em>the maximum value over all triplets of indices</em></strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code>. If all such triplets have a negative value, return <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>The <strong>value of a triplet of indices</strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is equal to <code class="language-plaintext highlighter-rouge">(nums[i] - nums[j ] ) * nums[k]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2 ] ) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2 ] ) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1 ] ) * nums[2] = -3. Hence, the answer would be 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumValueOfAnOrderedTripletI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumTripletValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the answer to store the maximum triplet value</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the maximum difference (nums[i] - nums[j]) encountered so far</span>
        <span class="kt">int</span> <span class="n">maxDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the maximum value encountered so far (potential nums[i])</span>
        <span class="kt">int</span> <span class="n">preMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate potential answer using current number as nums[k]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">maxDiff</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span>
            <span class="c1">// Update maxDiff: current number could be nums[j]</span>
            <span class="n">maxDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDiff</span><span class="o">,</span> <span class="n">preMax</span> <span class="o">-</span> <span class="n">x</span><span class="o">);</span>
            <span class="c1">// Update preMax: current number could be nums[i]</span>
            <span class="n">preMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">preMax</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases array with example inputs</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span>    <span class="c1">// Expected output: 77  ( ( 12-1)*7)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">19</span><span class="o">},</span>   <span class="c1">// Expected output: 133 ( ( 10-3)*19)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>            <span class="c1">// Expected output: 0   (no valid positive value possible)</span>
        <span class="o">};</span>

        <span class="c1">// Run all test cases and print results</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maximumTripletValue</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i &lt; j &lt; k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j ] ) * nums[k].]]></summary></entry><entry><title type="html">2140. Solving Questions With Brainpower</title><link href="https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower/" rel="alternate" type="text/html" title="2140. Solving Questions With Brainpower"/><published>2025-04-01T00:00:00+00:00</published><updated>2025-04-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">questions</code> where <code class="language-plaintext highlighter-rouge">questions[i] = [pointsi, brainpoweri]</code>.</li> <li>The array describes the questions of an exam, where you have to process the questions <strong>in order</strong> (i.e., starting from question <code class="language-plaintext highlighter-rouge">0</code>) and make a decision whether to <strong>solve</strong> or <strong>skip</strong> each question. Solving question <code class="language-plaintext highlighter-rouge">i</code> will <strong>earn</strong> you <code class="language-plaintext highlighter-rouge">pointsi</code> points but you will be <strong>unable</strong> to solve each of the next <code class="language-plaintext highlighter-rouge">brainpoweri</code> questions. If you skip question <code class="language-plaintext highlighter-rouge">i</code>, you get to make the decision on the next question. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">questions = [ [ 3, 2], [4, 3], [4, 4], [2, 5 ] ]</code>: <ul> <li>If question <code class="language-plaintext highlighter-rouge">0</code> is solved, you will earn <code class="language-plaintext highlighter-rouge">3</code> points but you will be unable to solve questions <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">2</code>.</li> <li>If instead, question <code class="language-plaintext highlighter-rouge">0</code> is skipped and question <code class="language-plaintext highlighter-rouge">1</code> is solved, you will earn <code class="language-plaintext highlighter-rouge">4</code> points but you will be unable to solve questions <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code>.</li> </ul> </li> </ul> </li> <li>Return <em>the <strong>maximum</strong> points you can earn for the exam</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: questions = [ [ 3,2],[4,3],[4,4],[2,5 ] ]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: questions = [ [ 1,1],[2,2],[3,3],[4,4],[5,5 ] ]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengxingxing
 * Date: 2025/04/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SolvingQuestionsWithBrainpower</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">mostPoints</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">questions</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Total number of questions.</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">questions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// dp[i] stores the maximum points obtainable from question i to the end.</span>
        <span class="c1">// dp[n] is the base case (0 points) for when we are beyond the last question.</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Iterate from the last question backwards.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="c1">// Retrieve the points for the current question.</span>
            <span class="kt">int</span> <span class="n">points</span> <span class="o">=</span> <span class="n">questions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="c1">// Retrieve the brainpower value (number of questions to skip after solving this question).</span>
            <span class="kt">int</span> <span class="n">jump</span> <span class="o">=</span> <span class="n">questions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Determine the next question index after solving the current one.</span>
            <span class="c1">// Ensure that nextPosition does not exceed the array bounds.</span>
            <span class="kt">int</span> <span class="n">nextPosition</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">jump</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Two options at this question:</span>
            <span class="c1">// Option 1: Solve this question → points + dp[nextPosition]</span>
            <span class="c1">// Option 2: Skip this question → dp[i + 1]</span>
            <span class="c1">// Choose the maximum of the two.</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">points</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">nextPosition</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// dp[0] holds the maximum points obtainable starting from the first question.</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1:</span>
        <span class="c1">// Explanation: Optimal strategy is to solve question 0 (3 points) and question 3 (2 points),</span>
        <span class="c1">// resulting in a total of 5 points.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">questions1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">mostPoints</span><span class="o">(</span><span class="n">questions1</span><span class="o">));</span>  <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 2:</span>
        <span class="c1">// Explanation: Optimal strategy is to skip question 0, solve question 1 (2 points)</span>
        <span class="c1">// and question 4 (5 points), resulting in a total of 7 points.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">questions2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">mostPoints</span><span class="o">(</span><span class="n">questions2</span><span class="o">));</span>  <span class="c1">// Expected output: 7</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri]. The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question. For example, given questions=[ [ 3, 2], [4, 3], [4, 4], [2, 5 ] ]: If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2. If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3. Return the maximum points you can earn for the exam.]]></summary></entry><entry><title type="html">1898. Maximum Number of Removable Characters</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfRemovableCharacters/" rel="alternate" type="text/html" title="1898. Maximum Number of Removable Characters"/><published>2025-03-31T00:00:00+00:00</published><updated>2025-03-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfRemovableCharacters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfRemovableCharacters/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">p</code> where <code class="language-plaintext highlighter-rouge">p</code> is a <strong>subsequence</strong> of <code class="language-plaintext highlighter-rouge">s</code>. You are also given a <strong>distinct 0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">removable</code> containing a subset of indices of <code class="language-plaintext highlighter-rouge">s</code> (<code class="language-plaintext highlighter-rouge">s</code> is also <strong>0-indexed</strong>).</li> <li>You want to choose an integer <code class="language-plaintext highlighter-rouge">k</code> (<code class="language-plaintext highlighter-rouge">0 &lt;= k &lt;= removable.length</code>) such that, after removing <code class="language-plaintext highlighter-rouge">k</code> characters from <code class="language-plaintext highlighter-rouge">s</code> using the <strong>first</strong> <code class="language-plaintext highlighter-rouge">k</code> indices in <code class="language-plaintext highlighter-rouge">removable</code>, <code class="language-plaintext highlighter-rouge">p</code> is still a <strong>subsequence</strong> of <code class="language-plaintext highlighter-rouge">s</code>. More formally, you will mark the character at <code class="language-plaintext highlighter-rouge">s[removable[i]]</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; k</code>, then remove all marked characters and check if <code class="language-plaintext highlighter-rouge">p</code> is still a subsequence.</li> <li>Return <em>the <strong>maximum</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>you can choose such that</em> <code class="language-plaintext highlighter-rouge">p</code> <em>is still a <strong>subsequence</strong> of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>after the removals</em>.</li> <li>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcacb", p = "ab", removable = [3,1,0]
Output: 2
Explanation: After removing the characters at indices 3 and 1, "abcacb" becomes "accb".
"ab" is a subsequence of "accb".
If we remove the characters at indices 3, 1, and 0, "abcacb" becomes "ccb", and "ab" is no longer a subsequence.
Hence, the maximum k is 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcbddddd", p = "abcd", removable = [3,2,1,4,5,6]
Output: 1
Explanation: After removing the character at index 3, "abcbddddd" becomes "abcddddd".
"abcd" is a subsequence of "abcddddd".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcab", p = "abc", removable = [0,1,2,3,4]
Output: 0
Explanation: If you remove the first index in the array removable, "abc" is no longer a subsequence.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(m)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfRemovableCharacters</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumRemovals</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">removable</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize binary search boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">removable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Binary search process</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point (using ceiling division to avoid infinite loop)</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If we can remove mid characters, try removing more</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canRemoveKCharacters</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">removable</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we can't remove mid characters, try removing fewer</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canRemoveKCharacters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">removable</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create boolean array to mark characters that should be removed</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">removed</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>

        <span class="c1">// Mark first k positions from removable array as true</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">removed</span><span class="o">[</span><span class="n">removable</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Use two pointers to check if p is still a subsequence</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Pointer for string p</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Skip removed characters</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">removed</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If characters match, advance pointer for string p</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return true if we found all characters of p</span>
        <span class="k">return</span> <span class="n">j</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcacb"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">p1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">removable1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maximumRemovals</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">p1</span><span class="o">,</span> <span class="n">removable1</span><span class="o">));</span>

        <span class="c1">// Test Case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcbddddd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">p2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">removable2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maximumRemovals</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">p2</span><span class="o">,</span> <span class="n">removable2</span><span class="o">));</span>

        <span class="c1">// Test Case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abcab"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">p3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">removable3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maximumRemovals</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">p3</span><span class="o">,</span> <span class="n">removable3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed). You want to choose an integer k (0 &lt;= k &lt;= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 &lt;= i &lt; k, then remove all marked characters and check if p is still a subsequence. Return the maximum k you can choose such that p is still a subsequence of s after the removals. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.]]></summary></entry><entry><title type="html">2278. Percentage of Letter in String</title><link href="https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString/" rel="alternate" type="text/html" title="2278. Percentage of Letter in String"/><published>2025-03-31T00:00:00+00:00</published><updated>2025-03-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a character <code class="language-plaintext highlighter-rouge">letter</code>, return <em>the <strong>percentage</strong> of characters in</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that equal</em> <code class="language-plaintext highlighter-rouge">letter</code> <em><strong>rounded down</strong> to the nearest whole percent.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "foobar", letter = "o"
Output: 33
Explanation:
The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "jjjj", letter = "k"
Output: 0
Explanation:
The percentage of characters in s that equal the letter 'k' is 0%, so we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PercentageOfLetterInString</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">percentageLetter</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">letter</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize counter to track letter occurrences</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Increment counter when matching letter is found</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">letter</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Calculate and return the percentage rounded down</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">count</span> <span class="o">*</span> <span class="mi">100</span><span class="o">)</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String with multiple occurrences of target letter</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"foobar"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter1</span> <span class="o">=</span> <span class="sc">'o'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">letter1</span><span class="o">));</span> <span class="c1">// Expected output: 33</span>

        <span class="c1">// Test Case 2: String without any occurrence of target letter</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"jjjj"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter2</span> <span class="o">=</span> <span class="sc">'k'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">letter2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 3: Additional test case with target letter 'e'</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"percentage"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter3</span> <span class="o">=</span> <span class="sc">'e'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">letter3</span><span class="o">));</span> <span class="c1">// Expected output: 30</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.]]></summary></entry><entry><title type="html">2109. Adding Spaces to a String</title><link href="https://zhengstar94.github.io//blog/2025/AddingSpacesToAString/" rel="alternate" type="text/html" title="2109. Adding Spaces to a String"/><published>2025-03-30T00:00:00+00:00</published><updated>2025-03-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AddingSpacesToAString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AddingSpacesToAString/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> string <code class="language-plaintext highlighter-rouge">s</code> and a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">spaces</code> that describes the indices in the original string where spaces will be added. Each space should be inserted <strong>before</strong> the character at the given index. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">s = "EnjoyYourCoffee"</code> and <code class="language-plaintext highlighter-rouge">spaces = [5, 9]</code>, we place spaces before <code class="language-plaintext highlighter-rouge">'Y'</code> and <code class="language-plaintext highlighter-rouge">'C'</code>, which are at indices <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">9</code> respectively. Thus, we obtain <code class="language-plaintext highlighter-rouge">"Enjoy **Y**our **C**offee"</code>.</li> </ul> </li> <li>Return <em>the modified string <strong>after</strong> the spaces have been added.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "LeetcodeHelpsMeLearn", spaces = [8,13,15]
Output: "Leetcode Helps Me Learn"
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in "LeetcodeHelpsMeLearn".
We then place spaces before those characters.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "icodeinpython", spaces = [1,5,7,9]
Output: "i code in py thon"
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in "icodeinpython".
We then place spaces before those characters.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "spacing", spaces = [0,1,2,3,4,5,6]
Output: " s p a c i n g"
Explanation:
We are also able to place spaces before the first character of the string.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddingSpacesToAString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">addSpaces</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize StringBuilder with optimal capacity to avoid resizing</span>
        <span class="nc">StringBuilder</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="n">spaces</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

        <span class="c1">// Counter for tracking the current position in spaces array</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if we need to add a space at current position</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">spaces</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">spaces</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">' '</span><span class="o">);</span>
                <span class="n">j</span><span class="o">++;</span> <span class="c1">// Move to next space position</span>
            <span class="o">}</span>
            <span class="c1">// Append the current character from input string</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Adding spaces in a camel case string</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"LeetcodeHelpsMeLearn"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">spaces1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Adding spaces in a lowercase string</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"icodeinpython"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">spaces2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Adding spaces between every character</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"spacing"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">spaces3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index. For example, given s="EnjoyYourCoffee" and spaces=[5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain "Enjoy **Y**our **C**offee". Return the modified string after the spaces have been added.]]></summary></entry><entry><title type="html">763. Partition Labels</title><link href="https://zhengstar94.github.io//blog/2025/PartitionLabels/" rel="alternate" type="text/html" title="763. Partition Labels"/><published>2025-03-30T00:00:00+00:00</published><updated>2025-03-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PartitionLabels</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PartitionLabels/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string <code class="language-plaintext highlighter-rouge">"ababcc"</code> can be partitioned into <code class="language-plaintext highlighter-rouge">["abab", "cc"]</code>, but partitions such as <code class="language-plaintext highlighter-rouge">["aba", "bcc"]</code> or <code class="language-plaintext highlighter-rouge">["ab", "ab", "cc"]</code> are invalid.</li> <li>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Return <em>a list of integers representing the size of these parts</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "eccbbbbdec"
Output: [10]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PartitionLabels</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">partitionLabels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the last position of each character (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">lastPos</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// First pass: Record the last occurrence of each character</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lastPos</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// List to store the sizes of partitions</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Variables to track partition boundaries</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Start index of current partition</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// End index of current partition</span>

        <span class="c1">// Second pass: Determine partition boundaries</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update the end position of current partition</span>
            <span class="c1">// by taking the maximum of current end and last occurrence of current character</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">lastPos</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]);</span>

            <span class="c1">// If we've reached the end of current partition</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Calculate partition size and add to result</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update start position for next partition</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String with multiple partitions</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"ababcbacadefegdehijhklij"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected output: [9,7,8]</span>

        <span class="c1">// Test Case 2: String with single partition</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"eccbbbbdec"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: [10]</span>

        <span class="c1">// Test Case 3: String where each character forms its own partition</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected output: [1,1,1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string "ababcc" can be partitioned into ["abab", "cc"], but partitions such as ["aba", "bcc"] or ["ab", "ab", "cc"] are invalid. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.]]></summary></entry></feed>