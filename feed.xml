<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-29T03:10:56+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2684. Maximum Number of Moves in a Grid</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfMovesInAGrid/" rel="alternate" type="text/html" title="2684. Maximum Number of Moves in a Grid"/><published>2025-06-29T00:00:00+00:00</published><updated>2025-06-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfMovesInAGrid</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfMovesInAGrid/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">grid</code> consisting of <strong>positive</strong> integers.</li> <li>You can start at <strong>any</strong> cell in the first column of the matrix, and traverse the grid in the following way: <ul> <li>From a cell <code class="language-plaintext highlighter-rouge">(row, col)</code>, you can move to any of the cells: <code class="language-plaintext highlighter-rouge">(row - 1, col + 1)</code>, <code class="language-plaintext highlighter-rouge">(row, col + 1)</code> and <code class="language-plaintext highlighter-rouge">(row + 1, col + 1)</code> such that the value of the cell you move to, should be <strong>strictly</strong> bigger than the value of the current cell.</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> number of <strong>moves</strong> that you can perform.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15 ] ]
Output: 3
Explanation: We can start at the cell (0, 0) and make the following moves:
- (0, 0) -&gt; (0, 1).
- (0, 1) -&gt; (1, 2).
- (1, 2) -&gt; (2, 3).
It can be shown that it is the maximum number of moves that can be made.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 3,2,4],[2,1,9],[1,1,7 ] ]
Output: 0
Explanation: Starting from any cell in the first column we cannot perform any moves.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfMovesInAGrid</span> <span class="o">{</span>
   
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxMoves</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the number of rows (m) and columns (n) in the grid</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create a memoization array to store the maximum moves from each cell</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// Initialize the memo array with -1, meaning no cell has been computed yet</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Variable to keep track of the overall maximum moves</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Try starting from every cell in the first column</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update the result with the maximum moves from this starting cell</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">memo</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// Return the maximum number of moves found</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the grid dimensions</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// If we are already at the last column, no more moves can be made</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// If this cell's result has already been computed, return it directly</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">// Initialize the maximum moves from this cell as 0</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Define the three possible row directions: up, straight, down</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">directions</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Try all three possible moves: right-up, right, right-down</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">directions</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the next row and next column after the move</span>
            <span class="kt">int</span> <span class="n">nextRow</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">dir</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">nextCol</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Check if the next cell is within the grid and its value is strictly greater</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextRow</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nextRow</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">nextRow</span><span class="o">][</span><span class="n">nextCol</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Recursively compute the moves from the next cell and add 1 for this move</span>
                <span class="kt">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">memo</span><span class="o">,</span> <span class="n">nextRow</span><span class="o">,</span> <span class="n">nextCol</span><span class="o">);</span>
                <span class="c1">// Take the maximum among all possible moves from this cell</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">steps</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Store the computed result in the memo array for future reference</span>
        <span class="n">memo</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
        <span class="c1">// Return the maximum moves from this cell</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Output the results for both test cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxMoves</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxMoves</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed m x n matrix grid consisting of positive integers. You can start at any cell in the first column of the matrix, and traverse the grid in the following way: From a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell. Return the maximum number of moves that you can perform.]]></summary></entry><entry><title type="html">2099. Find Subsequence of Length K With the Largest Sum</title><link href="https://zhengstar94.github.io//blog/2025/FindSubsequenceOfLengthKWithTheLargestSum/" rel="alternate" type="text/html" title="2099. Find Subsequence of Length K With the Largest Sum"/><published>2025-06-28T00:00:00+00:00</published><updated>2025-06-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindSubsequenceOfLengthKWithTheLargestSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindSubsequenceOfLengthKWithTheLargestSum/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>. You want to find a <strong>subsequence</strong> of <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">k</code> that has the <strong>largest</strong> sum.</li> <li>Return <em><strong>any</strong> such subsequence as an integer array of length</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,3,3], k = 2
Output: [3,3]
Explanation:
The subsequence has the largest sum of 3 + 3 = 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,-2,3,4], k = 3
Output: [-1,3,4]
Explanation: 
The subsequence has the largest sum of -1 + 3 + 4 = 6.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,4,3,3], k = 2
Output: [3,4]
Explanation:
The subsequence has the largest sum of 3 + 4 = 7. 
Another possible subsequence is [4, 3].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindSubsequenceOfLengthKWithTheLargestSum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSubsequence</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a 2D array to store pairs of values and their original indices.</span>
        <span class="c1">// The first column will hold the values from nums, and the second column will hold their indices.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">pairs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

        <span class="c1">// Populate the pairs array with values and their corresponding indices.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pairs</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Store the value from nums</span>
            <span class="n">pairs</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>       <span class="c1">// Store the original index of the value</span>
        <span class="o">}</span>

        <span class="c1">// Sort the pairs array based on the values in descending order.</span>
        <span class="c1">// This allows us to easily access the largest values.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">pairs</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// Extract the top k elements from the sorted pairs array.</span>
        <span class="c1">// These elements will be the largest k values along with their indices.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">topK</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">pairs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>

        <span class="c1">// Sort the top k elements based on their original indices to maintain the order in the original array.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">topK</span><span class="o">,</span> <span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>

        <span class="c1">// Create an array to hold the result subsequence.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>

        <span class="c1">// Populate the result array with the values from the top k elements.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">topK</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Extract the value from the sorted top k elements</span>
        <span class="o">}</span>

        <span class="c1">// Return the resulting subsequence.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Main method to test the maxSubsequence function with various test cases.</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">// Expected output: [3, 3]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">maxSubsequence</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">)));</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="c1">// Expected output: [-1, 3, 4]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">maxSubsequence</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">)));</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">// Expected output: [3, 4]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">maxSubsequence</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum. Return any such subsequence as an integer array of length k. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.]]></summary></entry><entry><title type="html">463. Island Perimeter</title><link href="https://zhengstar94.github.io//blog/2025/IslandPerimeter/" rel="alternate" type="text/html" title="463. Island Perimeter"/><published>2025-06-27T00:00:00+00:00</published><updated>2025-06-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/IslandPerimeter</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/IslandPerimeter/"><![CDATA[<ul> <li>You are given <code class="language-plaintext highlighter-rouge">row x col</code> <code class="language-plaintext highlighter-rouge">grid</code> representing a map where <code class="language-plaintext highlighter-rouge">grid[i][j] = 1</code> represents land and <code class="language-plaintext highlighter-rouge">grid[i][j] = 0</code> represents water.</li> <li>Grid cells are connected <strong>horizontally/vertically</strong> (not diagonally). The <code class="language-plaintext highlighter-rouge">grid</code> is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</li> <li>The island doesn’t have “lakes”, meaning the water inside isn’t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0 ] ]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1 ] ]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,0 ] ]
Output: 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IslandPerimeter</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>        <span class="c1">// Number of rows in the grid</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>     <span class="c1">// Number of columns in the grid</span>
        <span class="kt">int</span> <span class="n">perimeter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>          <span class="c1">// Variable to store the total perimeter</span>

        <span class="c1">// Traverse each cell in the grid</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If the current cell is land</span>
                <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="c1">// Each land cell initially contributes 4 to the perimeter</span>
                    <span class="n">perimeter</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span>

                    <span class="c1">// If the cell above (i-1, j) is also land,</span>
                    <span class="c1">// it means the current cell shares a border with the upper cell.</span>
                    <span class="c1">// Each shared border should be subtracted twice (once for each cell),</span>
                    <span class="c1">// so we subtract 2 from the perimeter.</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">perimeter</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// If the cell to the left (i, j-1) is also land,</span>
                    <span class="c1">// it means the current cell shares a border with the left cell.</span>
                    <span class="c1">// Again, subtract 2 for the shared border.</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">perimeter</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total calculated perimeter</span>
        <span class="k">return</span> <span class="n">perimeter</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example from the problem description</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">islandPerimeter</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Output: 16</span>

        <span class="c1">// Test case 2: Single land cell</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">islandPerimeter</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Output: 4</span>

        <span class="c1">// Test case 3: Two land cells in a row</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">islandPerimeter</span><span class="o">(</span><span class="n">grid3</span><span class="o">));</span> <span class="c1">// Output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><category term="Easy"/><summary type="html"><![CDATA[You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes”, meaning the water inside isn’t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.]]></summary></entry><entry><title type="html">695. Max Area of Island</title><link href="https://zhengstar94.github.io//blog/2025/MaxAreaOfIsland/" rel="alternate" type="text/html" title="695. Max Area of Island"/><published>2025-06-26T00:00:00+00:00</published><updated>2025-06-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxAreaOfIsland</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxAreaOfIsland/"><![CDATA[<ul> <li>You are given an <code class="language-plaintext highlighter-rouge">m x n</code> binary matrix <code class="language-plaintext highlighter-rouge">grid</code>. An island is a group of <code class="language-plaintext highlighter-rouge">1</code>’s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</li> <li>The <strong>area</strong> of an island is the number of cells with a value <code class="language-plaintext highlighter-rouge">1</code> in the island.</li> <li>Return <em>the maximum <strong>area</strong> of an island in</em> <code class="language-plaintext highlighter-rouge">grid</code>. If there is no island, return <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0 ] ]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,0,0,0,0,0,0,0 ] ]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxAreaOfIsland</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxAreaOfIsland</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxArea</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// To keep track of the largest island area found</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Number of rows in the grid</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Number of columns in the grid</span>

        <span class="c1">// Traverse every cell in the grid</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If the current cell is land (1), start a DFS to calculate the area of this island</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="c1">// Update maxArea if the current island's area is larger</span>
                    <span class="n">maxArea</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxArea</span><span class="o">,</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxArea</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Number of rows</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Number of columns</span>

        <span class="c1">// If out of bounds or the cell is water (0), return 0 (no area)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Mark the current cell as visited by setting it to 0 (water)</span>
        <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Current cell counts as 1 area</span>

        <span class="c1">// Recursively explore all four directions and sum up the area</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span> <span class="c1">// Down</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span> <span class="c1">// Up</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// Right</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// Left</span>

        <span class="k">return</span> <span class="n">area</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the maxAreaOfIsland function with sample test cases.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Output should be 6 for grid1 and 0 for grid2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxAreaOfIsland</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Output: 6</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxAreaOfIsland</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><category term="Medium"/><summary type="html"><![CDATA[You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0.]]></summary></entry><entry><title type="html">1081. Smallest Subsequence of Distinct Characters</title><link href="https://zhengstar94.github.io//blog/2025/SmallestSubsequenceOfDistinctCharacters/" rel="alternate" type="text/html" title="1081. Smallest Subsequence of Distinct Characters"/><published>2025-06-23T00:00:00+00:00</published><updated>2025-06-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SmallestSubsequenceOfDistinctCharacters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SmallestSubsequenceOfDistinctCharacters/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the</em> <em>lexicographically smallest</em> <em>subsequence</em> <em>of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that contains all the distinct characters of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>exactly once</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bcabc"
Output: "abc"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cbacdcbc"
Output: "acdb"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SmallestSubsequenceOfDistinctCharacters</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">smallestSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to count the remaining occurrences of each character in the string.</span>
        <span class="c1">// We use 128 to cover all ASCII characters.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

        <span class="c1">// Boolean array to record whether a character is already in the stack (result).</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

        <span class="c1">// First pass: count the occurrences of each character in the string.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Stack to build the result subsequence.</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each character in the string.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Decrement the count since we are now visiting this character.</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span><span class="o">]--;</span>

            <span class="c1">// If the character is already in the stack, skip it to ensure uniqueness.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">c</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// This loop ensures the lexicographical order is minimal:</span>
            <span class="c1">// - While the stack is not empty,</span>
            <span class="c1">// - and the current character is smaller than the character at the top of the stack,</span>
            <span class="c1">// - and the character at the top of the stack will appear again later (count &gt; 0),</span>
            <span class="c1">// we can safely remove the top character to get a smaller lexicographical order.</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Mark the removed character as not visited so it can be added again later.</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pollLast</span><span class="o">()]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Add the current character to the stack and mark it as visited.</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="n">visited</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Build the final result from the stack.</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span><span class="s">"bcabc"</span><span class="o">,</span> <span class="s">"cbacdcbc"</span><span class="o">};</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">smallestSubsequence</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.]]></summary></entry><entry><title type="html">2138. Divide a String Into Groups of Size k</title><link href="https://zhengstar94.github.io//blog/2025/DivideAStringIntoGroupsOfSizek/" rel="alternate" type="text/html" title="2138. Divide a String Into Groups of Size k"/><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DivideAStringIntoGroupsOfSizek</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DivideAStringIntoGroupsOfSizek/"><![CDATA[<ul> <li>A string <code class="language-plaintext highlighter-rouge">s</code> can be partitioned into groups of size <code class="language-plaintext highlighter-rouge">k</code> using the following procedure: <ul> <li>The first group consists of the first <code class="language-plaintext highlighter-rouge">k</code> characters of the string, the second group consists of the next <code class="language-plaintext highlighter-rouge">k</code> characters of the string, and so on. Each element can be a part of <strong>exactly one</strong> group.</li> <li>For the last group, if the string <strong>does not</strong> have <code class="language-plaintext highlighter-rouge">k</code> characters remaining, a character <code class="language-plaintext highlighter-rouge">fill</code> is used to complete the group.</li> </ul> </li> <li>Note that the partition is done so that after removing the <code class="language-plaintext highlighter-rouge">fill</code> character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Given the string <code class="language-plaintext highlighter-rouge">s</code>, the size of each group <code class="language-plaintext highlighter-rouge">k</code> and the character <code class="language-plaintext highlighter-rouge">fill</code>, return <em>a string array denoting the <strong>composition of every group</strong></em> <code class="language-plaintext highlighter-rouge">s</code> <em>has been divided into, using the above procedure</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcdefghi", k = 3, fill = "x"
Output: ["abc","def","ghi"]
Explanation:
The first 3 characters "abc" form the first group.
The next 3 characters "def" form the second group.
The last 3 characters "ghi" form the third group.
Since all groups can be completely filled by characters from the string, we do not need to use fill.
Thus, the groups formed are "abc", "def", and "ghi".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcdefghij", k = 3, fill = "x"
Output: ["abc","def","ghi","jxx"]
Explanation:
Similar to the previous example, we are forming the first three groups "abc", "def", and "ghi".
For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.
Thus, the 4 groups formed are "abc", "def", "ghi", and "jxx".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DivideAStringIntoGroupsOfSizek</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">divideString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">char</span> <span class="n">fill</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// Get the length of the input string.</span>

        <span class="c1">// Calculate the total number of groups needed.</span>
        <span class="c1">// (n + k - 1) / k is a common trick to perform integer division with rounding up.</span>
        <span class="c1">// For example, if n=10 and k=3, (10+3-1)/3 = 12/3 = 4 groups.</span>
        <span class="c1">// This ensures that if there are leftover characters, we still allocate a group for them.</span>
        <span class="kt">int</span> <span class="n">groupCount</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">k</span><span class="o">;</span>

        <span class="c1">// Create an array to store the resulting groups.</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">groupCount</span><span class="o">];</span>

        <span class="c1">// Iterate over each group index.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">groupCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate the starting index of the current group in the original string.</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span><span class="o">;</span>

            <span class="c1">// Calculate the ending index (exclusive) for the current group.</span>
            <span class="c1">// Use Math.min to avoid going out of bounds if the last group is shorter than k.</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

            <span class="c1">// Use StringBuilder for efficient string concatenation.</span>
            <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

            <span class="c1">// Append the substring for the current group.</span>
            <span class="c1">// This will add all available characters from start to end (end not included).</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

            <span class="c1">// If the current group is shorter than k, pad it with the fill character.</span>
            <span class="c1">// This loop will add as many fill characters as needed to reach length k.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">fill</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Convert the StringBuilder to a String and store it in the result array.</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Return the array containing all the groups.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Main method with test cases to demonstrate the function.</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: String length is a multiple of k, no padding needed.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">divideString</span><span class="o">(</span><span class="s">"abcdefghi"</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="sc">'x'</span><span class="o">)</span> <span class="o">)</span> <span class="o">);</span> <span class="c1">// Output: ["abc", "def", "ghi"]</span>

        <span class="c1">// Test case 2: String length is not a multiple of k, last group needs padding.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">divideString</span><span class="o">(</span><span class="s">"abcdefghij"</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="sc">'x'</span><span class="o">)</span> <span class="o">)</span> <span class="o">);</span> <span class="c1">// Output: ["abc", "def", "ghi", "jxx"]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[A string s can be partitioned into groups of size k using the following procedure: The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each element can be a part of exactly one group. For the last group, if the string does not have k characters remaining, a character fill is used to complete the group. Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s. Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.]]></summary></entry><entry><title type="html">1673. Find the Most Competitive Subsequence</title><link href="https://zhengstar94.github.io//blog/2025/FindTheMostCompetitiveSubsequence/" rel="alternate" type="text/html" title="1673. Find the Most Competitive Subsequence"/><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheMostCompetitiveSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheMostCompetitiveSubsequence/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and a positive integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the most <strong>competitive</strong> subsequence of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>of size</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>An array’s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.</li> <li>We define that a subsequence <code class="language-plaintext highlighter-rouge">a</code> is more <strong>competitive</strong> than a subsequence <code class="language-plaintext highlighter-rouge">b</code> (of the same length) if in the first position where <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> differ, subsequence <code class="language-plaintext highlighter-rouge">a</code> has a number <strong>less</strong> than the corresponding number in <code class="language-plaintext highlighter-rouge">b</code>. For example, <code class="language-plaintext highlighter-rouge">[1,3,4]</code> is more competitive than <code class="language-plaintext highlighter-rouge">[1,3,5]</code> because the first position they differ is at the final number, and <code class="language-plaintext highlighter-rouge">4</code> is less than <code class="language-plaintext highlighter-rouge">5</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,5,2,6], k = 2
Output: [2,6]
Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,3,3,5,4,9,6], k = 4
Output: [2,3,3,4]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheMostCompetitiveSubsequence</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">mostCompetitive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Use an array to simulate a stack, which will store the result subsequence.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="c1">// 'top' is the pointer to the next available position in the stack (also represents the current stack size).</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// While the stack is not empty,</span>
            <span class="c1">// and the current element is smaller than the top element of the stack,</span>
            <span class="c1">// and there are enough elements left in nums to fill the stack to size k after popping:</span>
            <span class="c1">//    - Pop the stack (i.e., remove the last element from the current subsequence).</span>
            <span class="c1">//    - This ensures that the subsequence remains as lexicographically small as possible.</span>
            <span class="c1">//    - The condition (n - i) &gt; (k - top) is crucial:</span>
            <span class="c1">//      It checks if, after popping, there are still enough elements left to fill the subsequence to length k.</span>
            <span class="c1">//      If not, we must keep the current stack elements to avoid ending up with fewer than k elements.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">top</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">[</span><span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">top</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">top</span><span class="o">--;</span> <span class="c1">// Pop the top element from the stack.</span>
            <span class="o">}</span>
            <span class="c1">// If the stack is not yet full (less than k elements), push the current element onto the stack.</span>
            <span class="c1">// This ensures we always build a subsequence of exactly length k.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">[</span><span class="n">top</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// At the end, 'stack' contains the most competitive subsequence of length k.</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: Input array [3,5,2,6], k = 2</span>
        <span class="c1">// Expected output: [2,6]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">mostCompetitive</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span> <span class="mi">2</span><span class="o">)));</span> <span class="c1">// [2,6]</span>

        <span class="c1">// Example 2: Input array [2,4,3,3,5,4,9,6], k = 4</span>
        <span class="c1">// Expected output: [2,3,3,4]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">mostCompetitive</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span> <span class="mi">4</span><span class="o">)));</span> <span class="c1">// [2,3,3,4]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k. An array’s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5.]]></summary></entry><entry><title type="html">316. Remove Duplicate Letters</title><link href="https://zhengstar94.github.io//blog/2025/RemoveDuplicateLetters/" rel="alternate" type="text/html" title="316. Remove Duplicate Letters"/><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RemoveDuplicateLetters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RemoveDuplicateLetters/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <strong>the smallest in lexicographical order</strong> among all possible results.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bcabc"
Output: "abc"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cbacdcbc"
Output: "acdb"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveDuplicateLetters</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">removeDuplicateLetters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span> <span class="c1">// Array to count the remaining occurrences of each character.</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">inStack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span> <span class="c1">// Flags to indicate if a character is already in the stack.</span>

        <span class="c1">// First pass: count the occurrences of each character in the string.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span> <span class="c1">// Monotonic stack to build the result.</span>

        <span class="c1">// Iterate through each character in the string.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span> <span class="c1">// Decrement the count for this character, as it's now being processed.</span>

            <span class="c1">// If the character is already in the stack, skip it to avoid duplicates.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">inStack</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * While the stack is not empty, and the current character is lexicographically
             * smaller than the character at the top of the stack, and the character at the
             * top of the stack will appear again later (count &gt; 0):
             *   - Pop the top character from the stack.
             *   - Mark it as not in the stack.
             * This ensures that:
             *   1. The result remains lexicographically smallest by removing bigger letters
             *      that can still be placed later.
             *   2. Each letter appears only once in the result.
             */</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span>
                    <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span>
                    <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">removed</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span> <span class="c1">// Remove the top character from the stack.</span>
                <span class="n">inStack</span><span class="o">[</span><span class="n">removed</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>    <span class="c1">// Mark the removed character as not in the stack.</span>
            <span class="o">}</span>

            <span class="c1">// Add the current character to the stack and mark it as present.</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="n">inStack</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Build the final result string from the characters in the stack.</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeDuplicateLetters</span><span class="o">(</span><span class="s">"bcabc"</span><span class="o">));</span>      <span class="c1">// Output: "abc"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeDuplicateLetters</span><span class="o">(</span><span class="s">"cbacdcbc"</span><span class="o">));</span>   <span class="c1">// Output: "acdb"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.]]></summary></entry><entry><title type="html">3085. Minimum Deletions to Make String K-Special</title><link href="https://zhengstar94.github.io//blog/2025/MinimumDeletionsToMakeStringKSpecial/" rel="alternate" type="text/html" title="3085. Minimum Deletions to Make String K-Special"/><published>2025-06-21T00:00:00+00:00</published><updated>2025-06-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumDeletionsToMakeStringKSpecial</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumDeletionsToMakeStringKSpecial/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">word</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>We consider <code class="language-plaintext highlighter-rouge">word</code> to be <strong>k-special</strong> if <code class="language-plaintext highlighter-rouge">|freq(word[i]) - freq(word[j])| &lt;= k</code> for all indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> in the string.</li> <li>Here, <code class="language-plaintext highlighter-rouge">freq(x)</code> denotes the frequency of the character <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">word</code>, and <code class="language-plaintext highlighter-rouge">|y|</code> denotes the absolute value of <code class="language-plaintext highlighter-rouge">y</code>.</li> <li>Return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code class="language-plaintext highlighter-rouge">word</code> <strong>*k-special*</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "aabcaba", k = 0

Output: 3

Explanation: We can make word 0-special by deleting 2 occurrences of "a" and 1 occurrence of "c". Therefore, word becomes equal to "baba" where freq('a') == freq('b') == 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "dabdcbdcdcd", k = 2

Output: 2

Explanation: We can make word 2-special by deleting 1 occurrence of "a" and 1 occurrence of "d". Therefore, word becomes equal to "bdcbdcdcd" where freq('b') == 2, freq('c') == 3, and freq('d') == 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "aaabaaa", k = 2

Output: 1

Explanation: We can make word 2-special by deleting 1 occurrence of "b". Therefore, word becomes equal to "aaaaaa" where each letter's frequency is now uniformly 6.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumDeletionsToMakeStringKSpecial</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumDeletions</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Count the frequency of each character in the string.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">freq</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Collect all non-zero frequencies into a list.</span>
        <span class="c1">// Only characters that appear in the string are relevant for further processing.</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freqList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">f</span> <span class="o">:</span> <span class="n">freq</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">freqList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Try every possible lower bound (lo) for the frequency interval [lo, lo + k].</span>
        <span class="c1">// The goal is to find the interval that requires the fewest deletions to fit all frequencies within it.</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="c1">// Initialize the answer with a large value.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lo</span> <span class="o">:</span> <span class="n">freqList</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This will count the number of deletions needed for the current interval.</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">freqList</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// If the frequency is less than the lower bound, we must delete all occurrences of this character.</span>
                    <span class="n">cnt</span> <span class="o">+=</span> <span class="n">v</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// If the frequency is greater than the upper bound, we must delete the excess occurrences.</span>
                    <span class="n">cnt</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">-</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">k</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">// If v is within [lo, lo + k], no deletion is needed for this character.</span>
            <span class="o">}</span>
            <span class="c1">// Update the answer if the current interval requires fewer deletions.</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Step 4: Return the minimum deletions found.</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to verify the solution.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"aabcaba"</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"dabdcbdcdcd"</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"aaabaaa"</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"abc"</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span> <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"aaaaa"</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string word and an integer k. We consider word to be k-special if |freq(word[i]) - freq(word[j])| &lt;= k for all indices i and j in the string. Here, freq(x) denotes the frequency of the character x in word, and |y| denotes the absolute value of y. Return the minimum number of characters you need to delete to make word *k-special*.]]></summary></entry><entry><title type="html">3443. Maximum Manhattan Distance After K Changes</title><link href="https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK/" rel="alternate" type="text/html" title="3443. Maximum Manhattan Distance After K Changes"/><published>2025-06-20T00:00:00+00:00</published><updated>2025-06-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> consisting of the characters <code class="language-plaintext highlighter-rouge">'N'</code>, <code class="language-plaintext highlighter-rouge">'S'</code>, <code class="language-plaintext highlighter-rouge">'E'</code>, and <code class="language-plaintext highlighter-rouge">'W'</code>, where <code class="language-plaintext highlighter-rouge">s[i]</code> indicates movements in an infinite grid: <ul> <li><code class="language-plaintext highlighter-rouge">'N'</code> : Move north by 1 unit.</li> <li><code class="language-plaintext highlighter-rouge">'S'</code> : Move south by 1 unit.</li> <li><code class="language-plaintext highlighter-rouge">'E'</code> : Move east by 1 unit.</li> <li><code class="language-plaintext highlighter-rouge">'W'</code> : Move west by 1 unit.</li> </ul> </li> <li>Initially, you are at the origin <code class="language-plaintext highlighter-rouge">(0, 0)</code>. You can change <strong>at most</strong> <code class="language-plaintext highlighter-rouge">k</code> characters to any of the four directions.</li> <li>Find the <strong>maximum</strong> <strong>Manhattan distance</strong> from the origin that can be achieved <strong>at any time</strong> while performing the movements <strong>in order</strong>.</li> <li>The <strong>Manhattan Distance</strong> between two cells <code class="language-plaintext highlighter-rouge">(xi, yi)</code> and <code class="language-plaintext highlighter-rouge">(xj, yj)</code> is <code class="language-plaintext highlighter-rouge">|xi - xj| + |yi - yj|</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "NWSE", k = 1

Output: 3

Explanation:

Change s[2] from 'S' to 'N'. The string s becomes "NWNE".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "NSWWEW", k = 3

Output: 6

Explanation:

Change s[1] from 'S' to 'N', and s[4] from 'E' to 'W'. The string s becomes "NNWWWW".

The maximum Manhattan distance from the origin that can be achieved is 6. Hence, 6 is the output.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumManhattanDistanceAfterKChanges</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ans: stores the maximum Manhattan distance found so far</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// x, y: current coordinates on the infinite grid (starting from origin 0,0)</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Simulate the movement step by step</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="c1">// Update current position based on the movement character</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'N'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">y</span><span class="o">++;</span>  <span class="c1">// Move north: increase y-coordinate</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'S'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">y</span><span class="o">--;</span>  <span class="c1">// Move south: decrease y-coordinate  </span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'E'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">x</span><span class="o">++;</span>  <span class="c1">// Move east: increase x-coordinate</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>  <span class="c1">// c == 'W'</span>
                <span class="n">x</span><span class="o">--;</span>  <span class="c1">// Move west: decrease x-coordinate</span>
            <span class="o">}</span>

            <span class="cm">/*
             * CRITICAL FORMULA EXPLANATION:
             *
             * Math.abs(x) + Math.abs(y) + k * 2:
             * - This represents the THEORETICAL maximum distance we could achieve at this step
             * - Math.abs(x) + Math.abs(y): current actual Manhattan distance from origin
             * - k * 2: maximum additional distance we can gain through k character changes
             *   (each change can add up to 2 units of distance)
             *
             * i + 1:
             * - This represents the PHYSICAL maximum distance possible
             * - Since we've taken (i+1) steps total, we cannot be more than (i+1) units away from origin
             * - This is a fundamental physical constraint in any grid movement
             *
             * Math.min(theoretical_max, physical_max):
             * - We take the minimum because both constraints must be satisfied
             * - Even if we could theoretically reach distance 100 with our changes,
             *   if we've only taken 5 steps, we can't be more than 5 units away
             *
             * Example walkthrough:
             * s = "NWSE", k = 1, at step 3 (after "NWS"):
             * - Current position: (-1, 0), current distance = 1
             * - Theoretical max: 1 + 1*2 = 3 (current distance + max improvement from 1 change)
             * - Physical max: 3 (we've taken 3 steps)
             * - Actual max at this step: min(3, 3) = 3
             */</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic example showing the greedy approach</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"NWSE"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = \""</span> <span class="o">+</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">"\", k = "</span> <span class="o">+</span> <span class="n">k1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDistance</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Explanation: At step 2, current distance=2, 2+2*1=4, but only walked 2 steps, so min(4,2)=2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"             At step 3, current distance=1, 1+2*1=3, walked 3 steps, so min(3,3)=3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: More complex example with multiple changes</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"NSWWEW"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = \""</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="s">"\", k = "</span> <span class="o">+</span> <span class="n">k2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDistance</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Explanation: With 3 changes, we can potentially add up to 6 units of distance"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s consisting of the characters 'N', 'S', 'E', and 'W', where s[i] indicates movements in an infinite grid: 'N' : Move north by 1 unit. 'S' : Move south by 1 unit. 'E' : Move east by 1 unit. 'W' : Move west by 1 unit. Initially, you are at the origin (0, 0). You can change at most k characters to any of the four directions. Find the maximum Manhattan distance from the origin that can be achieved at any time while performing the movements in order. The Manhattan Distance between two cells (xi, yi) and (xj, yj) is |xi - xj| + |yi - yj|.]]></summary></entry></feed>