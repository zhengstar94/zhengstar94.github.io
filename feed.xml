<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-24T05:29:40+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">Reverse LinkedList</title><link href="https://zhengstar94.github.io//blog/2025/Reverse-LinkedList/" rel="alternate" type="text/html" title="Reverse LinkedList"/><published>2025-09-21T00:00:00+00:00</published><updated>2025-09-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/Reverse-LinkedList</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/Reverse-LinkedList/"><![CDATA[<h1 id="reverse-linked-list">Reverse Linked List</h1> <h2 id="solution-traverse-the-linked-list-pointing-the-next-of-each-node-to-the-previous-node">Solution (Traverse the linked list, pointing the next of each node to the previous node)</h2> <ol> <li>Save the next of the current node, <code class="language-plaintext highlighter-rouge">next = curr.next</code></li> <li>Point the next of the current node to the previous node, <code class="language-plaintext highlighter-rouge">curr.next = prev</code></li> <li>Move the forward pointer back to <code class="language-plaintext highlighter-rouge">prev = curr</code></li> <li>Move the current pointer back to <code class="language-plaintext highlighter-rouge">curr = next</code></li> </ol> <h2 id="step">Step</h2> <p>1.<strong>Initial list and pre node</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/1-480.webp 480w,/assets/img/2023/08/1-800.webp 800w,/assets/img/2023/08/1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/1.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>2.<strong>Initial list and next node, <code class="language-plaintext highlighter-rouge">next = curr.next</code></strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/2-480.webp 480w,/assets/img/2023/08/2-800.webp 800w,/assets/img/2023/08/2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/2.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>3.<strong>The current.next points to the pre node, <code class="language-plaintext highlighter-rouge">curr.next = prev</code></strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/3-480.webp 480w,/assets/img/2023/08/3-800.webp 800w,/assets/img/2023/08/3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/3.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>4.<strong>The pre node points to the current node, <code class="language-plaintext highlighter-rouge">prev = curr</code></strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/4-480.webp 480w,/assets/img/2023/08/4-800.webp 800w,/assets/img/2023/08/4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/4.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>5.<strong>The current node points to the next node, <code class="language-plaintext highlighter-rouge">curr = next</code></strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/5-480.webp 480w,/assets/img/2023/08/5-800.webp 800w,/assets/img/2023/08/5-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/5.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>6.<strong>The next node moves to the current.next, <code class="language-plaintext highlighter-rouge">next = curr.next</code></strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/6-480.webp 480w,/assets/img/2023/08/6-800.webp 800w,/assets/img/2023/08/6-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/6.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>7.<strong>Loop traversal</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/7-480.webp 480w,/assets/img/2023/08/7-800.webp 800w,/assets/img/2023/08/7-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/7.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/8-480.webp 480w,/assets/img/2023/08/8-800.webp 800w,/assets/img/2023/08/8-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/8.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/9-480.webp 480w,/assets/img/2023/08/9-800.webp 800w,/assets/img/2023/08/9-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/9.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/10-480.webp 480w,/assets/img/2023/08/10-800.webp 800w,/assets/img/2023/08/10-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/10.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/11-480.webp 480w,/assets/img/2023/08/11-800.webp 800w,/assets/img/2023/08/11-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/11.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/12-480.webp 480w,/assets/img/2023/08/12-800.webp 800w,/assets/img/2023/08/12-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/12.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/13-480.webp 480w,/assets/img/2023/08/13-800.webp 800w,/assets/img/2023/08/13-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/13.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/14-480.webp 480w,/assets/img/2023/08/14-800.webp 800w,/assets/img/2023/08/14-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/14.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/15-480.webp 480w,/assets/img/2023/08/15-800.webp 800w,/assets/img/2023/08/15-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/15.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/16-480.webp 480w,/assets/img/2023/08/16-800.webp 800w,/assets/img/2023/08/16-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/16.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/17-480.webp 480w,/assets/img/2023/08/17-800.webp 800w,/assets/img/2023/08/17-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/17.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/18-480.webp 480w,/assets/img/2023/08/18-800.webp 800w,/assets/img/2023/08/18-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/18.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/19-480.webp 480w,/assets/img/2023/08/19-800.webp 800w,/assets/img/2023/08/19-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/19.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/20-480.webp 480w,/assets/img/2023/08/20-800.webp 800w,/assets/img/2023/08/20-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/20.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023/08/21-480.webp 480w,/assets/img/2023/08/21-800.webp 800w,/assets/img/2023/08/21-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2023/08/21.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="code">Code</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">LinkedLists</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2023/08/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReverseLinkedList</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ListNode</span> <span class="nf">reverseLinkedList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="reverse-linked-list-ii">Reverse Linked List II</h1> <h2 id="solution-iterate-and-insert-the-following-node-of-curr-to-the-position-after-pre">Solution (Iterate and insert the following node of curr to the position after pre)</h2> <ol> <li>Save the next node of the current node, <code class="language-plaintext highlighter-rouge">ListNode next = curr.next</code></li> <li>Let the next pointer of the current node point to the node pointed by next’s next pointer. <code class="language-plaintext highlighter-rouge">curr.next = next.next;</code></li> <li>Point the next of the <code class="language-plaintext highlighter-rouge">next</code> node to the node pointed by pre’s next pointer . <code class="language-plaintext highlighter-rouge">next.next = pre.next</code></li> <li>Move the <code class="language-plaintext highlighter-rouge">next</code> pointer to the position after the pre pointer, by setting the <code class="language-plaintext highlighter-rouge">next</code> pointer of the pre poniter to the <code class="language-plaintext highlighter-rouge">next</code> pointer. <code class="language-plaintext highlighter-rouge">pre.next = next;</code></li> </ol> <h2 id="step-1">Step</h2> <p>1.<strong>Initial List and Pre(head) Node</strong></p> <p><strong>left = 2, right = 4. After the pre loop, pre points to 1 and curr points to 2.</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/1-480.webp 480w,/assets/img/2025/09/1-800.webp 800w,/assets/img/2025/09/1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/1.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>2.<strong>Initial List and Next Node, <code class="language-plaintext highlighter-rouge">next = curr.next</code></strong></p> <p><strong>Before: curr.next = 3</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/2-480.webp 480w,/assets/img/2025/09/2-800.webp 800w,/assets/img/2025/09/2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/2.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>3.<strong>The current.next points to the pre.next node, <code class="language-plaintext highlighter-rouge">curr.next = next.next</code></strong></p> <p><strong>After: curr.next = 4</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/3-480.webp 480w,/assets/img/2025/09/3-800.webp 800w,/assets/img/2025/09/3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/3.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>4.<strong>The next.next node points to the pre.next. <code class="language-plaintext highlighter-rouge">next.next = pre.next</code></strong></p> <p><strong>next.next = pre.next;</strong> <strong>curr.next = 4</strong> <strong>next.next = 2</strong> <strong>pre.next = 2</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/4-480.webp 480w,/assets/img/2025/09/4-800.webp 800w,/assets/img/2025/09/4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/4.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>5.<strong>The pre node points to the next node, <code class="language-plaintext highlighter-rouge">pre.next = next</code></strong></p> <p><strong>curr.next = 4</strong> <strong>next.next = 2</strong> <strong>pre.next = 3</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/5-480.webp 480w,/assets/img/2025/09/5-800.webp 800w,/assets/img/2025/09/5-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/5.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>6.Loop1</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/6-480.webp 480w,/assets/img/2025/09/6-800.webp 800w,/assets/img/2025/09/6-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/6.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>7.<strong>Repeat step 2 to 5 , loop traversal, until to meet the end of range</strong></p> <p><strong>ListNode next = 4</strong> <strong>curr.next = 4</strong> <strong>next.next = 5</strong> <strong>pre.next = 3</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/7-480.webp 480w,/assets/img/2025/09/7-800.webp 800w,/assets/img/2025/09/7-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/7.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>8.<strong>Loop traversal</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/8-480.webp 480w,/assets/img/2025/09/8-800.webp 800w,/assets/img/2025/09/8-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/8.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/9-480.webp 480w,/assets/img/2025/09/9-800.webp 800w,/assets/img/2025/09/9-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/9.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/10-480.webp 480w,/assets/img/2025/09/10-800.webp 800w,/assets/img/2025/09/10-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/10.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/09/11-480.webp 480w,/assets/img/2025/09/11-800.webp 800w,/assets/img/2025/09/11-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/09/11.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="code-1">Code</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">LinkedLists</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2025/09/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReverseLinkedListII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ListNode</span> <span class="nf">reverseBetween</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[Reverse Linked List]]></summary></entry><entry><title type="html">双指针 - 滑动窗口</title><link href="https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow/" rel="alternate" type="text/html" title="双指针 - 滑动窗口"/><published>2025-09-06T00:00:00+00:00</published><updated>2025-09-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow/"><![CDATA[<h2 id="介绍">介绍</h2> <p>滑动窗口用于“连续子串/子数组”的最长/最短/计数类问题。简单来说，滑动窗口就是使用 2 个指针维护一个”活动区间”，右指针扩张窗口，左指针在不满足或满足条件时收缩。这样算法通常能做到线性复杂度。</p> <h2 id="定长窗口固定长度-k">定长窗口（固定长度 k）</h2> <p>LeetCode 例子：<strong>643. Maximum Average Subarray I</strong></p> <p>题意就是找长度为 k 的子数组的最大平均值，本质上等价于固定长度子数组的最大和问题。</p> <h3 id="思路要点">思路要点</h3> <p>固定长度的滑动窗口其实很直接：</p> <ol> <li><strong>右指针往前走</strong>，新元素加进窗口和；</li> <li>当窗口长度到达 k，就可以结算一次答案；</li> <li>然后把左端移出（减掉 nums[left]），left++，继续下一个窗口。</li> </ol> <p>这样窗口始终保持长度 = k，更新完全是 O(1) 的。</p> <h3 id="核心代码">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">best</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>           <span class="c1">// 扩张：加上右端</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>        <span class="c1">// 窗口长度正好等于 k</span>
        <span class="n">best</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">windowSum</span><span class="o">);</span> 
        <span class="n">windowSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>        <span class="c1">// 收缩：移出左端</span>
        <span class="n">left</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <h3 id="完整函数写法">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSumOfSizeK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">best</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">best</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">windowSum</span><span class="o">);</span> <span class="c1">// 结算一次答案</span>
            <span class="n">windowSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>          <span class="c1">// 左端移出</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">best</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="变长窗口求最长">变长窗口（求最长）</h2> <p>LeetCode 例子：<strong>3. Longest Substring Without Repeating Characters</strong></p> <p>题意：找最长的不含重复字符的子串。</p> <h3 id="思路要点-1">思路要点</h3> <p>变长窗口和定长的差别在于：</p> <ul> <li><strong>右指针一直扩张</strong>，新元素加入窗口；</li> <li>一旦违反约束（比如出现重复字符），就用 <strong>while</strong> 循环收缩左指针，直到窗口重新合法；</li> <li>每次窗口满足条件，就可以尝试更新答案。</li> </ul> <p>核心技巧就是「<strong>违规就收缩到刚刚合法</strong>」，这样不会错过最优解。</p> <h3 id="核心代码-1">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">window</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
    <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// 加入右端</span>

    <span class="c1">// 出现重复时收缩左边</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
        <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">window</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
        <span class="n">left</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="c1">// 到这里窗口已经合法，可以尝试更新答案</span>
    <span class="n">best</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="完整函数写法-1">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">window</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// 收缩直到没有重复</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
            <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">window</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="n">best</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">best</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div> <h2 id="变长窗口求最短覆盖">变长窗口（求最短覆盖）</h2> <p>LeetCode 例子：<strong>209. Minimum Size Subarray Sum</strong></p> <p>题意：给定一个正整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个目标值 <code class="language-plaintext highlighter-rouge">target</code>，找出和 ≥ <code class="language-plaintext highlighter-rouge">target</code> 的最短子数组长度。如果不存在则返回 0。</p> <h3 id="思路要点-2">思路要点</h3> <ul> <li> <ul> <li>右指针不断扩张，把元素加进窗口和；</li> </ul> </li> <li>当窗口和 ≥ target 时，开始收缩左指针，尽量缩短窗口；</li> <li>收缩过程中更新「最短长度」。</li> </ul> <h3 id="核心代码-2">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">best</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

    <span class="c1">// 满足条件，尝试收缩</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">windowSum</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">best</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">windowSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="n">left</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">best</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">best</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-2">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">best</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">windowSum</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">best</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">windowSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">best</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">best</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div> <h2 id="计数型窗口统计子数组个数">计数型窗口（统计子数组个数）</h2> <p>LeetCode 例子：<strong>992. Subarrays with K Different Integers</strong></p> <p>题意：给定一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">K</code>，统计数组中恰好有 K 个不同整数的子数组个数。 核心技巧是先写一个 <strong>atMost(K)</strong> 函数，统计至多 K 个不同整数的子数组个数，再用 <code class="language-plaintext highlighter-rouge">exactly(K) = atMost(K) - atMost(K - 1)</code>。</p> <h3 id="思路要点-3">思路要点</h3> <ul> <li>右指针扩张，把元素加入窗口，并更新窗口中每个元素的计数；</li> <li>当窗口中的不同元素数 &gt; K 时，收缩左指针，移出不必要的元素；</li> <li>每次循环时，窗口内以 <code class="language-plaintext highlighter-rouge">right</code> 结尾的所有子数组个数是 <code class="language-plaintext highlighter-rouge">right - left + 1</code>，累加到结果。</li> </ul> <h3 id="核心代码-3">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">window</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
    <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

    <span class="c1">// 种类数超过 K，收缩左指针</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">window</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
        <span class="n">left</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="n">count</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-3">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">subarraysWithKDistinct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">atMostK</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="no">K</span><span class="o">)</span> <span class="o">-</span> <span class="n">atMostK</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="no">K</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">atMostK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">window</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="n">window</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">window</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div> <h2 id="单调队列窗口快速求最大最小值">单调队列窗口（快速求最大/最小值）</h2> <p>LeetCode 例子：<strong>239. Sliding Window Maximum</strong></p> <p>题意：给定一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个窗口大小 <code class="language-plaintext highlighter-rouge">k</code>，求每个窗口内的最大值。<br/> 核心技巧是用 <strong>双端队列（deque）维护窗口单调递减</strong>，保证队头总是最大值，窗口移动时及时剔除过期或较小的元素。</p> <h3 id="思路要点-4">思路要点</h3> <ul> <li>右指针扩张，将元素加入队列前先剔除队尾小于当前元素的值，保持单调递减；</li> <li>当窗口左端移出时，队头元素如果等于移出的值，需要同步移除；</li> <li>每次窗口长度达到 <code class="language-plaintext highlighter-rouge">k</code> 时，队头就是该窗口最大值，加入结果。</li> </ul> <h3 id="核心代码-4">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">ri</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="c1">// 移除队尾比当前元素小的，保持单调递减</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

    <span class="c1">// 移除队头过期元素</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 当窗口长度达到 k，记录最大值</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span><span class="o">[</span><span class="n">ri</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()];</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">res</span><span class="o">;</span>

</code></pre></div></div> <h3 id="完整函数写法-4">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">ri</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">ri</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()];</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div> <h2 id="总结">总结</h2> <table> <thead> <tr> <th>窗口类型</th> <th>核心目标</th> <th>窗口变化</th> <th>窗口维护</th> <th>统计方式</th> <th>Leetcode</th> </tr> </thead> <tbody> <tr> <td><strong>定长窗口</strong></td> <td>求固定长度子数组的最大/最小/平均值</td> <td>右指针推进，长度满 k 时左指针同步右移</td> <td>进入元素加法/减法，O(1) 更新</td> <td>满足长度时更新结果</td> <td>LC 643, 最大平均子数组</td> </tr> <tr> <td><strong>变长窗口（求最长）</strong></td> <td>求最长满足条件的子串/子数组</td> <td>右指针扩张，违反条件收缩左指针</td> <td>Map/Set/计数表维护状态</td> <td>每次合法窗口更新最长</td> <td>LC 3, 最长不含重复字符子串</td> </tr> <tr> <td><strong>变长窗口（求最短 / 覆盖）</strong></td> <td>求最短子串/子数组满足条件</td> <td>右指针扩张，条件满足收缩左指针</td> <td>Map/计数/窗口和维护状态</td> <td>收缩过程中更新最短</td> <td>LC 209, 76</td> </tr> <tr> <td><strong>计数型窗口</strong></td> <td>统计满足条件的子数组/子串个数</td> <td>右指针扩张，条件超限收缩左指针</td> <td>Map/Set/计数表维护种类或频率</td> <td>窗口长度累加（right-left+1）</td> <td>LC 992, 至多/恰好 K 个不同整数</td> </tr> <tr> <td><strong>单调队列窗口</strong></td> <td>窗口内快速求最大/最小</td> <td>右指针扩张，队尾剔除不符合单调的元素</td> <td>双端队列维护单调递减/递增</td> <td>队头即窗口最大/最小</td> <td>LC 239, 滑动窗口最大值</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[介绍 滑动窗口用于“连续子串/子数组”的最长/最短/计数类问题。简单来说，滑动窗口就是使用 2 个指针维护一个”活动区间”，右指针扩张窗口，左指针在不满足或满足条件时收缩。这样算法通常能做到线性复杂度。]]></summary></entry><entry><title type="html">双指针 - 快慢指针</title><link href="https://zhengstar94.github.io//blog/2025/FastSlowPointers/" rel="alternate" type="text/html" title="双指针 - 快慢指针"/><published>2025-09-06T00:00:00+00:00</published><updated>2025-09-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FastSlowPointers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FastSlowPointers/"><![CDATA[<h2 id="介绍">介绍</h2> <p>快慢指针用于链表或数组中通过“速度差”获取结构信息。简单来说，就是用两个指针同时遍历，慢指针走得慢、快指针走得快，通过二者的相遇、交汇或间隔距离来判断环、找中点、倒数第 N 个节点或检测回文等。这样算法通常也能做到线性复杂度。</p> <h2 id="1-判环环的存在性">1. 判环（环的存在性）</h2> <p>LeetCode 例子：<strong>141. Linked List Cycle</strong></p> <p>题意：判断链表中是否存在环。</p> <h3 id="思路要点">思路要点</h3> <ul> <li>定义 <strong>快慢指针</strong>：慢指针一次走 1 步，快指针一次走 2 步；</li> <li>若链表存在环，快慢指针最终会在环内相遇；</li> <li>若链表无环，快指针先到达末尾。</li> </ul> <h3 id="核心代码">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 相遇则有环</span>
<span class="o">}</span>
<span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 无环</span>
</code></pre></div></div> <h3 id="完整函数写法">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="2-找环入口">2. 找环入口</h2> <p>LeetCode 例子：<strong>142. Linked List Cycle II</strong></p> <p>题意：返回链表环的起点，如果无环返回 null。</p> <h3 id="思路要点-1">思路要点</h3> <ul> <li>首先使用快慢指针判断环是否存在；</li> <li>相遇后，将一个指针重新指向链表头，两指针同步移动，每次走 1 步；</li> <li>再次相遇点即为环入口。</li> </ul> <h3 id="核心代码-1">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="c1">// 判断是否有环</span>
<span class="k">do</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">);</span>

<span class="c1">// 找环入口</span>
<span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-1">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">detectCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 判环</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">);</span>

    <span class="c1">// 找环入口</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="3-链表中点查找">3. 链表中点查找</h2> <p>LeetCode 例子：<strong>876. Middle of the Linked List</strong></p> <p>题意：找到链表的中点节点（偶数长度返回中间偏右节点）。</p> <h3 id="思路要点-2">思路要点</h3> <ul> <li>快指针每次走 2 步，慢指针每次走 1 步；</li> <li>快指针到达末尾时，慢指针恰好在中点位置。</li> </ul> <h3 id="核心代码-2">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-2">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">middleNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="4-倒数第-n-个节点">4. 倒数第 N 个节点</h2> <p>LeetCode 例子：<strong>19. Remove Nth Node From End of List</strong></p> <p>题意：返回链表倒数第 N 个节点（或删除该节点）。</p> <h3 id="思路要点-3">思路要点</h3> <ul> <li>快指针先走 N 步，使快慢指针间隔 N 个节点；</li> <li>然后快慢指针同时走，直到快指针到达末尾；</li> <li>慢指针指向的就是倒数第 N 个节点前一个节点（方便删除操作）。</li> </ul> <h3 id="核心代码删除倒数第-n-个节点">核心代码（删除倒数第 N 个节点）</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>

<span class="c1">// 快指针先走 N 步</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

<span class="c1">// 同时移动</span>
<span class="k">while</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 删除节点</span>
<span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-3">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="5-回文检查数组链表">5. 回文检查（数组/链表）</h2> <p>LeetCode 例子：<strong>234. Palindrome Linked List</strong></p> <p>题意：判断链表是否是回文结构。</p> <h3 id="思路要点-4">思路要点</h3> <ul> <li>用快慢指针找到链表中点；</li> <li>反转中点后的链表；</li> <li>两段链表逐节点比较，判断是否回文；</li> <li>可选：恢复链表结构。</li> </ul> <h3 id="核心代码-3">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 找中点</span>
<span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 反转后半段</span>
<span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">slow</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 比较</span>
<span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">p2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-4">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="c1">// 找中点</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 反转后半段</span>
    <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">slow</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 比较两段链表</span>
    <span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div> <h2 id="总结快慢指针">总结：快慢指针</h2> <table> <thead> <tr> <th>快慢指针类型</th> <th>核心目标</th> <th>指针变化</th> <th>状态维护</th> <th>统计方式</th> <th>面试高频题</th> </tr> </thead> <tbody> <tr> <td><strong>判环（Cycle Detection）</strong></td> <td>判断链表是否有环</td> <td>慢指针每次走 1 步，快指针每次走 2 步，相遇则有环</td> <td>无需额外结构，仅指针移动</td> <td>相遇即判定有环</td> <td>LC 141, Linked List Cycle</td> </tr> <tr> <td><strong>找环入口（Cycle Entry）</strong></td> <td>找出链表环的起始节点</td> <td>快慢指针相遇后，一个从头开始，一个从相遇点，步数同步推进，直到相遇</td> <td>指针移动和相遇条件</td> <td>相遇节点即环入口</td> <td>LC 142, Linked List Cycle II</td> </tr> <tr> <td><strong>链表中点</strong></td> <td>找到链表中点（偶数取上中/下中根据需求）</td> <td>慢指针 1 步，快指针 2 步</td> <td>无需额外维护</td> <td>慢指针到达即中点</td> <td>LC 876, Middle of Linked List</td> </tr> <tr> <td><strong>倒数第 N 个节点</strong></td> <td>找到链表倒数第 N 个节点</td> <td>快指针先走 N 步，慢指针随后同步推进</td> <td>记录快慢指针位置</td> <td>快指针到末尾时慢指针即目标</td> <td>LC 19, Remove Nth Node From End of List</td> </tr> <tr> <td><strong>回文检查</strong></td> <td>判断链表或数组是否回文</td> <td>快慢指针找中点，慢指针反转前半部分或记录栈</td> <td>链表反转或栈存储前半部分</td> <td>中点后对比两段元素</td> <td>LC 234, Palindrome Linked List</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[介绍]]></summary></entry><entry><title type="html">双指针 - 左右指针</title><link href="https://zhengstar94.github.io//blog/2025/LeftRightPointers/" rel="alternate" type="text/html" title="双指针 - 左右指针"/><published>2025-09-06T00:00:00+00:00</published><updated>2025-09-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LeftRightPointers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LeftRightPointers/"><![CDATA[<h2 id="介绍">介绍</h2> <p>左右指针（对撞）常用于 <strong>排序数组或区间问题</strong>，例如二数之和、三数之和、接雨水等。简单来说，就是用两个指针分别指向区间两端，根据条件向中间收缩或移动，通过利用数组或区间的单调性裁剪搜索空间。这样算法通常也能做到线性复杂度。</p> <h2 id="1-二数之和有序数组">1. 二数之和（有序数组）</h2> <p>LeetCode 例子：<strong>167. Two Sum II - Input array is sorted</strong></p> <p>题意：给定排序数组 <code class="language-plaintext highlighter-rouge">numbers</code> 和目标值 <code class="language-plaintext highlighter-rouge">target</code>，返回两个数的下标，使它们之和等于 <code class="language-plaintext highlighter-rouge">target</code>。</p> <h3 id="思路要点">思路要点</h3> <ul> <li>左指针 <code class="language-plaintext highlighter-rouge">left</code> 指向数组开头，右指针 <code class="language-plaintext highlighter-rouge">right</code> 指向数组末尾；</li> <li>计算 <code class="language-plaintext highlighter-rouge">sum = numbers[left] + numbers[right]</code>；</li> <li>若 <code class="language-plaintext highlighter-rouge">sum == target</code>，返回结果；</li> <li>若 <code class="language-plaintext highlighter-rouge">sum &lt; target</code>，左指针右移；</li> <li>若 <code class="language-plaintext highlighter-rouge">sum &gt; target</code>，右指针左移。</li> </ul> <h3 id="核心代码">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">};</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span><span class="o">++;</span>
    <span class="k">else</span> <span class="n">right</span><span class="o">--;</span>
<span class="o">}</span>
<span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
</code></pre></div></div> <h3 id="完整函数写法">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">};</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span><span class="o">++;</span>
        <span class="k">else</span> <span class="n">right</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="2-三数之和">2. 三数之和</h2> <p>LeetCode 例子：<strong>15. 3Sum</strong></p> <p>题意：给定数组 <code class="language-plaintext highlighter-rouge">nums</code>，找出所有不重复的三元组使得和为 0。</p> <h3 id="思路要点-1">思路要点</h3> <ul> <li>先排序数组；</li> <li>固定一个数 <code class="language-plaintext highlighter-rouge">nums[i]</code>，对剩余子数组使用左右指针寻找两数之和为 <code class="language-plaintext highlighter-rouge">-nums[i]</code>；</li> <li>遇到重复元素跳过，避免重复三元组。</li> </ul> <h3 id="核心代码-1">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]));</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="n">left</span><span class="o">++;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="n">right</span><span class="o">--;</span>
            <span class="n">left</span><span class="o">++;</span> <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">left</span><span class="o">++;</span>
        <span class="k">else</span> <span class="n">right</span><span class="o">--;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-1">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">threeSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]));</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="n">left</span><span class="o">++;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="n">right</span><span class="o">--;</span>
                <span class="n">left</span><span class="o">++;</span> <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">left</span><span class="o">++;</span>
            <span class="k">else</span> <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="3-盛水容器">3. 盛水容器</h2> <p>LeetCode 例子：<strong>11. Container With Most Water</strong></p> <p>题意：给定数组 <code class="language-plaintext highlighter-rouge">height</code>，每个元素代表柱子高度，求能盛水的最大面积。</p> <h3 id="思路要点-2">思路要点</h3> <ul> <li>左右指针指向两端；</li> <li>面积 = min(height[left], height[right]) * (right - left)；</li> <li>移动高度较小的指针，尝试获得更大面积；</li> <li>重复直到左右指针相遇。</li> </ul> <h3 id="核心代码-2">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">maxArea</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">*</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">);</span>
    <span class="n">maxArea</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxArea</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="n">left</span><span class="o">++;</span>
    <span class="k">else</span> <span class="n">right</span><span class="o">--;</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">maxArea</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-2">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">maxArea</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">*</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">);</span>
        <span class="n">maxArea</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxArea</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="n">left</span><span class="o">++;</span>
        <span class="k">else</span> <span class="n">right</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">maxArea</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="4-接雨水柱状图">4. 接雨水（柱状图）</h2> <p>LeetCode 例子：<strong>42. Trapping Rain Water</strong></p> <p>题意：给定数组 <code class="language-plaintext highlighter-rouge">height</code> 表示柱状图高度，计算柱状图能接的雨水总量。</p> <h3 id="思路要点-3">思路要点</h3> <ul> <li>左右指针指向两端，维护 <code class="language-plaintext highlighter-rouge">leftMax</code> 和 <code class="language-plaintext highlighter-rouge">rightMax</code> 为左右最高柱高度；</li> <li>若 <code class="language-plaintext highlighter-rouge">height[left] &lt; height[right]</code>：雨水量由 <code class="language-plaintext highlighter-rouge">leftMax</code> 决定，更新 <code class="language-plaintext highlighter-rouge">leftMax</code> 并累加雨水；左指针右移；</li> <li>否则：雨水量由 <code class="language-plaintext highlighter-rouge">rightMax</code> 决定，更新 <code class="language-plaintext highlighter-rouge">rightMax</code> 并累加雨水；右指针左移；</li> <li>重复直到左右指针相遇。</li> </ul> <h3 id="核心代码-3">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">water</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">leftMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftMax</span><span class="o">,</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>
        <span class="n">water</span> <span class="o">+=</span> <span class="n">leftMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="n">left</span><span class="o">++;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">rightMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">rightMax</span><span class="o">,</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">]);</span>
        <span class="n">water</span> <span class="o">+=</span> <span class="n">rightMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="n">right</span><span class="o">--;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">water</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-3">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">trap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">water</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">leftMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftMax</span><span class="o">,</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>
            <span class="n">water</span> <span class="o">+=</span> <span class="n">leftMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">rightMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">rightMax</span><span class="o">,</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">]);</span>
            <span class="n">water</span> <span class="o">+=</span> <span class="n">rightMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">water</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="5-回文--对称判断">5. 回文 / 对称判断</h2> <p>LeetCode 例子：<strong>234. Palindrome Linked List</strong></p> <p>题意：判断链表是否回文。</p> <h3 id="思路要点-4">思路要点</h3> <ul> <li>使用快慢指针找到链表中点；</li> <li>反转前半部分链表（或使用栈存储前半部分节点值）；</li> <li>对比中点后半部分与前半部分元素是否相同；</li> <li>若完全相同则回文，否则不是。</li> </ul> <h3 id="核心代码反转前半部分法">核心代码（反转前半部分法）</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

<span class="c1">// 找中点</span>
<span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 反转前半部分</span>
<span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 对比前半部分和后半部分</span>
<span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">prev</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</code></pre></div></div> <h3 id="完整函数写法-4">完整函数写法</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">prev</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="总结左右指针">总结：左右指针</h2> <table> <thead> <tr> <th>左右指针类型</th> <th>核心目标</th> <th>指针变化</th> <th>状态维护</th> <th>统计方式</th> <th>面试高频题</th> </tr> </thead> <tbody> <tr> <td><strong>二数之和（有序数组）</strong></td> <td>找到和为目标值的两个数</td> <td>左右指针分别从两端向中间移动</td> <td>无额外结构，仅根据 sum 判断移动方向</td> <td>相遇或 sum 满足条件即记录结果</td> <td>LC 167, Two Sum II</td> </tr> <tr> <td><strong>三数之和 / 四数之和</strong></td> <td>找到和为目标值的三元组/四元组</td> <td>固定一个或两个元素，剩余子数组左右指针收缩</td> <td>跳过重复元素保证结果唯一</td> <td>每次 sum 满足条件时记录结果</td> <td>LC 15, 3Sum; LC 18, 4Sum</td> </tr> <tr> <td><strong>盛水容器 / 最大面积</strong></td> <td>求两端形成的容器最大面积</td> <td>左右指针向中间移动，每次移动较矮的指针</td> <td>无需额外结构</td> <td>每次计算面积并更新最大值</td> <td>LC 11, Container With Most Water</td> </tr> <tr> <td><strong>接雨水（柱状图 / 容量问题）</strong></td> <td>求容器能接的水量</td> <td>左右指针根据高度向中间收缩</td> <td>维护左右最高高度</td> <td>每次更新可接水量累加</td> <td>LC 42, Trapping Rain Water</td> </tr> <tr> <td><strong>回文/对称判断</strong></td> <td>判断字符串或数组是否回文</td> <td>左右指针从两端向中间收缩</td> <td>无需额外结构</td> <td>相邻元素对比是否一致</td> <td>常见面试题</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[介绍]]></summary></entry><entry><title type="html">链表 - 反转 / 合并 / 快慢指针 / 找交点</title><link href="https://zhengstar94.github.io//blog/2025/LinkedList/" rel="alternate" type="text/html" title="链表 - 反转 / 合并 / 快慢指针 / 找交点"/><published>2025-09-06T00:00:00+00:00</published><updated>2025-09-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LinkedList</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LinkedList/"><![CDATA[<h2 id="介绍">介绍</h2> <ul> <li><strong>反转链表</strong>：包括整表反转、区间反转、K 个一组反转；</li> <li><strong>合并链表</strong>：包括合并两个有序链表、合并 K 个有序链表；</li> <li><strong>快慢指针</strong>：用于判环、找环入口、找中点、倒数第 N 个节点、回文判断；</li> <li><strong>找交点</strong>：判断两链表是否相交，找到第一个相交节点。</li> </ul> <hr/> <h2 id="1-反转链表">1. 反转链表</h2> <p><a href="https://zhengxingxing.com/blog/2025/Reverse-LinkedList/">反转链表</a>是链表题基础，必须掌握迭代和递归两种方法，并能扩展到区间反转和 k 组反转。</p> <h3 id="思路要点">思路要点</h3> <ul> <li>迭代法：用 <code class="language-plaintext highlighter-rouge">prev</code>、<code class="language-plaintext highlighter-rouge">curr</code> 逐节点反转 <code class="language-plaintext highlighter-rouge">next</code> 指针；</li> <li>递归法：利用递归回溯，将当前节点挂到后面节点的 <code class="language-plaintext highlighter-rouge">next</code>。</li> </ul> <h3 id="核心代码整表反转---迭代">核心代码（整表反转 - 迭代）</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="核心代码整表反转---递归">核心代码（整表反转 - 递归）</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">reverseList</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="2-合并链表">2. 合并链表</h2> <p>常见场景：合并两个有序链表或 K 个有序链表。可用迭代、递归或优先队列。</p> <h3 id="思路要点-1">思路要点</h3> <ul> <li> <p>创建 Dummy 节点简化边界；</p> </li> <li> <p>比较两链表当前节点值，选择较小的挂到新链表末尾；</p> </li> <li> <p>移动指针继续比较直到一条链表为空。</p> </li> </ul> <h3 id="核心代码合并两个有序链表">核心代码（合并两个有序链表）</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">l1</span> <span class="o">:</span> <span class="n">l2</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="3-快慢指针">3. 快慢指针</h2> <p>快慢指针通过不同速度指针的相遇、距离差解决链表结构问题。</p> <h3 id="题型与模板">题型与模板</h3> <ul> <li> <p><strong>判环</strong>（LC 141）：快指针走两步，慢指针走一步，相遇说明有环。</p> </li> <li> <p><strong>找环入口</strong>（LC 142）：相遇后一个指针回头，两指针同步走，相遇点即环入口。</p> </li> <li> <p><strong>找中点</strong>（LC 876）：快走两步慢走一步，快到尾慢在中点。</p> </li> <li> <p><strong>倒数第 N 个节点</strong>（LC 19）：快指针先走 N 步，然后快慢同步走直到快到尾。</p> </li> </ul> <h3 id="核心代码判环">核心代码（判环）</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="4-找交点">4. 找交点</h2> <p>判断两条链表是否相交，并找到第一个相交节点。</p> <h3 id="思路要点-2">思路要点</h3> <ul> <li> <p>用两个指针 pA, pB 分别遍历两链表；</p> </li> <li> <p>到尾后切换到另一条链表的头；</p> </li> <li> <p>如果有交点，最终会在交点相遇；若无交点，都会到 null。</p> </li> </ul> <h3 id="核心代码">核心代码</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">getIntersectionNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">headA</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">headB</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">headA</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">headB</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">pA</span> <span class="o">=</span> <span class="n">headA</span><span class="o">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="n">headB</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">pA</span> <span class="o">!=</span> <span class="n">pB</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pA</span> <span class="o">=</span> <span class="o">(</span><span class="n">pA</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">headB</span> <span class="o">:</span> <span class="n">pA</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">pB</span> <span class="o">=</span> <span class="o">(</span><span class="n">pB</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">headA</span> <span class="o">:</span> <span class="n">pB</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">pA</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="总结表格">总结表格</h2> <table> <thead> <tr> <th>类别</th> <th>核心目标</th> <th>核心技巧</th> <th>高频题</th> </tr> </thead> <tbody> <tr> <td><strong>反转链表</strong></td> <td>改变链表方向</td> <td>迭代双指针 / 递归回溯</td> <td>LC 206, 92, 25</td> </tr> <tr> <td><strong>合并链表</strong></td> <td>合并成有序链表</td> <td>Dummy 节点 + 双指针</td> <td>LC 21, 23</td> </tr> <tr> <td><strong>快慢指针</strong></td> <td>判环、找中点、找倒数第 N 个节点</td> <td>快走两步慢走一步；或先走 N 步</td> <td>LC 141, 142, 876, 19, 234</td> </tr> <tr> <td><strong>找交点</strong></td> <td>判断两链表是否相交</td> <td>双指针遍历两条链表长度</td> <td>LC 160</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[介绍]]></summary></entry><entry><title type="html">Todo List</title><link href="https://zhengstar94.github.io//blog/2025/TodoList/" rel="alternate" type="text/html" title="Todo List"/><published>2025-08-30T00:00:00+00:00</published><updated>2025-08-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TodoList</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TodoList/"><![CDATA[<h1 id="第-1-月---基础回顾">第 1 月 - 基础回顾</h1> <h2 id="第-1-周spring-boot-核心复习">第 1 周：Spring Boot 核心复习</h2> <h3 id="技术学习">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>复习 Spring Boot 基础架构 (1.5 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>重点：启动流程、自动配置原理、常用 starter。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>1. Debug Spring Boot 的启动类 SpringApplication.run()，理解其核心的 prepareContext 和 refreshContext 步骤。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>2. 深入理解 @SpringBootApplication 注解背后的三个核心注解 (@Configuration, @EnableAutoConfiguration, @ComponentScan)。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>3. 找一个常用的 starter (如 spring-boot-starter-web)，查看其 pom.xml 和 spring.factories 文件，理解自动配置的实现原理。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>掌握 15 个核心注解 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>@RestController, @Service, @Repository, @Autowired, @Value, @ConfigurationProperties 等。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>创建一个小型项目，亲自实践并分组理解这些注解： 声明Bean (@Component, @Service, @Repository, @Controller)； 依赖注入 (@Autowired, @Qualifier, @Resource)； 配置读取 (@Value, @ConfigurationProperties)； Web开发 (@RestController, @RequestMapping, @PathVariable, @RequestBody)； 配置类 (@Configuration, @Bean)。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>AOP 实战练习 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>实现：日志记录、性能监控、权限校验三个切面。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>使用 @Aspect 创建一个切面类。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>1. 日志切面: 使用 @Around 注解，记录Controller层每个方法的入参、返回值和执行耗时。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>2. 权限校验: 使用 @Before 注解，模拟检查用户请求中是否带有合法的 token。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>3. 性能监控: 同样使用 @Around，当方法执行超过特定阈值（如50ms）时，打印警告日志。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Spring Boot 与 MyBatis 整合 (1.5 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>配置数据源、事务管理、mapper 扫描。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>1. 在 pom.xml 中添加 mybatis-spring-boot-starter 依赖。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>2. 在 application.yml 中配置数据源 (URL, username, password) 和 MyBatis (mapper-locations)。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>3. 在启动类上添加 @MapperScan 注解，指定mapper接口的扫描路径。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>4. 编写一个 UserMapper 接口及对应的XML文件，实现基本的 CRUD 操作并进行测试。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Software Engineering Daily 跟读 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每天选一个 10 分钟片段，逐句跟读 3 遍。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用支持 A-B 复读的播放器（如 PotPlayer），对选定的 10 分钟片段进行逐句跟读。第一遍盲听，第二遍看文本跟读，第三遍不看文本模仿语音语调跟读。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>技术词汇积累 (20 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>每天 10 个新词：scalability, latency, throughput, idempotent 等。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南 - 进行中，目前第3天: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 Anki 或 Quizlet 等闪卡应用创建自己的技术词汇卡片集。正面是英文单词，背面是中文释义和例句 (e.g., “This API is idempotent, you can safely retry it.”)。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>英文自我介绍录制 (1 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>2 分钟版本，包含背景、技术栈、项目经验。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>撰写一份2分钟的英文自我介绍稿，覆盖三个核心部分：Who you are (背景学历), What you do (技术栈与项目), What you want (职业目标)。使用手机录音，反复练习直到流利自然。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>数组类题目×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>两数之和、三数之和、滑动窗口、双指针技巧。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>集中攻克 LeetCode 上的经典数组题，例如: 1. Two Sum, 15. 3Sum, 209. Minimum Size Subarray Sum (滑动窗口), 11. Container With Most Water (双指针)。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>整理解题模板 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>总结：滑动窗口、快慢指针、左右指针模板。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>在 Notion 或 Typora 中创建文档，为每种技巧总结出代码模板。例如，滑动窗口模板应包含 left, right 指针的移动逻辑、窗口内数据的更新方式以及结果的判断条件。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>短链系统-需求设计 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>功能需求、非功能需求、容量估算、API 设计。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>撰写一份迷你需求文档。功能需求: 长链生成短链、短链重定向、访问统计。非功能需求: 高可用、高性能、低延迟。API 设计: 设计 /api/v1/generate 和 /{shortCode} 两个核心 RESTful API，明确其请求方法、路径、参数和返回的 JSON 结构。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>短链系统-数据库设计 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>表结构、索引设计、分库分表策略。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 draw.io 或类似工具绘制 ER 图。设计核心表 url_mapping (id, short_code, long_url, created_at)。重点考虑 short_code 字段应建立唯一索引，并思考未来数据量增长后，如何进行分库分表（如按 short_code 的 hash 值）。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>票务系统 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>博客编写。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>粗略复习并学习票务系统的架构设计，以及对应的瓶颈/解决方案。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-2-周spring-生态深入">第 2 周：Spring 生态深入</h2> <h3 id="技术学习-1">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Spring Security 深入 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>JWT 认证、OAuth 2.0、权限控制、记住我功能。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在项目中集成 Spring Security。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 实现一个 JwtAuthenticationFilter 用于解析 JWT Token。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 配置 SecurityFilterChain，设置 /login, /register 等路径匿名访问，其他路径需要认证。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 使用 @PreAuthorize(“hasRole(‘ADMIN’)”) 注解实现方法级别的权限控制。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Spring Cloud 组件 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Eureka、Ribbon、Feign、Hystrix 基础使用。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>搭建一个最小化的微服务环境。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 启动一个 Eureka Server。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 创建两个 Spring Boot 应用作为 Eureka Client 互相注册。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 在一个应用中使用 @FeignClient 接口，以声明式的方式调用另一个应用提供的 API。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>4. 在被调用的服务中人为制造延迟，并在调用方使用 @HystrixCommand (或 Sentinel) 添加 fallback 逻辑。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>RestTemplate vs WebClient (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>同步异步调用对比、性能测试、最佳实践。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写测试用例。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 创建一个会 Thread.sleep(200) 的下游服务接口。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 分别使用 RestTemplate 和 WebClient 并发调用此接口 100 次。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 比较两者的总耗时，直观感受 WebClient 异步非阻塞带来的性能优势。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>全局异常处理 (1.5 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>@ControllerAdvice、自定义异常、统一返回格式。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 创建一个统一的 ApiResponse<T> 封装类。</T></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 创建一个自定义异常 BusinessException。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 使用 @RestControllerAdvice 注解创建一个全局异常处理器，并在其中使用 @ExceptionHandler 捕获 BusinessException 和 Exception，将其统一封装成 ApiResponse 格式返回。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-1">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>第一次 Cambly 对话 (30 min) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>话题：自我介绍、讨论最近的技术学习。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>提前准备好对话提纲：1. 自我介绍。 2. 描述你本周学习的 Spring Security 或 Spring Cloud 的一个具体知识点。 3. 准备 1-2 个问题请教外教。对话结束后，回看录像，记录自己表达不顺畅的地方。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>YouTube 技术视频精听 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Spring Boot Tutorial 系列，1.0 倍速，做笔记。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>观看 “Spring Boot Tutorial for Beginners” 系列视频。第一遍正常观看，理解内容。第二遍打开英文字幕，暂停并记录不熟悉的单词或表达。第三遍关掉字幕，尝试听懂每一个句子。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>技术博客朗读录音 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>选 Medium 上的 Java 文章，录音后对比原音频。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 baeldung.com 或 vladmihalcea.com 上找一篇关于 Java 或 Spring 的文章。朗读全文并录音，然后与原文音频（如果有的话）或自己的语感进行对比，纠正发音。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-1">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>链表专题×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>反转链表、合并链表、找环、找交点。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每天攻克一个链表高频题，例如: 206. Reverse Linked List, 21. Merge Two Sorted Lists, 141. Linked List Cycle (快慢指针), 160. Intersection of Two Linked Lists。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>链表题型总结 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>dummy 节点技巧、快慢指针应用、递归 vs 迭代。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在笔记中总结链表题的常用技巧。Dummy 节点: 简化对头节点的特殊处理。快慢指针: 用于找中点、判断环、找环的入口。递归 vs 迭代: 对比两种方式反转链表的代码实现和优缺点。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-1">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>短链系统-核心代码实现 (5 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>ID 生成器、长短链映射、301 跳转实现。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. ID生成器: 实现一个基于雪花算法 (Snowflake) 或自定义进制转换的短码生成器。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 映射存储: 编写 UrlMappingService，实现将 short_code 和 long_url 存入数据库的逻辑。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 301跳转: 编写一个 Controller，接收 /{shortCode} 请求，从数据库查找 long_url，并返回 301 (永久重定向) 状态码。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>短链系统-缓存层设计 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Redis 缓存策略、缓存更新、缓存击穿处理。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 在 pom.xml 中添加 spring-boot-starter-data-redis。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 在 UrlMappingService 的查询方法上添加 @Cacheable 注解，实现查询结果的自动缓存。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 思考并写下笔记：如何处理缓存穿透（缓存空对象）、缓存击穿（热点key失效用锁）和缓存雪崩（过期时间加随机值）。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-1">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-3-周jvm-与并发编程">第 3 周：JVM 与并发编程</h2> <h3 id="技术学习-2">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>JVM 内存模型 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>堆、栈、方法区、程序计数器、本地方法栈。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写简单的 Java 代码，并用文字或画图解释其在 JVM 内存中的分布。例如 User user = new User();，说明 user 引用在栈上，而 new User() 对象实例在堆上。解释方法区（元空间）存储了类信息。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>垃圾回收算法 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>标记清除、复制、标记整理、分代收集。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>重点理解不同算法的适用场景。标记-清除 (产生碎片), 复制 (无碎片但浪费空间，适用于新生代), 标记-整理 (无碎片但效率稍低，适用于老年代)。画图演示这三种算法的执行流程。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>GC 调优实战 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>GC 日志分析、常用参数调整、OOM 排查。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 编写一个会不断创建对象的程序来模拟内存溢出 (OOM)。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 使用 JVM 参数 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError 运行，并获取 heap dump 文件。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 使用 VisualVM 或 MAT (Memory Analyzer Tool) 打开 dump 文件，分析是哪个对象占用了最多内存。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>并发基础：synchronized vs Lock (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>原理对比、使用场景、性能差异。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写代码对比两者。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 用 synchronized 实现一个简单的线程安全计数器。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 用 ReentrantLock 实现同样的功能，并务必在 finally 块中调用 unlock()。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 尝试使用 ReentrantLock 的 tryLock() 方法，演示其可中断和可超时的特性。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>线程池详解 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>7 大参数、4 种拒绝策略、最佳实践。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>不要使用 Executors 的工厂方法。直接 new ThreadPoolExecutor(…)，手动传入 7 个核心参数，并清楚解释每个参数的含义（核心线程数、最大线程数、存活时间、队列类型、拒绝策略等）。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-2">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>模拟技术面试-自我介绍 (1 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>录制 5 个版本，选出最佳版本。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>针对不同类型的公司（大厂、创业公司、外企）准备三个版本的英文自我介绍，并分别录制。听自己的录音，改进语调和流利度。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>技术播客 1.1 倍速练习 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>逐步提升听力速度，做关键词笔记。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>听 “Java Pub House” 或 “Talking Kotlin” 等播客。先用 1.0 倍速听懂大意，再用 1.1 倍速进行第二遍收听，训练大脑处理更快语速的信息。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>第二次 Cambly 对话 (30 min) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>话题：解释一个技术概念（如微服务）。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>本次对话主题：向外教解释 JVM 的垃圾回收机制。提前画好示意图，练习用简单的语言 (like “It’s like a janitor cleaning up unused objects in memory.”) 解释复杂概念。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-2">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>二叉树专题×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>前序、中序、后序遍历、层序遍历、最大深度。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>练习二叉树遍历：144. Preorder, 94. Inorder, 145. Postorder (递归和迭代两种方法都要掌握), 102. Level Order Traversal。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>二叉树题型总结 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>递归遍历、迭代遍历、Morris 遍历。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>总结三种遍历方式的迭代实现模板。前序: 栈，先入右子节点再入左子节点。中序: 栈+指针，一路向左，到底后处理并转向右子树。后序: 双栈法或前序遍历的变种。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-2">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>短链系统-并发优化 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用线程池处理请求、同步锁保护共享资源。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 线程池: 对于一些非核心操作（如记录访问统计），使用 @Async 注解和一个自定义的 ThreadPoolTaskExecutor 将其异步化。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 同步锁: 当出现缓存击穿时，使用 synchronized 或 ReentrantLock 保护数据库查询代码块，防止多个线程同时查询数据库。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>短链系统-测试与部署 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>单元测试、集成测试、Docker 部署。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 使用 JUnit 和 Mockito 为 UrlMappingService 编写单元测试。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 使用 @SpringBootTest 编写集成测试，测试完整的 Controller -&gt; Service -&gt; DAO 链路。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 编写 Dockerfile 将应用打包成 Docker 镜像，并成功在本地 Docker 环境中运行起来。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-2">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-4-周分布式基础---redis">第 4 周：分布式基础 - Redis</h2> <h3 id="技术学习-3">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Redis 数据结构复习 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>String, List, Set, Hash, ZSet 的使用场景。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>为每种数据结构匹配一个具体的业务场景并写出示例代码。String: 存储用户Session或文章阅读数。Hash: 存储一个用户的完整信息对象。List: 实现一个简单的消息队列。Set: 存储一篇文章的点赞用户ID列表。ZSet: 实现一个游戏积分排行榜。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Redis 持久化机制 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>RDB vs AOF, 配置和优化。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>亲自修改 redis.conf 文件。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 开启 RDB 并设置 save 策略，然后执行 BGSAVE 并查看 dump 文件。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 开启 AOF 并设置 appendfsync 策略为 everysec，然后观察 aof 文件是如何记录写命令的。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Redis 集群方案 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>主从复制、哨兵模式、Cluster 模式。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>画出三种架构的示意图并解释其优缺点。主从复制: 解决数据备份和读扩展。哨兵模式: 在主从基础上实现自动故障转移。Cluster模式: 真正的分布式方案，通过哈希槽实现数据分片，解决单机容量和性能瓶颈。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Redis 实战场景 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>缓存穿透、缓存雪崩、热点 key 处理。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>针对每个问题，给出清晰的定义和解决方案。缓存穿透: 查询一个不存在的数据。解决方案：缓存空对象或使用布隆过滤器。缓存击穿: 热点Key失效。解决方案：使用互斥锁（如 SETNX）只让一个线程去加载数据。缓存雪崩: 大量Key同时失效。解决方案：给Key的过期时间增加一个随机值。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-3">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>第三次 Cambly 对话 (30 min) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>话题：描述一个技术项目。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>对话主题：向外教描述你的“短链系统”项目。练习使用 First, Then, Finally 等连接词来有条理地介绍项目背景、技术架构和挑战。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>技术视频 1.25 倍速练习 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Redis Tutorial 系列，做笔记。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 YouTube 搜索 “Redis Explained” 或 “Redis Tutorial”。先用 1.0 倍速观看并做笔记，然后用 1.25 倍速进行第二遍观看，检验自己是否仍能跟上节奏。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>英文技术文章阅读 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>选 Redis 相关文章，总结关键点。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>阅读 Redis 官方文档中关于持久化或集群的章节。目标不是读懂每个单词，而是能总结出该章节的核心思想和关键配置项。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-3">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>图论基础×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>BFS, DFS, 最短路径。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>练习图的两种基本遍历：BFS (常用于求无权图最短路径) 和 DFS (常用于遍历所有可能性)。练习题目: 200. Number of Islands (DFS/BFS), 797. All Paths From Source to Target (DFS)。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>图题型总结 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>邻接表 vs 邻接矩阵，Union-Find。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>总结图的两种表示方法：邻接矩阵 (适合稠密图) 和邻接表 (适合稀疏图) 的代码实现。学习并实现一个基础的并查集 (Union-Find) 模板，用于解决连通性问题。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-3">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>短链系统-集成 Redis (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 Redis 作为缓存，实现高可用。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将之前 @Cacheable 的缓存实现，替换为手动操作 RedisTemplate。在查询时，先查 Redis，若没有再查数据库，并将结果写入 Redis。这样可以更精细地控制缓存的过期时间和更新策略。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>性能测试与优化 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 JMeter 测试，优化瓶颈。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 JMeter 对未加缓存和加入Redis缓存后的重定向接口进行压力测试。记录下 QPS、平均响应时间、P99 响应时间等关键指标，并制作一个简单的对比图表，这将是简历上的亮点。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-3">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h1 id="第-2-月---深度强化">第 2 月 - 深度强化</h1> <h2 id="第-1-周分布式基础---kafka">第 1 周：分布式基础 - Kafka</h2> <h3 id="技术学习-4">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Kafka 架构原理 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Broker, Topic, Partition, Replica。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>画出 Kafka 的整体架构图。清晰地解释 Broker, Topic, Partition, Replica, Producer, Consumer, Consumer Group, Zookeeper/KRaft 各自的角色和关系。特别是要理解 Partition 是实现并行处理和水平扩展的关键。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>生产者模式 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>同步/异步发送、ACK 配置。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写一个 Kafka Producer。重点关注并测试三个 acks 配置 (0, 1, all) 对消息可靠性和性能的影响。了解并实践如何配置 retries 和 idempotence 来保证消息不丢失且不重复。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>消费者模式 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>消费者组、偏移量管理、再平衡。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写一个 Kafka Consumer。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 启动多个实例并指定同一个 group.id，观察 Partition 是如何被分配给不同实例的。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 尝试手动提交和自动提交偏移量，理解两者的区别和适用场景。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Kafka 实际应用案例 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>日志收集、流处理、消息队列。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在“短链系统”项目中，将原来的同步写访问日志改为：Controller 接收请求后，立即发送一条日志消息到 Kafka 的 access_log 主题，然后由一个独立的日志服务去消费和处理。以此来实践业务解耦。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-4">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>第四次 Cambly 对话 (30 min) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>话题：讨论分布式系统挑战。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>对话主题：讨论分布式系统面临的挑战，如网络延迟、节点故障、数据一致性。提前学习 CAP 理论和 BASE 理论的英文表达。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Kafka 相关英文视频练习 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1.25 倍速，笔记关键词。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>观看 Confluent 官方 YouTube 频道上的 “Kafka 101” 系列视频。用 1.25 倍速观看，练习在快速语境中抓取关键词（如 Partition, Offset, Broker, Zookeeper）。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>英文技术博客写作入门 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>写 Kafka 基础笔记。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>就本周学习的 Kafka 知识，写一篇 300-500 字的英文笔记或博客。主题可以是 “What is Kafka?” 或 “Kafka Producer’s Key Configurations”。使用 Grammarly 等工具检查语法。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-4">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>动态规划基础×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>背包问题、斐波那契、LCS。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>攻克 DP 入门经典题目：70. Climbing Stairs (斐波那契数列), 198. House Robber, 322. Coin Change, 53. Maximum Subarray。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>DP 模板总结 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>状态定义、转移方程、初始化。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>总结 DP 解题五步法：1. 定义 dp 数组的含义。 2. 找出状态转移方程。 3. 初始化 dp 数组。 4. 确定遍历顺序。 5. 举例推导 dp 数组。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-4">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>集成 Kafka 到短链系统 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>异步日志记录、消息通知。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 添加 spring-kafka 依赖。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 创建一个 KafkaProducerService，用于发送短链的访问日志。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 在重定向 Controller 中调用该服务。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>4. 创建一个 KafkaConsumerService，使用 @KafkaListener 注解来消费日志消息并打印。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>系统设计：URL Shortener 扩展 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>高可用设计、全球分布。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>思考并写下设计文档，解决两个问题：1. 如何实现自定义短链接？ (在 url_mapping 表中增加一个 custom_code 字段)。 2. 如何统计每个短链接的 PV/UV？ (使用 Redis 的 HyperLogLog 统计UV，使用 INCR 命令统计PV)。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-4">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-2-周性能调优与监控">第 2 周：性能调优与监控</h2> <h3 id="技术学习-5">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>性能调优工具 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>JProfiler, VisualVM 使用。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 启动你的 Spring Boot 应用。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 打开 VisualVM，连接到该应用的 Java 进程。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 使用 Sampler 页签找到 CPU 占用最高的“热点”方法。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>4. 使用 Profiler 页签进行内存分析，观察对象创建和 GC 情况。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>监控系统介绍 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Prometheus + Grafana 基础。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 在本地通过 Docker 启动 Prometheus 和 Grafana。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 配置 Prometheus 的 prometheus.yml 文件，添加一个 scrape job 来抓取你的 Spring Boot 应用暴露的 /actuator/prometheus 端点。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 在 Grafana 中配置 Prometheus 为数据源，并创建一个仪表盘，添加一个图表来展示 http_server_requests_seconds_count 指标，从而监控 QPS。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>链路追踪 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Zipkin or Jaeger 原理。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>概念学习为主。理解 Trace 和 Span 的父子关系。画图解释当一个请求跨越多个微服务（A -&gt; B -&gt; C）时，Trace ID 是如何通过 HTTP Header (如 B3 Propagation) 传递的，从而将所有 Span 串联起来。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-5">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>模拟面试：行为问题 (1 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>准备 STAR 方法回答。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>准备 3 个最常见的行为问题：”Tell me about a time you had a conflict with a teammate.”, “Describe a challenging technical problem you solved.”, “Tell me about a project you are most proud of.”。为每个问题都用 STAR 法则写下详细的英文回答稿。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>技术播客跟读 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>性能调优主题。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>找一个关于性能调优主题的播客片段。第一遍听，理解大意。第二遍，使用能够调速和复读的播放器，进行逐句跟读，重点模仿专业术语的发音和表达方式，例如 “latency bottleneck”, “memory footprint”, “garbage collection overhead”。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-5">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>贪心算法×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>区间调度、跳跃游戏。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>重点攻克贪心算法的经典题型。例如：455. Assign Cookies (理解贪心思想), 435. Non-overlapping Intervals (区间调度), 55. Jump Game, 122. Best Time to Buy and Sell Stock II。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>贪心总结 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>证明正确性方法。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>总结贪心算法的适用场景：通常涉及局部最优解能推导出全局最优解的问题。写下笔记，区分它与动态规划的区别（贪心不做后悔的选择，而DP会考虑所有选择的最优结果）。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-5">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>添加监控到短链系统 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>集成 Micrometer + Prometheus。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 在 pom.xml 中添加 spring-boot-starter-actuator 和 micrometer-registry-prometheus 依赖。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 在 application.yml 中配置 management.endpoints.web.exposure.include: prometheus 来暴露指标端点。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 运行应用，访问 http://localhost:8080/actuator/prometheus，确保能看到监控指标输出。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-5">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-3-周系统设计基础">第 3 周：系统设计基础</h2> <h3 id="技术学习-6">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>系统设计方法论 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>4S 分析法：Scenario, Service, Storage, Scale。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>找一个简单的系统设计问题，如“设计一个图片分享网站的后端”。严格按照 4S 法则进行思考和陈述：1. Scenario: 明确功能（上传/查看/评论），估算QPS和存储（DAU 1M）。 2. Service: 拆分为用户服务、图片服务、评论服务。 3. Storage: 用户数据用MySQL，图片用对象存储S3/OSS，评论用MongoDB。 4. Scale: 图片服务前加CDN，数据库做读写分离。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>常见设计模式 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>负载均衡、缓存、一致性哈希。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>为每个模式画一个简单的架构图。负载均衡: 解释常见的轮询、最少连接等策略。缓存: 画出 Cache-Aside 模式的流程图。一致性哈希: 画图演示当一个节点增减时，它如何比普通取模哈希影响更少的数据。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-6">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>系统设计英文视频 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Grokking the System Design Interview。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>观看 “Grokking the System Design Interview” 或 “Exponent” 频道上的系统设计面试视频。主动学习法： 视频开始时，面试官提出问题后暂停，自己先花 15 分钟设计一个草案，然后再继续观看，对比自己的思路和视频中讲解的差距。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-6">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>堆与优先队列×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Kth largest, merge k lists。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>掌握 PriorityQueue 的使用。练习相关经典题目：215. Kth Largest Element in an Array (小顶堆), 347. Top K Frequent Elements (小顶堆), 23. Merge k Sorted Lists (小顶堆)。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-6">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>设计 Twitter 系统框架 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>用户时间线、推文存储、粉丝模型。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>撰写一份迷你系统设计文档。1. API 设计: 设计发推、关注/取关、获取时间线的核心 API。 2. 数据库Schema: 设计用户表、推文表、关注关系表。 3. 核心挑战分析: 重点分析“粉丝很多的大V发推文”场景下，如何设计时间线（Timeline）的生成和读取（写扩散 vs 读扩散）。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-6">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-4-周项目故事准备">第 4 周：项目故事准备</h2> <h3 id="技术学习-7">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>STAR 方法复习 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Situation, Task, Action, Result。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将你在“短链系统”中做的最大亮点（如性能优化），严格按照 STAR 法则写成一段话。确保 A (Action) 部分足够详细，R (Result) 部分有数据支撑。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-7">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>项目故事英文版准备 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>翻译并练习讲述。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>选择你过去做过的另外两个项目（可以是课程设计、实习项目或个人作品）。同样使用 STAR 法则和“项目指标化”的方法，将它们包装成两个可以随时在面试中讲述的精彩故事。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-7">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>回顾上月算法 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>重做难题。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>回到第 1 个月练习过的数组和链表题目。找出当时做起来比较困难的 5 道题，不看答案，重新做一遍。目标是能在 15 分钟内写出 bug-free 的代码。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-7">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>扩展 2 个项目故事 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>应用 STAR 法则。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>选择你过去做过的另外两个项目（可以是课程设计、实习项目）。同样使用 STAR 法则和“项目指标化”的方法，将它们包装成两个可以随时在面试中讲述的精彩故事，并写入简历草稿中。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-7">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h1 id="第-3-月---云原生入门">第 3 月 - 云原生入门</h1> <h2 id="第-1-周docker-基础">第 1 周：Docker 基础</h2> <h3 id="技术学习-8">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Docker 安装与基本命令 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>pull, run, exec, logs。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>练习核心命令：docker pull (拉取镜像), docker run -d -p 8080:8080 (后台运行并映射端口), docker ps (查看运行中的容器), docker exec -it <container_id> /bin/sh (进入容器交互), docker logs -f (实时查看日志), docker stop/rm (停止/删除容器)。</container_id></li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Dockerfile 编写 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>多阶段构建、最佳实践。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>为你的“短链系统”编写一个 Dockerfile。使用多阶段构建 (multi-stage build)：第一阶段使用 maven 镜像打包 jar 文件，第二阶段使用轻量的 openjdk 镜像，仅复制第一阶段的 jar 文件来运行。这能显著减小最终镜像大小。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Docker Compose (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>多容器应用管理。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写 docker-compose.yml 文件，定义三个服务：app (你的短链系统), redis, mysql。通过 depends_on 控制启动顺序，通过 networks 让它们处于同一个网络中互相通信。实现 docker-compose up -d 一键启动整个应用环境。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-8">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Docker 英文教程视频 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1.5 倍速练习。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>观看 “Docker Tutorial for Beginners” 系列视频，在 1.5 倍速下练习听力，并跟着视频亲手敲每一个命令，确保理解其作用。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>参加线上英语技术 meetup (1 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>讨论容器化。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 Meetup.com 或 Eventbrite 上寻找关于 Docker 或云原生的线上活动。即使不发言，也要全程参与，感受技术讨论的氛围，并记录下高频出现的专业词汇。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-8">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>字符串处理×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>KMP, Rabin-Karp。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>练习字符串匹配算法，重点是 KMP 算法的思想（理解 next 数组的含义）。练习题目: 28. Implement strStr(), 459. Repeated Substring Pattern。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-8">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>容器化短链系统 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写 Dockerfile 并运行。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>运行 mvn clean package 打包项目。然后执行 docker build -t short-url-app . 构建镜像。最后，执行 docker-compose up -d 启动整个应用，并通过 localhost:8080 成功访问到服务。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-8">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-2-周kubernetes-入门">第 2 周：Kubernetes 入门</h2> <h3 id="技术学习-9">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>K8s 核心概念 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Pod, Node, Cluster。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在本地安装 Minikube。理解核心关系：Deployment 是一个“控制器”，它根据模板创建和管理 ReplicaSet，而 ReplicaSet 则确保指定数量的 Pod 始终在运行。Pod 是 K8s 中最小的部署单元。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Deployment 和 Service (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>滚动更新、负载均衡。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写 deployment.yaml，定义应用的镜像、副本数 (replicas: 3)。编写 service.yaml，类型设置为 NodePort，将 Service 的端口暴露到集群外部，从而可以通过 minikube ip:<node_port> 访问到你的应用。</node_port></li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>ConfigMap 和 Secret (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>配置管理。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将 application.yml 中的数据库配置抽离出来，存入一个 ConfigMap。将数据库密码存入一个 Secret。然后在 deployment.yaml 中，通过环境变量 (envFrom) 的方式将它们注入到应用的 Pod 中。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-9">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>K8s 英文文档阅读 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>总结术语。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>阅读 Kubernetes 官方文档中关于 “Concepts” -&gt; “Workloads” -&gt; “Deployments” 的章节。目标是能够用自己的话，结合英文术语，解释什么是滚动更新 (Rolling Update) 和回滚 (Rollback)。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>模拟英文面试：云原生 (1 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>解释 K8s 优势。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>准备并练习用英文回答这个问题：”Why would a company choose Kubernetes over Docker Compose for production?” 答案应覆盖可伸缩性 (scalability)、自愈能力 (self-healing)、服务发现 (service discovery) 等方面。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-9">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>二分搜索变体×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>旋转数组、峰值元素。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>练习非标准数组上的二分搜索。例如：33. Search in Rotated Sorted Array, 153. Find Minimum in Rotated Sorted Array, 162. Find Peak Element。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-9">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>部署短链系统到 Minikube (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>创建 Deployment 和 Service。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 将你的应用镜像推送到 Docker Hub。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 编写 deployment.yaml 和 service.yaml。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 在 Minikube 环境中，依次执行 kubectl apply -f deployment.yaml 和 kubectl apply -f service.yaml。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>4. 使用 kubectl get pods 和 kubectl get services 检查状态，并成功通过暴露的 NodePort 访问到你的应用。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-9">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-3-周云服务基础">第 3 周：云服务基础</h2> <h3 id="技术学习-10">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>AWS EC2 和 S3 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>实例创建、存储桶管理。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>注册一个 AWS 免费套餐账户。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. EC2: 启动一个 t2.micro 的 Amazon Linux 实例，并通过 SSH 客户端连接上去。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. S3: 创建一个存储桶 (Bucket)，通过 Web 控制台上传一张图片，并将其设置为公开访问，获取其访问 URL。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>阿里云 RDS 和 OSS (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>数据库实例、对象存储。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>类似地，在阿里云上：</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. RDS: 创建一个最基础配置的 MySQL 实例，获取其连接地址、用户名和密码。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. OSS: 创建一个 Bucket，上传一个文件，并了解其读写权限的设置。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>云安全基础 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>IAM, VPC。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>IAM: 创建一个新用户，只授予其 S3 的只读权限，然后使用这个用户的 Access Key 尝试上传文件，验证权限是否生效。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>VPC/安全组: 在 EC2 的安全组中，尝试关闭 22 (SSH) 端口，验证你是否无法再连接。然后再打开它。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-10">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>云服务英文文档 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>AWS 文档阅读。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>阅读 AWS Well-Architected Framework 的白皮书摘要。重点理解其五大支柱的英文名称和核心含义: Operational Excellence, Security, Reliability, Performance Efficiency, Cost Optimization。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-10">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>回溯算法×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>子集、排列、组合。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>掌握回溯算法的模板（选择、递归、撤销选择）。练习经典题目：46. Permutations (排列), 77. Combinations (组合), 78. Subsets (子集)。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-10">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>部署到云平台 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 ECS 部署短链系统。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 将你的“短链系统”应用打包成一个可执行的 jar 文件。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>2. 将 jar 文件上传到你创建的 EC2 实例上。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>3. 在 application.yml 中，将数据库地址修改为你创建的 RDS 实例地址。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>4. 在 EC2 上运行 java -jar your-app.jar，并确保 EC2 的安全组开放了 8080 端口，然后通过公网 IP 成功访问。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-10">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-4-周linux-运维基础">第 4 周：Linux 运维基础</h2> <h3 id="技术学习-11">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>常用命令实践 (2 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>ls, cd, grep, awk, sed 等。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>登录到你的 EC2 服务器上，进行实战练习。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>文件/目录: ls -al, mkdir, touch, cp, mv, rm -rf。</li> <li> <table> <tbody> <tr> <td>[ ] 文本处理: 使用 grep ‘error’ app.log</td> <td>awk ‘{print $1, $5}’</td> <td>sort</td> <td>uniq -c 组合命令来统计日志中每种错误信息的出现次数。</td> </tr> </tbody> </table> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>系统监控: 使用 top 查看 CPU/内存占用，使用 df -h 查看磁盘空间，使用 netstat -tuln 查看端口监听。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>shell 脚本入门 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>自动化部署脚本。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>编写一个 deploy.sh 脚本，实现自动化部署“短链系统”到你的 EC2 服务器上。脚本应包含以下步骤：git pull, mvn clean package, 停止旧的Java进程 (kill), 然后在后台启动新的 jar 包 (nohup java -jar … &amp;)。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-11">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Linux 命令英文解释 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>man page 阅读。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>学习如何阅读 man page。例如，执行 man ls，然后尝试理解 -l, -a, -h 等参数的英文解释。目标是能够独立通过 man page 学习一个不熟悉的命令。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-11">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>回顾云原生相关算法 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>负载均衡算法。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>概念学习为主。研究并能解释至少三种负载均衡算法的原理：1. Round Robin (轮询)。 2. Least Connections (最少连接)。 3. IP Hash。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-11">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>搭建个人服务器部署项目 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 Linux VM。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>综合本周所学，将你的 deploy.sh 脚本完善并实际运行在 EC2 实例上。最终目标是：在本地 git push 代码后，只需登录服务器执行一个 ./deploy.sh 命令，就能完成应用的更新部署。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-11">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h1 id="第-4-月---架构进阶">第 4 月 - 架构进阶</h1> <h2 id="第-1-周微服务架构">第 1 周：微服务架构</h2> <h3 id="技术学习-12">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>服务注册与发现 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Nacos or Consul。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将“短链系统”拆分为两个服务：short-url-service 和 user-service。在本地启动一个 Nacos Server。让这两个服务都作为 Nacos Client 注册到 Nacos 上。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>配置中心 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Apollo or Spring Cloud Config。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 Nacos 上创建一个配置文件，例如 short-url-service.yml，并将服务中的数据库配置等信息移到 Nacos 上。在服务中引入 Nacos Config 依赖，并配置 bootstrap.yml 来拉取配置。尝试在 Nacos 页面上修改配置，验证服务无需重启即可动态生效。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>网关 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Spring Cloud Gateway。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>创建第三个服务 api-gateway，引入 Spring Cloud Gateway 依赖。在 application.yml 中配置路由规则，将 /api/user/** 的请求转发到 user-service，将 /api/url/** 的请求转发到 short-url-service。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-12">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>微服务英文博客 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Medium 文章阅读。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>阅读 Martin Fowler 的著名文章 “Microservices”。目标是理解微服务架构的核心思想，如：组件化、围绕业务能力组织、去中心化治理等。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>写一篇微服务英文博客 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>发布到 Medium。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 Medium 或个人博客上，分享你本周将“短链系统”进行微服务改造的过程和心得。文章结构可以包括：Why Microservices?, The Architecture, Challenges Faced。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-12">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>设计相关算法×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>LRU Cache, LFU。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>亲手实现一个 LRU Cache (最近最少使用缓存)。可以使用 HashMap + 双向链表的方式实现，确保 get 和 put 操作的时间复杂度都是 O(1)。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-12">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将短链系统微服务化 (4 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>拆分服务，添加注册中心。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>完成代码拆分，确保服务能独立运行、注册到 Nacos，并通过 Gateway 成功访问。重点是处理服务间的调用（使用 Feign 或 RestTemplate），以及统一的配置管理。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-12">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-2-周系统设计实践---youtube">第 2 周：系统设计实践 - YouTube</h2> <h3 id="技术学习-13">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>视频上传与存储 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>分片上传、CDN。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>画出视频处理的流程图：1. 用户通过App/Web上传视频。 2. 后端接收视频文件，存入对象存储 (S3/OSS)。 3. 触发一个转码任务（放入消息队列）。 4. 转码服务器从队列获取任务，将原视频转码成多种分辨率 (1080p, 720p, 480p) 和格式 (HLS, DASH)。 5. 转码后的文件存回对象存储。 6. 用户观看时，通过 CDN 加速分发。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>推荐系统概述 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>协同过滤、内容基于。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>概念学习。理解协同过滤的核心思想：“物以类聚，人以群分”。基于用户的协同过滤: 找到与你品味相似的用户，把他喜欢的而你没看过的视频推荐给你。基于物品的协同过滤: 找到与你喜欢的视频相似的视频推荐给你。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-13">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>YouTube 系统设计视频 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>英文讲解练习。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>观看 “System Design Interview – A step by step guide” 系列中关于设计 YouTube 的视频。练习跟读视频中解释权衡 (trade-off) 的部分，例如：”On one hand, we can do this… but the downside is… So, a better approach would be…”</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-13">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>图算法进阶×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Dijkstra, Floyd。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>学习并实现两种核心的最短路径算法：Dijkstra (适用于无负权边) 和 Floyd-Warshall (适用于所有点对，可处理负权边)。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-13">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>设计 YouTube 系统 (5 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>视频流、推荐、搜索。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在系统设计文档中，重点细化两个模块：1. 视频上传流程图 (同技术学习部分)。 2. 视频推荐系统架构：画出离线和实时推荐的流程。离线部分使用 Spark/MapReduce 计算相似度，实时部分根据用户当前行为进行调整。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-13">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-3-周系统设计实践---twitter">第 3 周：系统设计实践 - Twitter</h2> <h3 id="技术学习-14">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>时间线设计 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Fanout on write vs read。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>重点对比两种模式的读写放大问题。写扩散 (Fan-out-on-write): 发推文时，将推文ID写入所有粉丝的时间线列表（存放在Redis ZSet中）。读请求非常快，但写请求很重。读扩散 (Fan-out-on-read): 读时间线时，实时去拉取所有关注对象的最新推文再聚合。写请求快，但读请求非常慢。理解业界通常采用两者结合的混合模式。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>趋势与搜索 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Elasticsearch 集成。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>画出数据流图。1. 用户发推文，推文数据进入 Kafka。 2. Flink/Spark Streaming 实时消费 Kafka 数据，进行热点词（Hashtag）统计，并将结果存入 Redis。 3. 另一路消费 Kafka，将推文数据写入 Elasticsearch 建立索引。 4. 用户请求趋势榜时读 Redis，请求搜索时查询 Elasticsearch。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-14">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Twitter 系统设计讨论 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Cambly 练习。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 Cambly 上与外教进行一次角色扮演。你扮演面试者，向外教（扮演面试官）解释你将如何设计 Twitter 的时间线功能。重点练习如何清晰地阐述你做出的技术权衡。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-14">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>滑动窗口进阶×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>最大子数组、最长无重复。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>练习需要存储额外信息的滑动窗口题目。例如：239. Sliding Window Maximum (需要使用单调队列), 3. Longest Substring Without Repeating Characters。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-14">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>设计 Twitter 系统 (5 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>推文、关注、时间线。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在系统设计文档中，重点细化时间线模块的设计。画出混合模式的架构图：对普通用户使用写扩散，对大V (celebrities) 使用读扩散，并解释这样做的原因。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-14">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h2 id="第-4-周面试模拟">第 4 周：面试模拟</h2> <h3 id="技术学习-15">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>常见面试题复习 (2 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>微服务优缺点。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>准备并能流利回答这些问题：1. 微服务和单体的优缺点对比？ 2. CAP 理论和 BASE 理论是什么？ 3. 分布式事务有哪些解决方案？(2PC, TCC, SAGA, 可靠消息最终一致性) 4. 如何设计一个高可用的系统？(冗余、降级、限流、隔离)</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-15">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>模拟系统设计面试 (1 h×3) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>用英文回答。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 Pramp 或找朋友进行模拟。严格遵守45分钟的时间限制。练习主动与面试官沟通，澄清需求，画出架构图，并有条理地阐述你的设计选择和权衡 (trade-off)。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-15">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>mock 面试算法题 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>时间限制内解决。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在白板或 A4 纸上手写代码，而不是用 IDE。练习在没有代码补全和实时纠错的情况下，写出语法正确、逻辑清晰的代码。写完后，自己充当测试人员，想出几个测试用例（包括边界情况）来验证代码的正确性。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-15">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Pramp 系统设计练习 (2 h×2) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>模拟面试。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>完成至少两场 Pramp 上的系统设计面试。一场扮演面试者，一场扮演面试官。扮演面试官能让你更好地理解面试官的考察点，从而在自己面试时表现得更好。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-15">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 技术学习</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 项目实战</li> </ul> <hr/> <h1 id="第-5-月---面试冲刺">第 5 月 - 面试冲刺</h1> <h2 id="第-1-周简历优化">第 1 周：简历优化</h2> <h3 id="技术学习-16">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>更新技术栈 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在简历的“技术栈”部分，将云原生技能具体化，例如：Docker (熟练编写多阶段构建Dockerfile)、Kubernetes (熟悉核心组件，有Minikube部署经验)、Prometheus (通过Micrometer暴露指标并搭建监控)。</li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>量化成果 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>为“短链系统”项目添加 3-5 个硬核数据指标。例如：性能 (QPS从500提升至8000)、稳定性 (引入Sentinel实现限流熔断)、效率 (Docker部署时间从30分钟降至2分钟)</li> </ul> </li> </ul> <h3 id="英语学习-16">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>英文简历撰写 (2 h×3) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>准备三个不同侧重点的英文简历版本：A版强调分布式系统经验，B版突出云原生实践，C版为通用后端岗。</li> </ul> </li> </ul> <h3 id="算法练习-16">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>高频题复习×7 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>LeetCode Top 100 Liked Questions，每天完成 3-4 题，并要求自己能用两种以上的方法解出其中一题。</li> </ul> </li> </ul> <h3 id="实战项目-16">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>完善项目文档 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>为 GitHub 上的“短链系统”项目撰写一份高质量的 README.md，包含清晰的技术架构图、部署指南和核心功能 GIF 演示。</li> </ul> </li> </ul> <h3 id="-每日时间分配建议-16">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职准备</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试模拟</li> </ul> <hr/> <h2 id="第-2-周投递策略">第 2 周：投递策略</h2> <h3 id="技术学习-17">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>研究目标公司技术栈 (2 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>阿里、腾讯、Google。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>1. 找 3-5 个目标岗位的 JD，提炼高频技术关键词。2. 观看该公司近一年的技术分享视频。3. 阅读其官方技术博客，了解他们遇到的挑战和解决方案。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-17">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Cover Letter 写作 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>针对你的 Dream Company，撰写一封高度定制化的英文求职信，信中要提到你对他们某项具体技术的理解或赞赏。</li> </ul> </li> </ul> <h3 id="算法练习-17">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>公司高频题练习 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Google 常见题。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 LeetCode 的企业题库功能，集中练习目标公司（如 Google）近半年内出现频率最高的 20 道题。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-17">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>海投 20 份简历 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>创建一个面试追踪表 (Excel/Notion)，记录公司、岗位、投递渠道、当前状态、反馈。重点关注那些在一周内有反馈的公司。</li> </ul> </li> </ul> <h3 id="-每日时间分配建议-17">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职准备</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试模拟</li> </ul> <hr/> <h2 id="第-3-周面试实战">第 3 周：面试实战</h2> <h3 id="技术学习-18">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>复盘面试题 (2 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>常见坑点。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每次面试后 1 小时内，立即记录所有问题。对于答得不好的技术问题，要求自己写一篇500字以上的技术博客文章来彻底搞懂它。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-18">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>英文面试复盘 (1 h×3) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>录音分析。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>如果有英文面试，请求对方允许你录音。面试后反复听录音，找出自己表达不流畅、用词不当的地方，并进行修正。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-18">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每日 3 题 (1.5 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>保持手感。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每天完成 1 道 easy、1 道 medium、1 道 hard 题目，严格限制 medium 和 hard 的解题时间在 25 分钟和 45 分钟内。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-18">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>参加 2 场面试 (变时) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>记录笔记。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>安排一场目标公司的面试和一场“保底”公司的面试。用保底公司的面试来练习和建立信心，用目标公司的面试来检验最高水平。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-18">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职准备</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试模拟</li> </ul> <hr/> <h2 id="第-4-周海外机会探索">第 4 周：海外机会探索</h2> <h3 id="技术学习-19">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>研究签证政策 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>US H1B, EU Blue Card。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>重点研究 H1B 的抽签流程、时间线和对学历/工作的要求；了解欧洲蓝卡的申请条件和优势。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-19">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>LinkedIn 优化 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>英文 profile。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将 LinkedIn 的 Profile 标题、个人简介和每一段工作经历都用 STAR 法则进行优化，添加所有相关的技能标签，并设置为“对新机会开放”。</li> </ul> </li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>联系海外人脉 (1 h×3) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>发消息。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>找到 10 位在海外目标公司工作的校友或华人工程师，发送礼貌的、个性化的好友请求，准备好一段简洁的自我介绍和问题。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-19">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>海外公司题型 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>FAANG 风格。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>重点练习图论 (Graph)、动态规划 (DP) 和系统设计相关的算法题（如 LRU Cache），这些是 FAANG 面试的重灾区。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-19">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>申请 5 个远程职位 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>准备材料。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 akeri.io、We Work Remotely 等平台上寻找合适的远程工作机会，并完成申请。重点关注对时区要求友好的公司。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-19">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职准备</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试模拟</li> </ul> <hr/> <h1 id="第-6-月---offer-收割">第 6 月 - Offer 收割</h1> <h2 id="第-1-周精投目标公司">第 1 周：精投目标公司</h2> <h3 id="技术学习-20">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>公司特定技术复习 (2 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>针对心仪公司。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>根据已预约的面试，深入复习其 JD 中要求而你相对薄弱的技术。例如，如果 JD 强调 Elasticsearch，则花一天时间复习其核心原理和 API。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-20">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>外企面试准备 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>文化适应问题。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>准备 BQ (Behavioral Questions) 问题库，特别是关于团队协作、处理冲突、项目领导力等体现文化适应性的问题，并为每个问题准备一个 STAR 故事。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-20">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>全真模拟×7 (1.5 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>45 min 内解题。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>使用 Pramp 或与朋友结对，进行 7 场 45 分钟的模拟算法面试。练习在有压力的情况下清晰地沟通思路、编写代码并处理边界情况。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-20">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>投递 10 个目标职位 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>定制简历。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>这 10 个职位都应是你真心想去的。为每一个职位都对简历进行微调，突出与该 JD 最匹配的技能和项目经历，并通过内推渠道投递。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-20">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职行动</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试实战</li> </ul> <hr/> <h2 id="第-2-周面试冲刺">第 2 周：面试冲刺</h2> <h3 id="技术学习-21">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>薄弱环节补强 (2 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>基于复盘。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>根据前几轮面试的复盘结果，找到你被问倒次数最多的 1-2 个知识领域（例如并发编程或 JVM 内存模型），进行地毯式复习和总结。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-21">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每日英文对话练习 (30 min×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Cambly。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每天和 Cambly 导师进行 30 分钟对话。主题： 用英文向导师解释一个你昨天复习的技术概念，例如“什么是 Raft 协议？”。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-21">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>随机题练习 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>适应未知。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>在 LeetCode 上使用随机选题功能，每天做 3 道题，训练自己在面对完全未知问题时的分析和建模能力。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-21">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每周 3 场面试 (变时) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>立即复盘。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将面试安排在周二、周三、周四。面试后立即复盘，总结出的问题在第二天立刻解决，确保在下一场面试中不再犯同样错误。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-21">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职行动</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试实战</li> </ul> <hr/> <h2 id="第-3-周offer-谈判准备">第 3 周：Offer 谈判准备</h2> <h3 id="技术学习-22">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>谈判技巧学习 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>薪资、福利。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>阅读或观看关于薪酬谈判的资料，学习如何沟通你的期望、如何利用 competing offer、以及如何询问福利细节（如签字费、股票归属计划等）。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-22">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Offer 谈判英文练习 (1 h×3) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>模拟对话。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>模拟与 HR 的英文电话或邮件沟通。练习如何专业地表达感谢、询问 Offer 细节、以及提出你的薪酬期望 (counter offer)。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-22">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>保持节奏练习 (1 h×7) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>每日 2 题。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>强度降低，但不能完全停止。每日完成 2 道 medium 题目，保持思维活跃，以应对可能出现的更高轮次面试。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-22">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>跟进 Offer (变时) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>邮件沟通。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>对于已经完成终面的公司，每隔 3-4 个工作日发送一封礼貌的邮件跟进进展。如果收到口头 Offer，务必请求对方发送正式的书面 Offer Letter。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-22">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职行动</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试实战</li> </ul> <hr/> <h2 id="第-4-周最终复盘与调整">第 4 周：最终复盘与调整</h2> <h3 id="技术学习-23">技术学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>6 个月总结 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>进步与不足。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>用 XMind 或类似工具，绘制一份你自己的后端技术知识图谱，将这 6 个月的所有学习内容结构化地串联起来。</li> </ul> </li> </ul> </li> </ul> <h3 id="英语学习-23">英语学习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>英语进步评估 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>录音对比。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>找出你在第 1 个月录制的英文自我介绍，现在重新录制一遍。对比两个版本，直观地感受自己的进步。</li> </ul> </li> </ul> </li> </ul> <h3 id="算法练习-23">算法练习</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>算法知识图谱构建 (2 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>总结所有模板。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>将所有刷过的题目按类型（DP, DFS, Sliding Window…）分类，并为每种类型总结出核心的解题模板和易错点。</li> </ul> </li> </ul> </li> </ul> <h3 id="实战项目-23">实战项目</h3> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>规划下一阶段 (3 h) <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>持续学习计划。</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>行动指南: <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>确定入职公司后，开始研究该公司的技术栈和内部开源框架，为 Onboarding 做准备。同时，设定入职后 3 个月的学习目标。</li> </ul> </li> </ul> </li> </ul> <h3 id="-每日时间分配建议-23">📋 每日时间分配建议</h3> <ul> <li>9:00-11:00 求职行动</li> <li>14:00-15:00 算法练习</li> <li>19:00-20:00 英语学习</li> <li>20:30-22:00 面试实战</li> </ul>]]></content><author><name></name></author><category term="Todo List"/><category term="TodoList"/><summary type="html"><![CDATA[第 1 月 - 基础回顾]]></summary></entry><entry><title type="html">Twitter Database Read and Write and Sharding System Design Detailed Guide</title><link href="https://zhengstar94.github.io//blog/2025/TwitterDatabaseReadAndWriteAndShardingSystemDesignDetailedGuide/" rel="alternate" type="text/html" title="Twitter Database Read and Write and Sharding System Design Detailed Guide"/><published>2025-08-01T00:00:00+00:00</published><updated>2025-08-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TwitterDatabaseReadAndWriteAndShardingSystemDesignDetailedGuide</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TwitterDatabaseReadAndWriteAndShardingSystemDesignDetailedGuide/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>The database is the foundational infrastructure of social platforms like Twitter/X, responsible for storing massive user data, tweets, and relationship graphs. Facing billions of DAU and hundreds of millions of daily tweets, the read/write operations are extremely unbalanced (read/write ratio 100:1), with data hotspots (e.g., celebrity tweets) and cross-query complexity becoming major bottlenecks. This article systematically introduces the architecture schemes for database read/write and sharding, trade-offs, engineering implementation details, and common interview follow-up questions, based on hybrid storage (SQL for users, NoSQL for tweets, Graph DB for relationships) and sharding strategies, aiming to achieve high throughput, low latency, and high availability.</p> <hr/> <h2 id="1-requirements-and-challenges">1. Requirements and Challenges</h2> <ul> <li><strong>Massive Data Scale</strong>: Daily writes of 24 TB+ (text, media), PB-level storage over 5 years; total accounts 15 billion, tweets in trillions.</li> <li><strong>Read/Write Imbalance</strong>: Read operations dominate (e.g., timeline aggregation requires cross-user queries), write operations require strong consistency (e.g., tweet posting).</li> <li><strong>Hotspot Issues</strong>: Celebrity user data concentration, single shard load &gt;80%; new data hotspots cause IO contention.</li> <li><strong>Low Latency and Consistency</strong>: Queries &lt;100 ms, strong consistency scenarios (e.g., authentication) allow no delay, eventual consistency (e.g., follower counts) can tolerate second-level delays.</li> <li><strong>Fault Tolerance</strong>: Continue operating during node failures or network partitions, with data replication across data centers.</li> </ul> <hr/> <h2 id="2-scheme-comparison-and-trade-offs">2. Scheme Comparison and Trade-offs</h2> <h3 id="21-sharding-by-creation-time">2.1 Sharding by Creation Time</h3> <ul> <li><strong>Principle</strong>: Distribute data to different shards based on tweet creation time (e.g., by day/week), similar to archiving file cabinets by date, facilitating time-range queries.</li> <li><strong>Advantages</strong>: Efficient time queries, only accessing a few shards; easy to archive historical data.</li> <li><strong>Disadvantages</strong>: Uneven hot/cold distribution, high write pressure on new shards (hotspots), resource waste on old shards.</li> </ul> <h3 id="22-sharding-by-user-id-hash">2.2 Sharding by User ID Hash</h3> <ul> <li><strong>Principle</strong>: Hash user ID (e.g., Murmur 3), store same-user data in the same shard, similar to classifying phone books by name initials.</li> <li><strong>Advantages</strong>: Localized user timeline queries, simple implementation.</li> <li><strong>Disadvantages</strong>: Homepage timeline requires cross-shard aggregation; hot users cause uneven shards, severe hotspots.</li> </ul> <h3 id="23-sharding-by-tweet-id-hash">2.3 Sharding by Tweet ID Hash</h3> <ul> <li><strong>Principle</strong>: Hash tweet ID to distribute data evenly, similar to randomly assigning lottery numbers to avoid concentration.</li> <li><strong>Advantages</strong>: Even data distribution, reduced hotspots; high availability, minimal fault impact.</li> <li><strong>Disadvantages</strong>: Timeline aggregation requires accessing multiple shards, high query cost (relies on caching).</li> </ul> <p>Comparison Table:</p> <table> <thead> <tr> <th>Sharding Scheme</th> <th>Advantages</th> <th>Disadvantages</th> <th>Applicable Scenario Comparison</th> </tr> </thead> <tbody> <tr> <td><strong>By Creation Time</strong></td> <td>- Efficient time queries<br/>- Easy historical data archiving</td> <td>- New shard hotspots, resource waste<br/>- Frequent creation for quick filling</td> <td>Suitable for historical data analysis, but poor for real-time read/write.</td> </tr> <tr> <td><strong>By User ID Hash</strong></td> <td>- Localized user timeline<br/>- Simple implementation</td> <td>- Many cross-shard homepage queries<br/>- Uneven hot users, severe hotspots</td> <td>Superior to time sharding in user queries, but poor large-scale scaling.</td> </tr> <tr> <td><strong>By Tweet ID Hash</strong></td> <td>- Even data distribution<br/>- Reduced hotspots, high availability</td> <td>- Complex timeline queries, requires strong caching support</td> <td>Best for large-scale: Balanced with caching for high read performance.</td> </tr> </tbody> </table> <hr/> <h2 id="3-recommended-architecture-sharding-by-tweet-id-hash--readwrite-separation">3. Recommended Architecture: Sharding by Tweet ID Hash + Read/Write Separation</h2> <h3 id="31-storage-selection">3.1 Storage Selection</h3> <ul> <li><strong>SQL (MySQL)</strong>: User profiles, authentication (strong consistency).</li> <li><strong>NoSQL (Cassandra)</strong>: Tweet storage (high throughput).</li> <li><strong>Graph DB (Neo 4 j)</strong>: Follow relationships (graph queries).</li> <li><strong>Object Storage (S 3)</strong>: Media files.</li> </ul> <h3 id="32-sharding-mechanism">3.2 Sharding Mechanism</h3> <ul> <li>Use consistent hash ring (1024 shards), with tweet ID as the key for even distribution.</li> <li>Tool: Vitess as the sharding routing layer, supporting automatic rebalancing.</li> </ul> <h3 id="33-readwrite-separation">3.3 Read/Write Separation</h3> <ul> <li>Master DB (Cassandra) dedicated to writes, consistency level QUORUM.</li> <li>Slave DB (MySQL replicas) for multiple reads, consistency level ONE; asynchronous replication tools like Debezium + Kafka to sync changes (latency &lt;1 s).</li> </ul> <h3 id="34-fault-tolerance-and-rebalancing">3.4 Fault Tolerance and Rebalancing</h3> <ul> <li>Multi-AZ deployment, Vitess automatic failover (&lt;10 s).</li> <li>Rebalancing script monitors load hourly (&gt;70% triggers), gradual data migration.</li> </ul> <p>The following is a simplified architecture diagram of the recommended architecture (Mermaid syntax):</p> <pre><code class="language-mermaid">graph TD
    A["Client Request"] --&gt; B["API Gateway"]
    B --&gt; C["Timeline/Tweet Service"]
    C --&gt; D{"Read/Write?"}
    D --&gt;|"Write"| E["Master DB: Cassandra (QUORUM Consistency)"]
    D --&gt;|"Read"| F["Slave DB: MySQL Replica (ONE Consistency)"]
    E --&gt; G["Kafka: Asynchronous Replication Changes"]
    G --&gt; F
    H["Vitess: Sharding Routing + Rebalancing"] -.-&gt; E
    H -.-&gt; F
    I["S3: Media Storage"] -.-&gt; C
    J["Neo4j: Relationship Graph"] -.-&gt; C
    K["Prometheus: Monitoring Load"] -.-&gt; H
</code></pre> <p>This diagram shows the overall process of read/write separation and sharding routing.</p> <hr/> <h2 id="4-key-data-structures-and-processes">4. Key Data Structures and Processes</h2> <h3 id="41-table-design">4.1 Table Design</h3> <ul> <li> <p><strong>User Table (MySQL)</strong>: | Field | Type | Description | |————–|————–|——————————| | userId | BIGINT | User ID (Primary Key) | | name | VARCHAR (100)| Username | | email | VARCHAR (100)| Email | | creationTime | DATETIME | Creation Time | | lastLogin | DATETIME | Last Login | | isHotUser | BOOLEAN | Whether Hot User |</p> </li> <li> <p><strong>Tweet Table (Cassandra)</strong>: | Field | Type | Description | |————–|————–|——————————| | tweetId | BIGINT | Tweet ID (Partition Key) | | userId | BIGINT | Author ID | | content | VARCHAR (280)| Content | | creationTime | TIMESTAMP | Creation Time (Clustering Key) |</p> </li> <li> <p><strong>Follow Table (Neo 4 j)</strong>: Nodes as User, relationships as FOLLOWS.</p> </li> </ul> <h3 id="42-tweet-write-and-read-process">4.2 Tweet Write and Read Process</h3> <p>The following is the process sequence diagram (Mermaid syntax):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant Client as Client
    participant Service as Tweet Service
    participant Vitess as Vitess Routing
    participant MainDB as Master DB (Cassandra)
    participant SlaveDB as Slave DB (MySQL)
    participant Kafka as Kafka Replication

    Client-&gt;&gt;Service: Post Tweet
    Service-&gt;&gt;Vitess: Calculate Shard (Tweet ID Hash)
    Vitess-&gt;&gt;MainDB: Write to Master DB
    MainDB--&gt;&gt;Vitess: Confirm
    Vitess-&gt;&gt;Kafka: Send Change Event
    Kafka-&gt;&gt;SlaveDB: Asynchronous Replication to Slave DB

    Client-&gt;&gt;Service: Query Timeline
    Service-&gt;&gt;Vitess: Route to Shards
    Vitess-&gt;&gt;SlaveDB: Read from Slave DB
    SlaveDB--&gt;&gt;Vitess: Return Data
    Vitess--&gt;&gt;Service: Aggregate Results
    Service--&gt;&gt;Client: Return
</code></pre> <h4 id="java-code-example-writing-tweet">Java Code Example (Writing Tweet)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Handle write in tweet service (sharding by tweet ID hash)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertTweet</span><span class="o">(</span><span class="kt">long</span> <span class="n">tweetId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">content</span><span class="o">,</span> <span class="nc">Timestamp</span> <span class="n">creationTime</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Calculate hash shard</span>
    <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="nc">MurmurHash3</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">tweetId</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">shard</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">hash</span> <span class="o">%</span> <span class="n">numShards</span><span class="o">);</span>

    <span class="c1">// Insert using Vitess or Cassandra client</span>
    <span class="nc">PreparedStatement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">prepare</span><span class="o">(</span><span class="s">"INSERT INTO tweets (tweetId, userId, content, creationTime) VALUES (?, ?, ?, ?)"</span><span class="o">);</span>
    <span class="nc">BoundStatement</span> <span class="n">bound</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">tweetId</span><span class="o">,</span> <span class="n">userId</span><span class="o">,</span> <span class="n">content</span><span class="o">,</span> <span class="n">creationTime</span><span class="o">);</span>
    <span class="n">session</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">bound</span><span class="o">);</span>  <span class="c1">// QUORUM consistency</span>

    <span class="c1">// Asynchronously deliver to Kafka for replication</span>
    <span class="n">kafkaProducer</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="k">new</span> <span class="nc">ProducerRecord</span><span class="o">&lt;&gt;(</span><span class="s">"tweet_changes"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">tweetId</span><span class="o">),</span> <span class="n">serializeTweet</span><span class="o">(</span><span class="n">tweetId</span><span class="o">,</span> <span class="n">userId</span><span class="o">,</span> <span class="n">content</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="java-code-example-reading-tweet">Java Code Example (Reading Tweet)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Handle read in timeline service (from slave DB)</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="nf">queryTweetsByUser</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">sinceTime</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Vitess routes to relevant shards</span>
    <span class="nc">QueryBuilder</span> <span class="n">qb</span> <span class="o">=</span> <span class="nc">QueryBuilder</span><span class="o">.</span><span class="na">select</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="s">"tweets"</span><span class="o">);</span>
    <span class="n">qb</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">eq</span><span class="o">(</span><span class="s">"userId"</span><span class="o">,</span> <span class="n">userId</span><span class="o">)).</span><span class="na">and</span><span class="o">(</span><span class="n">gt</span><span class="o">(</span><span class="s">"creationTime"</span><span class="o">,</span> <span class="n">sinceTime</span><span class="o">));</span>
    <span class="nc">ResultSet</span> <span class="n">results</span> <span class="o">=</span> <span class="n">vitessSession</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">qb</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>

    <span class="c1">// Convert to Tweet list</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">tweets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Row</span> <span class="n">row</span> <span class="o">:</span> <span class="n">results</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">tweets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Tweet</span><span class="o">(</span><span class="n">row</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="s">"tweetId"</span><span class="o">),</span> <span class="n">row</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"content"</span><span class="o">),</span> <span class="n">row</span><span class="o">.</span><span class="na">getTimestamp</span><span class="o">(</span><span class="s">"creationTime"</span><span class="o">)));</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">tweets</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="5-performance-optimization-and-engineering-details">5. Performance Optimization and Engineering Details</h2> <ul> <li><strong>Index Optimization</strong>: Cassandra secondary indexes (creationTime + userId), reducing scans.</li> <li><strong>Asynchronous Replication</strong>: Debezium captures changes, Kafka buffering, latency &lt;1 s.</li> <li><strong>Rebalancing</strong>: Vitess moveTables for gradual migration, rate-limited &lt;1 GB/min to avoid interruptions.</li> <li><strong>Media Processing</strong>: Asynchronous upload to S 3, CDN pre-warming for hot files.</li> <li><strong>Monitoring</strong>: Grafana tracks IO/CPU, shard load, alerts &gt;80% to trigger autoscaling.</li> </ul> <hr/> <h2 id="6-high-frequency-interview-follow-ups-and-real-engineering-pitfalls">6. High-Frequency Interview Follow-Ups and Real Engineering Pitfalls</h2> <h3 id="high-frequency-follow-ups">High-Frequency Follow-Ups</h3> <ul> <li>How to detect and migrate hotspot shards? (Monitor load, Vitess automatic rebalancing)</li> <li>How to ensure consistency under read/write separation? (QUORUM writes, ONE reads + asynchronous replication)</li> <li>How to dynamically adjust shard count with data growth? (Consistent hash ring expansion, virtual nodes for evenness)</li> </ul> <h3 id="engineering-pitfalls">Engineering Pitfalls</h3> <ul> <li>Replication latency peaks &gt;5 s, causing dirty reads; solution: Prioritize high-priority changes, monitor lag.</li> <li>Rebalancing interrupts service; solution: Dual-write synchronization, test with Chaos Engineering.</li> <li>High index maintenance overhead; solution: Periodic rebuilds, test query plans.</li> </ul> <h3 id="common-misconceptions">Common Misconceptions</h3> <ul> <li>Using only user ID sharding, ignoring hotspots leading to single-shard crashes.</li> <li>No read/write separation, writes drag down read performance.</li> <li>Ignoring cross-data center replication, data loss during network partitions.</li> </ul> <hr/> <h2 id="7-summary">7. Summary</h2> <p>Twitter database read/write and sharding are key to handling massive data. Through sharding by tweet ID hash + read/write separation + asynchronous replication architecture, balanced load, low latency, and high availability can be achieved. Engineering focuses on sharding routing (Vitess), consistency management (QUORUM/ONE), and monitoring degradation to avoid hotspots and fault risks. In practice, combine with caching (e.g., Redis) and message queues (e.g., Kafka) to support overall system scaling.</p>]]></content><author><name></name></author><category term="System Design Other"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Twitter Notification and Real-Time Push System Design Detailed Guide</title><link href="https://zhengstar94.github.io//blog/2025/TwitterNotificationAndReal-TimePushSystemDesignDetailedGuide/" rel="alternate" type="text/html" title="Twitter Notification and Real-Time Push System Design Detailed Guide"/><published>2025-08-01T00:00:00+00:00</published><updated>2025-08-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TwitterNotificationAndReal-TimePushSystemDesignDetailedGuide</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TwitterNotificationAndReal-TimePushSystemDesignDetailedGuide/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Notifications and real-time pushes are key interactive mechanisms in Twitter/X social platforms, used to handle events such as likes, @mentions, and replies, ensuring users receive updates promptly. Facing billions of DAU and daily billions of interactions, the system must support high-concurrency pushes, low-latency delivery, and high availability. This article systematically introduces the architecture schemes for notification pushes, trade-offs, engineering implementation details, and common interview follow-up questions, based on asynchronous decoupling (Kafka) and real-time communication (WebSocket), aiming to balance resource consumption and user experience.</p> <hr/> <h2 id="1-requirements-and-challenges">1. Requirements and Challenges</h2> <ul> <li> <p><strong>High-Frequency Interactions</strong>: Billions of notifications daily (such as likes/@), with peak TPS in the tens of thousands; hot events can trigger millions of pushes instantly.</p> </li> <li> <p><strong>Real-Time Performance</strong>: Delivery latency &lt;1 s, with frequent mobile reconnections (&gt;10% users).</p> </li> <li> <p><strong>Resource Contention</strong>: Long connections consume memory (each &gt;1 KB), peak CPU &gt;80%; queue backlogs lead to losses.</p> </li> <li> <p><strong>Consistency and Filtering</strong>: Eventual consistency can tolerate second-level delays, but active users must be distinguished to avoid invalid pushes.</p> </li> <li> <p><strong>Fault Tolerance</strong>: Limit rates and degrade during DDoS attacks or network partitions; support multi-channels (Web/mobile).</p> </li> </ul> <hr/> <h2 id="2-scheme-comparison-and-trade-offs">2. Scheme Comparison and Trade-offs</h2> <h3 id="21-websocket-push-mode">2.1 WebSocket (Push Mode)</h3> <ul> <li> <p><strong>Principle</strong>: Establish a persistent bidirectional connection where the server actively pushes notifications, similar to a real-time phone call: once there’s a message, the system directly “calls” the user’s connection.</p> </li> <li> <p><strong>Advantages</strong>: Real-time low latency (&lt;1 s), efficient bandwidth usage.</p> </li> <li> <p><strong>Disadvantages</strong>: Complex connection management, high memory/CPU under high concurrency; high reconnection overhead on disconnections.</p> </li> </ul> <h3 id="22-polling-pull-mode">2.2 Polling (Pull Mode)</h3> <ul> <li> <p><strong>Principle</strong>: The client periodically polls the server for new notifications, similar to checking a mailbox: the user asks “Any new messages?” every few seconds.</p> </li> <li> <p><strong>Advantages</strong>: Simple implementation, no need for long connections.</p> </li> <li> <p><strong>Disadvantages</strong>: High latency (average &gt; interval time), bandwidth waste (many empty polls); unsuitable for real-time scenarios.</p> </li> </ul> <h3 id="23-hybrid-mode-push--pull">2.3 Hybrid Mode (Push + Pull)</h3> <ul> <li> <p><strong>Principle</strong>: Use push (WebSocket) for online users, and pull (FCM/APNS fallback) for offline/mobile, similar to smart mail: instant notifications when online, batch delivery when offline.</p> </li> <li> <p><strong>Advantages</strong>: Balances real-time and resources, reduces invalid pushes.</p> </li> <li> <p><strong>Disadvantages</strong>: Complex multi-channel management, consistency challenges.</p> </li> </ul> <p>Comparison Table:</p> <table> <thead> <tr> <th>Scheme</th> <th>Advantages</th> <th>Disadvantages</th> <th>Applicable Scenario Comparison</th> </tr> </thead> <tbody> <tr> <td><strong>WebSocket</strong></td> <td>- Real-time delivery &lt;1 s<br/>- Low bandwidth consumption</td> <td>- High connection memory<br/>- High DDoS risk</td> <td>Superior to Polling in interaction-intensive scenarios, but requires rate limiting for high-concurrency scaling.</td> </tr> <tr> <td><strong>Polling</strong></td> <td>- Simple implementation, stateless<br/>- Easy fault tolerance</td> <td>- High latency (&gt; a few seconds)<br/>- High bandwidth/server pressure</td> <td>Suitable for low-frequency notifications, but poor real-time performance, not recommended as primary.</td> </tr> <tr> <td><strong>Hybrid Mode</strong></td> <td>- Balances online/offline<br/>- Resource optimization, delivery &gt;99%</td> <td>- Complex implementation, multi-channel synchronization<br/>- Filtering logic overhead</td> <td>Best for large-scale: Reduces pressure by 50% compared to pure push, high real-time performance.</td> </tr> </tbody> </table> <hr/> <h2 id="3-recommended-architecture-websocket-combined-with-kafka-asynchronous-push">3. Recommended Architecture: WebSocket Combined with Kafka Asynchronous Push</h2> <h3 id="31-notification-type-classification">3.1 Notification Type Classification</h3> <ul> <li> <p>Distinguish high-priority (@mentions/replies) and low-priority (likes), prioritize hot notifications.</p> </li> <li> <p>Prioritize pushes for active users (Redis online status, TTL=5 min).</p> </li> </ul> <h3 id="32-asynchronous-push">3.2 Asynchronous Push</h3> <ul> <li> <p>After interaction triggers, deliver to Kafka queue; consumers filter and batch push.</p> </li> <li> <p>Merge notifications (e.g., “5 people liked”) to reduce frequency.</p> </li> </ul> <h3 id="33-multi-channel-delivery">3.3 Multi-Channel Delivery</h3> <ul> <li> <p>Web/App: WebSocket as the main channel.</p> </li> <li> <p>Mobile: Fallback to FCM/APNS.</p> </li> </ul> <h3 id="34-rate-limiting-and-degradation">3.4 Rate Limiting and Degradation</h3> <ul> <li> <p>Redis token bucket rate limiting (1000/min/user).</p> </li> <li> <p>Batch merge pushes every 5 s during high load.</p> </li> </ul> <p>The following is a simplified architecture diagram of the recommended architecture (Mermaid syntax):</p> <pre><code class="language-mermaid">graph TD
    A["Interaction Event (Like/@)"] --&gt; B["Notification Service"]
    B --&gt; C["Kafka: Asynchronous Queue"]
    C --&gt; D["Consumer: Filter Active Users + Merge Notifications"]
    D --&gt; E{"Online?"}
    E --&gt;|"Yes"| F["WebSocket: Real-time Push"]
    E --&gt;|"No"| G["FCM/APNS: Mobile Push"]
    H["Redis: Online Status + Rate Limiting"] -.-&gt; D
    H -.-&gt; F
    I["Prometheus: Monitoring Delivery Rate"] -.-&gt; G
    I -.-&gt; F
</code></pre> <p>This diagram shows the overall process from event triggering to delivery.</p> <hr/> <h2 id="4-key-data-structures-and-processes">4. Key Data Structures and Processes</h2> <h3 id="41-redis-structure">4.1 Redis Structure</h3> <ul> <li> <p><code class="language-plaintext highlighter-rouge">online:{userId}</code>: Online status, value “1”, TTL=5 min.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">rate:{userId}</code>: Push rate limiting count, EX=60 s.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">notification:{userId}</code>: Temporary storage for merged notifications (HashMap).</p> </li> </ul> <h3 id="42-notification-push-process">4.2 Notification Push Process</h3> <p>The following is the process sequence diagram (Mermaid syntax):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant Client as Client
    participant Service as Interaction Service
    participant Kafka as Kafka Queue
    participant Consumer as Consumer
    participant Redis as Redis (Online/Rate Limiting)
    participant WS as WebSocket
    Client-&gt;&gt;Service: Trigger Interaction (e.g., Like)
    Service-&gt;&gt;Kafka: Deliver Notification Event
    Kafka-&gt;&gt;Consumer: Consume Batch
    Consumer-&gt;&gt;Redis: Check Active + Rate Limiting
    Redis--&gt;&gt;Consumer: Return Status
    Consumer-&gt;&gt;Consumer: Merge Notifications
    Consumer-&gt;&gt;WS: Push Merged Notifications
    WS--&gt;&gt;Client: Deliver
    Note over Consumer, WS: Offline fallback to FCM/APNS
</code></pre> <h4 id="java-code-example-delivering-notifications">Java Code Example (Delivering Notifications)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Deliver notifications to Kafka in the interaction service</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendNotification</span><span class="o">(</span><span class="kt">long</span> <span class="n">fromUserId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">toUserId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">type</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tweetId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Serialize notification data</span>
    <span class="nc">String</span> <span class="n">notificationJson</span> <span class="o">=</span> <span class="n">serializeNotification</span><span class="o">(</span><span class="n">fromUserId</span><span class="o">,</span> <span class="n">toUserId</span><span class="o">,</span> <span class="n">type</span><span class="o">,</span> <span class="n">tweetId</span><span class="o">);</span>
    <span class="c1">// Configure Producer and send</span>
    <span class="n">kafkaProducer</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="k">new</span> <span class="nc">ProducerRecord</span><span class="o">&lt;&gt;(</span><span class="s">"notification-queue"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">toUserId</span><span class="o">),</span> <span class="n">notificationJson</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="java-code-example-consumer-processing-and-pushing">Java Code Example (Consumer Processing and Pushing)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Kafka consumer processing logic</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNotifications</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">KafkaConsumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaConsumer</span><span class="o">&lt;&gt;(</span><span class="n">props</span><span class="o">);</span>
    <span class="n">consumer</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nc">Collections</span><span class="o">.</span><span class="na">singleton</span><span class="o">(</span><span class="s">"notification-queue"</span><span class="o">));</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ConsumerRecords</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofMillis</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Notification</span><span class="o">&gt;&gt;</span> <span class="n">batchMap</span> <span class="o">=</span> <span class="n">groupByUser</span><span class="o">(</span><span class="n">records</span><span class="o">);</span> <span class="c1">// Aggregate by user</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Notification</span><span class="o">&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">batchMap</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">userId</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Notification</span><span class="o">&gt;</span> <span class="n">notifications</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="c1">// Check online and rate limiting</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"1"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">redis</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"online:"</span> <span class="o">+</span> <span class="n">userId</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="n">redis</span><span class="o">.</span><span class="na">incr</span><span class="o">(</span><span class="s">"rate:"</span> <span class="o">+</span> <span class="n">userId</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Merge notifications</span>
                <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="n">aggregateNotifications</span><span class="o">(</span><span class="n">notifications</span><span class="o">);</span>
                <span class="c1">// Push</span>
                <span class="nc">Session</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">connections</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ws</span><span class="o">.</span><span class="na">isOpen</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">ws</span><span class="o">.</span><span class="na">getAsyncRemote</span><span class="o">().</span><span class="na">sendText</span><span class="o">(</span><span class="no">JSON</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">merged</span><span class="o">));</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Fallback to mobile push</span>
                    <span class="n">fcm</span><span class="o">.</span><span class="na">sendToDevice</span><span class="o">(</span><span class="n">getDeviceToken</span><span class="o">(</span><span class="n">userId</span><span class="o">),</span> <span class="n">merged</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">redis</span><span class="o">.</span><span class="na">expire</span><span class="o">(</span><span class="s">"rate:"</span> <span class="o">+</span> <span class="n">userId</span><span class="o">,</span> <span class="mi">60</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="5-performance-optimization-and-engineering-details">5. Performance Optimization and Engineering Details</h2> <ul> <li> <p><strong>Batch Processing</strong>: Consumers process 500 notifications per batch, Redis MGET for batch online checks.</p> </li> <li> <p><strong>Heartbeat Detection</strong>: WebSocket ping/pong every 30 s to update online status.</p> </li> <li> <p><strong>Security Protection</strong>: IP rate limiting, encrypted pushes to prevent DDoS.</p> </li> <li> <p><strong>Scaling</strong>: Kafka partitions=100, WebSocket nodes autoscaling (&gt;80% CPU).</p> </li> <li> <p><strong>Monitoring</strong>: Grafana tracks delivery rate/latency, alerts for losses &gt;1%.</p> </li> </ul> <hr/> <h2 id="6-high-frequency-interview-follow-ups-and-real-engineering-pitfalls">6. High-Frequency Interview Follow-Ups and Real Engineering Pitfalls</h2> <h3 id="high-frequency-follow-ups">High-Frequency Follow-Ups</h3> <ul> <li> <p>How to prevent queue backlogs under high concurrency? (Dynamic consumer scaling, priority queues)</p> </li> <li> <p>How to handle consistency losses? (Kafka persistence, retry mechanisms)</p> </li> <li> <p>How to ensure multi-channel synchronization? (Unified JSON format, Redis temporary storage)</p> </li> </ul> <h3 id="engineering-pitfalls">Engineering Pitfalls</h3> <ul> <li> <p>Connection memory overflow; solution: Horizontal scaling, limit connections/node &lt;100 k.</p> </li> <li> <p>DDoS amplification; solution: Token bucket + Captcha.</p> </li> <li> <p>Merge logic bugs leading to duplicate notifications; solution: HashMap aggregation + test scripts.</p> </li> </ul> <h3 id="common-misconceptions">Common Misconceptions</h3> <ul> <li> <p>Using only Polling, poor real-time performance leading to user churn.</p> </li> <li> <p>Unlimited flows, peak crashes the system.</p> </li> <li> <p>Ignoring offline pushes, poor mobile user experience.</p> </li> </ul> <hr/> <h2 id="7-summary">7. Summary</h2> <p>Twitter notifications and real-time pushes are core to enhancing user stickiness. Through WebSocket + Kafka asynchronous + multi-channel architecture, efficient delivery and resource optimization can be achieved. Engineering focuses on filtering merges, rate limiting degradation, and monitoring to ensure &gt;99% delivery rate. Combined with upstream (such as timeline events), avoid high-frequency bottlenecks, and emphasize trade-offs in interviews (such as real-time vs. Resources). Actual deployment requires testing billions-scale loads to support platform growth.</p>]]></content><author><name></name></author><category term="System Design Other"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Detailed System Design of Twitter Timeline Generation</title><link href="https://zhengstar94.github.io//blog/2025/DetailedSystemDesignOfTwitterTimelineGeneration/" rel="alternate" type="text/html" title="Detailed System Design of Twitter Timeline Generation"/><published>2025-07-31T00:00:00+00:00</published><updated>2025-07-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DetailedSystemDesignOfTwitterTimelineGeneration</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DetailedSystemDesignOfTwitterTimelineGeneration/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>The timeline is a core feature of social platforms like Twitter/X. The home timeline must aggregate the latest posts from hundreds to millions of followed users in real-time, demanding high concurrency handling, low latency, and high availability. This article systematically introduces mainstream architectural approaches for timeline generation, trade-offs, engineering implementation details, and common interview follow-up questions.</p> <hr/> <h2 id="1-requirements-and-challenges">1. Requirements and Challenges</h2> <ul> <li><strong>High Concurrency</strong>: Billions of DAU, with home refresh peaks reaching tens of thousands of TPS.</li> <li><strong>Extreme Read-Write Imbalance</strong>: Read-write ratio up to 100:1, with the majority of requests being home timeline reads.</li> <li><strong>Celebrity Effect</strong>: Posts from popular users must impact millions of followers, easily creating hotspots.</li> <li><strong>Low Latency</strong>: Home refresh &lt;200 ms, post publishing &lt;100 ms.</li> <li><strong>Consistency</strong>: Eventual consistency is acceptable, with some scenarios tolerating a few seconds of delay.</li> </ul> <hr/> <h2 id="2-scheme-comparison-and-trade-offs">2. Scheme Comparison and Trade-offs</h2> <h3 id="21-fan-out-on-write-push-model">2.1 Fan-out on Write (Push Model)</h3> <ul> <li><strong>Principle</strong>: When a user publishes a post, the system immediately “pushes” (writes) the post ID to the home timeline caches of all followers. This is like an express delivery system: the poster prepares the package, and the system automatically distributes it to each follower’s “mailbox” (cache), so followers can directly retrieve it from their mailbox upon refresh. In simple terms, it’s “preparing everything in advance” to ensure efficient reads, but it assumes the follower list isn’t too large.</li> <li><strong>Advantages</strong>: Extremely fast reads, O (1) cache hits, suitable for high-read scenarios.</li> <li><strong>Disadvantages</strong>: High write pressure; a celebrity post requires millions of write operations, prone to write avalanches.</li> </ul> <h3 id="22-fan-out-on-read-pull-model">2.2 Fan-out on Read (Pull Model)</h3> <ul> <li><strong>Principle</strong>: When a user refreshes their home timeline, the system dynamically “pulls” (queries) the latest posts from all followed users’ timelines and aggregates/sorts them. This is similar to shopping at a supermarket: each refresh, the follower goes to each followed user’s “shelf” (cache or database) to pick the latest items and combines them into their shopping cart. In simple terms, it’s “on-demand fetching,” with simple writes but real-time computation during reads, prone to lag during peaks.</li> <li><strong>Advantages</strong>: Easy writes; a celebrity post only needs one write.</li> <li><strong>Disadvantages</strong>: Slow reads, requiring cross-shard/cross-service aggregation, high latency, poor scalability.</li> </ul> <h3 id="23-hybrid-fan-out">2.3 Hybrid Fan-out</h3> <ul> <li><strong>Principle</strong>: Combines the above two, differentiating by user type—ordinary users use fan-out on write (pre-push), while popular users use fan-out on read (on-demand pull). This is like a hybrid delivery model: direct door delivery for ordinary friends’ packages, but fans self-pickup for celebrities’ to avoid overwhelming the delivery staff. In simple terms, it’s a “tailored” intelligent strategy that balances read-write loads but requires extra logic for type judgment and data merging.</li> <li><strong>Advantages</strong>: Balances read-write efficiency; popular users don’t overwhelm writes, ordinary users get fast reads.</li> <li><strong>Disadvantages</strong>: Complex implementation, needing dynamic user type judgment and some computational overhead for merging.</li> </ul> <hr/> <h2 id="3-recommended-architecture-hybrid-fan-out--caching">3. Recommended Architecture: Hybrid Fan-out + Caching</h2> <h3 id="31-user-classification">3.1 User Classification</h3> <ul> <li>Set a threshold (e.g., followers &gt;10,000 for popular users); ordinary users use fan-out on write, popular users use fan-out on read.</li> <li>Cache user type results in Redis (TTL=1 hour) to reduce frequent database queries.</li> </ul> <h3 id="32-fan-out-on-write-ordinary-users">3.2 Fan-out on Write (Ordinary Users)</h3> <ul> <li>After a user posts, the post ID is asynchronously batched via Kafka and pushed to all active followers’ home timeline caches (Redis List/ZSet).</li> <li>Inactive followers are not pushed to save resources.</li> </ul> <p>The following is the sequence diagram for fan-out on write (ordinary users) (Mermaid syntax):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User as Ordinary User
    participant TimelineService as Timeline Service
    participant Kafka as Kafka Queue
    participant Redis as Redis Cache (Follower Home)

    User-&gt;&gt;TimelineService: Publish Post
    TimelineService-&gt;&gt;Kafka: Asynchronously Batch Push Post ID to Followers
    Kafka-&gt;&gt;Redis: Write to Each Active Follower's Home Timeline Cache
    Redis--&gt;&gt;Kafka: Confirm Write
    Note over TimelineService, Redis: Followers Read Directly from Cache on Refresh
</code></pre> <h4 id="java-code-example-fan-out-on-write-handling-during-posting">Java Code Example: Fan-out on Write Handling (During Posting)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In TimelineService, handle ordinary user posting with fan-out on write (simplified; actual should be async via Kafka)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">fanOutOnWrite</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tweetId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Fetch active followers list (assume from DB or cache)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">activeFollowers</span> <span class="o">=</span> <span class="n">getActiveFollowers</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
    
    <span class="c1">// Use Redis Pipeline for batch writes to optimize performance</span>
    <span class="nc">Pipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">pipelined</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">followerId</span> <span class="o">:</span> <span class="n">activeFollowers</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Push post ID to follower's home timeline (use LPUSH to keep newest on top)</span>
        <span class="n">pipeline</span><span class="o">.</span><span class="na">lpush</span><span class="o">(</span><span class="s">"home_timeline:"</span> <span class="o">+</span> <span class="n">followerId</span><span class="o">,</span> <span class="n">tweetId</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>  <span class="c1">// Execute batch operations</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="33-fan-out-on-read-popular-users">3.3 Fan-out on Read (Popular Users)</h3> <ul> <li>Popular users’ posts are only written to their own user timeline cache.</li> <li>When followers refresh home, the timeline service dynamically pulls these popular users’ latest posts and merges/sorts them with ordinary users’ posts (using a priority queue).</li> </ul> <p>The following is the sequence diagram for fan-out on read (popular users) (Mermaid syntax, focusing on write phase; read phase in home generation flow):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User as Popular User
    participant TimelineService as Timeline Service
    participant Redis as Redis Cache (User Timeline)

    User-&gt;&gt;TimelineService: Publish Post
    TimelineService-&gt;&gt;Redis: Write Only to Popular User's User Timeline Cache
    Redis--&gt;&gt;TimelineService: Confirm Write
    Note over TimelineService, Redis: Followers Dynamically Pull and Merge on Refresh
</code></pre> <h4 id="java-code-example-fan-out-on-read-handling-during-posting-write-to-own-timeline-only">Java Code Example: Fan-out on Read Handling (During Posting, Write to Own Timeline Only)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In TimelineService, handle popular user posting with fan-out on read (write to own timeline only)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">writeToUserTimeline</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tweetId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Push post ID to user's personal timeline (use LPUSH to keep newest on top)</span>
    <span class="n">redis</span><span class="o">.</span><span class="na">lpush</span><span class="o">(</span><span class="s">"user_timeline:"</span> <span class="o">+</span> <span class="n">userId</span><span class="o">,</span> <span class="n">tweetId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="34-caching-and-pre-warming">3.4 Caching and Pre-warming</h3> <ul> <li>Home timelines, user timelines, and post contents use sharded Redis caches; regularly pre-warm for popular/active users.</li> <li>Combine TTL and LRU to ensure hot data resides in memory.</li> </ul> <h3 id="35-monitoring-and-degradation">3.5 Monitoring and Degradation</h3> <ul> <li>Use Prometheus to monitor fan-out latency, cache hit rates, etc.</li> <li>Under high load, automatically degrade to return cached data only, prompting users to “refresh for latest.”</li> </ul> <h3 id="36-architecture-diagram">3.6 Architecture Diagram</h3> <p>The following is a simplified architecture diagram of the recommended approach (Mermaid syntax, viewable in Mermaid-supported Markdown renderers):</p> <pre><code class="language-mermaid">graph TD
    A[User Posts] --&gt; B{User Type?}
    B --&gt;|Ordinary User| C[Fan-out on Write: Kafka Async Push Post ID to Followers' Home Cache]
    B --&gt;|Popular User| D[Fan-out on Read: Write Only to User Timeline Cache]
    E[Follower Refreshes Home] --&gt; F[Pull Ordinary Users' Posts from Cache]
    E --&gt; G[Dynamically Pull Popular Users' Posts from Cache]
    F --&gt; H[Merge &amp; Sort: Priority Queue]
    G --&gt; H
    H --&gt; I[Return Timeline]
    J[Redis Sharded Cache] -.-&gt; C
    J -.-&gt; D
    J -.-&gt; F
    J -.-&gt; G
    K[Kafka Queue] -.-&gt; C
    L[Prometheus Monitoring] -.-&gt; I
</code></pre> <p>This diagram illustrates the overall flow for posting and home refresh, highlighting the hybrid fan-out branching logic.</p> <hr/> <h2 id="4-key-data-structures-and-flows">4. Key Data Structures and Flows</h2> <h3 id="41-redis-cache-structures">4.1 Redis Cache Structures</h3> <ul> <li><code class="language-plaintext highlighter-rouge">home_timeline:{user_id}</code>: Home timeline cache, stores post IDs, TTL=1 hour.</li> <li><code class="language-plaintext highlighter-rouge">user_timeline:{user_id}</code>: User timeline cache, stores post IDs, TTL=1 hour.</li> <li><code class="language-plaintext highlighter-rouge">tweet:{tweet_id}</code>: Post content cache.</li> </ul> <h3 id="42-home-timeline-generation-flow">4.2 Home Timeline Generation Flow</h3> <p>The following is the sequence diagram for the flow (Mermaid syntax):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User as User
    participant TimelineService as Timeline Service
    participant Redis as Redis Cache
    participant Kafka as Kafka Queue

    User-&gt;&gt;TimelineService: Refresh Home
    TimelineService-&gt;&gt;Redis: Pull Ordinary Followed Users' Posts (Fan-out on Write Cache)
    Redis--&gt;&gt;TimelineService: Return Post List
    TimelineService-&gt;&gt;Redis: Pull Popular Followed Users' Latest Posts (Fan-out on Read)
    Redis--&gt;&gt;TimelineService: Return Post List
    TimelineService-&gt;&gt;TimelineService: Merge &amp; Sort (Priority Queue)
    TimelineService--&gt;&gt;User: Return Merged Timeline

    Note over TimelineService, Kafka: During Posting: Ordinary Users Async Fan-out via Kafka to Followers' Cache
</code></pre> <h4 id="java-code-example-merge--sort-during-home-refresh">Java Code Example (Merge &amp; Sort During Home Refresh)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. Pull ordinary followed users' posts from Redis (pre-pushed via fan-out on write)</span>
<span class="c1">// Assume nonHotKey is the current user's home cache key, limit is posts per page (e.g., 20)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">nonHotTweets</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">lrange</span><span class="o">(</span><span class="n">nonHotKey</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">limit</span><span class="o">);</span>

<span class="c1">// 2. Pull all popular users' (celebrities) latest posts from Redis</span>
<span class="c1">// hotKey is the popular user's user timeline cache key, pull up to 500 to prevent overload</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">hotTweets</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">lrange</span><span class="o">(</span><span class="n">hotKey</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">500</span><span class="o">);</span>

<span class="c1">// 3. Create a priority queue (max-heap) for merging posts in descending timestamp order</span>
<span class="c1">// This ensures the final home timeline has newest posts first</span>
<span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
    <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Long</span><span class="o">.</span><span class="na">compare</span><span class="o">(-</span><span class="n">a</span><span class="o">.</span><span class="na">timestamp</span><span class="o">,</span> <span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="na">timestamp</span><span class="o">)</span> <span class="c1">// Larger timestamps rank first</span>
<span class="o">);</span>

<span class="c1">// 4. Add ordinary and popular users' posts to the priority queue</span>
<span class="n">pq</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">nonHotTweets</span><span class="o">);</span>
<span class="n">pq</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">hotTweets</span><span class="o">);</span>

<span class="c1">// 5. Pop newest posts from the queue sequentially until reaching the page limit (e.g., 20)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">merged</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 6. Return the merged home timeline post list</span>
<span class="k">return</span> <span class="n">merged</span><span class="o">;</span>
</code></pre></div></div> <hr/> <h2 id="5-performance-optimizations-and-engineering-details">5. Performance Optimizations and Engineering Details</h2> <ul> <li><strong>Batch Operations</strong>: Kafka messages and Redis Pipeline for batch writes to reduce network IO.</li> <li><strong>Async Decoupling</strong>: All fan-out on write operations handled asynchronously via Kafka to avoid blocking main flows.</li> <li><strong>Merge &amp; Sort</strong>: Use efficient heap sort for merging popular and ordinary posts, with memory pre-allocation to prevent GC jitter.</li> <li><strong>Sharding &amp; Scaling</strong>: Shard Redis, Kafka, and timeline services for horizontal scaling to support DAU growth.</li> <li><strong>Pagination Support</strong>: Support page_token for users to pull more historical posts on scroll.</li> </ul> <hr/> <h2 id="6-common-interview-follow-ups-and-real-engineering-pitfalls">6. Common Interview Follow-ups and Real Engineering Pitfalls</h2> <h3 id="high-frequency-follow-ups">High-Frequency Follow-ups</h3> <ul> <li>How to handle write pressure for celebrity posts? (Hybrid fan-out, async batching, push only to active followers)</li> <li>How to self-protect during cache avalanches? (Pre-warming, rate limiting, degradation)</li> <li>How to ensure no interruptions during shard migrations? (Dual-write sync, throttled migration, graceful degradation)</li> </ul> <h3 id="engineering-pitfalls">Engineering Pitfalls</h3> <ul> <li>Kafka queue backlogs causing post delays, requiring dynamic consumer scaling.</li> <li>Unsynchronized cache invalidations leading to stale data, needing dual-write consistency or Pub/Sub.</li> <li>Untimely hotspot shard migrations causing single-point bottlenecks affecting the whole system.</li> </ul> <h3 id="common-misconceptions">Common Misconceptions</h3> <ul> <li>Using fan-out on write for all users, leading to system crashes under celebrity effects.</li> <li>Relying only on TTL without pre-warming, high risk of cache avalanches.</li> <li>No load balancing after sharding, with hot shards dragging down the system.</li> </ul> <hr/> <h2 id="7-summary">7. Summary</h2> <p>Home timeline generation is a core challenge in social platform system design. Adopting a hybrid fan-out + caching + async decoupling + monitoring/degradation architecture balances high concurrency, low latency, and high availability, handling celebrity effects and sudden hotspots while ensuring smooth experiences for most users. Engineering implementations must focus on batching, async, sharding, cache consistency, and degradation strategies to avoid common misconceptions and pitfalls.</p>]]></content><author><name></name></author><category term="System Design Other"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Technical Guide to Distributed Unique IDs</title><link href="https://zhengstar94.github.io//blog/2025/TechnicalGuideToDistributedUniqueIDs/" rel="alternate" type="text/html" title="Technical Guide to Distributed Unique IDs"/><published>2025-07-06T00:00:00+00:00</published><updated>2025-07-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TechnicalGuideToDistributedUniqueIDs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TechnicalGuideToDistributedUniqueIDs/"><![CDATA[<h2 id="1-the-need-for-distributed-globally-unique-ids">1. The Need for Distributed, Globally Unique IDs</h2> <p>In traditional monolithic architectures, systems typically rely on a single database. The primary keys for business tables are often generated using the database’s <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> feature. This method is simple, reliable, and guarantees uniqueness within that single database.</p> <p>However, in modern distributed and microservices architectures, systems are often partitioned to handle high concurrency and massive data volumes. This means that data for a single business entity, such as “orders,” is spread across multiple database instances or tables. In such a scenario, if each shard independently uses its own <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> mechanism, ID collisions become inevitable, as illustrated below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/07/6-480.webp 480w,/assets/img/2025/07/6-800.webp 800w,/assets/img/2025/07/6-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/07/6.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Although the system architecture is distributed, at the business logic and user level, an order ID must be globally unique. Duplicate primary keys are unacceptable.</p> <p>Therefore, designing a high-performance, highly available, and globally unique ID generation scheme is a foundational requirement for any distributed system. This document provides an in-depth analysis of common distributed ID generation solutions.</p> <h2 id="2-common-distributed-id-generation-schemes">2. Common Distributed ID Generation Schemes</h2> <h3 id="21-uuid-universally-unique-identifier">2.1. UUID (Universally Unique Identifier)</h3> <p>A UUID is a 128-bit number used to identify information in computer systems. The theoretical number of possible UUIDs is <code class="language-plaintext highlighter-rouge">2^128</code>, making collisions practically impossible for the foreseeable future. The standard format is <code class="language-plaintext highlighter-rouge">8-4-4-4-12</code>, though hyphens are often removed in practice.</p> <p><strong>Key UUID Versions:</strong></p> <ul> <li><strong>Version 1 (Time-based):</strong> Generated from a timestamp, a random number, and the local MAC address. While unique, it can expose the MAC address, posing a security risk.</li> <li><strong>Version 2 (DCE Security):</strong> Similar to Version 1, but replaces parts of the timestamp with POSIX UID/GID. It is rarely used.</li> <li><strong>Version 3 (Name-based, MD 5):</strong> Generated from the MD 5 hash of a namespace and a name. It is deterministic: the same input produces the same UUID.</li> <li><strong>Version 4 (Random):</strong> Generated from random or pseudo-random numbers. This is the most common version, and it’s what <code class="language-plaintext highlighter-rouge">UUID.randomUUID()</code> in Java generates.</li> <li><strong>Version 5 (Name-based, SHA-1):</strong> Similar to Version 3 but uses the SHA-1 hashing algorithm.</li> </ul> <p><strong>Java Code Example:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.UUID</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UuidExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Version 4: Random UUID</span>
        <span class="no">UUID</span> <span class="n">randomUuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Random UUID: "</span> <span class="o">+</span> <span class="n">randomUuid</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>

        <span class="c1">// Version 3: Name-based UUID</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">nameBytes</span> <span class="o">=</span> <span class="s">"hello-world"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
        <span class="no">UUID</span> <span class="n">nameUuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">nameUUIDFromBytes</span><span class="o">(</span><span class="n">nameBytes</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Name-based UUID: "</span> <span class="o">+</span> <span class="n">nameUuid</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Analysis:</strong></p> <ul> <li><strong>Pros:</strong></li> <li><strong>Local Generation:</strong> Extremely high performance as no network requests are needed.</li> <li><strong>Global Uniqueness:</strong> The probability of collision is infinitesimally small.</li> <li><strong>Simplicity:</strong> Natively supported in most languages, often requiring just a single line of code.</li> <li><strong>Cons:</strong></li> <li><strong>Storage Inefficiency:</strong> UUIDs are long strings (36 characters with hyphens), consuming more storage space than numerical IDs.</li> <li><strong>Poor Indexing Performance:</strong> UUIDs are non-sequential. Using them as primary keys in database engines like InnoDB (which uses B+ trees) leads to frequent index page splits and random data inserts, severely degrading write performance.</li> <li><strong>Lack of Readability:</strong> The ID itself is opaque and carries no discernible information.</li> </ul> <h3 id="22-database-auto-increment-scheme">2.2. Database Auto-Increment Scheme</h3> <p>This scheme extends the single-database auto-increment concept to a distributed environment through careful configuration.</p> <p><strong>Core Idea:</strong> Configure each database instance with a different <strong>starting value (offset)</strong> and a common <strong>step (increment)</strong>.</p> <p>For example, with three MySQL servers, the configuration could be:</p> <ul> <li><strong>DB 1:</strong> <code class="language-plaintext highlighter-rouge">auto_increment_offset=1</code>, <code class="language-plaintext highlighter-rouge">auto_increment_increment=3</code> → Generated IDs: 1, 4, 7, 10, …</li> <li><strong>DB 2:</strong> <code class="language-plaintext highlighter-rouge">auto_increment_offset=2</code>, <code class="language-plaintext highlighter-rouge">auto_increment_increment=3</code> → Generated IDs: 2, 5, 8, 11, …</li> <li><strong>DB 3:</strong> <code class="language-plaintext highlighter-rouge">auto_increment_offset=3</code>, <code class="language-plaintext highlighter-rouge">auto_increment_increment=3</code> → Generated IDs: 3, 6, 9, 12, …</li> </ul> <p><strong>Analysis:</strong></p> <ul> <li><strong>Pros:</strong></li> <li><strong>Simple Implementation:</strong> Requires only database configuration, no extra components.</li> <li><strong>Ordered IDs:</strong> Generates numeric, incrementally ordered IDs, which are friendly to database indexes.</li> <li><strong>Cons:</strong></li> <li><strong>Strong Database Dependency:</strong> The database becomes a performance bottleneck and a single point of failure for ID generation.</li> <li><strong>Poor Scalability:</strong> Adding or removing database instances is a high-risk operation, requiring recalculation and reconfiguration across all instances.</li> <li><strong>Consistency Risks:</strong> In scenarios like master-slave failover, there’s a risk of data inconsistency that could lead to duplicate IDs.</li> </ul> <h3 id="23-redis-atomic-increment-scheme">2.3. Redis Atomic Increment Scheme</h3> <p>Redis provides atomic commands like <code class="language-plaintext highlighter-rouge">INCR</code> and <code class="language-plaintext highlighter-rouge">INCRBY</code>. Because Redis executes commands in a single-threaded manner, it naturally guarantees the uniqueness and order of generated IDs.</p> <p><strong>Core Idea:</strong> Use Redis’s atomic operations to generate a globally unique sequence.</p> <p><strong>Implementation:</strong> For each ID request, a client sends an <code class="language-plaintext highlighter-rouge">INCR a_unique_key</code> command to Redis. To prevent the ID from growing indefinitely, it’s often combined with a business prefix or a timestamp.</p> <p><strong>Analysis:</strong></p> <ul> <li><strong>Pros:</strong></li> <li><strong>High Performance:</strong> Operations are in-memory and significantly faster than a database.</li> <li><strong>Ordered IDs:</strong> The generated IDs are strictly increasing.</li> <li><strong>Cons:</strong></li> <li><strong>Introduces a New Component:</strong> Requires the introduction and maintenance of Redis, increasing architectural complexity.</li> <li><strong>Strong Redis Dependency:</strong> The availability of the ID service is tied to Redis. A highly available Redis cluster (e.g., Sentinel or Cluster mode) is necessary to mitigate this.</li> <li><strong>Network Overhead:</strong> Every ID generation requires a network round-trip, which can be a significant cost under high concurrency.</li> </ul> <h2 id="3-a-milestone-twitters-snowflake-algorithm">3. A Milestone: Twitter’s Snowflake Algorithm</h2> <p>The previous solutions all have significant drawbacks. In 2010, Twitter open-sourced its Snowflake algorithm, an elegant solution for generating IDs locally in a distributed environment. It has since become the foundational model for many modern distributed ID schemes.</p> <h3 id="31-core-idea-and-id-structure">3.1. Core Idea and ID Structure</h3> <p>Snowflake’s core idea is to <strong>partition a 64-bit long integer into several sections at the binary level, with each section having a specific meaning</strong>. This allows each node to generate globally unique IDs locally, without communicating with other nodes.</p> <p>A standard Snowflake ID is structured as follows:</p> <table> <thead> <tr> <th style="text-align: left">Section</th> <th style="text-align: center">Sign Bit</th> <th style="text-align: center">Timestamp</th> <th style="text-align: center">Datacenter ID</th> <th style="text-align: center">Worker ID</th> <th style="text-align: center">Sequence</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Bits</strong></td> <td style="text-align: center">1 bit</td> <td style="text-align: center">41 bits</td> <td style="text-align: center">5 bits</td> <td style="text-align: center">5 bits</td> <td style="text-align: center">12 bits</td> </tr> <tr> <td style="text-align: left"><strong>Meaning</strong></td> <td style="text-align: center">Fixed to 0 (for positive IDs)</td> <td style="text-align: center">Millisecond timestamp offset</td> <td style="text-align: center">Identifies the datacenter</td> <td style="text-align: center">Identifies the node/machine</td> <td style="text-align: center">Intra-millisecond counter</td> </tr> </tbody> </table> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p>Think of the Snowflake algorithm as a system for <strong>minting highly precise, unique identification cards</strong>.</p> <ul> <li><strong>The 64-bit ID</strong> is the blank ID card.</li> <li><strong>The Timestamp (41 bits)</strong> is the <strong>“Date of Issue,”</strong> precise to the millisecond. It defines the “era” of the ID and is its most significant part.</li> <li><strong>The Datacenter ID (5 bits)</strong> is the <strong>“Issuing Province.”</strong></li> <li><strong>The Worker ID (5 bits)</strong> is the specific <strong>“Issuing City Office”</strong> within that province.</li> <li><strong>The Sequence (12 bits)</strong> is the <strong>“Serial Number”</strong> issued by that specific office within the same millisecond.</li> </ul> <p>By combining the <strong>time of issue + location of issue (province + city) + local serial number</strong>, this system guarantees that every ID card produced is globally unique.</p> </blockquote> <h3 id="32-detailed-breakdown-of-each-section">3.2. Detailed Breakdown of Each Section</h3> <h4 id="321-sign-bit-1-bit">3.2.1. Sign Bit (1 bit)</h4> <p>The most significant bit of a <code class="language-plaintext highlighter-rouge">long</code> in Java is the sign bit. It is fixed to <code class="language-plaintext highlighter-rouge">0</code> to ensure all generated IDs are positive and to simplify cross-language compatibility.</p> <h4 id="322-timestamp-41-bits">3.2.2. Timestamp (41 bits)</h4> <ul> <li><strong>Content:</strong> This section stores the difference between the <code class="language-plaintext highlighter-rouge">current timestamp (in milliseconds)</code> and a <code class="language-plaintext highlighter-rouge">custom epoch timestamp</code>.</li> <li><strong>The <code class="language-plaintext highlighter-rouge">twepoch</code>:</strong> In Twitter’s official implementation, this epoch is set to <code class="language-plaintext highlighter-rouge">1288834974657L</code>, which corresponds to <strong>Nov 04, 2010 01:42:54 UTC</strong>.</li> <li><strong>Why a Custom Epoch?</strong> 41 bits cannot store the full number of milliseconds since the Unix epoch (Jan 1, 1970). By using a more recent starting point, a large absolute timestamp is converted into a smaller relative one. This allows 41 bits to cover a span of approximately <strong>69 years</strong> ($2^{41} / (1000 \cdot 60 \cdot 60 \cdot 24 \cdot 365) \approx 69$ years). The algorithm can thus be used until around the year 2079.</li> </ul> <h4 id="323-datacenter-id-5-bits--worker-id-5-bits--10-bits">3.2.3. Datacenter ID (5 bits) + Worker ID (5 bits) = 10 bits</h4> <p>These 10 bits collectively form the <strong>worker node ID</strong>, distinguishing different ID generation nodes.</p> <ul> <li><strong>Capacity:</strong></li> <li>Datacenter ID (5 bits): Supports $2^5 = 32$ datacenters.</li> <li>Worker ID (5 bits): Supports $2^5 = 32$ machines per datacenter.</li> <li>This allows for a total of $32 \times 32 = 1024$ nodes.</li> <li><strong>Allocation Mechanism:</strong> Manually configuring worker IDs in a dynamic cloud environment is infeasible. The standard practice is to <strong>rely on a coordination service like ZooKeeper for automatic allocation</strong>.</li> <li><strong>Process:</strong> On startup, a service instance creates an <strong>ephemeral sequential node</strong> in a designated ZooKeeper path. ZooKeeper assigns a globally unique sequence number to this node, which is then used as the <code class="language-plaintext highlighter-rouge">workerId</code>.</li> <li><strong>Automatic Reclamation:</strong> Because the node is ephemeral, it is automatically deleted if the service instance crashes or loses its connection to ZooKeeper. This allows the <code class="language-plaintext highlighter-rouge">workerId</code> to be reused by a new instance, preventing ID waste.</li> </ul> <h4 id="324-sequence-12-bits">3.2.4. Sequence (12 bits)</h4> <ul> <li><strong>Purpose:</strong> Resolves collisions when multiple IDs are generated on the <strong>same node within the same millisecond</strong>.</li> <li><strong>Capacity:</strong> 12 bits can represent $2^{12} = 4096$ values (0-4095).</li> <li><strong>Mechanism:</strong></li> <li>The sequence number is incremented for each ID generated within the same millisecond.</li> <li><strong>What if the sequence is exhausted (reaches 4095)?</strong> The original Snowflake implementation performs a <strong>spin-wait</strong>, pausing the thread until the next millisecond arrives.</li> <li>Once the clock ticks to the next millisecond, the sequence number is reset to <code class="language-plaintext highlighter-rouge">0</code>.</li> <li><strong>Performance Limit:</strong> This design sets the theoretical performance ceiling for a single Snowflake node at <strong>4095 IDs/millisecond</strong>, or approximately <strong>4.09 million IDs/second</strong>, which is more than sufficient for most use cases.</li> </ul> <h3 id="33-the-core-challenge-clock-skew">3.3. The Core Challenge: Clock Skew</h3> <p>This is Snowflake’s most famous “Achilles’ heel.” Server clocks can drift backwards due to NTP synchronization or other reasons.</p> <ul> <li><strong>Critical Impact:</strong> If the clock moves backward, the <code class="language-plaintext highlighter-rouge">current timestamp</code> could be less than the <code class="language-plaintext highlighter-rouge">last recorded timestamp</code>, potentially leading to duplicate IDs and breaking the algorithm’s time-ordered nature.</li> <li><strong>Twitter’s Original Solution:</strong> A <strong>Fail-Fast</strong> strategy.</li> <li>The code detects if the current time is earlier than the last recorded time and <strong>immediately throws an exception</strong>.</li> <li>This means the node becomes <strong>unavailable</strong> for ID generation until the clock issue is resolved.</li> <li>This strategy prioritizes data correctness over availability (“better to be down than to be wrong”).</li> </ul> <h3 id="34-snowflake-summary">3.4. Snowflake Summary</h3> <table> <thead> <tr> <th style="text-align: left">Pros</th> <th style="text-align: left">Cons</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>High Performance:</strong> Local generation with low latency.</td> <td style="text-align: left"><strong>Strong Clock Dependency:</strong> Clock skew is a critical issue.</td> </tr> <tr> <td style="text-align: left"><strong>Time-Ordered IDs:</strong> IDs are roughly sortable by time.</td> <td style="text-align: left"><strong>Requires Coordination Service:</strong> Worker ID allocation depends on components like ZooKeeper.</td> </tr> <tr> <td style="text-align: left"><strong>Embedded Information:</strong> IDs contain timestamp and node data.</td> <td style="text-align: left"><strong>Fixed Bit Allocation:</strong> The 1024-node limit can be a constraint in large-scale deployments.</td> </tr> <tr> <td style="text-align: left"><strong>Numeric Type:</strong> Efficient storage and querying as a 64-bit long.</td> <td style="text-align: left"><strong>Frontend Overflow Risk:</strong> JavaScript cannot precisely handle 64-bit integers.</td> </tr> </tbody> </table> <h2 id="4-industry-evolutions-and-variants">4. Industry Evolutions and Variants</h2> <p>While Snowflake’s design is brilliant, its complexity in worker ID allocation and its vulnerability to clock skew left room for improvement. Major tech companies like Baidu and Meituan have developed and open-sourced their own enhanced solutions.</p> <h3 id="41-baidus-uidgenerator-engineered-for-performance-and-ease-of-use">4.1. Baidu’s UidGenerator: Engineered for Performance and Ease of Use</h3> <p>UidGenerator is an open-source ID generator from Baidu that improves upon Snowflake with a focus on <strong>usability</strong> and <strong>concurrent performance</strong>.</p> <h4 id="411-core-design-a-restructured-id-1-28-22-13">4.1.1. Core Design: A Restructured ID (1-28-22-13)</h4> <p>UidGenerator significantly alters the 64-bit structure, changing the time unit from milliseconds to seconds.</p> <table> <thead> <tr> <th style="text-align: left">Section</th> <th style="text-align: center">Sign Bit</th> <th style="text-align: center">Delta Seconds</th> <th style="text-align: center">Worker ID</th> <th style="text-align: center">Sequence</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Bits</strong></td> <td style="text-align: center">1 bit</td> <td style="text-align: center">28 bits</td> <td style="text-align: center">22 bits</td> <td style="text-align: center">13 bits</td> </tr> </tbody> </table> <ul> <li><strong>Timestamp (28 bits, seconds):</strong></li> <li><strong>Sacrifice:</strong> The usable lifespan is reduced from 69 years to approximately <strong>8.5 years</strong> ($2^{28}$ seconds). This is a major trade-off that requires careful system lifecycle planning.</li> <li><strong>Gain:</strong> Frees up <code class="language-plaintext highlighter-rouge">41 - 28 = 13</code> bits for other sections.</li> <li><strong>Worker ID (22 bits):</strong></li> <li><strong>Pain Point Solved:</strong> Supports $2^{22}$ (over <strong>4 million</strong>) nodes. This completely resolves the <code class="language-plaintext highlighter-rouge">workerId</code> limitation of classic Snowflake, making it highly suitable for containerized cloud environments with frequent instance churn.</li> <li><strong>Sequence (13 bits):</strong></li> <li><strong>Capacity:</strong> Supports $2^{13} = 8192$.</li> <li><strong>Meaning:</strong> Allows for 8192 unique IDs to be generated <strong>per second</strong> on a single node.</li> </ul> <h4 id="412-worker-id-allocation-from-zookeeper-to-the-database">4.1.2. Worker ID Allocation: From ZooKeeper to the Database</h4> <p>UidGenerator replaces the ZooKeeper dependency with a component that nearly every project already has: a <strong>database</strong>.</p> <ul> <li><strong>Implementation:</strong> On startup, the service inserts a record into a <code class="language-plaintext highlighter-rouge">WORKER_NODE</code> table containing its host and port. The <strong>auto-incremented primary key</strong> generated by the database for this record is used as the <code class="language-plaintext highlighter-rouge">workerId</code>.</li> <li><strong>Advantage:</strong> <strong>Drastically reduces operational overhead and technology stack complexity</strong>, as there is no need to maintain a ZK cluster.</li> <li><strong>Disadvantages:</strong></li> <li><strong>Startup Dependency on DB:</strong> New instances cannot start if the database is down.</li> <li><strong>ID Waste:</strong> The default strategy consumes a new <code class="language-plaintext highlighter-rouge">workerId</code> on every restart.</li> </ul> <h4 id="413-the-performance-weapon-cacheduidgenerator-and-the-ringbuffer">4.1.3. The Performance Weapon: CachedUidGenerator and the RingBuffer</h4> <p>This is the core of UidGenerator and its recommended mode of operation. It uses a <strong>“space-for-time”</strong> trade-off to deliver extreme performance.</p> <ul> <li><strong>Core Idea:</strong> <strong>Pre-generation and caching of IDs.</strong> This decouples the “production” of IDs from their “consumption.”</li> <li><strong>The RingBuffer:</strong></li> <li><strong>Producer:</strong> A <strong>background thread</strong> asynchronously generates IDs in batches and populates a RingBuffer (a circular array).</li> <li><strong>Consumer:</strong> When a business thread requests an ID, it does not compute it on the spot. Instead, it retrieves one from the RingBuffer <strong>lock-free (via CAS atomic operations)</strong>.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p><code class="language-plaintext highlighter-rouge">CachedUidGenerator</code> operates like a <strong>highly efficient, modern coffee shop</strong>.</p> <ul> <li><strong>Business Requests</strong> are the customers.</li> <li><strong>The RingBuffer</strong> is a <strong>large, pre-filled dispenser of freshly brewed coffee</strong>.</li> <li><strong>Getting an ID (Consumption):</strong> A customer orders, and the barista <strong>instantly</strong> dispenses a cup from the machine. The process is immediate, with no waiting.</li> <li><strong>The Background Thread (Production):</strong> A staff member in the back is constantly monitoring the coffee level in the dispenser. When it drops below a certain threshold (e.g., 50%), they <strong>brew a large new batch</strong> and quickly refill the machine.</li> </ul> <p>Through this “front-of-house for sales, back-of-house for preparation” model, the customer (the business logic) experiences lightning-fast service, completely unaware of the “time-consuming” brewing process. This is the secret to <code class="language-plaintext highlighter-rouge">CachedUidGenerator</code> ‘s high performance.</p> </blockquote> <ul> <li><strong>Benefits:</strong></li> <li><strong>Extreme Performance:</strong> The business thread’s action is reduced to a memory access operation with virtually no lock contention, resulting in massive throughput.</li> <li><strong>Eliminates Jitter:</strong> It smooths out the performance “hiccups” that can occur at time boundaries (e.g., the start of a new second) in other implementations.</li> <li>It also employs advanced techniques like <strong>Cache-Line Padding</strong> to avoid “False Sharing” on multi-core CPUs, demonstrating a commitment to squeezing out every last drop of performance.</li> </ul> <h4 id="414-the-unresolved-challenge-clock-skew">4.1.4. The Unresolved Challenge: Clock Skew</h4> <p>On this issue, UidGenerator still adheres to the original <strong>“Fail-Fast”</strong> strategy, throwing an exception upon detecting clock skew.</p> <h4 id="415-uidgenerator-summary">4.1.5. UidGenerator Summary</h4> <table> <thead> <tr> <th style="text-align: left">Pros</th> <th style="text-align: left">Cons</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Exceptional Performance:</strong> Cached mode offers lock-free retrieval.</td> <td style="text-align: left"><strong>Shorter ID Lifespan:</strong> ~8.5 years by default, requires planning.</td> </tr> <tr> <td style="text-align: left"><strong>High Usability:</strong> Worker ID allocation depends only on a database.</td> <td style="text-align: left"><strong>Clock Skew Unresolved:</strong> Still uses the fail-fast approach.</td> </tr> <tr> <td style="text-align: left"><strong>Massive Worker ID Space:</strong> 22 bits support over 4 M nodes.</td> <td style="text-align: left"><strong>Potential Worker ID Waste:</strong> Restarts consume new IDs by default.</td> </tr> </tbody> </table> <h3 id="42-meituans-leaf-engineered-for-robustness-and-high-availability">4.2. Meituan’s Leaf: Engineered for Robustness and High Availability</h3> <p>Leaf is Meituan’s open-source ID service, offering two distinct solutions to cater to different needs: <strong><code class="language-plaintext highlighter-rouge">Leaf-segment</code></strong> and <strong><code class="language-plaintext highlighter-rouge">Leaf-snowflake</code></strong>.</p> <h4 id="421-leaf-segment-the-ultimate-optimization-of-segment-mode">4.2.1. Leaf-segment: The Ultimate Optimization of Segment Mode</h4> <p>This solution takes a completely different approach from Snowflake, focusing on optimizing the database-based model.</p> <ul> <li><strong>Core Idea:</strong> <strong>Database Segment Mode.</strong> Instead of fetching one ID at a time, Leaf fetches a large “segment” (or batch) of IDs from the database into memory.</li> <li>For example, it might fetch the range <code class="language-plaintext highlighter-rouge">[1, 1000]</code> in a single database transaction. For the next 1000 requests, Leaf serves IDs from memory by simply incrementing a counter, with zero database interaction.</li> <li><strong>Dual Buffer Mechanism:</strong></li> <li><strong>Pain Point Solved:</strong> In a simple segment model, there’s a performance jitter when one segment is exhausted and the next one needs to be fetched from the database.</li> <li><strong>Leaf’s Solution:</strong> It maintains two buffers. While one buffer is actively serving IDs, an <strong>asynchronous thread</strong> pre-fetches the next segment into the second (standby) buffer once the active buffer’s usage crosses a threshold (e.g., 10%). When the active buffer is depleted, the system <strong>instantly and seamlessly</strong> switches to the standby buffer.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p><code class="language-plaintext highlighter-rouge">Leaf-segment</code> is like the <strong>ticketing machine at a bank or hospital</strong>.</p> <ul> <li><strong>Getting an ID</strong> is a customer pressing a button and taking a ticket.</li> <li><strong>A Segment</strong> is an entire <strong>roll of ticket paper</strong> inside the machine (e.g., 1000 tickets).</li> <li><strong>Fetching from DB</strong> is the lobby manager noticing the paper is low and getting a new roll from the storeroom.</li> <li><strong>The Dual Buffer Mechanism</strong> means this is an advanced machine with <strong>two cartridge slots</strong>. While cartridge 1 is in use, the manager is prompted to load a new roll into cartridge 2. When cartridge 1 runs out, the machine instantly switches to cartridge 2, ensuring uninterrupted service.</li> </ul> </blockquote> <ul> <li><strong>High Availability Design:</strong> Leaf recommends setting the segment <code class="language-plaintext highlighter-rouge">step</code> to a multiple of the peak QPS (e.g., enough for 10 minutes). This means that even if the database goes down, Leaf can continue to serve IDs from its in-memory buffers for 10-20 minutes, buying valuable time for database recovery.</li> </ul> <h4 id="422-leaf-snowflake-a-hardened-snowflake">4.2.2. Leaf-snowflake: A Hardened Snowflake</h4> <p>This solution enhances the classic Snowflake algorithm, specifically addressing its two major pain points.</p> <ul> <li><strong>Worker ID Allocation (ZK + Local Cache):</strong></li> <li><strong>Still Uses ZooKeeper:</strong> Leaf acknowledges ZK’s strengths for initial, unique <code class="language-plaintext highlighter-rouge">workerId</code> allocation via persistent sequential nodes.</li> <li><strong>Introduces a Local File Cache:</strong> After obtaining a <code class="language-plaintext highlighter-rouge">workerId</code> from ZK, Leaf <strong>caches it in a local disk file</strong>.</li> <li><strong>High Availability Impact:</strong> On subsequent restarts, Leaf <strong>first reads the local file</strong> to get its <code class="language-plaintext highlighter-rouge">workerId</code>. It only contacts ZK if the file doesn’t exist. This dramatically reduces its dependency on ZK; a service can restart successfully even if the ZK cluster is down.</li> <li><strong>Clock Skew Handling (ZK + Proactive Shutdown):</strong></li> <li>This is Leaf-snowflake’s most significant contribution. It uses ZK as a <strong>“third-party time authority.”</strong></li> <li><strong>Detection:</strong> Each node periodically reports its timestamp to its ZK node. If it detects its local clock is earlier than the last timestamp it reported, it knows a clock skew has occurred.</li> <li><strong>Handling Strategy:</strong> The recommended best practice is <strong>automatic node removal</strong>. * Upon detecting clock skew, the node proactively changes its status to “unavailable” and removes itself from the load balancer’s pool. * Traffic is automatically routed to healthy nodes, ensuring the overall cluster remains available. * Simultaneously, it raises a high-priority alert for operators to investigate the “sick” machine.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p><code class="language-plaintext highlighter-rouge">Leaf-snowflake</code> is like a <strong>highly responsible, experienced chain store manager</strong>.</p> <ul> <li><strong>Worker ID Allocation:</strong> <blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*   When opening a new store, the manager calls headquarters (ZooKeeper) to get a permanent **store ID**.
</code></pre></div> </div> </blockquote> <ul> <li>He immediately makes a copy of the ID and <strong>locks it in the store’s safe</strong> (local file cache).</li> <li>For all future re-openings (restarts), he checks the safe first and <strong>doesn’t need to call headquarters</strong>, ensuring he can open even if HQ’s phone lines are down.</li> </ul> </li> <li><strong>Clock Skew Handling:</strong> <blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*   The manager notices the clock on his wall is wrong (clock skew).
</code></pre></div> </div> </blockquote> <ul> <li>Instead of shutting down chaotically (throwing an exception), he quietly flips the “Open” sign to “Under Maintenance” and <strong>proactively informs</strong> the central delivery platform (load balancer): “Stop sending me orders for now; I have an equipment issue.”</li> <li>Customer orders are automatically routed to other stores, and the <strong>brand’s overall service is unaffected</strong>. Meanwhile, he has already sent a maintenance request to headquarters. This is a model of professional fault handling.</li> </ul> </li> </ul> </blockquote> <h4 id="423-leaf-summary">4.2.3. Leaf Summary</h4> <p>Leaf provides two excellent, distinct solutions:</p> <ul> <li><strong>Leaf-segment:</strong> Ideal for scenarios requiring <strong>strictly ordered, purely numeric</strong> IDs. It offers exceptional performance and availability.</li> <li><strong>Leaf-snowflake:</strong> A <strong>hardened version of Snowflake</strong>. It masterfully solves the critical issues of ZK dependency and clock skew, offering extreme robustness.</li> </ul> <h3 id="43-the-mist-algorithm-a-timestamp-less-approach">4.3. The Mist Algorithm: A Timestamp-less Approach</h3> <p>This algorithm takes a radical approach, positing that the dependency on time is the root of all evil. Therefore, it <strong>eliminates the timestamp entirely</strong>.</p> <ul> <li><strong>Core Design:</strong> <strong>Complete decoupling from time.</strong></li> <li><strong>Advantage:</strong> <strong>Completely immune to clock skew.</strong> Server time fluctuations have no impact on ID generation, making the system incredibly robust.</li> <li><strong>Trade-off:</strong> It must rely on an <strong>external, centralized service (like Redis)</strong> to provide a globally unique, incrementing sequence.</li> <li><strong>ID Structure (1-47-8-8):</strong></li> <li><code class="language-plaintext highlighter-rouge">1</code> Sign Bit</li> <li><code class="language-plaintext highlighter-rouge">47</code> bits for an incrementing number (from Redis <code class="language-plaintext highlighter-rouge">INCR</code>). This guarantees strict ordering and a very long lifespan.</li> <li><code class="language-plaintext highlighter-rouge">16</code> bits for random factors. This makes the final ID <strong>unpredictable</strong>, protecting business data (like order volume) from being easily estimated.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p>The <strong>Mist Algorithm</strong> is like a <strong>central bank issuing currency</strong>.</p> <ul> <li><strong>The ID</strong> is a unique banknote.</li> <li><strong>The centralized Redis</strong> is the <strong>one and only national mint</strong>. All ID generation instances must request “batch numbers” from it.</li> <li><strong>The 47-bit incrementing number</strong> is the <strong>unique, strictly increasing serial number</strong> on each banknote.</li> <li><strong>The 16-bit random factor</strong> represents the banknote’s <strong>security features, like watermarks and security threads</strong>. It makes two consecutive serial numbers look completely different, preventing counterfeiting and analysis.</li> </ul> <p>The advantage of this model is absolute authority, security, and immunity to local “clock” inaccuracies. The disadvantage is that if the mint shuts down, the entire nation’s money supply is halted.</p> </blockquote> <ul> <li><strong>Architectural Trade-off:</strong></li> <li><strong>Introduces a Central Bottleneck:</strong> The system’s overall performance is capped by the QPS and network latency of the central Redis instance.</li> <li><strong>Introduces a Single Point of Failure:</strong> If the Redis cluster fails, the entire ID generation service fails.</li> <li><strong>Use Cases:</strong></li> <li>Scenarios with <strong>zero tolerance for clock skew</strong>.</li> <li>Scenarios requiring <strong>unpredictable IDs</strong> for security (e.g., financial transactions, e-commerce orders).</li> <li>Scenarios where the business QPS is within the limits of a highly available Redis cluster.</li> </ul> <h2 id="5-solution-comparison-and-conclusion">5. Solution Comparison and Conclusion</h2> <table> <thead> <tr> <th style="text-align: left">Scheme</th> <th style="text-align: left">ID Trend</th> <th style="text-align: left">Performance</th> <th style="text-align: left">Core Dependency</th> <th style="text-align: left">WorkerID Allocation</th> <th style="text-align: left">Clock Skew Handling</th> <th style="text-align: left">Key Advantage</th> <th style="text-align: left">Core Drawback</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>UUID</strong></td> <td style="text-align: left">Unordered</td> <td style="text-align: left">Extreme (Local)</td> <td style="text-align: left">None</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Simplicity, no network cost</td> <td style="text-align: left">String, unordered, poor index perf</td> </tr> <tr> <td style="text-align: left"><strong>DB Auto-Inc</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">Low</td> <td style="text-align: left">Database</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Simplicity, ordered IDs</td> <td style="text-align: left">DB dependency, poor scalability</td> </tr> <tr> <td style="text-align: left"><strong>Redis Inc</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">High</td> <td style="text-align: left">Redis</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Good performance, ordered IDs</td> <td style="text-align: left">Redis dependency, network cost</td> </tr> <tr> <td style="text-align: left"><strong>Snowflake</strong></td> <td style="text-align: left">Time-ordered</td> <td style="text-align: left">Extreme (Local)</td> <td style="text-align: left">ZooKeeper</td> <td style="text-align: left">ZK Ephemeral Node</td> <td style="text-align: left"><strong>Throws Exception</strong></td> <td style="text-align: left">Balanced performance, embedded info</td> <td style="text-align: left">Strong clock dependency, ZK complexity</td> </tr> <tr> <td style="text-align: left"><strong>UidGenerator</strong></td> <td style="text-align: left">Time-ordered</td> <td style="text-align: left">Ultimate (Local)</td> <td style="text-align: left">Database</td> <td style="text-align: left">DB Auto-Inc ID</td> <td style="text-align: left"><strong>Throws Exception</strong></td> <td style="text-align: left">Extreme performance, massive WorkerID space</td> <td style="text-align: left">Short lifespan (~8.5 yrs), clock skew unresolved</td> </tr> <tr> <td style="text-align: left"><strong>Leaf-segment</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">Extreme (Mem)</td> <td style="text-align: left">Database</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Smooth perf, HA, sequential IDs</td> <td style="text-align: left">Predictable IDs, DB dependency</td> </tr> <tr> <td style="text-align: left"><strong>Leaf-snowflake</strong></td> <td style="text-align: left">Time-ordered</td> <td style="text-align: left">Extreme (Local)</td> <td style="text-align: left">ZooKeeper</td> <td style="text-align: left">ZK + Local Cache</td> <td style="text-align: left"><strong>Proactive Shutdown</strong></td> <td style="text-align: left"><strong>Extreme Robustness</strong>, solves clock skew</td> <td style="text-align: left">ZK dependency, slightly complex</td> </tr> <tr> <td style="text-align: left"><strong>Mist</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">High (Limited)</td> <td style="text-align: left">Redis</td> <td style="text-align: left">N/A</td> <td style="text-align: left"><strong>Immune</strong></td> <td style="text-align: left"><strong>Clock immune, unpredictable IDs</strong></td> <td style="text-align: left">Centralized dependency &amp; bottleneck</td> </tr> </tbody> </table> <p><strong>Conclusion:</strong></p> <p>There is no “best” distributed ID solution, only the one that is “most suitable” for your specific context.</p> <ul> <li>For <strong>simplicity and rapid integration</strong> where ID order is not critical, <strong>UUID</strong> is an option.</li> <li>For a <strong>high-performance, time-ordered, and information-rich ID</strong>, <strong>Snowflake</strong> is the classic benchmark.</li> <li>To build on that with a focus on <strong>extreme ease-of-use and massive node support</strong> (while accepting a limited lifespan), <strong>Baidu’s UidGenerator</strong> is an excellent choice.</li> <li>For systems with the <strong>highest requirements for robustness and availability</strong>, especially for gracefully handling clock skew, <strong>Meituan’s Leaf-snowflake</strong> is arguably the most complete solution in the industry.</li> <li>If your business requires <strong>strictly sequential, purely numeric IDs</strong>, <strong>Meituan’s Leaf-segment</strong> offers unparalleled performance and smoothness.</li> <li>Finally, if <strong>clock safety and ID unpredictability</strong> are paramount, and you can accept the architectural cost of centralization, the <strong>Mist algorithm</strong> provides a novel and effective alternative.</li> </ul> <p>When making a selection, always consider your application’s QPS, requirements for ID format and order, your team’s operational capabilities, and the specific trade-offs you are willing to make between availability and data consistency.</p>]]></content><author><name></name></author><category term="System Design Other"/><summary type="html"><![CDATA[1. The Need for Distributed, Globally Unique IDs]]></summary></entry></feed>