<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-06T04:07:13+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">503. Next Greater Element II</title><link href="https://zhengstar94.github.io//blog/2025/NextGreaterElementII/" rel="alternate" type="text/html" title="503. Next Greater Element II"/><published>2025-06-06T00:00:00+00:00</published><updated>2025-06-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NextGreaterElementII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NextGreaterElementII/"><![CDATA[<ul> <li>Given a circular integer array <code class="language-plaintext highlighter-rouge">nums</code> (i.e., the next element of <code class="language-plaintext highlighter-rouge">nums[nums.length - 1]</code> is <code class="language-plaintext highlighter-rouge">nums[0]</code>), return <em>the <strong>next greater number</strong> for every element in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>The <strong>next greater number</strong> of a number <code class="language-plaintext highlighter-rouge">x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, return <code class="language-plaintext highlighter-rouge">-1</code> for this number.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NextGreaterElementII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">nextGreaterElements</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Initialize result array with -1 (default value when no greater element found)</span>
        <span class="c1">// This handles the case where some elements don't have a next greater element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>  <span class="c1">// Fill all positions with -1 initially</span>

        <span class="c1">// Monotonic decreasing stack to store array indices</span>
        <span class="c1">// Stack property: elements corresponding to indices in stack are in decreasing order</span>
        <span class="c1">// from bottom to top. This allows us to efficiently find next greater elements.</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// CORE ALGORITHM: Traverse the array twice to simulate circular array behavior</span>
        <span class="c1">// First traversal (i = 0 to n-1): Handle normal cases and build the stack</span>
        <span class="c1">// Second traversal (i = n to 2n-1): Handle circular cases using the built stack</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate actual array index using modulo operation</span>
            <span class="c1">// This maps: 0,1,2,3,4,5,6,7,8,9 -&gt; 0,1,2,3,4,0,1,2,3,4 for n=5</span>
            <span class="kt">int</span> <span class="n">currentIndex</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="o">;</span>

            <span class="c1">// CRITICAL SECTION: Process stack while current element is greater than stack top</span>
            <span class="c1">// This is where we find the "next greater element" for previously seen smaller elements</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">currentIndex</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()])</span> <span class="o">{</span>
                <span class="c1">// Pop the index from stack - this element has found its next greater element</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="c1">// Set the result: nums[currentIndex] is the next greater element for nums[index]</span>
                <span class="c1">// This works because:</span>
                <span class="c1">// 1. All elements between index and currentIndex in the original traversal were smaller</span>
                <span class="c1">// 2. nums[currentIndex] is the first element greater than nums[index]</span>
                <span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">currentIndex</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// STACK BUILDING PHASE: Only push indices during first traversal</span>
            <span class="c1">// Second traversal is purely for finding answers, not for building stack</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Push current index to stack</span>
                <span class="c1">// This element is waiting to find its next greater element</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">currentIndex</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Note: During second traversal (i &gt;= n), we don't push to stack</span>
            <span class="c1">// We only use existing stack elements to find circular next greater elements</span>
        <span class="o">}</span>

        <span class="c1">// After both traversals, elements still in stack don't have next greater elements</span>
        <span class="c1">// Their result remains -1 (initialized value)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic circular case</span>
        <span class="c1">// nums[2] = 1 needs to look circularly to find next greater element nums[1] = 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [2, -1, 2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Mixed case with circular element</span>
        <span class="c1">// nums[4] = 3 finds next greater element nums[3] = 4 by going circularly</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [2, 3, 4, -1, 4]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: All elements are equal</span>
        <span class="c1">// No element has a next greater element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [-1, -1, -1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Single element</span>
        <span class="c1">// Single element cannot have next greater element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [-1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Strictly decreasing array</span>
        <span class="c1">// Each element (except first) finds next greater element by going circularly to the first element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result5</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [-1, 5, 5, 5, 5]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums. The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, return -1 for this number.]]></summary></entry><entry><title type="html">540. Single Element in a Sorted Array</title><link href="https://zhengstar94.github.io//blog/2025/SingleElementInASortedArray/" rel="alternate" type="text/html" title="540. Single Element in a Sorted Array"/><published>2025-06-06T00:00:00+00:00</published><updated>2025-06-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SingleElementInASortedArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SingleElementInASortedArray/"><![CDATA[<ul> <li>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</li> <li>Return <em>the single element that appears only once</em>.</li> <li>Your solution must run in <code class="language-plaintext highlighter-rouge">O(log n)</code> time and <code class="language-plaintext highlighter-rouge">O(1)</code> space.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,7,7,10,11,11]
Output: 10
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingleElementInASortedArray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">singleNonDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize binary search boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                    <span class="c1">// Start of search range</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>     <span class="c1">// End of search range</span>

        <span class="c1">// Continue binary search until we narrow down to a single element</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle index, avoiding integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="cm">/**
             * CRITICAL STEP: Ensure mid is at an even index
             *
             * Why this matters:
             * - In the portion before the single element, pairs start at even indices: (0,1), (2,3), (4,5)...
             * - In the portion after the single element, pairs start at odd indices due to shift
             *
             * By always checking from an even index, we can reliably determine:
             * - If nums[even] == nums[even+1]: we're in the "before single element" portion
             * - If nums[even] != nums[even+1]: we're in the "after single element" portion or at the single element
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mid</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mid</span><span class="o">--;</span>  <span class="c1">// Move to the previous even index</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Decision Logic:
             *
             * Case 1: nums[mid] == nums[mid + 1]
             * - This means we found a proper pair starting at an even index
             * - This indicates we're in the "before single element" portion
             * - The single element must be to the RIGHT of this pair
             * - Move left boundary to mid + 2 (skip this pair entirely)
             *
             * Case 2: nums[mid] != nums[mid + 1]
             * - This means the pair pattern is broken
             * - Either mid is the single element, or we're in the "after single element" portion
             * - The single element must be at mid or to the LEFT of mid
             * - Move right boundary to mid (include mid in next search)
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Single element is in the right half</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>  <span class="c1">// Skip the current pair and search right</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Single element is in the left half (including current position)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>     <span class="c1">// Include current position in next search</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the single element</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Single element in the middle</span>
        <span class="c1">// Array structure: [1,1] [2] [3,3] [4,4] [8,8]</span>
        <span class="c1">// Expected: 2 (breaks the pair pattern)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Single element towards the end</span>
        <span class="c1">// Array structure: [3,3] [7,7] [10] [11,11]</span>
        <span class="c1">// Expected: 10</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">11</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Single element at the beginning</span>
        <span class="c1">// Array structure: [1] [2,2] [3,3] [4,4] [8,8]</span>
        <span class="c1">// Expected: 1 (all subsequent pairs shift to odd start indices)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Single element at beginning):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Single element at the end</span>
        <span class="c1">// Array structure: [1,1] [2,2] [3,3] [4,4] [8]</span>
        <span class="c1">// Expected: 8 (last element has no pair)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 (Single element at end):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Edge case - single element array</span>
        <span class="c1">// Array structure: [1]</span>
        <span class="c1">// Expected: 1 (only one element exists)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 (Single element array):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 1"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch"/><category term="Medium"/><summary type="html"><![CDATA[You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in O(log n) time and O(1) space.]]></summary></entry><entry><title type="html">2434. Using a Robot to Print the Lexicographically Smallest String</title><link href="https://zhengstar94.github.io//blog/2025/UsingARobotToPrintTheLexicographicallySmallestString/" rel="alternate" type="text/html" title="2434. Using a Robot to Print the Lexicographically Smallest String"/><published>2025-06-06T00:00:00+00:00</published><updated>2025-06-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/UsingARobotToPrintTheLexicographicallySmallestString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/UsingARobotToPrintTheLexicographicallySmallestString/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> and a robot that currently holds an empty string <code class="language-plaintext highlighter-rouge">t</code>. Apply one of the following operations until <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> <strong>are both empty</strong>: <ul> <li>Remove the <strong>first</strong> character of a string <code class="language-plaintext highlighter-rouge">s</code> and give it to the robot. The robot will append this character to the string <code class="language-plaintext highlighter-rouge">t</code>.</li> <li>Remove the <strong>last</strong> character of a string <code class="language-plaintext highlighter-rouge">t</code> and give it to the robot. The robot will write this character on paper.</li> </ul> </li> <li>Return <em>the lexicographically smallest string that can be written on the paper.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "zza"
Output: "azz"
Explanation: Let p denote the written string.
Initially p="", s="zza", t="".
Perform first operation three times p="", s="", t="zza".
Perform second operation three times p="azz", s="", t="".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bac"
Output: "abc"
Explanation: Let p denote the written string.
Perform first operation twice p="", s="c", t="ba". 
Perform second operation twice p="ab", s="c", t="". 
Perform first operation p="ab", s="", t="c". 
Perform second operation p="abc", s="", t="".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bdda"
Output: "addb"
Explanation: Let p denote the written string.
Initially p="", s="bdda", t="".
Perform first operation four times p="", s="", t="bdda".
Perform second operation four times p="addb", s="", t="".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UsingARobotToPrintTheLexicographicallySmallestString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">robotWithString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Step 1: Preprocessing - Build suffix minimum array</span>
        <span class="c1">// sufMin[i] represents the minimum character from position i to the end of string</span>
        <span class="c1">// This helps us decide whether to wait for a smaller character or output current one</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">sufMin</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Set sentinel value to avoid boundary checking</span>
        <span class="c1">// When we reach the end, any character is &lt;= MAX_VALUE, so we can output everything</span>
        <span class="n">sufMin</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Build sufMin array from right to left</span>
        <span class="c1">// For each position i, sufMin[i] = min(current_char, min_of_remaining_suffix)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">sufMin</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sufMin</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">],</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Main algorithm execution</span>
        <span class="c1">// Initialize result builder with initial capacity for better performance</span>
        <span class="nc">StringBuilder</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

        <span class="c1">// Use ArrayDeque instead of Stack for better performance</span>
        <span class="c1">// This stack simulates the temporary string 't' in the problem</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Process each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Operation 1: Take character from string s and put it into stack t</span>
            <span class="c1">// Always push the current character first</span>
            <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>

            <span class="c1">// Operation 2: Decide when to pop characters from stack and write to paper</span>
            <span class="c1">// Key insight: Pop character if it's &lt;= minimum character in remaining suffix</span>
            <span class="c1">// This ensures we output smaller characters as early as possible</span>

            <span class="c1">// sufMin[i + 1] represents minimum character from next position to end</span>
            <span class="c1">// If current stack top &lt;= sufMin[i + 1], it means:</span>
            <span class="c1">// 1. Either no more characters left (sufMin[i+1] = MAX_VALUE), so output everything</span>
            <span class="c1">// 2. Or current character is not larger than any future character, safe to output</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">sufMin</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Pop from stack and append to result (write to paper)</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="c1">// At this point, both s and stack t should be empty</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: Example from problem statement</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"zza"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: azz"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2: Another example from problem statement</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"bac"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: abc"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 3: Third example from problem statement</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"bdda"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: addb"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 4: Edge case - single character</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: a"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 5: Already sorted string</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result5</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: abc"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 6: Reverse sorted string</span>
        <span class="nc">String</span> <span class="n">s6</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result6</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty: Remove the first character of a string s and give it to the robot. The robot will append this character to the string t. Remove the last character of a string t and give it to the robot. The robot will write this character on paper.]]></summary></entry><entry><title type="html">2929. Distribute Candies Among Children II</title><link href="https://zhengstar94.github.io//blog/2025/DistributeCandiesAmongChildrenII/" rel="alternate" type="text/html" title="2929. Distribute Candies Among Children II"/><published>2025-06-01T00:00:00+00:00</published><updated>2025-06-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DistributeCandiesAmongChildrenII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DistributeCandiesAmongChildrenII/"><![CDATA[<ul> <li>You are given two positive integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">limit</code>.</li> <li>Return <em>the <strong>total number</strong> of ways to distribute</em> <code class="language-plaintext highlighter-rouge">n</code> <em>candies among</em> <code class="language-plaintext highlighter-rouge">3</code> <em>children such that no child gets more than</em> <code class="language-plaintext highlighter-rouge">limit</code> <em>candies.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, limit = 2
Output: 3
Explanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 3, limit = 3
Output: 10
Explanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DistributeCandiesAmongChildrenII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">distributeCandies</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Using Inclusion-Exclusion Principle:</span>
        <span class="c1">// Valid solutions (≤ limit) = Total solutions - Invalid solutions (&gt; limit)</span>

        <span class="cm">/*
         * Breaking down the formula: c2(n + 2) - 3 * c2(n - limit + 1) + 3 * c2(n - 2 * limit) - c2(n - 3 * limit - 1)
         *
         * Term 1: c2(n + 2)
         * - Total ways to distribute n candies among 3 children without any limit
         * - Using stars and bars method: place n candies in 3 distinguishable boxes
         * - We have n+2 positions, choose 2 positions for dividers
         * - Formula: C(n+2, 2)
         *
         * Term 2: -3 * c2(n - limit + 1)
         * - Subtract cases where at least one child gets more than limit candies
         * - Set A: child 1 gets &gt; limit candies (we don't care about child 2 and 3)
         * - Set B: child 2 gets &gt; limit candies
         * - Set C: child 3 gets &gt; limit candies
         * - For Set A: child 1 gets at least (limit+1) candies
         *   Equivalent to: give child 1 exactly (limit+1) candies first,
         *   then distribute remaining (n-(limit+1)) candies among all 3 children
         * - Ways for Set A: C((n-(limit+1))+2, 2) = C(n-limit+1, 2)
         * - |A| = |B| = |C| = C(n-limit+1, 2), so total: 3 * C(n-limit+1, 2)
         *
         * Term 3: +3 * c2(n - 2 * limit)
         * - Add back cases where exactly two children get &gt; limit candies (inclusion-exclusion)
         * - Set A∩B: both child 1 and child 2 get &gt; limit candies
         * - Set A∩C: both child 1 and child 3 get &gt; limit candies
         * - Set B∩C: both child 2 and child 3 get &gt; limit candies
         * - For Set A∩B: both child 1 and child 2 get at least (limit+1) candies
         *   Give child 1 and child 2 each (limit+1) candies first,
         *   then distribute remaining (n-2*(limit+1)) candies among all 3 children
         * - Ways for Set A∩B: C((n-2*(limit+1))+2, 2) = C(n-2*limit, 2)
         * - |A∩B| = |A∩C| = |B∩C| = C(n-2*limit, 2), so total: 3 * C(n-2*limit, 2)
         *
         * Term 4: -c2(n - 3 * limit - 1)
         * - Subtract cases where all three children get &gt; limit candies
         * - Set A∩B∩C: all three children get &gt; limit candies
         * - Give each child (limit+1) candies first,
         *   then distribute remaining (n-3*(limit+1)) candies among all 3 children
         * - Ways: C((n-3*(limit+1))+2, 2) = C(n-3*limit-1, 2)
         *
         * Final formula by inclusion-exclusion principle:
         * |Valid| = |Total| - |A∪B∪C|
         * = |Total| - (|A|+|B|+|C| - |A∩B|-|A∩C|-|B∩C| + |A∩B∩C|)
         * = C(n+2,2) - 3*C(n-limit+1,2) + 3*C(n-2*limit,2) - C(n-3*limit-1,2)
         */</span>

        <span class="k">return</span> <span class="nf">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span>                    <span class="c1">// Total ways without constraint  C（n+2，2）</span>
                <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>        <span class="c1">// Subtract single violations  C（n-（limit+1）+2， 2）</span>
                <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">limit</span><span class="o">)</span>        <span class="c1">// Add back double violations  C(n-2*(limit+1)+2， 2)  </span>
                <span class="o">-</span> <span class="n">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">limit</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>       <span class="c1">// Subtract triple violations  C(n-3*(limit+1)+2, 2)</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">c2</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">n</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: n=5, limit=2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"n=5, limit=2: "</span> <span class="o">+</span> <span class="n">distributeCandies</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Example 2: n=3, limit=3  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"n=3, limit=3: "</span> <span class="o">+</span> <span class="n">distributeCandies</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected: 10</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given two positive integers n and limit. Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.]]></summary></entry><entry><title type="html">1901. Find a Peak Element II</title><link href="https://zhengstar94.github.io//blog/2025/FindAPeakElementII/" rel="alternate" type="text/html" title="1901. Find a Peak Element II"/><published>2025-05-28T00:00:00+00:00</published><updated>2025-05-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindAPeakElementII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindAPeakElementII/"><![CDATA[<ul> <li>A <strong>peak</strong> element in a 2D grid is an element that is <strong>strictly greater</strong> than all of its <strong>adjacent</strong> neighbors to the left, right, top, and bottom.</li> <li>Given a <strong>0-indexed</strong> <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">mat</code> where <strong>no two adjacent cells are equal</strong>, find <strong>any</strong> peak element <code class="language-plaintext highlighter-rouge">mat[i][j]</code> and return <em>the length 2 array</em> <code class="language-plaintext highlighter-rouge">[i,j]</code>.</li> <li>You may assume that the entire matrix is surrounded by an <strong>outer perimeter</strong> with the value <code class="language-plaintext highlighter-rouge">-1</code> in each cell.</li> <li>You must write an algorithm that runs in <code class="language-plaintext highlighter-rouge">O(m log(n))</code> or <code class="language-plaintext highlighter-rouge">O(n log(m))</code> time.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: mat = [ [ 1,4],[3,2 ] ]
Output: [0,1]
Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: mat = [ [ 10,20,15],[21,30,14],[7,16,32 ] ]
Output: [1,1]
Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogm) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/05/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindAPeakElementII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findPeakGrid</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize binary search boundaries for rows</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                    <span class="c1">// Start from first row</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// End at last row</span>

        <span class="c1">// Perform binary search on rows</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Find middle row to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Find the column index of maximum element in current row i</span>
            <span class="c1">// This is crucial: the max element in a row is already a peak</span>
            <span class="c1">// in horizontal direction (left-right), we only need to check vertical</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indexOfMax</span><span class="o">(</span><span class="n">mat</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Compare current max element with the element directly below it</span>
            <span class="c1">// This comparison determines which direction to search next</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mat</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">mat</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Current element is greater than element below</span>
                <span class="c1">// This means:</span>
                <span class="c1">// 1. If current element is also &gt; element above, it's a peak</span>
                <span class="c1">// 2. If current element &lt;= element above, peak exists above</span>
                <span class="c1">// In both cases, peak exists in current row or above</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  <span class="c1">// Search in upper half (including current row)</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Current element &lt;= element below</span>
                <span class="c1">// This means there's a larger element below, so peak must be below</span>
                <span class="c1">// We can safely exclude current row and search below</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Search in lower half (excluding current row)</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the row containing a peak</span>
        <span class="c1">// Return the coordinates: [row_index, column_index_of_max_in_that_row]</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">left</span><span class="o">,</span> <span class="n">indexOfMax</span><span class="o">(</span><span class="n">mat</span><span class="o">[</span><span class="n">left</span><span class="o">])};</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">indexOfMax</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Initialize with first element's index</span>

        <span class="c1">// Iterate through the array to find maximum element's index</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If current element is greater than previously found max</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">idx</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  <span class="c1">// Update max element's index</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">idx</span><span class="o">;</span>  <span class="c1">// Return index of maximum element</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== LeetCode 1901: Find a Peak Element II ===\n"</span><span class="o">);</span>

        <span class="c1">// Test Case 1: Example from LeetCode</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input matrix:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">mat1</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">findPeakGrid</span><span class="o">(</span><span class="n">mat1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak found at: ["</span> <span class="o">+</span> <span class="n">result1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak value: "</span> <span class="o">+</span> <span class="n">mat1</span><span class="o">[</span><span class="n">result1</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">result1</span><span class="o">[</span><span class="mi">1</span><span class="o">]]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Verification: "</span> <span class="o">+</span> <span class="n">verifyPeak</span><span class="o">(</span><span class="n">mat1</span><span class="o">,</span> <span class="n">result1</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result1</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Example from LeetCode</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">15</span><span class="o">},</span> <span class="o">{</span><span class="mi">21</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">14</span><span class="o">},</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">32</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input matrix:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">mat2</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">findPeakGrid</span><span class="o">(</span><span class="n">mat2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak found at: ["</span> <span class="o">+</span> <span class="n">result2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak value: "</span> <span class="o">+</span> <span class="n">mat2</span><span class="o">[</span><span class="n">result2</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">result2</span><span class="o">[</span><span class="mi">1</span><span class="o">]]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Verification: "</span> <span class="o">+</span> <span class="n">verifyPeak</span><span class="o">(</span><span class="n">mat2</span><span class="o">,</span> <span class="n">result2</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result2</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%3d"</span><span class="o">,</span> <span class="n">row</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">verifyPeak</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>

        <span class="c1">// Check all four directions</span>
        <span class="c1">// Up</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Down</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Left</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Right</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  <span class="c1">// All adjacent elements are smaller</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch"/><category term="Medium"/><summary type="html"><![CDATA[A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom. Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j]. You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell. You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.]]></summary></entry><entry><title type="html">2894. Divisible and Non-divisible Sums Differencer</title><link href="https://zhengstar94.github.io//blog/2025/DivisibleAndNonDivisibleSumsDifference/" rel="alternate" type="text/html" title="2894. Divisible and Non-divisible Sums Differencer"/><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DivisibleAndNonDivisibleSumsDifference</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DivisibleAndNonDivisibleSumsDifference/"><![CDATA[<ul> <li>You are given positive integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code>.</li> <li>Define two integers as follows: <ul> <li><code class="language-plaintext highlighter-rouge">num1</code>: The sum of all integers in the range <code class="language-plaintext highlighter-rouge">[1, n]</code> (both <strong>inclusive</strong>) that are <strong>not divisible</strong> by <code class="language-plaintext highlighter-rouge">m</code>.</li> <li><code class="language-plaintext highlighter-rouge">num2</code>: The sum of all integers in the range <code class="language-plaintext highlighter-rouge">[1, n]</code> (both <strong>inclusive</strong>) that are <strong>divisible</strong> by <code class="language-plaintext highlighter-rouge">m</code>.</li> </ul> </li> <li>Return <em>the integer</em> <code class="language-plaintext highlighter-rouge">num1 - num2</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 10, m = 3
Output: 19
Explanation: In the given example:
- Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.
- Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.
We return 37 - 18 = 19 as the answer.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, m = 6
Output: 15
Explanation: In the given example:
- Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.
- Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.
We return 15 - 0 = 15 as the answer.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, m = 1
Output: -15
Explanation: In the given example:
- Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.
- Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.
We return 0 - 15 = -15 as the answer.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/05/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DivisibleAndNonDivisibleSumsDifference</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">differenceOfSums</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate the sum of all numbers in range [1, n] using arithmetic series formula: n * (n + 1) / 2</span>
        <span class="kt">int</span> <span class="n">totalSum</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// Calculate how many numbers in range [1, n] are divisible by m</span>
        <span class="c1">// This gives us the count of multiples: m, 2m, 3m, ..., count*m where count*m &lt;= n</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">m</span><span class="o">;</span>

        <span class="c1">// Calculate the sum of all numbers divisible by m</span>
        <span class="c1">// Numbers divisible by m: m + 2m + 3m + ... + count*m</span>
        <span class="c1">// Factor out m: m * (1 + 2 + 3 + ... + count)</span>
        <span class="c1">// Apply arithmetic series formula: m * count * (count + 1) / 2</span>
        <span class="kt">int</span> <span class="n">divisibleSum</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">count</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// Calculate the sum of numbers NOT divisible by m</span>
        <span class="c1">// This equals total sum minus sum of divisible numbers</span>
        <span class="kt">int</span> <span class="n">nonDivisibleSum</span> <span class="o">=</span> <span class="n">totalSum</span> <span class="o">-</span> <span class="n">divisibleSum</span><span class="o">;</span>

        <span class="c1">// Return the difference: sum of non-divisible numbers minus sum of divisible numbers</span>
        <span class="k">return</span> <span class="n">nonDivisibleSum</span> <span class="o">-</span> <span class="n">divisibleSum</span><span class="o">;</span>

        <span class="c1">// Alternative simplified calculation: return totalSum - 2 * divisibleSum;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example from problem description</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">differenceOfSums</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">m1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: n = "</span> <span class="o">+</span> <span class="n">n1</span> <span class="o">+</span> <span class="s">", m = "</span> <span class="o">+</span> <span class="n">m1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 19"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result1</span> <span class="o">==</span> <span class="mi">19</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2: Example from problem description</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">differenceOfSums</span><span class="o">(</span><span class="n">n2</span><span class="o">,</span> <span class="n">m2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: n = "</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">+</span> <span class="s">", m = "</span> <span class="o">+</span> <span class="n">m2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 15"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result2</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 3: Example from problem description</span>
        <span class="kt">int</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="n">m3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">differenceOfSums</span><span class="o">(</span><span class="n">n3</span><span class="o">,</span> <span class="n">m3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: n = "</span> <span class="o">+</span> <span class="n">n3</span> <span class="o">+</span> <span class="s">", m = "</span> <span class="o">+</span> <span class="n">m3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: -15"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result3</span> <span class="o">==</span> <span class="o">-</span><span class="mi">15</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given positive integers n and m. Define two integers as follows: num1: The sum of all integers in the range [1, n] (both inclusive) that are not divisible by m. num2: The sum of all integers in the range [1, n] (both inclusive) that are divisible by m. Return the integer num1 - num2.]]></summary></entry><entry><title type="html">2942. Find Words Containing Character</title><link href="https://zhengstar94.github.io//blog/2025/FindWordsContainingCharacter/" rel="alternate" type="text/html" title="2942. Find Words Containing Character"/><published>2025-05-24T00:00:00+00:00</published><updated>2025-05-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindWordsContainingCharacter</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindWordsContainingCharacter/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array of strings <code class="language-plaintext highlighter-rouge">words</code> and a character <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>Return <em>an <strong>array of indices</strong> representing the words that contain the character</em> <code class="language-plaintext highlighter-rouge">x</code>.</li> <li><strong>Note</strong> that the returned array may be in <strong>any</strong> order.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["leet","code"], x = "e"
Output: [0,1]
Explanation: "e" occurs in both words: "leet", and "code". Hence, we return indices 0 and 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["abc","bcd","aaaa","cbc"], x = "a"
Output: [0,2]
Explanation: "a" occurs in "abc", and "aaaa". Hence, we return indices 0 and 2.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["abc","bcd","aaaa","cbc"], x = "z"
Output: []
Explanation: "z" does not occur in any of the words. Hence, we return an empty array.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n × m) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/05/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindWordsContainingCharacter</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findWordsContaining</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">char</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize result list to store indices of words containing the character</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each word in the array with index</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if current word contains the target character</span>
            <span class="c1">// indexOf() returns -1 if character is not found, otherwise returns the first occurrence index</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">indexOf</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add the current index to result list if character is found</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the list of indices containing the target character</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with character 'e' found in both words</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"leet"</span><span class="o">,</span> <span class="s">"code"</span><span class="o">};</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="sc">'e'</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">findWordsContaining</span><span class="o">(</span><span class="n">words1</span><span class="o">,</span> <span class="n">x1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words1</span><span class="o">)</span> <span class="o">+</span> <span class="s">", x = '"</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [0, 1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Character 'a' found in first and third words</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"abc"</span><span class="o">,</span> <span class="s">"bcd"</span><span class="o">,</span> <span class="s">"aaaa"</span><span class="o">,</span> <span class="s">"cbc"</span><span class="o">};</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">findWordsContaining</span><span class="o">(</span><span class="n">words2</span><span class="o">,</span> <span class="n">x2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words2</span><span class="o">)</span> <span class="o">+</span> <span class="s">", x = '"</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [0, 2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Character 'z' not found in any word - should return empty list</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"abc"</span><span class="o">,</span> <span class="s">"bcd"</span><span class="o">,</span> <span class="s">"aaaa"</span><span class="o">,</span> <span class="s">"cbc"</span><span class="o">};</span>
        <span class="kt">char</span> <span class="n">x3</span> <span class="o">=</span> <span class="sc">'z'</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">findWordsContaining</span><span class="o">(</span><span class="n">words3</span><span class="o">,</span> <span class="n">x3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words3</span><span class="o">)</span> <span class="o">+</span> <span class="s">", x = '"</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: []"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Additional Test Case: Character 'o' found in multiple words</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words4</span> <span class="o">=</span> <span class="o">{</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">,</span> <span class="s">"programming"</span><span class="o">};</span>
        <span class="kt">char</span> <span class="n">x4</span> <span class="o">=</span> <span class="sc">'o'</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">findWordsContaining</span><span class="o">(</span><span class="n">words4</span><span class="o">,</span> <span class="n">x4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Additional Test Case:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words4</span><span class="o">)</span> <span class="o">+</span> <span class="s">", x = '"</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [0, 1, 3]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed array of strings words and a character x. Return an array of indices representing the words that contain the character x. Note that the returned array may be in any order.]]></summary></entry><entry><title type="html">719. Find K-th Smallest Pair Distance</title><link href="https://zhengstar94.github.io//blog/2025/FindKthSmallestPairDistance/" rel="alternate" type="text/html" title="719. Find K-th Smallest Pair Distance"/><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindKthSmallestPairDistance</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindKthSmallestPairDistance/"><![CDATA[<ul> <li>The <strong>distance of a pair</strong> of integers <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> is defined as the absolute difference between <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>.</li> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">kth</code> <em>smallest <strong>distance among all the pairs</strong></em> <code class="language-plaintext highlighter-rouge">nums[i]</code> <em>and</em> <code class="language-plaintext highlighter-rouge">nums[j]</code> <em>where</em> <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; nums.length</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,1], k = 1
Output: 0
Explanation: Here are all the pairs:
(1,3) -&gt; 2
(1,1) -&gt; 0
(3,1) -&gt; 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1], k = 2
Output: 0
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,6,1], k = 3
Output: 5
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n×(logn+logD)) time | O(log(n)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.KthElement</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/05/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindKthSmallestPairDistance</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">smallestDistancePair</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the input array to allow efficient counting of pairs with two pointers</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// The smallest possible distance is 0 (duplicates), largest possible is max - min</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Binary search over the distance range</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// count of pairs with distance &lt;= mid</span>

            <span class="c1">// Use two pointers to count pairs with distance &lt;= mid efficiently</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// For each position j in the array, we want to find how many elements nums[i]</span>
                <span class="c1">// (with i &lt; j) satisfy the condition: nums[j] - nums[i] &lt;= mid</span>
                <span class="c1">// Here mid is our current guess for the maximum allowed pair distance.</span>

                <span class="c1">// Move the left pointer i forward until the distance between nums[j] and nums[i]</span>
                <span class="c1">// is not greater than mid.</span>
                <span class="c1">// This means if the difference is too big (nums[j] - nums[i] &gt; mid),</span>
                <span class="c1">// we need to increase i to reduce the distance.</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">i</span><span class="o">++;</span>  <span class="c1">// Shift i rightward to find smaller difference</span>
                <span class="o">}</span>

                <span class="c1">// Now, all elements from nums[i] up to nums[j-1] form pairs with nums[j] whose distances</span>
                <span class="c1">// are less than or equal to mid.</span>
                <span class="c1">// Since the array is sorted, nums[i], nums[i+1], ..., nums[j-1] all satisfy</span>
                <span class="c1">// nums[j] - nums[x] &lt;= mid (for x from i to j-1).</span>
                <span class="c1">//</span>
                <span class="c1">// The number of such pairs with nums[j] as one element is (j - i).</span>
                <span class="c1">// Add this count to the total count of pairs with distance &lt;= mid.</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>


            <span class="c1">// If count of pairs with distance &lt;= mid is &gt;= k, try to find smaller or equal distance</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, increase distance range to find larger distances</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When the loop finishes, left is the smallest distance with at least k pairs</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">FindKthSmallestPairDistance</span> <span class="n">solver</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FindKthSmallestPairDistance</span><span class="o">();</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [1,3,1], k = 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">solver</span><span class="o">.</span><span class="na">smallestDistancePair</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 0\n"</span><span class="o">);</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [1,1,1], k = 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">solver</span><span class="o">.</span><span class="na">smallestDistancePair</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 0\n"</span><span class="o">);</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [1,6,1], k = 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">solver</span><span class="o">.</span><span class="na">smallestDistancePair</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 5\n"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.KthElement"/><category term="Hard"/><category term="BinarySearch"/><summary type="html"><![CDATA[The distance of a pair of integers a and b is defined as the absolute difference between a and b. Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 &lt;= i &lt; j &lt; nums.length.]]></summary></entry><entry><title type="html">378. Kth Smallest Element in a Sorted Matrix</title><link href="https://zhengstar94.github.io//blog/2025/KthSmallestElementInASortedMatrix/" rel="alternate" type="text/html" title="378. Kth Smallest Element in a Sorted Matrix"/><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/KthSmallestElementInASortedMatrix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/KthSmallestElementInASortedMatrix/"><![CDATA[<ul> <li>Given an <code class="language-plaintext highlighter-rouge">n x n</code> <code class="language-plaintext highlighter-rouge">matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code class="language-plaintext highlighter-rouge">kth</code> <em>smallest element in the matrix</em>.</li> <li>Note that it is the <code class="language-plaintext highlighter-rouge">kth</code> smallest element <strong>in the sorted order</strong>, not the <code class="language-plaintext highlighter-rouge">kth</code> <strong>distinct</strong> element.</li> <li>You must find a solution with a memory complexity better than <code class="language-plaintext highlighter-rouge">O(n^2)</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [ [ 1,5,9],[10,11,13],[12,13,15 ] ], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [ [ -5 ] ], k = 1
Output: -5
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n × log(max-min)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.KthElement</span><span class="o">;</span>

<span class="cm">/**
 * author: zhengxingxing
 * date: 2025/05/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KthSmallestElementInASortedMatrix</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>         <span class="c1">// The smallest possible value in the matrix</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// The largest possible value in the matrix</span>

        <span class="c1">// Binary search on value range</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>  <span class="c1">// Prevents potential overflow</span>

            <span class="c1">// Count how many elements in the matrix are ≤ mid</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">countLessOrEqual</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If there are fewer than k elements ≤ mid, then the target must be in the right half</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, mid is large enough (maybe too large), move left</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the smallest number such that at least k elements are ≤ it</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Counts the number of elements in the matrix that are less than or equal to the given target.
     *
     * We take advantage of the sorted property:
     * - Start from the bottom-left corner.
     * - If the current number is ≤ target, then all numbers above it in that column are also ≤ target.
     * - If it's &gt; target, move upward to smaller numbers.
     *
     * Example: For matrix[i][j]
     * - If matrix[i][j] ≤ target → count += i + 1, move right
     * - Else → move up
     *
     * Time Complexity: O(n), where n is number of rows/columns
     *
     * @param matrix the input sorted matrix
     * @param target the value to compare against
     * @return count of elements ≤ target
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countLessOrEqual</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Start from the bottom-left corner</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Traverse while staying within matrix boundaries</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Since matrix[row][col] ≤ target, all elements above in this column (from row 0 to current row)</span>
                <span class="c1">// are also ≤ target due to sorted column. So we can add (row + 1) elements in one go.</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Move to next column (right)</span>
                <span class="n">col</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current element is &gt; target, move up to smaller elements</span>
                <span class="n">row</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Test cases to validate the solution.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">15</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: matrix = [ [ 1,5,9],[10,11,13],[12,13,15 ] ], k = 8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">kthSmallest</span><span class="o">(</span><span class="n">matrix1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 13\n"</span><span class="o">);</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: matrix = [ [ -5 ] ], k = 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">kthSmallest</span><span class="o">(</span><span class="n">matrix2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: -5"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.KthElement"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n^2).]]></summary></entry><entry><title type="html">668. Kth Smallest Number in Multiplication Table</title><link href="https://zhengstar94.github.io//blog/2025/KthSmallestNumberInMultiplicationTable/" rel="alternate" type="text/html" title="668. Kth Smallest Number in Multiplication Table"/><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/KthSmallestNumberInMultiplicationTable</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/KthSmallestNumberInMultiplicationTable/"><![CDATA[<ul> <li>Nearly everyone has used the <a href="https://en.wikipedia.org/wiki/Multiplication_table">Multiplication Table</a>. The multiplication table of size <code class="language-plaintext highlighter-rouge">m x n</code> is an integer matrix <code class="language-plaintext highlighter-rouge">mat</code> where <code class="language-plaintext highlighter-rouge">mat[i][j] == i * j</code> (<strong>1-indexed</strong>).</li> <li>Given three integers <code class="language-plaintext highlighter-rouge">m</code>, <code class="language-plaintext highlighter-rouge">n</code>, and <code class="language-plaintext highlighter-rouge">k</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">kth</code> <em>smallest element in the</em> <code class="language-plaintext highlighter-rouge">m x n</code> <em>multiplication table</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, k = 5
Output: 3
Explanation: The 5th smallest number is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 2, n = 3, k = 6
Output: 6
Explanation: The 6th smallest number is 6.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(mlog(mn)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.KthElement</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KthSmallestNumberInMultiplicationTable</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findKthNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the binary search boundaries:</span>
        <span class="c1">// - left: smallest possible value in the table (always 1)</span>
        <span class="c1">// - right: largest possible value in the table (m*n)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Binary search loop</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle value to test</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Count elements less than or equal to x in the multiplication table</span>
            <span class="c1">// First, handle complete rows (rows where all elements are &lt;= x)</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>  <span class="c1">// (x/n) complete rows, each contributing n elements</span>

            <span class="c1">// Then, handle partial rows (rows where only some elements are &lt;= x)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// In row i, elements less than or equal to x are: i, 2i, 3i, ..., up to x/i multiples</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Adjust search boundaries</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If we have at least k elements &lt;= x, the kth smallest could be x or smaller</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we have fewer than k elements &lt;= x, the kth smallest must be larger than x</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the kth smallest number</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method with test cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: m=3, n=3, k=5 (Expected output: 3)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: m=3, n=3, k=5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKthNumber</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: m=2, n=3, k=6 (Expected output: 6)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: m=2, n=3, k=6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKthNumber</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: m=5, n=6, k=10 (Expected output: 5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: m=5, n=6, k=10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKthNumber</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.KthElement"/><category term="Hard"/><category term="BinarySearch"/><summary type="html"><![CDATA[Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed). Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.]]></summary></entry></feed>