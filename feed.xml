<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-22T08:46:59+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">3499. Maximize Active Section with Trade I</title><link href="https://zhengstar94.github.io//blog/2025/MaximizeActiveSectionWithTradeI/" rel="alternate" type="text/html" title="3499. Maximize Active Section with Trade I"/><published>2025-04-22T00:00:00+00:00</published><updated>2025-04-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximizeActiveSectionWithTradeI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximizeActiveSectionWithTradeI/"><![CDATA[<ul> <li>You are given a binary string <code class="language-plaintext highlighter-rouge">s</code> of length <code class="language-plaintext highlighter-rouge">n</code>, where: <ul> <li><code class="language-plaintext highlighter-rouge">'1'</code> represents an <strong>active</strong> section.</li> <li><code class="language-plaintext highlighter-rouge">'0'</code> represents an <strong>inactive</strong> section.</li> </ul> </li> <li>You can perform <strong>at most one trade</strong> to maximize the number of active sections in <code class="language-plaintext highlighter-rouge">s</code>. In a trade, you: <ul> <li>Convert a contiguous block of <code class="language-plaintext highlighter-rouge">'1'</code>s that is surrounded by <code class="language-plaintext highlighter-rouge">'0'</code>s to all <code class="language-plaintext highlighter-rouge">'0'</code>s.</li> <li>Afterward, convert a contiguous block of <code class="language-plaintext highlighter-rouge">'0'</code>s that is surrounded by <code class="language-plaintext highlighter-rouge">'1'</code>s to all <code class="language-plaintext highlighter-rouge">'1'</code>s.</li> </ul> </li> <li>Return the <strong>maximum</strong> number of active sections in <code class="language-plaintext highlighter-rouge">s</code> after making the optimal trade.</li> <li><strong>Note:</strong> Treat <code class="language-plaintext highlighter-rouge">s</code> as if it is <strong>augmented</strong> with a <code class="language-plaintext highlighter-rouge">'1'</code> at both ends, forming <code class="language-plaintext highlighter-rouge">t = '1' + s + '1'</code>. The augmented <code class="language-plaintext highlighter-rouge">'1'</code>s <strong>do not</strong> contribute to the final count.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "01"

Output: 1

Explanation:

Because there is no block of '1's surrounded by '0's, no valid trade is possible. The maximum number of active sections is 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "0100"

Output: 4

Explanation:

String "0100" → Augmented to "101001".
Choose "0100", convert "101001" → "100001" → "111111".
The final string without augmentation is "1111". The maximum number of active sections is 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1000100"

Output: 7

Explanation:

String "1000100" → Augmented to "110001001".
Choose "000100", convert "110001001" → "110000001" → "111111111".
The final string without augmentation is "1111111". The maximum number of active sections is 7.
</code></pre></div></div> <p><strong>Example 4</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "01010"

Output: 4

Explanation:

String "01010" → Augmented to "1010101".
Choose "010", convert "1010101" → "1000101" → "1111101".
The final string without augmentation is "11110". The maximum number of active sections is 4.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximizeActiveSectionWithTradeI</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert string to char array for easier manipulation</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Variables to track:</span>
        <span class="c1">// total1: counts the total number of 1's in the original string</span>
        <span class="c1">// mx: stores the maximum convertible area (sum of two consecutive sequences of 0's)</span>
        <span class="c1">// pre0: stores the length of the previous sequence of 0's</span>
        <span class="kt">int</span> <span class="n">total1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Initialize pre0 to MIN_VALUE to handle the first sequence of 0's</span>
        <span class="kt">int</span> <span class="n">pre0</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Mark the start of current consecutive sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Find the end of current consecutive sequence of same characters</span>
            <span class="c1">// This is a grouped loop pattern to handle consecutive identical elements</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate the length of current consecutive sequence</span>
            <span class="kt">int</span> <span class="n">groupLength</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>

            <span class="c1">// Process the current sequence based on its type (0's or 1's)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If current sequence is 1's, add its length to total count of 1's</span>
                <span class="n">total1</span> <span class="o">+=</span> <span class="n">groupLength</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current sequence is 0's:</span>
                <span class="c1">// mx = Math.max(mx, pre0 + groupLength) finds the maximum convertible area</span>
                <span class="c1">// by comparing current maximum with sum of current and previous 0 sequences</span>
                <span class="c1">// This is crucial because we can potentially convert two adjacent 0 sequences into 1's</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">pre0</span> <span class="o">+</span> <span class="n">groupLength</span><span class="o">);</span>
                <span class="c1">// Update pre0 for next iteration</span>
                <span class="n">pre0</span> <span class="o">=</span> <span class="n">groupLength</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the final result:</span>
        <span class="c1">// total1: original count of 1's</span>
        <span class="c1">// mx: maximum additional 1's we can get through one trade operation</span>
        <span class="c1">// The sum represents the maximum possible 1's after one trade</span>
        <span class="k">return</span> <span class="n">total1</span> <span class="o">+</span> <span class="n">mx</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Simple case with one 0 and one 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"01"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 2: Case where trade can convert multiple positions</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"0100"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 3: Case with longer consecutive 0's</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"1000100"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected: 7</span>

        <span class="c1">// Test Case 4: Alternating 0's and 1's</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"01010"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s4</span><span class="o">));</span> <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[You are given a binary string s of length n, where: '1' represents an active section. '0' represents an inactive section. You can perform at most one trade to maximize the number of active sections in s. In a trade, you: Convert a contiguous block of '1's that is surrounded by '0's to all '0's. Afterward, convert a contiguous block of '0's that is surrounded by '1's to all '1's. Return the maximum number of active sections in s after making the optimal trade. Note: Treat s as if it is augmented with a '1' at both ends, forming t='1' + s + '1'. The augmented '1's do not contribute to the final count.]]></summary></entry><entry><title type="html">2145. Count the Hidden Sequences</title><link href="https://zhengstar94.github.io//blog/2025/CountTheHiddenSequences/" rel="alternate" type="text/html" title="2145. Count the Hidden Sequences"/><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountTheHiddenSequences</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountTheHiddenSequences/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array of <code class="language-plaintext highlighter-rouge">n</code> integers <code class="language-plaintext highlighter-rouge">differences</code>, which describes the <strong>differences</strong> between each pair of <strong>consecutive</strong> integers of a <strong>hidden</strong> sequence of length <code class="language-plaintext highlighter-rouge">(n + 1)</code>. More formally, call the hidden sequence <code class="language-plaintext highlighter-rouge">hidden</code>, then we have that <code class="language-plaintext highlighter-rouge">differences[i] = hidden[i + 1] - hidden[i]</code>.</li> <li>You are further given two integers <code class="language-plaintext highlighter-rouge">lower</code> and <code class="language-plaintext highlighter-rouge">upper</code> that describe the <strong>inclusive</strong> range of values <code class="language-plaintext highlighter-rouge">[lower, upper]</code> that the hidden sequence can contain. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">differences = [1, -3, 4]</code>, <code class="language-plaintext highlighter-rouge">lower = 1</code>, <code class="language-plaintext highlighter-rouge">upper = 6</code>, the hidden sequence is a sequence of length <code class="language-plaintext highlighter-rouge">4</code> whose elements are in between <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">6</code> (<strong>inclusive</strong>). <ul> <li><code class="language-plaintext highlighter-rouge">[3, 4, 1, 5]</code> and <code class="language-plaintext highlighter-rouge">[4, 5, 2, 6]</code> are possible hidden sequences.</li> <li><code class="language-plaintext highlighter-rouge">[5, 6, 3, 7]</code> is not possible since it contains an element greater than <code class="language-plaintext highlighter-rouge">6</code>.</li> <li><code class="language-plaintext highlighter-rouge">[1, 2, 3, 4]</code> is not possible since the differences are not correct.</li> </ul> </li> </ul> </li> <li>Return <em>the number of <strong>possible</strong> hidden sequences there are.</em> If there are no possible sequences, return <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: differences = [1,-3,4], lower = 1, upper = 6
Output: 2
Explanation: The possible hidden sequences are:
- [3, 4, 1, 5]
- [4, 5, 2, 6]
Thus, we return 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5
Output: 4
Explanation: The possible hidden sequences are:
- [-3, 0, -4, 1, 2, 0]
- [-2, 1, -3, 2, 3, 1]
- [-1, 2, -2, 3, 4, 2]
- [0, 3, -1, 4, 5, 3]
Thus, we return 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: differences = [4,-7,2], lower = 3, upper = 6
Output: 0
Explanation: There are no possible hidden sequences. Thus, we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountTheHiddenSequences</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">differences</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize tracking variables</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Minimum cumulative difference</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Maximum cumulative difference</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Current cumulative difference</span>

        <span class="c1">// Iterate through the differences array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">d:</span> <span class="n">differences</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Update current cumulative difference</span>
            <span class="n">cur</span> <span class="o">+=</span> <span class="n">d</span><span class="o">;</span>

            <span class="c1">// Update minimum and maximum cumulative differences</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>  <span class="c1">// Track how far below start we go</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>  <span class="c1">// Track how far above start we go</span>

            <span class="c1">// If the required range (y-x) exceeds the allowed range (upper-lower),</span>
            <span class="c1">// it's impossible to construct a valid array</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="o">){</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Calculate the number of possible starting values that would create valid arrays</span>
        <span class="c1">// (upper - lower): total allowed range</span>
        <span class="c1">// (y - x): minimum required range</span>
        <span class="c1">// +1: account for inclusive bounds</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Example with possible solutions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">differences1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countArray</span><span class="o">(</span><span class="n">differences1</span><span class="o">,</span> <span class="n">lower1</span><span class="o">,</span> <span class="n">upper1</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test Case 2: Example with more possible solutions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">differences2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countArray</span><span class="o">(</span><span class="n">differences2</span><span class="o">,</span> <span class="n">lower2</span><span class="o">,</span> <span class="n">upper2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 3: Example with no possible solutions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">differences3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper3</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countArray</span><span class="o">(</span><span class="n">differences3</span><span class="o">,</span> <span class="n">lower3</span><span class="o">,</span> <span class="n">upper3</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i]. You are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain. For example, given differences=[1, -3, 4], lower=1, upper=6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive). [3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences. [5, 6, 3, 7] is not possible since it contains an element greater than 6. [1, 2, 3, 4] is not possible since the differences are not correct. Return the number of possible hidden sequences there are. If there are no possible sequences, return 0.]]></summary></entry><entry><title type="html">467. Unique Substrings in Wraparound String</title><link href="https://zhengstar94.github.io//blog/2025/UniqueSubstringsInWraparoundString/" rel="alternate" type="text/html" title="467. Unique Substrings in Wraparound String"/><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/UniqueSubstringsInWraparoundString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/UniqueSubstringsInWraparoundString/"><![CDATA[<ul> <li>We define the string <code class="language-plaintext highlighter-rouge">base</code> to be the infinite wraparound string of <code class="language-plaintext highlighter-rouge">"abcdefghijklmnopqrstuvwxyz"</code>, so <code class="language-plaintext highlighter-rouge">base</code> will look like this: <ul> <li><code class="language-plaintext highlighter-rouge">"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...."</code>.</li> </ul> </li> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the number of <strong>unique non-empty substrings</strong> of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>are present in</em> <code class="language-plaintext highlighter-rouge">base</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "a"
Output: 1
Explanation: Only the substring "a" of s is in base.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cac"
Output: 2
Explanation: There are two substrings ("a", "c") of s in base.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "zab"
Output: 6
Explanation: There are six substrings ("z", "a", "b", "za", "ab", and "zab") of s in base.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UniqueSubstringsInWraparoundString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findSubstringInWraproundString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// dp[i] stores the maximum length of continuous substring ending with character (i+'a')</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Outer loop: process the entire string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Mark the start of current continuous group</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Inner loop: extend the current group as far as possible</span>
            <span class="c1">// A group continues if:</span>
            <span class="c1">// 1. Next character is one more than current (e.g., 'a' to 'b')</span>
            <span class="c1">// 2. Current is 'z' and next is 'a'</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
                            <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'z'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'a'</span><span class="o">)))</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current continuous group</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Process each character in the current group</span>
            <span class="c1">// For each character, update the maximum length of continuous substring ending with it</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Calculate index in dp array (0 for 'a', 1 for 'b', etc.)</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>

                <span class="c1">// len-j represents number of possible substrings ending at current character</span>
                <span class="c1">// Example: for "abc", at 'a':</span>
                <span class="c1">// - len=3, j=0: dp['a'] = max(dp['a'], 3) for substrings "a", "ab", "abc"</span>
                <span class="c1">// at 'b':</span>
                <span class="c1">// - len=3, j=1: dp['b'] = max(dp['b'], 2) for substrings "b", "bc"</span>
                <span class="c1">// at 'c':</span>
                <span class="c1">// - len=3, j=2: dp['c'] = max(dp['c'], 1) for substring "c"</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">idx</span><span class="o">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Move to next character</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Calculate sum of all unique substring counts</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="n">dp</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">count</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Single character</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">findSubstringInWraproundString</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 2: Non-continuous characters</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"cac"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">findSubstringInWraproundString</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test Case 3: Continuous characters including wraparound</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"zab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">findSubstringInWraproundString</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[We define the string base to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so base will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Given a string s, return the number of unique non-empty substrings of s are present in base.]]></summary></entry><entry><title type="html">3350. Adjacent Increasing Subarrays Detection II</title><link href="https://zhengstar94.github.io//blog/2025/AdjacentIncreasingSubarraysDetectionII/" rel="alternate" type="text/html" title="3350. Adjacent Increasing Subarrays Detection II"/><published>2025-04-20T00:00:00+00:00</published><updated>2025-04-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AdjacentIncreasingSubarraysDetectionII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AdjacentIncreasingSubarraysDetectionII/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code> of <code class="language-plaintext highlighter-rouge">n</code> integers, your task is to find the <strong>maximum</strong> value of <code class="language-plaintext highlighter-rouge">k</code> for which there exist <strong>two</strong> adjacent subarrays of length <code class="language-plaintext highlighter-rouge">k</code> each, such that both subarrays are <strong>strictly</strong> <strong>increasing</strong>. Specifically, check if there are <strong>two</strong> subarrays of length <code class="language-plaintext highlighter-rouge">k</code> starting at indices <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> (<code class="language-plaintext highlighter-rouge">a &lt; b</code>), where: <ul> <li>Both subarrays <code class="language-plaintext highlighter-rouge">nums[a..a + k - 1]</code> and <code class="language-plaintext highlighter-rouge">nums[b..b + k - 1]</code> are <strong>strictly increasing</strong>.</li> <li>The subarrays must be <strong>adjacent</strong>, meaning <code class="language-plaintext highlighter-rouge">b = a + k</code>.</li> </ul> </li> <li>Return the <strong>maximum</strong> <em>possible</em> value of <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,5,7,8,9,2,3,4,3,1]

Output: 3

Explanation:

The subarray starting at index 2 is [7, 8, 9], which is strictly increasing.
The subarray starting at index 5 is [2, 3, 4], which is also strictly increasing.
These two subarrays are adjacent, and 3 is the maximum possible value of k for which two such adjacent strictly increasing subarrays exist.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,4,4,4,5,6,7]

Output: 2

Explanation:

The subarray starting at index 0 is [1, 2], which is strictly increasing.
The subarray starting at index 2 is [3, 4], which is also strictly increasing.
These two subarrays are adjacent, and 2 is the maximum possible value of k for which two such adjacent strictly increasing subarrays exist.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdjacentIncreasingSubarraysDetectionII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxIncreasingSubarrays</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize variables to track maximum length found so far</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Length of previous strictly increasing sequence</span>
        <span class="kt">int</span> <span class="n">preCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Current position in array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

        <span class="c1">// Process array using grouped loop approach</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="c1">// Mark start of current increasing sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Find end of current strictly increasing sequence</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current increasing sequence</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Case 1: Split current sequence into two equal parts</span>
            <span class="kt">int</span> <span class="n">splitLen</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">// Case 2: Use adjacent sequences (current and previous)</span>
            <span class="kt">int</span> <span class="n">adjacentLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">preCnt</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
            <span class="c1">// Take maximum of the two cases</span>
            <span class="kt">int</span> <span class="n">currentMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">splitLen</span><span class="o">,</span> <span class="n">adjacentLen</span><span class="o">);</span>
            <span class="c1">// Update global maximum if necessary</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">currentMax</span><span class="o">);</span>

            <span class="c1">// Current sequence becomes previous sequence for next iteration</span>
            <span class="n">preCnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Sequence with multiple increasing subarrays</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Processing demonstration:"</span><span class="o">);</span>
        <span class="n">printProcess</span><span class="o">(</span><span class="n">test1</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Sequence with one long increasing subarray</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nProcessing demonstration:"</span><span class="o">);</span>
        <span class="n">printProcess</span><span class="o">(</span><span class="n">test2</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printProcess</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">preCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Find current increasing sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Print current sequence being processed</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nCurrent sequence: "</span> <span class="o">+</span> <span class="n">nums</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Current sequence length (cnt): "</span> <span class="o">+</span> <span class="n">cnt</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Previous sequence length (preCnt): "</span> <span class="o">+</span> <span class="n">preCnt</span><span class="o">);</span>

            <span class="c1">// Print calculations for both cases</span>
            <span class="kt">int</span> <span class="n">splitLen</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Case 1 (Split current sequence) = "</span> <span class="o">+</span> <span class="n">splitLen</span><span class="o">);</span>

            <span class="kt">int</span> <span class="n">adjacentLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">preCnt</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Case 2 (Use adjacent sequences) = "</span> <span class="o">+</span> <span class="n">adjacentLen</span><span class="o">);</span>

            <span class="kt">int</span> <span class="n">currentMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">splitLen</span><span class="o">,</span> <span class="n">adjacentLen</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Current maximum = "</span> <span class="o">+</span> <span class="n">currentMax</span><span class="o">);</span>

            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">currentMax</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Updated global maximum = "</span> <span class="o">+</span> <span class="n">ans</span><span class="o">);</span>

            <span class="c1">// Update for next iteration</span>
            <span class="n">preCnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[Given an array nums of n integers, your task is to find the maximum value of k for which there exist two adjacent subarrays of length k each, such that both subarrays are strictly increasing. Specifically, check if there are two subarrays of length k starting at indices a and b (a &lt; b), where: Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly increasing. The subarrays must be adjacent, meaning b=a + k. Return the maximum possible value of k. A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry><entry><title type="html">3255. Find the Power of K-Size Subarrays II</title><link href="https://zhengstar94.github.io//blog/2025/FindThePowerOfKSizeSubarraysII/" rel="alternate" type="text/html" title="3255. Find the Power of K-Size Subarrays II"/><published>2025-04-20T00:00:00+00:00</published><updated>2025-04-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindThePowerOfKSizeSubarraysII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindThePowerOfKSizeSubarraysII/"><![CDATA[<ul> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code> and a <em>positive</em> integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>The <strong>power</strong> of an array is defined as: <ul> <li>Its <strong>maximum</strong> element if <em>all</em> of its elements are <strong>consecutive</strong> and <strong>sorted</strong> in <strong>ascending</strong> order.</li> <li>-1 otherwise.</li> </ul> </li> <li>You need to find the <strong>power</strong> of all subarrays of <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Return an integer array <code class="language-plaintext highlighter-rouge">results</code> of size <code class="language-plaintext highlighter-rouge">n - k + 1</code>, where <code class="language-plaintext highlighter-rouge">results[i]</code> is the <em>power</em> of <code class="language-plaintext highlighter-rouge">nums[i..(i + k - 1)]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,3,2,5], k = 3

Output: [3,4,-1,-1,-1]

Explanation:

There are 5 subarrays of nums of size 3:
	[1, 2, 3] with the maximum element 3.
	[2, 3, 4] with the maximum element 4.
	[3, 4, 3] whose elements are not consecutive.
	[4, 3, 2] whose elements are not sorted.
	[3, 2, 5] whose elements are not consecutive.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,2,2,2,2], k = 4

Output: [-1,-1]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,3,2,3,2], k = 2

Output: [-1,3,-1,3,-1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n - k + 1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindThePowerOfKSizeSubarraysII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">resultsArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Initialize result array with length n-k+1 (total possible subarrays of size k)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="c1">// Fill result array with -1 as default value (indicating invalid subarrays)</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Index to traverse through the array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Main loop to process the entire array</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Mark the start of a potential consecutive sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Find the longest consecutive increasing sequence starting from index i</span>
            <span class="c1">// For example: in [1,2,3,4,3], starting from 1, this will find [1,2,3,4]</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current consecutive sequence</span>
            <span class="c1">// len = end position (i) - start position + 1</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// If the consecutive sequence length is &gt;= k, process all valid k-sized subarrays</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Process each possible k-sized subarray within the consecutive sequence</span>
                <span class="c1">// For example: if sequence is [1,2,3,4] and k=3:</span>
                <span class="c1">// First iteration (j=0): processes [1,2,3]</span>
                <span class="c1">// Second iteration (j=1): processes [2,3,4]</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="c1">// j is the start of current k-sized subarray</span>
                    <span class="c1">// j + k - 1 is the end of current k-sized subarray</span>
                    <span class="c1">// Store the last element of the k-sized subarray as its energy value</span>
                    <span class="c1">// For [1,2,3], store 3 at ans[0]</span>
                    <span class="c1">// For [2,3,4], store 4 at ans[1]</span>
                    <span class="n">ans</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Move to next position to start checking for new consecutive sequence</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with consecutive increasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">)</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">resultsArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">)));</span>
        <span class="c1">// Expected output: [3, 4, -1, -1, -1]</span>

        <span class="c1">// Test Case 2: Array with all same elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">)</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">resultsArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">)));</span>
        <span class="c1">// Expected output: [-1, -1]</span>

        <span class="c1">// Test Case 3: Array with alternating numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">)</span> <span class="o">+</span> <span class="s">", k = "</span> <span class="o">+</span> <span class="n">k3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">resultsArray</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">)));</span>
        <span class="c1">// Expected output: [-1, -1, -1, -1, -1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[You are given an array of integers nums of length n and a positive integer k. The power of an array is defined as: Its maximum element if all of its elements are consecutive and sorted in ascending order. -1 otherwise. You need to find the power of all subarrays of nums of size k. Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].]]></summary></entry><entry><title type="html">781. Rabbits in Forest</title><link href="https://zhengstar94.github.io//blog/2025/RabbitsInForest/" rel="alternate" type="text/html" title="781. Rabbits in Forest"/><published>2025-04-20T00:00:00+00:00</published><updated>2025-04-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RabbitsInForest</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RabbitsInForest/"><![CDATA[<ul> <li>There is a forest with an unknown number of rabbits. We asked n rabbits <strong>“How many rabbits have the same color as you?”</strong> and collected the answers in an integer array <code class="language-plaintext highlighter-rouge">answers</code> where <code class="language-plaintext highlighter-rouge">answers[i]</code> is the answer of the <code class="language-plaintext highlighter-rouge">ith</code> rabbit.</li> <li>Given the array <code class="language-plaintext highlighter-rouge">answers</code>, return <em>the minimum number of rabbits that could be in the forest</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answers = [1,1,2]
Output: 5
Explanation:
The two rabbits that answered "1" could both be the same color, say red.
The rabbit that answered "2" can't be red or the answers would be inconsistent.
Say the rabbit that answered "2" was blue.
Then there should be 2 other blue rabbits in the forest that didn't answer into the array.
The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answers = [10,10,10]
Output: 11
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitsInForest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numRabbits</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">answers</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create an array to count responses (size 1000 due to constraint: answers[i] &lt; 1000)</span>
        <span class="c1">// This array stores how many rabbits gave each specific answer</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">1000</span><span class="o">];</span>
        <span class="c1">// Variable to store the minimum total number of rabbits</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each rabbit's answer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">answer</span> <span class="o">:</span> <span class="n">answers</span><span class="o">)</span> <span class="o">{</span>
            <span class="cm">/* Key Logic for grouping rabbits:
             * answer + 1 = size of each color group (including the rabbit itself)
             * count[answer] = number of rabbits processed so far who gave this answer
             *
             * The modulo operation (%) helps determine if we need a new group:
             * - When count[answer] % (answer + 1) == 0, it means all previous groups are full
             * - For example, if answer = 2:
             *   - Each group should have 3 rabbits
             *   - When count[2] = 0, 3, 6, etc., we need a new group
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">answer</span><span class="o">]</span> <span class="o">%</span> <span class="o">(</span><span class="n">answer</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add a new complete group of rabbits</span>
                <span class="c1">// answer + 1 represents the total number of rabbits in this color group</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">answer</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Increment the count for this answer</span>
            <span class="c1">// This tracks how many rabbits have given this specific answer</span>
            <span class="n">count</span><span class="o">[</span><span class="n">answer</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed answers</span>
        <span class="c1">// Expected output: 5 (2 red rabbits + 3 blue rabbits)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numRabbits</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Same answers</span>
        <span class="c1">// Expected output: 11 (one group of 11 rabbits)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numRabbits</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Empty array</span>
        <span class="c1">// Expected output: 0 (no rabbits)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numRabbits</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Single answer</span>
        <span class="c1">// Expected output: 3 (one rabbit answered 2, so total 3 rabbits of same color)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">numRabbits</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[There is a forest with an unknown number of rabbits. We asked n rabbits “How many rabbits have the same color as you?” and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest.]]></summary></entry><entry><title type="html">2765. Longest Alternating Subarray</title><link href="https://zhengstar94.github.io//blog/2025/LongestAlternatingSubarray/" rel="alternate" type="text/html" title="2765. Longest Alternating Subarray"/><published>2025-04-19T00:00:00+00:00</published><updated>2025-04-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestAlternatingSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestAlternatingSubarray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>. A subarray <code class="language-plaintext highlighter-rouge">s</code> of length <code class="language-plaintext highlighter-rouge">m</code> is called <strong>alternating</strong> if: <ul> <li><code class="language-plaintext highlighter-rouge">m</code> is greater than <code class="language-plaintext highlighter-rouge">1</code>.</li> <li><code class="language-plaintext highlighter-rouge">s1 = s0 + 1</code>.</li> <li>The <strong>0-indexed</strong> subarray <code class="language-plaintext highlighter-rouge">s</code> looks like <code class="language-plaintext highlighter-rouge">[s0, s1, s0, s1,...,s(m-1) % 2]</code>. In other words, <code class="language-plaintext highlighter-rouge">s1 - s0 = 1</code>, <code class="language-plaintext highlighter-rouge">s2 - s1 = -1</code>, <code class="language-plaintext highlighter-rouge">s3 - s2 = 1</code>, <code class="language-plaintext highlighter-rouge">s4 - s3 = -1</code>, and so on up to <code class="language-plaintext highlighter-rouge">s[m - 1] - s[m - 2] = (-1)m</code>.</li> </ul> </li> <li>Return <em>the maximum length of all <strong>alternating</strong> subarrays present in</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>or</em> <code class="language-plaintext highlighter-rouge">-1</code> <em>if no such subarray exists**.</em></li> <li>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,4,3,4]

Output: 4

Explanation:

The alternating subarrays are [2, 3], [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,5,6]

Output: 2

Explanation:

[4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestAlternatingSubarray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">alternatingSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// An alternating subarray needs at least 2 elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Track the maximum length of any valid alternating subarray found</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Current position in the array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Outer loop: Find potential starting points for alternating subarrays</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if current pair can start an alternating sequence</span>
            <span class="c1">// The first two numbers must differ by exactly 1 (increasing)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Mark the start of a potential alternating sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>

            <span class="c1">// Inner loop: Extend the current alternating sequence as far as possible</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Calculate the distance from the start of current sequence</span>
                <span class="c1">// This distance determines whether we expect an increase or decrease</span>
                <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>

                <span class="c1">// Determine if the next number should be larger or smaller</span>
                <span class="c1">// If distance is even (0,2,4...), expect increase (+1)</span>
                <span class="c1">// If distance is odd (1,3,5...), expect decrease (-1)</span>
                <span class="c1">// Example for [3,4,3,4]:</span>
                <span class="c1">// distance=0: 3-&gt;4 (+1)</span>
                <span class="c1">// distance=1: 4-&gt;3 (-1)</span>
                <span class="c1">// distance=2: 3-&gt;4 (+1)</span>
                <span class="kt">int</span> <span class="n">expectedDiff</span> <span class="o">=</span> <span class="o">(</span><span class="n">distance</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Calculate what the next number should be based on the pattern</span>
                <span class="kt">int</span> <span class="n">expectedNext</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">expectedDiff</span><span class="o">;</span>

                <span class="c1">// If the next number doesn't match our expectation,</span>
                <span class="c1">// we've reached the end of this alternating sequence</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">expectedNext</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// After the sequence ends, update the maximum length if necessary</span>
            <span class="c1">// Add 1 to (i - start) because i points to the last valid position</span>
            <span class="c1">// Example: If start=1 and i=4, length is 4-1+1=4 elements</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method with test cases demonstrating various scenarios
     * Each test case shows different aspects of alternating subarrays
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Contains the alternating sequence [3,4,3,4]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">alternatingSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>  <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 2: Contains two alternating sequences of length 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">alternatingSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>  <span class="c1">// Expected: 2</span>

        <span class="c1">// Test Case 3: No valid alternating sequence (no consecutive +1)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">alternatingSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>  <span class="c1">// Expected: -1</span>

        <span class="c1">// Test Case 4: Multiple alternating sequences, returns longest</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">alternatingSubarray</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>  <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if: m is greater than 1. s1=s0 + 1. The 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0=1, s2 - s1=-1, s3 - s2=1, s4 - s3=-1, and so on up to s[m - 1] - s[m - 2] = (-1)m. Return the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists**. A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry><entry><title type="html">1839. Longest Substring Of All Vowels in Order</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubstringOfAllVowelsInOrder/" rel="alternate" type="text/html" title="1839. Longest Substring Of All Vowels in Order"/><published>2025-04-19T00:00:00+00:00</published><updated>2025-04-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubstringOfAllVowelsInOrder</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubstringOfAllVowelsInOrder/"><![CDATA[<ul> <li>A string is considered <strong>beautiful</strong> if it satisfies the following conditions: <ul> <li>Each of the 5 English vowels (<code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'e'</code>, <code class="language-plaintext highlighter-rouge">'i'</code>, <code class="language-plaintext highlighter-rouge">'o'</code>, <code class="language-plaintext highlighter-rouge">'u'</code>) must appear <strong>at least once</strong> in it.</li> <li>The letters must be sorted in <strong>alphabetical order</strong> (i.e. all <code class="language-plaintext highlighter-rouge">'a'</code>s before <code class="language-plaintext highlighter-rouge">'e'</code>s, all <code class="language-plaintext highlighter-rouge">'e'</code>s before <code class="language-plaintext highlighter-rouge">'i'</code>s, etc.).</li> </ul> </li> <li>For example, strings <code class="language-plaintext highlighter-rouge">"aeiou"</code> and <code class="language-plaintext highlighter-rouge">"aaaaaaeiiiioou"</code> are considered <strong>beautiful</strong>, but <code class="language-plaintext highlighter-rouge">"uaeio"</code>, <code class="language-plaintext highlighter-rouge">"aeoiu"</code>, and <code class="language-plaintext highlighter-rouge">"aaaeeeooo"</code> are <strong>not beautiful</strong>.</li> <li>Given a string <code class="language-plaintext highlighter-rouge">word</code> consisting of English vowels, return <em>the <strong>length of the longest beautiful substring</strong> of</em> <code class="language-plaintext highlighter-rouge">word</code><em>. If no such substring exists, return</em> <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>A <strong>substring</strong> is a contiguous sequence of characters in a string.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"
Output: 13
Explanation: The longest beautiful substring in word is "aaaaeiiiiouuu" of length 13.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "aeeeiiiioooauuuaeiou"
Output: 5
Explanation: The longest beautiful substring in word is "aeiou" of length 5.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "a"
Output: 0
Explanation: There is no beautiful substring, so return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubstringOfAllVowelsInOrder</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestBeautifulSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// Early return if string length is less than 5 (minimum length needed for all vowels)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Track the maximum length of valid beautiful substring found</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Index for traversing the string</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Main loop to process the entire string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="c1">// Skip if current character is not 'a' as beautiful substring must start with 'a'</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'a'</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Mark the start of potential beautiful substring</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="c1">// Counter for different vowels encountered (starts with 1 for 'a')</span>
            <span class="kt">int</span> <span class="n">vowelCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Track current vowel in the sequence</span>
            <span class="kt">char</span> <span class="n">currentVowel</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>

            <span class="c1">// Inner loop to find the length of current beautiful substring candidate</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="c1">// Case 1: Current character is same as previous vowel</span>
                <span class="c1">// Example: "aa" or "ee" - continue counting length</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">currentVowel</span><span class="o">){</span>
                    <span class="n">i</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="c1">// Case 2: Current character is the next vowel in sequence</span>
                <span class="c1">// Example: 'a' -&gt; 'e' or 'e' -&gt; 'i'</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">isNextVowel</span><span class="o">(</span><span class="n">currentVowel</span><span class="o">,</span> <span class="n">c</span><span class="o">)){</span>
                    <span class="n">currentVowel</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>        <span class="c1">// Update current vowel</span>
                    <span class="n">vowelCount</span><span class="o">++;</span>            <span class="c1">// Increment unique vowel count</span>
                    <span class="n">i</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="c1">// Case 3: Invalid sequence found, break the inner loop</span>
                <span class="k">else</span><span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Check if we found a valid beautiful substring</span>
            <span class="c1">// (must contain all 5 vowels in order)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">vowelCount</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNextVowel</span><span class="o">(</span><span class="kt">char</span> <span class="n">current</span><span class="o">,</span> <span class="kt">char</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="sc">'a'</span><span class="o">:</span> <span class="k">return</span> <span class="n">next</span> <span class="o">==</span> <span class="sc">'e'</span><span class="o">;</span>    <span class="c1">// 'a' should be followed by 'e'</span>
            <span class="k">case</span> <span class="sc">'e'</span><span class="o">:</span> <span class="k">return</span> <span class="n">next</span> <span class="o">==</span> <span class="sc">'i'</span><span class="o">;</span>    <span class="c1">// 'e' should be followed by 'i'</span>
            <span class="k">case</span> <span class="sc">'i'</span><span class="o">:</span> <span class="k">return</span> <span class="n">next</span> <span class="o">==</span> <span class="sc">'o'</span><span class="o">;</span>    <span class="c1">// 'i' should be followed by 'o'</span>
            <span class="k">case</span> <span class="sc">'o'</span><span class="o">:</span> <span class="k">return</span> <span class="n">next</span> <span class="o">==</span> <span class="sc">'u'</span><span class="o">;</span>    <span class="c1">// 'o' should be followed by 'u'</span>
            <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>           <span class="c1">// Any other case is invalid</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Should find "aaaaeiiiiouuu" (length 13)</span>
        <span class="nc">String</span> <span class="n">word1</span> <span class="o">=</span> <span class="s">"aeiaaioaaaaeiiiiouuuooaauuaeiu"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">longestBeautifulSubstring</span><span class="o">(</span><span class="n">word1</span><span class="o">));</span> <span class="c1">// Should output 13</span>

        <span class="c1">// Test case 2: Should find "aeiou" (length 5)</span>
        <span class="nc">String</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"aeeeiiiioooauuuaeiou"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">longestBeautifulSubstring</span><span class="o">(</span><span class="n">word2</span><span class="o">));</span> <span class="c1">// Should output 5</span>

        <span class="c1">// Test case 3: No valid beautiful substring possible</span>
        <span class="nc">String</span> <span class="n">word3</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">longestBeautifulSubstring</span><span class="o">(</span><span class="n">word3</span><span class="o">));</span> <span class="c1">// Should output 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[A string is considered beautiful if it satisfies the following conditions: Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it. The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.). For example, strings "aeiou" and "aaaaaaeiiiioou" are considered beautiful, but "uaeio", "aeoiu", and "aaaeeeooo" are not beautiful. Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0. A substring is a contiguous sequence of characters in a string.]]></summary></entry><entry><title type="html">1578. Minimum Time to Make Rope Colorful</title><link href="https://zhengstar94.github.io//blog/2025/MinimumTimeToMakeRopeColorful/" rel="alternate" type="text/html" title="1578. Minimum Time to Make Rope Colorful"/><published>2025-04-19T00:00:00+00:00</published><updated>2025-04-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumTimeToMakeRopeColorful</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumTimeToMakeRopeColorful/"><![CDATA[<ul> <li>Alice has <code class="language-plaintext highlighter-rouge">n</code> balloons arranged on a rope. You are given a <strong>0-indexed</strong> string <code class="language-plaintext highlighter-rouge">colors</code> where <code class="language-plaintext highlighter-rouge">colors[i]</code> is the color of the <code class="language-plaintext highlighter-rouge">ith</code> balloon.</li> <li>Alice wants the rope to be <strong>colorful</strong>. She does not want <strong>two consecutive balloons</strong> to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it <strong>colorful</strong>. You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">neededTime</code> where <code class="language-plaintext highlighter-rouge">neededTime[i]</code> is the time (in seconds) that Bob needs to remove the <code class="language-plaintext highlighter-rouge">ith</code> balloon from the rope.</li> <li>Return <em>the <strong>minimum time</strong> Bob needs to make the rope <strong>colorful</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: colors = "abaac", neededTime = [1,2,3,4,5]
Output: 3
Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
Bob can remove the blue balloon at index 2. This takes 3 seconds.
There are no longer two consecutive balloons of the same color. Total time = 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: colors = "abc", neededTime = [1,2,3]
Output: 0
Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: colors = "aabaa", neededTime = [1,2,3,4,1]
Output: 2
Explanation: Bob will remove the balloons at indices 0 and 4. Each balloons takes 1 second to remove.
There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumTimeToMakeRopeColorful</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minCost</span><span class="o">(</span><span class="nc">String</span> <span class="n">colors</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">neededTime</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// Total time needed to remove balloons</span>
        <span class="kt">int</span> <span class="n">totalTime</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Index to traverse the array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Get the current color of the balloon at position i</span>
            <span class="kt">char</span> <span class="n">currentColor</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="c1">// Initialize maxTime with the time needed to remove current balloon</span>
            <span class="c1">// This will keep track of the maximum time among same-colored balloons</span>
            <span class="kt">int</span> <span class="n">maxTime</span> <span class="o">=</span> <span class="n">neededTime</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">// Initialize sumTime with the time of current balloon</span>
            <span class="c1">// This will accumulate the total time of all same-colored balloons</span>
            <span class="kt">int</span> <span class="n">sumTime</span> <span class="o">=</span> <span class="n">neededTime</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">// Move to next position after recording current balloon's information</span>
            <span class="n">i</span><span class="o">++;</span>

            <span class="c1">// Keep checking next balloons as long as they have the same color</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">colors</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">currentColor</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update maxTime if current balloon takes longer to remove</span>
                <span class="c1">// We want to keep the balloon with maximum removal time</span>
                <span class="n">maxTime</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxTime</span><span class="o">,</span> <span class="n">neededTime</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="c1">// Add current balloon's removal time to the total</span>
                <span class="n">sumTime</span> <span class="o">+=</span> <span class="n">neededTime</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="c1">// Move to next position</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If sumTime != maxTime, it means we found multiple balloons of same color</span>
            <span class="c1">// We need to remove all balloons except the one with maximum removal time</span>
            <span class="c1">// The cost of removal will be (sumTime - maxTime)</span>
            <span class="c1">// Example: if we have [1,2,3] of same color, maxTime=3, sumTime=6</span>
            <span class="c1">// We keep the balloon with time 3 and remove others, cost = 6-3 = 3</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sumTime</span> <span class="o">!=</span> <span class="n">maxTime</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">totalTime</span> <span class="o">+=</span> <span class="o">(</span><span class="n">sumTime</span> <span class="o">-</span> <span class="n">maxTime</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">totalTime</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Remove balloon with time 3 from "abaac"</span>
        <span class="nc">String</span> <span class="n">colors1</span> <span class="o">=</span> <span class="s">"abaac"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">neededTime1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">minCost</span><span class="o">(</span><span class="n">colors1</span><span class="o">,</span> <span class="n">neededTime1</span><span class="o">));</span> <span class="c1">// Should output 3</span>

        <span class="c1">// Test case 2: No removal needed as all colors are different</span>
        <span class="nc">String</span> <span class="n">colors2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">neededTime2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">minCost</span><span class="o">(</span><span class="n">colors2</span><span class="o">,</span> <span class="n">neededTime2</span><span class="o">));</span> <span class="c1">// Should output 0</span>

        <span class="c1">// Test case 3: Remove balloons with times 1 and 1</span>
        <span class="nc">String</span> <span class="n">colors3</span> <span class="o">=</span> <span class="s">"aabaa"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">neededTime3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">minCost</span><span class="o">(</span><span class="n">colors3</span><span class="o">,</span> <span class="n">neededTime3</span><span class="o">));</span> <span class="c1">// Should output 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon. Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope. Return the minimum time Bob needs to make the rope colorful.]]></summary></entry><entry><title type="html">2176. Count Equal and Divisible Pairs in an Array</title><link href="https://zhengstar94.github.io//blog/2025/CountEqualAndDivisiblePairsInAnArray/" rel="alternate" type="text/html" title="2176. Count Equal and Divisible Pairs in an Array"/><published>2025-04-17T00:00:00+00:00</published><updated>2025-04-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountEqualAndDivisiblePairsInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountEqualAndDivisiblePairsInAnArray/"><![CDATA[<ul> <li>Given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the <strong>number of pairs</strong></em> <code class="language-plaintext highlighter-rouge">(i, j)</code> <em>where</em> <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; n</code>, <em>such that</em> <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code> <em>and</em> <code class="language-plaintext highlighter-rouge">(i * j)</code> <em>is divisible by</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,1,2,2,2,1,3], k = 2
Output: 4
Explanation:
There are 4 pairs that meet all the requirements:
- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4], k = 1
Output: 0
Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n²) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountEqualAndDivisiblePairsInAnArray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store indices for each number</span>
        <span class="c1">// Key: number from array</span>
        <span class="c1">// Value: list of indices where this number appears</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array to find valid pairs</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="c1">// Check all previous indices of the current number</span>
                <span class="c1">// to find valid pairs</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="c1">// Use long to prevent integer overflow</span>
                    <span class="c1">// Check if product of indices is divisible by k</span>
                    <span class="k">if</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="n">i</span> <span class="o">*</span> <span class="n">prevIndex</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">count</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Initialize new ArrayList for first occurrence of a number</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">// Add current index to the list of indices for this number</span>
            <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple valid pairs</span>
        <span class="c1">// Expected output: 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: No valid pairs</span>
        <span class="c1">// Expected output: 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 &lt;= i &lt; j &lt; n, such that nums[i] == nums[j] and (i * j) is divisible by k.]]></summary></entry></feed>