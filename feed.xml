<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-04T05:07:14+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1800. Maximum Ascending Subarray Sum</title><link href="https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum/" rel="alternate" type="text/html" title="1800. Maximum Ascending Subarray Sum"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum/"><![CDATA[<ul> <li>Given an array of positive integers <code class="language-plaintext highlighter-rouge">nums</code>, return the <em>maximum possible sum of an <strong>ascending</strong> subarray in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>A subarray is defined as a contiguous sequence of numbers in an array.</li> <li>A subarray <code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> is <strong>ascending</strong> if for all <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">l &lt;= i &lt; r</code>, <code class="language-plaintext highlighter-rouge">numsi &lt; numsi+1</code>. Note that a subarray of size <code class="language-plaintext highlighter-rouge">1</code> is <strong>ascending</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumAscendingSubarraySum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxAscendingSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or empty array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables:</span>
        <span class="c1">// maxSum: keeps track of the maximum sum found so far</span>
        <span class="c1">// currentSum: keeps track of the current ascending sequence sum</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the array starting from second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If current element is greater than previous element</span>
            <span class="c1">// Continue building the ascending sequence</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If sequence breaks, start a new sequence from current element</span>
                <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// Update maxSum if currentSum is greater</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">currentSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with mixed ascending and non-ascending sequences</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">50</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 65</span>

        <span class="c1">// Test Case 2: Completely ascending array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">40</span><span class="o">,</span><span class="mi">50</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 150</span>

        <span class="c1">// Test Case 3: Array with multiple small ascending sequences</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">12</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 33</span>

        <span class="c1">// Test Case 4: Array with single element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums. A subarray is defined as a contiguous sequence of numbers in an array. A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l &lt;= i &lt; r, numsi &lt; numsi+1. Note that a subarray of size 1 is ascending.]]></summary></entry><entry><title type="html">922. Sort Array By Parity II</title><link href="https://zhengstar94.github.io//blog/2025/SortArrayByParityII/" rel="alternate" type="text/html" title="922. Sort Array By Parity II"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SortArrayByParityII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SortArrayByParityII/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>, half of the integers in <code class="language-plaintext highlighter-rouge">nums</code> are <strong>odd</strong>, and the other half are <strong>even</strong>.</li> <li>Sort the array so that whenever <code class="language-plaintext highlighter-rouge">nums[i]</code> is odd, <code class="language-plaintext highlighter-rouge">i</code> is <strong>odd</strong>, and whenever <code class="language-plaintext highlighter-rouge">nums[i]</code> is even, <code class="language-plaintext highlighter-rouge">i</code> is <strong>even</strong>.</li> <li>Return <em>any answer array that satisfies this condition</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3]
Output: [2,3]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SortArrayByParityII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParityII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize pointer for even indices starting from 0</span>
        <span class="kt">int</span> <span class="n">evenIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Initialize pointer for odd indices starting from 1</span>
        <span class="kt">int</span> <span class="n">oddIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create a new array to store the result</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Iterate through each number in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If number is even, place it at even index</span>
                <span class="n">result</span><span class="o">[</span><span class="n">evenIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="c1">// Move even index pointer by 2 positions</span>
                <span class="n">evenIndex</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If number is odd, place it at odd index</span>
                <span class="n">result</span><span class="o">[</span><span class="n">oddIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="c1">// Move odd index pointer by 2 positions</span>
                <span class="n">oddIndex</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the sorted array</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with multiple elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">sortArrayByParityII</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Array with minimum elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">sortArrayByParityII</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even. Return any answer array that satisfies this condition.]]></summary></entry><entry><title type="html">2962. Count Subarrays Where Max Element Appears at Least K Times</title><link href="https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes/" rel="alternate" type="text/html" title="2962. Count Subarrays Where Max Element Appears at Least K Times"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and a <strong>positive</strong> integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Return <em>the number of subarrays where the <strong>maximum</strong> element of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>appears <strong>at least</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>times in that subarray.</em></li> <li>A <strong>subarray</strong> is a contiguous sequence of elements within (prep. 在…之内 adv. 在内部) an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,2,3,3], k = 2
Output: 6
Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,2,1], k = 3
Output: 0
Explanation: No subarray contains the element 4 at least 3 times.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubarraysWhereMaxElementAppearsAtLeastKTimes</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1. Find the maximum value in the array</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 2. Process using sliding window technique</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Store the final count of valid subarrays</span>
        <span class="kt">int</span> <span class="n">cntMx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Count of maximum value occurrences in current window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Left pointer of the sliding window</span>

        <span class="c1">// Iterate through array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If current element is the maximum value, increment the counter</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cntMx</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Key Part 1: Window Adjustment
             * When we find exactly k occurrences of maximum value in the window:
             * 1. We need to shrink the window from left until cntMx &lt; k
             * 2. This helps us find the leftmost valid position for the current right pointer
             *
             * For example, in [1,3,2,3,3] with k=2:
             * When right=3 (fourth position), window contains [1,3,2,3]
             * We move left pointer until we have less than k max values
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">cntMx</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If we remove a maximum value from the left, decrease the counter</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">++]</span> <span class="o">==</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">cntMx</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Key Part 2: Counting Valid Subarrays
             * After the while loop:
             * - 'left' represents the position where window becomes invalid
             * - All positions before 'left' can be valid starting points
             *
             * For example, when right=3 in [1,3,2,3]:
             * If left=2, we can start subarrays from:
             * - position 0: [1,3,2,3]
             * - position 1: [3,2,3]
             * So we add 'left' (2) to answer
             *
             * This is why ans += left works:
             * - It counts all possible valid starting positions
             * - Each starting position forms exactly one valid subarray with current right pointer
             */</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with maximum value appearing multiple times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
        <span class="c1">// Valid subarrays are: [1,3,2,3], [3,2,3], [1,3,2,3,3], [3,2,3,3], [2,3,3], [3,3]</span>

        <span class="c1">// Test Case 2: Array where maximum value appears less than k times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
        <span class="c1">// No valid subarrays as maximum value (4) appears less than 3 times</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and a positive integer k. Return the number of subarrays where the maximum element of nums appears at least k times in that subarray. A subarray is a contiguous sequence of elements within (prep. 在…之内 adv. 在内部) an array.]]></summary></entry><entry><title type="html">3105. Longest Strictly Increasing or Strictly Decreasing Subarray</title><link href="https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray/" rel="alternate" type="text/html" title="3105. Longest Strictly Increasing or Strictly Decreasing Subarray"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray/"><![CDATA[<ul> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>. Return <em>the length of the <strong>longest</strong> subarray of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>which is either <strong>strictly increasing</strong> or <strong>strictly decreasing</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,3,3,2]

Output: 2

Explanation:

The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].

The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].

Hence, we return 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,3,3]

Output: 1

Explanation:

The strictly increasing subarrays of nums are [3], [3], [3], and [3].

The strictly decreasing subarrays of nums are [3], [3], [3], and [3].

Hence, we return 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1]

Output: 3

Explanation:

The strictly increasing subarrays of nums are [3], [2], and [1].

The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].

Hence, we return 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestStrictlyIncreasingOrStrictlyDecreasingSubarray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestMonotonicSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Return 0 for null or empty array</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Return 1 for single element array</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables:</span>
        <span class="c1">// inc: length of current increasing sequence</span>
        <span class="c1">// dec: length of current decreasing sequence</span>
        <span class="c1">// maxLen: maximum length found so far</span>
        <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through the array starting from second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>  <span class="c1">// If current element is greater than previous</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Extend increasing sequence</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset decreasing sequence</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>  <span class="c1">// If current element is less than previous</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="n">dec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Extend decreasing sequence</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset increasing sequence</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>  <span class="c1">// If current element equals previous</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset both sequences</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum length found</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">inc</span><span class="o">,</span> <span class="n">dec</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>  <span class="c1">// Return the final result</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the implementation with various test cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 2: Equal elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 3: Strictly decreasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 4: Strictly increasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 5: Strictly decreasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.]]></summary></entry><entry><title type="html">1358. Number of Substrings Containing All Three Characters</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfSubstringsContainingAllThreeCharacters/" rel="alternate" type="text/html" title="1358. Number of Substrings Containing All Three Characters"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfSubstringsContainingAllThreeCharacters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfSubstringsContainingAllThreeCharacters/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> consisting only of characters <em>a</em>, <em>b</em> and <em>c</em>.</li> <li>Return the number of substrings containing <strong>at least</strong> one occurrence of all these characters <em>a</em>, <em>b</em> and <em>c</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaacb"
Output: 3
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "aaacb", "aacb" and "acb". 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc"
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSubstringsContainingAllThreeCharacters</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to keep track of frequency of each character (a, b, c) in current window</span>
        <span class="c1">// count[0] for 'a', count[1] for 'b', count[2] for 'c'</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>

        <span class="c1">// Left pointer of sliding window, used for window contraction</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Variable to store the final result (total count of valid substrings)</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through string using right pointer to expand window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Increment count for current character</span>
            <span class="c1">// Subtract 'a' to convert character to index (0 for 'a', 1 for 'b', 2 for 'c')</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>

            <span class="c1">// While window contains all three characters</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// For current valid window, add number of possible substrings</span>
                <span class="c1">// s.length() - right represents number of possible extensions of current valid window</span>
                <span class="c1">// Example: for "abcabc", when right=2 ("abc"), possible substrings are:</span>
                <span class="c1">// "abc", "abca", "abcab", "abcabc"</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">right</span><span class="o">;</span>

                <span class="c1">// Contract window from left by decreasing count of leftmost character</span>
                <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>

                <span class="c1">// Move left pointer to continue checking smaller windows</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return total count of valid substrings</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Regular case with repeated pattern</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcabc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>

        <span class="c1">// Test Case 2: Uneven distribution of characters</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"aaacb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 3: Minimal case with exactly one occurrence of each</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 4: Invalid case with missing characters</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"aaaa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 5: Longer string with multiple valid substrings</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abcabcabc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s5</span><span class="o">));</span> <span class="c1">// Expected output: 28</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s consisting only of characters a, b and c. Return the number of substrings containing at least one occurrence of all these characters a, b and c.]]></summary></entry><entry><title type="html">1752. Check if Array Is Sorted and Rotated</title><link href="https://zhengstar94.github.io//blog/2025/CheckIfArrayIsSortedAndRotated/" rel="alternate" type="text/html" title="1752. Check if Array Is Sorted and Rotated"/><published>2025-02-02T00:00:00+00:00</published><updated>2025-02-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CheckIfArrayIsSortedAndRotated</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CheckIfArrayIsSortedAndRotated/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if the array was originally sorted in non-decreasing order, then rotated <strong>some</strong> number of positions (including zero)</em>. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> <li>There may be <strong>duplicates</strong> in the original array.</li> <li><strong>Note:</strong> An array <code class="language-plaintext highlighter-rouge">A</code> rotated by <code class="language-plaintext highlighter-rouge">x</code> positions results in an array <code class="language-plaintext highlighter-rouge">B</code> of the same length such that <code class="language-plaintext highlighter-rouge">A[i] == B[(i+x) % A.length]</code>, where <code class="language-plaintext highlighter-rouge">%</code> is the modulo operation.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: true
Explanation: [1,2,3] is the original sorted array.
You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckIfArrayIsSortedAndRotated</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Count the number of inversions (where current element &gt; next element)</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Check adjacent elements including first and last (circular check)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">n</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// If more than one inversion is found, array cannot be sorted and rotated</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array that is sorted and rotated</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Should output true</span>

        <span class="c1">// Test Case 2: Array that cannot be sorted by rotation</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Should output false</span>

        <span class="c1">// Test Case 3: Already sorted array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Should output true</span>

        <span class="c1">// Test Case 4: Array with duplicate elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">check</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Should output true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.]]></summary></entry><entry><title type="html">598. Range Addition II</title><link href="https://zhengstar94.github.io//blog/2025/RangeAdditionII/" rel="alternate" type="text/html" title="598. Range Addition II"/><published>2025-02-02T00:00:00+00:00</published><updated>2025-02-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RangeAdditionII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RangeAdditionII/"><![CDATA[<ul> <li>You are given an <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">M</code> initialized with all <code class="language-plaintext highlighter-rouge">0</code>’s and an array of operations <code class="language-plaintext highlighter-rouge">ops</code>, where <code class="language-plaintext highlighter-rouge">ops[i] = [ai, bi]</code> means <code class="language-plaintext highlighter-rouge">M[x][y]</code> should be incremented by one for all <code class="language-plaintext highlighter-rouge">0 &lt;= x &lt; ai</code> and <code class="language-plaintext highlighter-rouge">0 &lt;= y &lt; bi</code></li> <li>Count and return <em>the number of maximum integers in the matrix after performing all the operations</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, ops = [ [2,2],[3,3] ]
Output: 4
Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, ops = [ [2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3] ]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, ops = []
Output: 9
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(k) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RangeAdditionII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If operations array is empty or null, return the total area of matrix</span>
        <span class="c1">// as all elements will be 0 (maximum value) in this case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ops</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ops</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables to track minimum rows and columns</span>
        <span class="c1">// The overlapping area will be determined by these minimums</span>
        <span class="kt">int</span> <span class="n">minRow</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">minCol</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Iterate through each operation to find the smallest affected area</span>
        <span class="c1">// This will be the area where all operations overlap</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">op</span> <span class="o">:</span> <span class="n">ops</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">minRow</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minRow</span><span class="o">,</span> <span class="n">op</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>  <span class="c1">// Find minimum row bound</span>
            <span class="n">minCol</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minCol</span><span class="o">,</span> <span class="n">op</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>  <span class="c1">// Find minimum column bound</span>
        <span class="o">}</span>

        <span class="c1">// Return the area of overlap (number of maximum elements)</span>
        <span class="c1">// This is the product of minimum rows and columns</span>
        <span class="k">return</span> <span class="n">minRow</span> <span class="o">*</span> <span class="n">minCol</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with two operations</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxCount</span><span class="o">(</span><span class="n">m1</span><span class="o">,</span> <span class="n">n1</span><span class="o">,</span> <span class="n">ops1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test Case 2: Multiple operations with same pattern</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxCount</span><span class="o">(</span><span class="n">m2</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">ops2</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test Case 3: Empty operations array</span>
        <span class="kt">int</span> <span class="n">m3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ops3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxCount</span><span class="o">(</span><span class="n">m3</span><span class="o">,</span> <span class="n">n3</span><span class="o">,</span> <span class="n">ops3</span><span class="o">));</span> <span class="c1">// Expected output: 9</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an m x n matrix M initialized with all 0’s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &lt;= x &lt; ai and 0 &lt;= y &lt; bi Count and return the number of maximum integers in the matrix after performing all the operations.]]></summary></entry><entry><title type="html">1234. Replace the Substring for Balanced String</title><link href="https://zhengstar94.github.io//blog/2025/ReplaceTheSubstringForBalancedString/" rel="alternate" type="text/html" title="1234. Replace the Substring for Balanced String"/><published>2025-02-01T00:00:00+00:00</published><updated>2025-02-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ReplaceTheSubstringForBalancedString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ReplaceTheSubstringForBalancedString/"><![CDATA[<ul> <li>You are given a string s of length <code class="language-plaintext highlighter-rouge">n</code> containing only four kinds of characters: <code class="language-plaintext highlighter-rouge">'Q'</code>, <code class="language-plaintext highlighter-rouge">'W'</code>, <code class="language-plaintext highlighter-rouge">'E'</code>, and <code class="language-plaintext highlighter-rouge">'R'</code>.</li> <li>A string is said to be <strong>balanced</strong> if each of its characters appears <code class="language-plaintext highlighter-rouge">n / 4</code> times where <code class="language-plaintext highlighter-rouge">n</code> is the length of the string.</li> <li>Return <em>the minimum length of the substring that can be replaced with <strong>any</strong> other string of the same length to make</em> <code class="language-plaintext highlighter-rouge">s</code> <strong><em>balanced</em></strong>. If s is already <strong>balanced</strong>, return <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "QWER"
Output: 0
Explanation: s is already balanced.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER". 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowMin</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReplaceTheSubstringForBalancedString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">balancedString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store character frequency</span>
        <span class="c1">// Using ASCII array instead of HashMap for better performance</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

        <span class="c1">// Count initial frequency of each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Calculate target frequency for each character</span>
        <span class="c1">// For a balanced string, each character should appear exactly n/4 times</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>

        <span class="c1">// Check if string is already balanced</span>
        <span class="c1">// If each character appears exactly target times, return 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="sc">'Q'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="sc">'W'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span>
                <span class="n">count</span><span class="o">[</span><span class="sc">'E'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="sc">'R'</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize minimum length as string length</span>
        <span class="c1">// This is the maximum possible length we might need to replace</span>
        <span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Initialize left pointer for sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Sliding window implementation</span>
        <span class="c1">// Right pointer moves through the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Decrease count of current character</span>
            <span class="c1">// This character is now inside our window</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)]--;</span>

            <span class="c1">// Try to minimize window size while maintaining valid condition</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="c1">// Ensure window is valid</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'Q'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="c1">// Check if Q outside window &lt;= target</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'W'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="c1">// Check if W outside window &lt;= target</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'E'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="c1">// Check if E outside window &lt;= target</span>
                    <span class="n">count</span><span class="o">[</span><span class="sc">'R'</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Check if R outside window &lt;= target</span>

                <span class="c1">// Update minimum length if current window is smaller</span>
                <span class="c1">// right - left + 1 gives current window size</span>
                <span class="n">minLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minLen</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

                <span class="c1">// Move left pointer by one position</span>
                <span class="c1">// Add the character at left pointer back to count</span>
                <span class="c1">// (it's now outside the window)</span>
                <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)]++;</span>

                <span class="c1">// Move left pointer to try to find smaller valid window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">minLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution with various test cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Already balanced string</span>
        <span class="c1">// Expected output: 0 (no replacement needed)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QWER"</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Need to replace one character</span>
        <span class="c1">// String "QQWE" needs one character replacement to be balanced</span>
        <span class="c1">// Expected output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQWE"</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Need to replace two characters</span>
        <span class="c1">// Expected output: 2 (replace "QQ" with "ER")</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQQW"</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Longer string test</span>
        <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQQWEERR"</span><span class="o">));</span>

        <span class="c1">// Test Case 5: All same characters</span>
        <span class="c1">// Expected output: 3 (need to replace three Q's)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">balancedString</span><span class="o">(</span><span class="s">"QQQQ"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowMin"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'. A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string. Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. If s is already balanced, return 0.]]></summary></entry><entry><title type="html">81. Search in Rotated Sorted Array II</title><link href="https://zhengstar94.github.io//blog/2025/SearchInRotatedSortedArrayII/" rel="alternate" type="text/html" title="81. Search in Rotated Sorted Array II"/><published>2025-02-01T00:00:00+00:00</published><updated>2025-02-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SearchInRotatedSortedArrayII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SearchInRotatedSortedArrayII/"><![CDATA[<ul> <li>There is an integer array <code class="language-plaintext highlighter-rouge">nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong> values).</li> <li>Before being passed to your function, <code class="language-plaintext highlighter-rouge">nums</code> is <strong>rotated</strong> at an unknown pivot index <code class="language-plaintext highlighter-rouge">k</code> (<code class="language-plaintext highlighter-rouge">0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code class="language-plaintext highlighter-rouge">[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code class="language-plaintext highlighter-rouge">[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code class="language-plaintext highlighter-rouge">5</code> and become <code class="language-plaintext highlighter-rouge">[4,5,6,6,7,0,1,2,4,4]</code>.</li> <li>Given the array <code class="language-plaintext highlighter-rouge">nums</code> <strong>after</strong> the rotation and an integer <code class="language-plaintext highlighter-rouge">target</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if</em> <code class="language-plaintext highlighter-rouge">target</code> <em>is in</em> <code class="language-plaintext highlighter-rouge">nums</code><em>, or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>if it is not in</em> <code class="language-plaintext highlighter-rouge">nums</code><em>.</em></li> <li>You must decrease the overall operation steps as much as possible.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n))time∣O(1)space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2025/02/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SearchInRotatedSortedArrayII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: empty array or null input</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize pointers for binary search</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point avoiding potential integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If target is found at mid, return true</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Handle the case where left element equals middle element</span>
            <span class="c1">// This is the key difference from the original rotated sorted array problem</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Skip one duplicate element and continue</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the left half is sorted</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Check if target lies in the left sorted half</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                    <span class="c1">// Target is in the left half, search there</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Target is in the right half</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Right half must be sorted</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Check if target lies in the right sorted half</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
                    <span class="c1">// Target is in the right half, search there</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Target is in the left half</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Target was not found in the array</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Here we test our solution with five common cases.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// We expect: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// We expect: false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// We expect: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// We expect: false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="mi">2</span><span class="o">));</span>     <span class="c1">// We expect: true</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Binary Search"/><category term="Medium"/><summary type="html"><![CDATA[There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums. You must decrease the overall operation steps as much as possible.]]></summary></entry><entry><title type="html">3151. Special Array I</title><link href="https://zhengstar94.github.io//blog/2025/SpecialArrayI/" rel="alternate" type="text/html" title="3151. Special Array I"/><published>2025-02-01T00:00:00+00:00</published><updated>2025-02-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SpecialArrayI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SpecialArrayI/"><![CDATA[<ul> <li>An array is considered <strong>special</strong> if every pair of its adjacent elements contains two numbers with different parity.</li> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>. Return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">nums</code> is a <strong>special</strong> array, otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1]

Output: true

Explanation:

There is only one element. So the answer is true.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,4]

Output: true

Explanation:

There is only two pairs: (2,1) and (1,4), and both of them contain numbers with different parity. So the answer is true.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,3,1,6]

Output: false

Explanation:

nums[1] and nums[2] are both odd. So the answer is false.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpecialArrayI</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isArraySpecial</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Iterate through the array up to the second-to-last element</span>
        <span class="c1">// We use length-1 because we're checking pairs of elements (current and next)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if current element and next element have the same parity</span>
            <span class="c1">// nums[i] % 2 gets the remainder (0 for even, 1 for odd)</span>
            <span class="c1">// If both elements have the same parity (both odd or both even),</span>
            <span class="c1">// then the array is not special</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>  <span class="c1">// Found two adjacent elements with same parity</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// If we've made it through the entire array without finding</span>
        <span class="c1">// any adjacent elements with the same parity, the array is special</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Single element array</span>
        <span class="c1">// Any single element array is considered special by default</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">isArraySpecial</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">}));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 2: Array with alternating even-odd parity</span>
        <span class="c1">// [2(even), 1(odd), 4(even)] - all adjacent pairs have different parity</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">isArraySpecial</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">}));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 3: Array with adjacent odd numbers</span>
        <span class="c1">// [4(even), 3(odd), 1(odd), 6(even)] - contains adjacent odd numbers</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">isArraySpecial</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">}));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test Case 4: Longer array with alternating parity</span>
        <span class="c1">// [2(even), 1(odd), 4(even), 3(odd), 6(even), 5(odd)]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">isArraySpecial</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">}));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 5: Array with adjacent even numbers</span>
        <span class="c1">// [2(even), 2(even), 4(even)] - contains adjacent even numbers</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">isArraySpecial</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">}));</span> <span class="c1">// Expected: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[An array is considered special if every pair of its adjacent elements contains two numbers with different parity. You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.]]></summary></entry></feed>