<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-01T00:58:31+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2905. Find Indices With Index and Value Difference II</title><link href="https://zhengstar94.github.io//blog/2025/FindIndicesWithIndexAndValueDifferenceII/" rel="alternate" type="text/html" title="2905. Find Indices With Index and Value Difference II"/><published>2025-08-01T00:00:00+00:00</published><updated>2025-08-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindIndicesWithIndexAndValueDifferenceII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindIndicesWithIndexAndValueDifferenceII/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> having length <code class="language-plaintext highlighter-rouge">n</code>, an integer <code class="language-plaintext highlighter-rouge">indexDifference</code>, and an integer <code class="language-plaintext highlighter-rouge">valueDifference</code>.</li> <li>Your task is to find <strong>two</strong> indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>, both in the range <code class="language-plaintext highlighter-rouge">[0, n - 1]</code>, that satisfy the following conditions: <ul> <li><code class="language-plaintext highlighter-rouge">abs(i - j) &gt;= indexDifference</code>, and</li> <li><code class="language-plaintext highlighter-rouge">abs(nums[i] - nums[j]) &gt;= valueDifference</code></li> </ul> </li> <li>Return <em>an integer array</em> <code class="language-plaintext highlighter-rouge">answer</code>, <em>where</em> <code class="language-plaintext highlighter-rouge">answer = [i, j]</code> <em>if there are two such indices</em>, <em>and</em> <code class="language-plaintext highlighter-rouge">answer = [-1, -1]</code> <em>otherwise</em>. If there are multiple choices for the two indices, return <em>any of them</em>.</li> <li><strong>Note:</strong> <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> may be <strong>equal</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
Output: [0,3]
Explanation: In this example, i = 0 and j = 3 can be selected.
abs(0 - 3) &gt;= 2 and abs(nums[0] - nums[3]) &gt;= 4.
Hence, a valid answer is [0,3].
[3,0] is also a valid answer.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1], indexDifference = 0, valueDifference = 0
Output: [0,0]
Explanation: In this example, i = 0 and j = 0 can be selected.
abs(0 - 0) &gt;= 0 and abs(nums[0] - nums[0]) &gt;= 0.
Hence, a valid answer is [0,0].
Other valid answers are [0,1], [1,0], and [1,1].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3], indexDifference = 2, valueDifference = 4
Output: [-1,-1]
Explanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.
Hence, [-1,-1] is returned.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/08/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindIndicesWithIndexAndValueDifferenceII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findIndices</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">indexDifference</span><span class="o">,</span> <span class="kt">int</span> <span class="n">valueDifference</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// maxIdx: stores the index of the current maximum value in the sliding window</span>
        <span class="kt">int</span> <span class="n">maxIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// minIdx: stores the index of the current minimum value in the sliding window</span>
        <span class="kt">int</span> <span class="n">minIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Start j from indexDifference to ensure abs(i - j) &gt;= indexDifference</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indexDifference</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// i is the left boundary of the window for current j</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">indexDifference</span><span class="o">;</span>

            <span class="c1">// If the new left boundary value is greater than the current max, update maxIdx</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">maxIdx</span><span class="o">]){</span>
                <span class="n">maxIdx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If the new left boundary value is less than the current min, update minIdx</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">minIdx</span><span class="o">]){</span>
                <span class="n">minIdx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the difference between the current max in the window and nums[j] </span>
            <span class="c1">// is at least valueDifference. If so, return the pair.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">maxIdx</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">valueDifference</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">maxIdx</span><span class="o">,</span> <span class="n">j</span><span class="o">};</span>
            <span class="o">}</span>

            <span class="c1">// Check if the difference between nums[j] and the current min in the window</span>
            <span class="c1">// is at least valueDifference. If so, return the pair.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">minIdx</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">valueDifference</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">minIdx</span><span class="o">,</span> <span class="n">j</span><span class="o">};</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no such pair is found, return [-1, -1]</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">indexDifference1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">valueDifference1</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="c1">// Example 1: Should print [0, 3] or [3, 0] (any valid pair)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findIndices</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">indexDifference1</span><span class="o">,</span> <span class="n">valueDifference1</span><span class="o">)));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">indexDifference2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">valueDifference2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Example 2: Should print [0, 0] or [1, 1] or any valid pair</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findIndices</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">indexDifference2</span><span class="o">,</span> <span class="n">valueDifference2</span><span class="o">)));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">indexDifference3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">valueDifference3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="c1">// Example 3: Should print [-1, -1] (no valid pair)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findIndices</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">indexDifference3</span><span class="o">,</span> <span class="n">valueDifference3</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference. Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions: abs(i - j) &gt;= indexDifference, and abs(nums[i] - nums[j]) &gt;= valueDifference Return an integer array answer, where answer=[i, j] if there are two such indices, and answer=[-1, -1] otherwise. If there are multiple choices for the two indices, return any of them. Note: i and j may be equal.]]></summary></entry><entry><title type="html">3584. Maximum Product of First and Last Elements of a Subsequence</title><link href="https://zhengstar94.github.io//blog/2025/MaximumProductOfFirstAndLastElementsOfASubsequence/" rel="alternate" type="text/html" title="3584. Maximum Product of First and Last Elements of a Subsequence"/><published>2025-08-01T00:00:00+00:00</published><updated>2025-08-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumProductOfFirstAndLastElementsOfASubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumProductOfFirstAndLastElementsOfASubsequence/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">m</code>.</li> <li>Return the <strong>maximum</strong> product of the first and last elements of any <strong>subsequence</strong> of <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">m</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,-9,2,3,-2,-3,1], m = 1

Output: 81

Explanation:

The subsequence [-9] has the largest product of the first and last elements: -9 * -9 = 81. Therefore, the answer is 81.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,-5,5,6,-4], m = 3

Output: 20

Explanation:

The subsequence [-5, 6, -4] has the largest product of the first and last elements.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,-1,2,-6,5,2,-5,7], m = 2

Output: 35

Explanation:

The subsequence [5, 7] has the largest product of the first and last elements.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n - m) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/08/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumProductOfFirstAndLastElementsOfASubsequence</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the answer to the smallest possible value.</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="c1">// min will keep track of the minimum value among all possible "first" elements for the current window.</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="c1">// max will keep track of the maximum value among all possible "first" elements for the current window.</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="c1">// Iterate over all possible positions for the last element of the subsequence.</span>
        <span class="c1">// i is the index of the current "last" element of the subsequence.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// y is the candidate for the "first" element of the subsequence.</span>
            <span class="c1">// For each i, the possible "first" elements are nums[0] to nums[i - m + 1].</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Update min and max to always reflect the smallest and largest possible "first" elements so far.</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

            <span class="c1">// x is the current "last" element of the subsequence.</span>
            <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="c1">// Calculate the product of the current "last" element with both the minimum and maximum "first" elements.</span>
            <span class="c1">// This is necessary because both large positive and large negative numbers can yield the largest product.</span>
            <span class="kt">long</span> <span class="n">productWithMin</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">min</span><span class="o">;</span>
            <span class="kt">long</span> <span class="n">productWithMax</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">max</span><span class="o">;</span>

            <span class="c1">// Update the answer with the maximum product found so far.</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">productWithMin</span><span class="o">,</span> <span class="n">productWithMax</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// Return the maximum product found.</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Example 1: Should print 81</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumProduct</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">m1</span><span class="o">));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="c1">// Example 2: Should print 20</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumProduct</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">m2</span><span class="o">));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">// Example 3: Should print 35</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumProduct</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">m3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer m. Return the maximum product of the first and last elements of any subsequence of nums of size m.]]></summary></entry><entry><title type="html">118. Pascal’s Triangle</title><link href="https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix/" rel="alternate" type="text/html" title="118. Pascal’s Triangle"/><published>2025-08-01T00:00:00+00:00</published><updated>2025-08-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix/"><![CDATA[<ul> <li>Given an integer <code class="language-plaintext highlighter-rouge">numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.</li> <li>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numRows = 5
Output: [ [ 1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1 ] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numRows = 1
Output: [ [ 1 ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(numRows<span class="p">^</span>2) time | O(numRows<span class="p">^</span>2) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/08/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PascalTriangle</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">generate</span><span class="o">(</span><span class="kt">int</span> <span class="n">numRows</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This list will store all rows of Pascal's Triangle.</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Loop through each row index from 0 to numRows - 1.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numRows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Create a new list to represent the current row.</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">row</span>  <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// Loop through each element in the current row.</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// The first and last elements of each row are always 1.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="o">){</span>
                    <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Each inner element is the sum of the two elements directly above it</span>
                    <span class="c1">// from the previous row: result.get(i - 1).get(j - 1) and result.get(i - 1).get(j)</span>
                    <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Add the completed row to the result list.</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Return the complete Pascal's Triangle.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">numRows1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">numRows2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Test case 1: Generate 5 rows of Pascal's Triangle.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"numRows = 5: "</span> <span class="o">+</span> <span class="n">generate</span><span class="o">(</span><span class="n">numRows1</span><span class="o">));</span>
        <span class="c1">// Test case 2: Generate 1 row of Pascal's Triangle.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"numRows = 1: "</span> <span class="o">+</span> <span class="n">generate</span><span class="o">(</span><span class="n">numRows2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:]]></summary></entry><entry><title type="html">Detailed System Design of Twitter Timeline Generation</title><link href="https://zhengstar94.github.io//blog/2025/DetailedSystemDesignOfTwitterTimelineGeneration/" rel="alternate" type="text/html" title="Detailed System Design of Twitter Timeline Generation"/><published>2025-07-31T00:00:00+00:00</published><updated>2025-07-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DetailedSystemDesignOfTwitterTimelineGeneration</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DetailedSystemDesignOfTwitterTimelineGeneration/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>The timeline is a core feature of social platforms like Twitter/X. The home timeline must aggregate the latest posts from hundreds to millions of followed users in real-time, demanding high concurrency handling, low latency, and high availability. This article systematically introduces mainstream architectural approaches for timeline generation, trade-offs, engineering implementation details, and common interview follow-up questions.</p> <hr/> <h2 id="1-requirements-and-challenges">1. Requirements and Challenges</h2> <ul> <li><strong>High Concurrency</strong>: Billions of DAU, with home refresh peaks reaching tens of thousands of TPS.</li> <li><strong>Extreme Read-Write Imbalance</strong>: Read-write ratio up to 100:1, with the majority of requests being home timeline reads.</li> <li><strong>Celebrity Effect</strong>: Posts from popular users must impact millions of followers, easily creating hotspots.</li> <li><strong>Low Latency</strong>: Home refresh &lt;200 ms, post publishing &lt;100 ms.</li> <li><strong>Consistency</strong>: Eventual consistency is acceptable, with some scenarios tolerating a few seconds of delay.</li> </ul> <hr/> <h2 id="2-scheme-comparison-and-trade-offs">2. Scheme Comparison and Trade-offs</h2> <h3 id="21-fan-out-on-write-push-model">2.1 Fan-out on Write (Push Model)</h3> <ul> <li><strong>Principle</strong>: When a user publishes a post, the system immediately “pushes” (writes) the post ID to the home timeline caches of all followers. This is like an express delivery system: the poster prepares the package, and the system automatically distributes it to each follower’s “mailbox” (cache), so followers can directly retrieve it from their mailbox upon refresh. In simple terms, it’s “preparing everything in advance” to ensure efficient reads, but it assumes the follower list isn’t too large.</li> <li><strong>Advantages</strong>: Extremely fast reads, O (1) cache hits, suitable for high-read scenarios.</li> <li><strong>Disadvantages</strong>: High write pressure; a celebrity post requires millions of write operations, prone to write avalanches.</li> </ul> <h3 id="22-fan-out-on-read-pull-model">2.2 Fan-out on Read (Pull Model)</h3> <ul> <li><strong>Principle</strong>: When a user refreshes their home timeline, the system dynamically “pulls” (queries) the latest posts from all followed users’ timelines and aggregates/sorts them. This is similar to shopping at a supermarket: each refresh, the follower goes to each followed user’s “shelf” (cache or database) to pick the latest items and combines them into their shopping cart. In simple terms, it’s “on-demand fetching,” with simple writes but real-time computation during reads, prone to lag during peaks.</li> <li><strong>Advantages</strong>: Easy writes; a celebrity post only needs one write.</li> <li><strong>Disadvantages</strong>: Slow reads, requiring cross-shard/cross-service aggregation, high latency, poor scalability.</li> </ul> <h3 id="23-hybrid-fan-out">2.3 Hybrid Fan-out</h3> <ul> <li><strong>Principle</strong>: Combines the above two, differentiating by user type—ordinary users use fan-out on write (pre-push), while popular users use fan-out on read (on-demand pull). This is like a hybrid delivery model: direct door delivery for ordinary friends’ packages, but fans self-pickup for celebrities’ to avoid overwhelming the delivery staff. In simple terms, it’s a “tailored” intelligent strategy that balances read-write loads but requires extra logic for type judgment and data merging.</li> <li><strong>Advantages</strong>: Balances read-write efficiency; popular users don’t overwhelm writes, ordinary users get fast reads.</li> <li><strong>Disadvantages</strong>: Complex implementation, needing dynamic user type judgment and some computational overhead for merging.</li> </ul> <hr/> <h2 id="3-recommended-architecture-hybrid-fan-out--caching">3. Recommended Architecture: Hybrid Fan-out + Caching</h2> <h3 id="31-user-classification">3.1 User Classification</h3> <ul> <li>Set a threshold (e.g., followers &gt;10,000 for popular users); ordinary users use fan-out on write, popular users use fan-out on read.</li> <li>Cache user type results in Redis (TTL=1 hour) to reduce frequent database queries.</li> </ul> <h3 id="32-fan-out-on-write-ordinary-users">3.2 Fan-out on Write (Ordinary Users)</h3> <ul> <li>After a user posts, the post ID is asynchronously batched via Kafka and pushed to all active followers’ home timeline caches (Redis List/ZSet).</li> <li>Inactive followers are not pushed to save resources.</li> </ul> <p>The following is the sequence diagram for fan-out on write (ordinary users) (Mermaid syntax):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User as Ordinary User
    participant TimelineService as Timeline Service
    participant Kafka as Kafka Queue
    participant Redis as Redis Cache (Follower Home)

    User-&gt;&gt;TimelineService: Publish Post
    TimelineService-&gt;&gt;Kafka: Asynchronously Batch Push Post ID to Followers
    Kafka-&gt;&gt;Redis: Write to Each Active Follower's Home Timeline Cache
    Redis--&gt;&gt;Kafka: Confirm Write
    Note over TimelineService, Redis: Followers Read Directly from Cache on Refresh
</code></pre> <h4 id="java-code-example-fan-out-on-write-handling-during-posting">Java Code Example: Fan-out on Write Handling (During Posting)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In TimelineService, handle ordinary user posting with fan-out on write (simplified; actual should be async via Kafka)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">fanOutOnWrite</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tweetId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Fetch active followers list (assume from DB or cache)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">activeFollowers</span> <span class="o">=</span> <span class="n">getActiveFollowers</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
    
    <span class="c1">// Use Redis Pipeline for batch writes to optimize performance</span>
    <span class="nc">Pipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">pipelined</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">followerId</span> <span class="o">:</span> <span class="n">activeFollowers</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Push post ID to follower's home timeline (use LPUSH to keep newest on top)</span>
        <span class="n">pipeline</span><span class="o">.</span><span class="na">lpush</span><span class="o">(</span><span class="s">"home_timeline:"</span> <span class="o">+</span> <span class="n">followerId</span><span class="o">,</span> <span class="n">tweetId</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>  <span class="c1">// Execute batch operations</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="33-fan-out-on-read-popular-users">3.3 Fan-out on Read (Popular Users)</h3> <ul> <li>Popular users’ posts are only written to their own user timeline cache.</li> <li>When followers refresh home, the timeline service dynamically pulls these popular users’ latest posts and merges/sorts them with ordinary users’ posts (using a priority queue).</li> </ul> <p>The following is the sequence diagram for fan-out on read (popular users) (Mermaid syntax, focusing on write phase; read phase in home generation flow):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User as Popular User
    participant TimelineService as Timeline Service
    participant Redis as Redis Cache (User Timeline)

    User-&gt;&gt;TimelineService: Publish Post
    TimelineService-&gt;&gt;Redis: Write Only to Popular User's User Timeline Cache
    Redis--&gt;&gt;TimelineService: Confirm Write
    Note over TimelineService, Redis: Followers Dynamically Pull and Merge on Refresh
</code></pre> <h4 id="java-code-example-fan-out-on-read-handling-during-posting-write-to-own-timeline-only">Java Code Example: Fan-out on Read Handling (During Posting, Write to Own Timeline Only)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In TimelineService, handle popular user posting with fan-out on read (write to own timeline only)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">writeToUserTimeline</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tweetId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Push post ID to user's personal timeline (use LPUSH to keep newest on top)</span>
    <span class="n">redis</span><span class="o">.</span><span class="na">lpush</span><span class="o">(</span><span class="s">"user_timeline:"</span> <span class="o">+</span> <span class="n">userId</span><span class="o">,</span> <span class="n">tweetId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="34-caching-and-pre-warming">3.4 Caching and Pre-warming</h3> <ul> <li>Home timelines, user timelines, and post contents use sharded Redis caches; regularly pre-warm for popular/active users.</li> <li>Combine TTL and LRU to ensure hot data resides in memory.</li> </ul> <h3 id="35-monitoring-and-degradation">3.5 Monitoring and Degradation</h3> <ul> <li>Use Prometheus to monitor fan-out latency, cache hit rates, etc.</li> <li>Under high load, automatically degrade to return cached data only, prompting users to “refresh for latest.”</li> </ul> <h3 id="36-architecture-diagram">3.6 Architecture Diagram</h3> <p>The following is a simplified architecture diagram of the recommended approach (Mermaid syntax, viewable in Mermaid-supported Markdown renderers):</p> <pre><code class="language-mermaid">graph TD
    A[User Posts] --&gt; B{User Type?}
    B --&gt;|Ordinary User| C[Fan-out on Write: Kafka Async Push Post ID to Followers' Home Cache]
    B --&gt;|Popular User| D[Fan-out on Read: Write Only to User Timeline Cache]
    E[Follower Refreshes Home] --&gt; F[Pull Ordinary Users' Posts from Cache]
    E --&gt; G[Dynamically Pull Popular Users' Posts from Cache]
    F --&gt; H[Merge &amp; Sort: Priority Queue]
    G --&gt; H
    H --&gt; I[Return Timeline]
    J[Redis Sharded Cache] -.-&gt; C
    J -.-&gt; D
    J -.-&gt; F
    J -.-&gt; G
    K[Kafka Queue] -.-&gt; C
    L[Prometheus Monitoring] -.-&gt; I
</code></pre> <p>This diagram illustrates the overall flow for posting and home refresh, highlighting the hybrid fan-out branching logic.</p> <hr/> <h2 id="4-key-data-structures-and-flows">4. Key Data Structures and Flows</h2> <h3 id="41-redis-cache-structures">4.1 Redis Cache Structures</h3> <ul> <li><code class="language-plaintext highlighter-rouge">home_timeline:{user_id}</code>: Home timeline cache, stores post IDs, TTL=1 hour.</li> <li><code class="language-plaintext highlighter-rouge">user_timeline:{user_id}</code>: User timeline cache, stores post IDs, TTL=1 hour.</li> <li><code class="language-plaintext highlighter-rouge">tweet:{tweet_id}</code>: Post content cache.</li> </ul> <h3 id="42-home-timeline-generation-flow">4.2 Home Timeline Generation Flow</h3> <p>The following is the sequence diagram for the flow (Mermaid syntax):</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User as User
    participant TimelineService as Timeline Service
    participant Redis as Redis Cache
    participant Kafka as Kafka Queue

    User-&gt;&gt;TimelineService: Refresh Home
    TimelineService-&gt;&gt;Redis: Pull Ordinary Followed Users' Posts (Fan-out on Write Cache)
    Redis--&gt;&gt;TimelineService: Return Post List
    TimelineService-&gt;&gt;Redis: Pull Popular Followed Users' Latest Posts (Fan-out on Read)
    Redis--&gt;&gt;TimelineService: Return Post List
    TimelineService-&gt;&gt;TimelineService: Merge &amp; Sort (Priority Queue)
    TimelineService--&gt;&gt;User: Return Merged Timeline

    Note over TimelineService, Kafka: During Posting: Ordinary Users Async Fan-out via Kafka to Followers' Cache
</code></pre> <h4 id="java-code-example-merge--sort-during-home-refresh">Java Code Example (Merge &amp; Sort During Home Refresh)</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. Pull ordinary followed users' posts from Redis (pre-pushed via fan-out on write)</span>
<span class="c1">// Assume nonHotKey is the current user's home cache key, limit is posts per page (e.g., 20)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">nonHotTweets</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">lrange</span><span class="o">(</span><span class="n">nonHotKey</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">limit</span><span class="o">);</span>

<span class="c1">// 2. Pull all popular users' (celebrities) latest posts from Redis</span>
<span class="c1">// hotKey is the popular user's user timeline cache key, pull up to 500 to prevent overload</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">hotTweets</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="na">lrange</span><span class="o">(</span><span class="n">hotKey</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">500</span><span class="o">);</span>

<span class="c1">// 3. Create a priority queue (max-heap) for merging posts in descending timestamp order</span>
<span class="c1">// This ensures the final home timeline has newest posts first</span>
<span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
    <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Long</span><span class="o">.</span><span class="na">compare</span><span class="o">(-</span><span class="n">a</span><span class="o">.</span><span class="na">timestamp</span><span class="o">,</span> <span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="na">timestamp</span><span class="o">)</span> <span class="c1">// Larger timestamps rank first</span>
<span class="o">);</span>

<span class="c1">// 4. Add ordinary and popular users' posts to the priority queue</span>
<span class="n">pq</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">nonHotTweets</span><span class="o">);</span>
<span class="n">pq</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">hotTweets</span><span class="o">);</span>

<span class="c1">// 5. Pop newest posts from the queue sequentially until reaching the page limit (e.g., 20)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">merged</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 6. Return the merged home timeline post list</span>
<span class="k">return</span> <span class="n">merged</span><span class="o">;</span>
</code></pre></div></div> <hr/> <h2 id="5-performance-optimizations-and-engineering-details">5. Performance Optimizations and Engineering Details</h2> <ul> <li><strong>Batch Operations</strong>: Kafka messages and Redis Pipeline for batch writes to reduce network IO.</li> <li><strong>Async Decoupling</strong>: All fan-out on write operations handled asynchronously via Kafka to avoid blocking main flows.</li> <li><strong>Merge &amp; Sort</strong>: Use efficient heap sort for merging popular and ordinary posts, with memory pre-allocation to prevent GC jitter.</li> <li><strong>Sharding &amp; Scaling</strong>: Shard Redis, Kafka, and timeline services for horizontal scaling to support DAU growth.</li> <li><strong>Pagination Support</strong>: Support page_token for users to pull more historical posts on scroll.</li> </ul> <hr/> <h2 id="6-common-interview-follow-ups-and-real-engineering-pitfalls">6. Common Interview Follow-ups and Real Engineering Pitfalls</h2> <h3 id="high-frequency-follow-ups">High-Frequency Follow-ups</h3> <ul> <li>How to handle write pressure for celebrity posts? (Hybrid fan-out, async batching, push only to active followers)</li> <li>How to self-protect during cache avalanches? (Pre-warming, rate limiting, degradation)</li> <li>How to ensure no interruptions during shard migrations? (Dual-write sync, throttled migration, graceful degradation)</li> </ul> <h3 id="engineering-pitfalls">Engineering Pitfalls</h3> <ul> <li>Kafka queue backlogs causing post delays, requiring dynamic consumer scaling.</li> <li>Unsynchronized cache invalidations leading to stale data, needing dual-write consistency or Pub/Sub.</li> <li>Untimely hotspot shard migrations causing single-point bottlenecks affecting the whole system.</li> </ul> <h3 id="common-misconceptions">Common Misconceptions</h3> <ul> <li>Using fan-out on write for all users, leading to system crashes under celebrity effects.</li> <li>Relying only on TTL without pre-warming, high risk of cache avalanches.</li> <li>No load balancing after sharding, with hot shards dragging down the system.</li> </ul> <hr/> <h2 id="7-summary">7. Summary</h2> <p>Home timeline generation is a core challenge in social platform system design. Adopting a hybrid fan-out + caching + async decoupling + monitoring/degradation architecture balances high concurrency, low latency, and high availability, handling celebrity effects and sudden hotspots while ensuring smooth experiences for most users. Engineering implementations must focus on batching, async, sharding, cache consistency, and degradation strategies to avoid common misconceptions and pitfalls.</p>]]></content><author><name></name></author><category term="System Design Other"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">1814. Count Nice Pairs in an Array</title><link href="https://zhengstar94.github.io//blog/2025/CountNicePairsInAnArray/" rel="alternate" type="text/html" title="1814. Count Nice Pairs in an Array"/><published>2025-07-30T00:00:00+00:00</published><updated>2025-07-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountNicePairsInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountNicePairsInAnArray/"><![CDATA[<ul> <li>You are given an array <code class="language-plaintext highlighter-rouge">nums</code> that consists of non-negative integers. Let us define <code class="language-plaintext highlighter-rouge">rev(x)</code> as the reverse of the non-negative integer <code class="language-plaintext highlighter-rouge">x</code>. For example, <code class="language-plaintext highlighter-rouge">rev(123) = 321</code>, and <code class="language-plaintext highlighter-rouge">rev(120) = 21</code>. A pair of indices <code class="language-plaintext highlighter-rouge">(i, j)</code> is <strong>nice</strong> if it satisfies all of the following conditions: <ul> <li><code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; nums.length</code></li> <li><code class="language-plaintext highlighter-rouge">nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li> </ul> </li> <li>Return <em>the number of nice pairs of indices</em>. Since that number can be too large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">10^9 + 7</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [42,11,1,97]
Output: 2
Explanation: The two pairs are:
 - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
 - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [13,10,35,24,76]
Output: 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * k) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountNicePairsInAnArray</span> <span class="o">{</span>
    <span class="c1">// The modulo value as required by the problem to prevent integer overflow</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1_000_000_007</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countNicePairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This map will store the frequency of each difference value (num - rev(num))</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Use long to prevent overflow during summation</span>

        <span class="c1">// Iterate through each number in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the difference between the number and its reversed value</span>
            <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="n">rev</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>

            <span class="c1">// Get the current count of this diff value in the map.</span>
            <span class="c1">// If this diff has appeared before, it means for each previous occurrence,</span>
            <span class="c1">// we can form a new nice pair with the current number.</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">diff</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Add the count to the answer. Each previous same diff forms a nice pair with this num.</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="o">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>

            <span class="c1">// Update the map: increment the count of this diff value by 1</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">diff</span><span class="o">,</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of nice pairs, cast to int as required</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper function to reverse the digits of a non-negative integer.
     * For example, rev(123) = 321, rev(120) = 21.
     *
     * @param x The integer to reverse.
     * @return The reversed integer.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">rev</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Extract digits from right to left and build the reversed number</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// Add the last digit of x to res</span>
            <span class="n">x</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// Remove the last digit from x</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">42</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">97</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">13</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">76</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">1000</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countNicePairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countNicePairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countNicePairs</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions: 0 &lt;= i &lt; j &lt; nums.length nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) Return the number of nice pairs of indices. Since that number can be too large, return it modulo 10^9 + 7.]]></summary></entry><entry><title type="html">3371. Identify the Largest Outlier in an Array</title><link href="https://zhengstar94.github.io//blog/2025/IdentifyTheLargestOutlierInAnArray/" rel="alternate" type="text/html" title="3371. Identify the Largest Outlier in an Array"/><published>2025-07-30T00:00:00+00:00</published><updated>2025-07-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/IdentifyTheLargestOutlierInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/IdentifyTheLargestOutlierInAnArray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. This array contains <code class="language-plaintext highlighter-rouge">n</code> elements, where <strong>exactly</strong> <code class="language-plaintext highlighter-rouge">n - 2</code> elements are <strong>special</strong> <strong>numbers</strong>. One of the remaining <strong>two</strong> elements is the <em>sum</em> of these <strong>special numbers</strong>, and the other is an <strong>outlier</strong>.</li> <li>An <strong>outlier</strong> is defined as a number that is <em>neither</em> one of the original special numbers <em>nor</em> the element representing the sum of those numbers.</li> <li><strong>Note</strong> that special numbers, the sum element, and the outlier must have <strong>distinct</strong> indices, but <em>may</em> share the <strong>same</strong> value.</li> <li>Return the <strong>largest</strong> potential <strong>outlier</strong> in <code class="language-plaintext highlighter-rouge">nums</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,5,10]

Output: 10

Explanation:

The special numbers could be 2 and 3, thus making their sum 5 and the outlier 10.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-2,-1,-3,-6,4]

Output: 4

Explanation:

The special numbers could be -2, -1, and -3, thus making their sum -6 and the outlier 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1,1,5,5]

Output: 5

Explanation:

The special numbers could be 1, 1, 1, 1, and 1, thus making their sum 5 and the other 5 as the outlier.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IdentifyTheLargestOutlierInAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getLargestOutlier</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to count the occurrences of each number in the array.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Calculate the total sum of the array and populate the count map.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span> <span class="c1">// Equivalent to cnt[num]++</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="c1">// Iterate through each element, treating it as a possible outlier.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// (total - x) must be even for y to be an integer.</span>
            <span class="c1">// This ensures that y = (total - x) / 2 is a valid integer.</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">total</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="n">total</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="cm">/*
                 * Explanation of this block:
                 * - We are considering x as the possible outlier.
                 * - According to the problem, the sum of all numbers is: total = 2 * y + x,
                 *   where y is the sum of all "special numbers".
                 * - Rearranging gives y = (total - x) / 2.
                 * - We need to check if y exists in the array (cnt.containsKey(y)).
                 * - Additionally, if y == x, we must ensure that there are at least two occurrences
                 *   (so that x and y are at different indices).
                 * - If these conditions are met, x is a valid outlier candidate.
                 * - We update ans to be the maximum outlier found so far.
                 */</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">x</span> <span class="o">||</span> <span class="n">cnt</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getLargestOutlier</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 10</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getLargestOutlier</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getLargestOutlier</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums. This array contains n elements, where exactly n - 2 elements are special numbers. One of the remaining two elements is the sum of these special numbers, and the other is an outlier. An outlier is defined as a number that is neither one of the original special numbers nor the element representing the sum of those numbers. Note that special numbers, the sum element, and the outlier must have distinct indices, but may share the same value. Return the largest potential outlier in nums.]]></summary></entry><entry><title type="html">2419. Longest Subarray With Maximum Bitwise AND</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubarrayWithMaximumBitwiseAND/" rel="alternate" type="text/html" title="2419. Longest Subarray With Maximum Bitwise AND"/><published>2025-07-30T00:00:00+00:00</published><updated>2025-07-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubarrayWithMaximumBitwiseAND</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubarrayWithMaximumBitwiseAND/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code>.</li> <li>Consider a <strong>non-empty</strong> subarray from <code class="language-plaintext highlighter-rouge">nums</code> that has the <strong>maximum</strong> possible <strong>bitwise AND</strong>. <ul> <li>In other words, let <code class="language-plaintext highlighter-rouge">k</code> be the maximum value of the bitwise AND of <strong>any</strong> subarray of <code class="language-plaintext highlighter-rouge">nums</code>. Then, only subarrays with a bitwise AND equal to <code class="language-plaintext highlighter-rouge">k</code> should be considered.</li> </ul> </li> <li>Return <em>the length of the <strong>longest</strong> such subarray</em>.</li> <li>The bitwise AND of an array is the bitwise AND of all the numbers in it.</li> <li>A <strong>subarray</strong> is a contiguous sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,3,2,2]
Output: 2
Explanation:
The maximum possible bitwise AND of a subarray is 3.
The longest subarray with that value is [3,3], so we return 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4]
Output: 1
Explanation:
The maximum possible bitwise AND of a subarray is 4.
The longest subarray with that value is [4], so we return 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubarrayWithMaximumBitwiseAND</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Find the maximum value in the array.</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">maxVal</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">maxVal</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Find the longest sequence of consecutive elements equal to maxVal.</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// To store the maximum length found.</span>
        <span class="kt">int</span> <span class="n">currLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// To store the current length of consecutive maxVal elements.</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">maxVal</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current element equals maxVal, increment the current length.</span>
                <span class="n">currLen</span><span class="o">++;</span>
                <span class="c1">// Update maxLen if the current sequence is longer.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">currLen</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">maxLen</span> <span class="o">=</span> <span class="n">currLen</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If the current element is not maxVal, reset the current length.</span>
                <span class="n">currLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the length of the longest subarray found.</span>
        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: The longest subarray with maximum bitwise AND is [3, 3], length is 2.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="c1">// Example 2: The longest subarray with maximum bitwise AND is [4], length is 1.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums of size n. Consider a non-empty subarray from nums that has the maximum possible bitwise AND. In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered. Return the length of the longest such subarray. The bitwise AND of an array is the bitwise AND of all the numbers in it. A subarray is a contiguous sequence of elements within an array.]]></summary></entry><entry><title type="html">16.24. Pairs With Sum LCCI</title><link href="https://zhengstar94.github.io//blog/2025/PairsWithSumLCCI/" rel="alternate" type="text/html" title="16.24. Pairs With Sum LCCI"/><published>2025-07-28T00:00:00+00:00</published><updated>2025-07-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PairsWithSumLCCI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PairsWithSumLCCI/"><![CDATA[<ul> <li>Design an algorithm to find all pairs of integers within an array which sum to a specified value.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,6,5], target = 11
Output: [ [ 5,6 ] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,6,5,6], target = 11
Output: [ [ 5,6],[5,6 ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PairsWithSumLCCI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">pairSums</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// This map records how many times each number appears in the array.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Count the occurrences of each number in the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Iterate through the array to find valid pairs.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">num</span><span class="o">;</span> <span class="c1">// The number needed to form the target sum with 'num'.</span>

            <span class="c1">// Check if both 'num' and its complement are still available (not used up in previous pairs).</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">complement</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Special case: when num == complement, we need at least two of this number to form a pair.</span>
                <span class="c1">// For example, if target=10 and num=5, we need two 5's to form [5,5].</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">complement</span> <span class="o">&amp;&amp;</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// If there is only one occurrence left, we cannot form a pair [num, num].</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Add the pair [num, complement] to the result list.</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">complement</span><span class="o">));</span>
                <span class="c1">// Decrement the count for both numbers, since they have been used in a pair.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">complement</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// If either number is not available, skip to the next.</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="c1">// Output: [ [5, 6] ]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pairSums</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="c1">// Output: [ [5, 6], [5, 6] ]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pairSums</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="c1">// Output: [ [1, 5], [2, 4] ]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pairSums</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[Design an algorithm to find all pairs of integers within an array which sum to a specified value.]]></summary></entry><entry><title type="html">2210. Count Hills and Valleys in an Array</title><link href="https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray/" rel="alternate" type="text/html" title="2210. Count Hills and Valleys in an Array"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>. An index <code class="language-plaintext highlighter-rouge">i</code> is part of a <strong>hill</strong> in <code class="language-plaintext highlighter-rouge">nums</code> if the closest non-equal neighbors of <code class="language-plaintext highlighter-rouge">i</code> are smaller than <code class="language-plaintext highlighter-rouge">nums[i]</code>. Similarly, an index <code class="language-plaintext highlighter-rouge">i</code> is part of a <strong>valley</strong> in <code class="language-plaintext highlighter-rouge">nums</code> if the closest non-equal neighbors of <code class="language-plaintext highlighter-rouge">i</code> are larger than <code class="language-plaintext highlighter-rouge">nums[i]</code>. Adjacent indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> are part of the <strong>same</strong> hill or valley if <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code>.</li> <li>Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on <strong>both</strong> the left and right of the index.</li> <li>Return <em>the number of hills and valleys in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 &gt; 2 and 4 &gt; 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 &gt; 1 and 6 &gt; 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 &lt; 5 and 4 &gt; 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountHillsAndValleysInAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countPeaksAndValleys</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the total number of peaks and valleys found.</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Start from the second element, since the first element cannot be a peak or valley.</span>

        <span class="c1">// Loop through the array, but skip the first and last elements,</span>
        <span class="c1">// because they cannot be peaks or valleys (they don't have both neighbors).</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
            <span class="c1">// If the current element is equal to the previous one,</span>
            <span class="c1">// skip it to avoid counting the same peak/valley multiple times.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Find the closest non-equal neighbor to the left of nums[i].</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Move left pointer to the left until a different value is found or the start of the array is reached.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">left</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Find the closest non-equal neighbor to the right of nums[i].</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Move right pointer to the right until a different value is found or the end of the array is reached.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">right</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Only check for peak/valley if both left and right non-equal neighbors exist.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
                <span class="c1">// Check if nums[i] is a peak:</span>
                <span class="c1">// It is a peak if it is greater than both its closest non-equal neighbors.</span>
                <span class="c1">// Check if nums[i] is a valley:</span>
                <span class="c1">// It is a valley if it is less than both its closest non-equal neighbors.</span>
                <span class="k">if</span><span class="o">((</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])){</span>
                    <span class="n">count</span><span class="o">++;</span> <span class="c1">// Found a peak or valley, increment the counter.</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Move i to the next different element to avoid counting the same peak/valley multiple times.</span>
            <span class="c1">// This is important for handling consecutive equal elements as a single peak or valley.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j]. Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index. Return the number of hills and valleys in nums.]]></summary></entry><entry><title type="html">1679. Max Number of K-Sum Pairs</title><link href="https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs/" rel="alternate" type="text/html" title="1679. Max Number of K-Sum Pairs"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>In one operation, you can pick two numbers from the array whose sum equals <code class="language-plaintext highlighter-rouge">k</code> and remove them from the array.</li> <li>Return <em>the maximum number of operations you can perform on the array</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [112,131,411]

Output: -1

Explanation:

Each numbers largest digit in order is [2,3,4].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2536,1613,3366,162]

Output: 5902

Explanation:

All the numbers have 6 as their largest digit, so the answer is 2536 + 3366 = 5902.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [51,71,17,24,42]

Output: 88

Explanation:

Each number's largest digit in order is [5,7,7,4,4].

So we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxNumberOfKSumPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This HashMap will store the count of each number that has not yet been paired.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable counts the number of valid pairs found.</span>

        <span class="c1">// Iterate through each number in the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">num</span><span class="o">;</span> <span class="c1">// The number we need to pair with 'num' to sum to k.</span>

            <span class="c1">// Check if there is an available 'target' number that has not been paired yet.</span>
            <span class="c1">// countMap.getOrDefault(target, 0) &gt; 0 means there is at least one 'target' left to pair.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">result</span><span class="o">++;</span> <span class="c1">// We found a valid pair (num + target == k), so increment the result.</span>

                <span class="c1">// Since we've used one 'target' for pairing, decrease its count by 1.</span>
                <span class="c1">// This ensures each number is used at most once.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If there is no available 'target' to pair with 'num',</span>
                <span class="c1">// record 'num' in the map for possible pairing with future numbers.</span>
                <span class="c1">// Increase the count of 'num' by 1.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After processing all numbers, 'result' contains the maximum number of valid pairs.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">6</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span> <span class="c1">// Output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array.]]></summary></entry></feed>