<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-23T06:53:40+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">791. Custom Sort String</title><link href="https://zhengstar94.github.io//blog/2024/CustomSortString/" rel="alternate" type="text/html" title="791. Custom Sort String"/><published>2024-11-23T00:00:00+00:00</published><updated>2024-11-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CustomSortString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CustomSortString/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">order</code> and <code class="language-plaintext highlighter-rouge">s</code>. All the characters of <code class="language-plaintext highlighter-rouge">order</code> are <strong>unique</strong> and were sorted in some custom order previously.</li> <li>Permute the characters of <code class="language-plaintext highlighter-rouge">s</code> so that they match the order that <code class="language-plaintext highlighter-rouge">order</code> was sorted. More specifically, if a character <code class="language-plaintext highlighter-rouge">x</code> occurs before a character <code class="language-plaintext highlighter-rouge">y</code> in <code class="language-plaintext highlighter-rouge">order</code>, then <code class="language-plaintext highlighter-rouge">x</code> should occur before <code class="language-plaintext highlighter-rouge">y</code> in the permuted string.</li> <li>Return <em>any permutation of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that satisfies this property</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: order = "cba", s = "abcd"

Output: "cbad"

Explanation: "a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a".

Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: order = "bcafg", s = "abcd"

Output: "bcad"

Explanation: The characters "b", "c", and "a" from order dictate  the order for the characters in s. The character "d" in s does not appear in order, so its position is flexible.

Following the order of appearance in order, "b", "c", and "a" from s should be arranged as "b", "c", "a". "d" can be placed at any position since it's not in order. The output "bcad" correctly follows this rule. Other arrangements like "dbca" or "bcda" would also be valid, as long as "b", "c", "a" maintain their order.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomSortString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">customSortString</span><span class="o">(</span><span class="nc">String</span> <span class="n">order</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a frequency array to store count of each character in s</span>
        <span class="c1">// Index 0 represents 'a', 1 represents 'b', and so on</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Count frequency of each character in string s</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// StringBuilder to construct the result efficiently</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// First, append characters according to the order string</span>
        <span class="c1">// For each character in order, append it to result as many times as it appears in s</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">order</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="c1">// Decrement count after appending each character</span>
                <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Finally, append any remaining characters that weren't in order</span>
        <span class="c1">// This ensures all characters from s are included in the result</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span> <span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic test</span>
        <span class="nc">String</span> <span class="n">order1</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order1</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order1</span><span class="o">,</span> <span class="n">s1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Order string longer than s</span>
        <span class="nc">String</span> <span class="n">order2</span> <span class="o">=</span> <span class="s">"bcafg"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order2</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order2</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: String s contains duplicate characters</span>
        <span class="nc">String</span> <span class="n">order3</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aabcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (contains duplicate characters):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order3</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order3</span><span class="o">,</span> <span class="n">s3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Order contains characters not in s</span>
        <span class="nc">String</span> <span class="n">order4</span> <span class="o">=</span> <span class="s">"cbafg"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 (order contains characters not in s):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order4</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order4</span><span class="o">,</span> <span class="n">s4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: String s contains characters not in order</span>
        <span class="nc">String</span> <span class="n">order5</span> <span class="o">=</span> <span class="s">"cb"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 (s contains characters not in order):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order5</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order5</span><span class="o">,</span> <span class="n">s5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously. Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string. Return any permutation of s that satisfies this property.]]></summary></entry><entry><title type="html">525. Contiguous Array</title><link href="https://zhengstar94.github.io//blog/2024/ContiguousArray/" rel="alternate" type="text/html" title="525. Contiguous Array"/><published>2024-11-22T00:00:00+00:00</published><updated>2024-11-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ContiguousArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ContiguousArray/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the maximum length of a contiguous subarray with an equal number of</em> <code class="language-plaintext highlighter-rouge">0</code> <em>and</em> <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContiguousArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Map to store the first occurrence of each count</span>
        <span class="c1">// Key: running sum (count), Value: index where this count first appeared</span>
        <span class="c1">// Initialize with 0 at index -1 to handle cases where valid subarray starts from index 0</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// maxLen: tracks the length of the longest valid subarray found so far</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// count: running sum (treating 0 as -1 and 1 as 1)</span>
        <span class="c1">// When count remains unchanged between two positions, the subarray between them has equal 0s and 1s</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update running sum: add 1 for 1s, subtract 1 for 0s</span>
            <span class="c1">// This helps track the balance between 0s and 1s</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

            <span class="c1">// If we've seen this count before, we've found a valid subarray</span>
            <span class="c1">// Example: if count becomes 0 again, it means we have equal 0s and 1s from the start</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">count</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Calculate length of current valid subarray (current position - previous position with same count)</span>
                <span class="c1">// Update maxLen if current valid subarray is longer</span>
                <span class="c1">// Example: if count = 1 appears at index 2 and 5, then indexes 3,4,5 form a valid subarray</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">count</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If this is the first time we see this count, record its position</span>
                <span class="c1">// We only store the first occurrence to find the longest possible subarray</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic case with alternating values</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 2: Minimal case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 3: Grouped zeros and ones</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.]]></summary></entry><entry><title type="html">278. First Bad Version</title><link href="https://zhengstar94.github.io//blog/2024/FirstBadVersion/" rel="alternate" type="text/html" title="278. First Bad Version"/><published>2024-11-21T00:00:00+00:00</published><updated>2024-11-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/FirstBadVersion</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/FirstBadVersion/"><![CDATA[<ul> <li>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</li> <li>Suppose you have <code class="language-plaintext highlighter-rouge">n</code> versions <code class="language-plaintext highlighter-rouge">[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</li> <li>You are given an API <code class="language-plaintext highlighter-rouge">bool isBadVersion(version)</code> which returns whether <code class="language-plaintext highlighter-rouge">version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -&gt; false
call isBadVersion(5) -&gt; true
call isBadVersion(4) -&gt; true
Then 4 is the first bad version.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1, bad = 1
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(logn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstBadVersion</span> <span class="kd">extends</span> <span class="nc">VersionControl</span><span class="o">{</span>
    <span class="c1">// Reference to the VersionControl instance</span>
    <span class="nc">VersionControl</span> <span class="n">versionControl</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstBadVersion</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Use binary search to find the first bad version</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate mid point to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If mid is a bad version, search in the left half</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">versionControl</span><span class="o">.</span><span class="na">isBadVersion</span><span class="o">(</span><span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If mid is a good version, search in the right half</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the first bad version</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">VersionControl</span> <span class="o">{</span>
    <span class="c1">// The first bad version number</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">firstBadVersion</span><span class="o">;</span>

    <span class="c1">// Constructor with specified first bad version</span>
    <span class="kd">public</span> <span class="nf">VersionControl</span><span class="o">(</span><span class="kt">int</span> <span class="n">firstBadVersion</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">firstBadVersion</span> <span class="o">=</span> <span class="n">firstBadVersion</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Default constructor with first bad version set to 4</span>
    <span class="kd">public</span> <span class="nf">VersionControl</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">firstBadVersion</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// API method to check if a version is bad</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBadVersion</span><span class="o">(</span><span class="kt">int</span> <span class="n">version</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Return true if version is greater than or equal to first bad version</span>
        <span class="k">return</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="n">firstBadVersion</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test method to validate the solution</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Bad version is 4</span>
        <span class="nc">VersionControl</span> <span class="n">vc1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VersionControl</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="nc">FirstBadVersion</span> <span class="nc">FirstBadVersion1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FirstBadVersion</span><span class="o">();</span>
        <span class="nc">FirstBadVersion1</span><span class="o">.</span><span class="na">versionControl</span> <span class="o">=</span> <span class="n">vc1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 (Bad Version 4): "</span> <span class="o">+</span> <span class="nc">FirstBadVersion1</span><span class="o">.</span><span class="na">firstBadVersion</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2: Bad version is 1</span>
        <span class="nc">VersionControl</span> <span class="n">vc2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VersionControl</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">FirstBadVersion</span> <span class="nc">FirstBadVersion2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FirstBadVersion</span><span class="o">();</span>
        <span class="nc">FirstBadVersion2</span><span class="o">.</span><span class="na">versionControl</span> <span class="o">=</span> <span class="n">vc2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 (Bad Version 1): "</span> <span class="o">+</span> <span class="nc">FirstBadVersion2</span><span class="o">.</span><span class="na">firstBadVersion</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 3: Bad version is 2</span>
        <span class="nc">VersionControl</span> <span class="n">vc3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VersionControl</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">FirstBadVersion</span> <span class="nc">FirstBadVersion3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FirstBadVersion</span><span class="o">();</span>
        <span class="nc">FirstBadVersion3</span><span class="o">.</span><span class="na">versionControl</span> <span class="o">=</span> <span class="n">vc3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Bad Version 2): "</span> <span class="o">+</span> <span class="nc">FirstBadVersion3</span><span class="o">.</span><span class="na">firstBadVersion</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch"/><summary type="html"><![CDATA[You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.]]></summary></entry><entry><title type="html">219. Contains Duplicate II</title><link href="https://zhengstar94.github.io//blog/2024/ContainsDuplicateII/" rel="alternate" type="text/html" title="219. Contains Duplicate II"/><published>2024-11-20T00:00:00+00:00</published><updated>2024-11-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ContainsDuplicateII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ContainsDuplicateII/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if there are two <strong>distinct indices</strong></em> <code class="language-plaintext highlighter-rouge">i</code> <em>and</em> <code class="language-plaintext highlighter-rouge">j</code> <em>in the array such that</em> <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code> <em>and</em> <code class="language-plaintext highlighter-rouge">abs(i - j) &lt;= k</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1], k = 3
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,0,1,1], k = 1
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContainsDuplicateII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to store the value and its last occurrence index.</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if the current number already exists in the map.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="c1">// Retrieve the index of the previous occurrence of nums[i].</span>
                <span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

                <span class="c1">// If the difference between the current and previous indices is &lt;= k, return true.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">prevIndex</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Update the map with the current index of nums[i].</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// If no such pair is found, return false.</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Duplicate "1" within distance 3 -&gt; Expected: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span> <span class="o">},</span> <span class="mi">3</span> <span class="o">));</span> <span class="c1">// true</span>

        <span class="c1">// Test case 2: Duplicate "1" within distance 1 -&gt; Expected: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="o">},</span> <span class="mi">1</span> <span class="o">));</span> <span class="c1">// true</span>

        <span class="c1">// Test case 3: No duplicates within the required distance -&gt; Expected: false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">},</span> <span class="mi">2</span> <span class="o">));</span> <span class="c1">// false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.]]></summary></entry><entry><title type="html">14. Longest Common Prefix</title><link href="https://zhengstar94.github.io//blog/2024/LongestCommonPrefix/" rel="alternate" type="text/html" title="14. Longest Common Prefix"/><published>2024-11-19T00:00:00+00:00</published><updated>2024-11-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestCommonPrefix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestCommonPrefix/"><![CDATA[<ul> <li>Write a function to find the longest common prefix string amongst an array of strings.</li> <li>If there is no common prefix, return an empty string <code class="language-plaintext highlighter-rouge">""</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: strs = [ "flower","flow","flight" ]
Output: "fl"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: strs = [ "dog","racecar","car" ]
Output: ""
Explanation: There is no common prefix among the input strings.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(S) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestCommonPrefix</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: return empty string if array is null or empty</span>
        <span class="k">if</span><span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If array contains only one string, return that string as the prefix</span>
        <span class="k">if</span><span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Initialize prefix with the first string</span>
        <span class="nc">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the remaining strings in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="cm">/**
             * The indexOf(prefix) method returns the position where the prefix starts in the string
             * If prefix is found at the beginning of the string, indexOf returns 0
             * If prefix is not found at the beginning:
             * - Either prefix is not in the string at all (returns -1)
             * - Or prefix is found but not at the start (returns &gt; 0)
             * In both cases, we need to shorten the prefix
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">indexOf</span><span class="o">(</span><span class="n">prefix</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/**
                 * Shorten the prefix by removing its last character:
                 * - substring(0, prefix.length() - 1) creates a new string
                 * - Starting from index 0 (inclusive)
                 * - Ending at prefix.length() - 1 (exclusive)
                 * Example:
                 * If prefix = "flower", new prefix will be "flowe"
                 * This process continues until either:
                 * 1. The shortened prefix is found at the start of current string
                 * 2. Or prefix becomes empty string
                 */</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

                <span class="c1">// If prefix becomes empty, there is no common prefix</span>
                <span class="k">if</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the final common prefix found</span>
        <span class="k">return</span> <span class="n">prefix</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: strings with common prefix "fl"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"flower"</span><span class="o">,</span> <span class="s">"flow"</span><span class="o">,</span> <span class="s">"flight"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>  <span class="c1">// Expected output: "fl"</span>

        <span class="c1">// Test case 2: strings with no common prefix</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"racecar"</span><span class="o">,</span> <span class="s">"car"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>  <span class="c1">// Expected output: ""</span>

        <span class="c1">// Test case 3: empty array</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>  <span class="c1">// Expected output: ""</span>

        <span class="c1">// Test case 4: array with single string</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"single"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>  <span class="c1">// Expected output: "single"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><summary type="html"><![CDATA[Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".]]></summary></entry><entry><title type="html">1768. Merge Strings Alternately</title><link href="https://zhengstar94.github.io//blog/2024/MergeStringsAlternately/" rel="alternate" type="text/html" title="1768. Merge Strings Alternately"/><published>2024-11-18T00:00:00+00:00</published><updated>2024-11-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MergeStringsAlternately</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MergeStringsAlternately/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">word1</code> and <code class="language-plaintext highlighter-rouge">word2</code>. Merge the strings by adding letters in alternating order, starting with <code class="language-plaintext highlighter-rouge">word1</code>. If a string is longer than the other, append the additional letters onto the end of the merged string.</li> <li>Return <em>the merged string.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "abc", word2 = "pqr"
Output: "apbqcr"
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "ab", word2 = "pqrs"
Output: "apbqrs"
Explanation: Notice that as word2 is longer, "rs" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "abcd", word2 = "pq"
Output: "apbqcd"
Explanation: Notice that as word1 is longer, "cd" is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m + n) time | O(m + n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeStringsAlternately</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">mergeAlternately</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// StringBuilder is used for efficient string concatenation</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="c1">// Two pointers to track current position in each string</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// pointer for word1</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// pointer for word2</span>

        <span class="c1">// Process both strings until we reach the end of either string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="c1">// Append current character from word1 and increment pointer</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">++));</span>
            <span class="c1">// Append current character from word2 and increment pointer</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">++));</span>
        <span class="o">}</span>

        <span class="c1">// Append remaining characters from word1 (if any)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">++));</span>
        <span class="o">}</span>

        <span class="c1">// Append remaining characters from word2 (if any)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">++));</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Equal length strings</span>
        <span class="nc">String</span> <span class="n">word1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"pqr"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 - Equal length strings:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: apbqcr"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Second string is longer</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"pqrs"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 - Second string is longer:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: apbqrs"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: First string is longer</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"pq"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 - First string is longer:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: apbqcd"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Empty string case</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"pqr"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">mergeAlternately</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 - First string is empty:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: word1 = "</span> <span class="o">+</span> <span class="n">word1</span> <span class="o">+</span> <span class="s">", word2 = "</span> <span class="o">+</span> <span class="n">word2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: pqr"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string.]]></summary></entry><entry><title type="html">986. Interval List Intersections</title><link href="https://zhengstar94.github.io//blog/2024/IntervalListIntersections/" rel="alternate" type="text/html" title="986. Interval List Intersections"/><published>2024-11-17T00:00:00+00:00</published><updated>2024-11-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/IntervalListIntersections</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/IntervalListIntersections/"><![CDATA[<ul> <li>You are given two lists of closed intervals, <code class="language-plaintext highlighter-rouge">firstList</code> and <code class="language-plaintext highlighter-rouge">secondList</code>, where <code class="language-plaintext highlighter-rouge">firstList[i] = [starti, endi]</code> and <code class="language-plaintext highlighter-rouge">secondList[j] = [startj, endj]</code>. Each list of intervals is pairwise <strong>disjoint</strong> and in <strong>sorted order</strong>.</li> <li>Return <em>the intersection of these two interval lists</em>.</li> <li>A <strong>closed interval</strong> <code class="language-plaintext highlighter-rouge">[a, b]</code> (with <code class="language-plaintext highlighter-rouge">a &lt;= b</code>) denotes the set of real numbers <code class="language-plaintext highlighter-rouge">x</code> with <code class="language-plaintext highlighter-rouge">a &lt;= x &lt;= b</code>.</li> <li>The <strong>intersection</strong> of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of <code class="language-plaintext highlighter-rouge">[1, 3]</code> and <code class="language-plaintext highlighter-rouge">[2, 4]</code> is <code class="language-plaintext highlighter-rouge">[2, 3]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: firstList = [ [0,2],[5,10],[13,23],[24,25] ], secondList = [ [1,5],[8,12],[15,24],[25,26] ]
Output: [ [1,2],[5,5],[8,10],[15,23],[24,24],[25,25] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: firstList = [ [1,3],[5,9] ], secondList = []
Output: []
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(n + m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntervalListIntersections</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">intervalIntersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ArrayList to store intersection intervals</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Two pointers to traverse both lists</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for firstList</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for secondList</span>

        <span class="c1">// Continue until we reach the end of either list</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">firstList</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">secondList</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Extract start and end points of current intervals</span>
            <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">firstList</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>   <span class="c1">// start of interval from first list</span>
            <span class="kt">int</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">firstList</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>     <span class="c1">// end of interval from first list</span>

            <span class="kt">int</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">secondList</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>   <span class="c1">// start of interval from second list</span>
            <span class="kt">int</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">secondList</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>     <span class="c1">// end of interval from second list</span>

            <span class="c1">// Find the intersection points</span>
            <span class="c1">// Intersection start is the maximum of both starts</span>
            <span class="kt">int</span> <span class="n">intersectStart</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">start1</span><span class="o">,</span> <span class="n">start2</span><span class="o">);</span>
            <span class="c1">// Intersection end is the minimum of both ends</span>
            <span class="kt">int</span> <span class="n">intersectEnd</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">end1</span><span class="o">,</span> <span class="n">end2</span><span class="o">);</span>

            <span class="c1">// If we have a valid intersection (start &lt;= end)</span>
            <span class="c1">// add it to our result list</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intersectStart</span> <span class="o">&lt;=</span> <span class="n">intersectEnd</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">intersectStart</span><span class="o">,</span> <span class="n">intersectEnd</span><span class="o">});</span>
            <span class="o">}</span>

            <span class="c1">// Move the pointer of the interval that ends first</span>
            <span class="c1">// This is crucial for not missing any potential intersections</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">end1</span> <span class="o">&lt;</span> <span class="n">end2</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>  <span class="c1">// first interval ends earlier, move to next interval in first list</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>  <span class="c1">// second interval ends earlier or at same time, move to next interval in second list</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert ArrayList to array and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple intersections</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">13</span><span class="o">,</span><span class="mi">23</span><span class="o">},</span> <span class="o">{</span><span class="mi">24</span><span class="o">,</span><span class="mi">25</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span><span class="mi">24</span><span class="o">},</span> <span class="o">{</span><span class="mi">25</span><span class="o">,</span><span class="mi">26</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList1</span><span class="o">,</span> <span class="n">secondList1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Empty list scenario</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">9</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList2</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList2</span><span class="o">,</span> <span class="n">secondList2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Complete overlap scenario</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Complete Overlap):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList3</span><span class="o">,</span> <span class="n">secondList3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].]]></summary></entry><entry><title type="html">1868. Product of Two Run-Length Encoded Arrays</title><link href="https://zhengstar94.github.io//blog/2024/ProductOfTwoRunLengthEncodedArrays/" rel="alternate" type="text/html" title="1868. Product of Two Run-Length Encoded Arrays"/><published>2024-11-17T00:00:00+00:00</published><updated>2024-11-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ProductOfTwoRunLengthEncodedArrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ProductOfTwoRunLengthEncodedArrays/"><![CDATA[<ul> <li><strong>Run-length encoding</strong> is a compression algorithm that allows for an integer array <code class="language-plaintext highlighter-rouge">nums</code> with many segments of <strong>consecutive repeated</strong> numbers to be represented by a (generally smaller) 2D array <code class="language-plaintext highlighter-rouge">encoded</code>. Each <code class="language-plaintext highlighter-rouge">encoded[i] = [vali, freqi]</code> describes the <code class="language-plaintext highlighter-rouge">ith</code> segment of repeated numbers in <code class="language-plaintext highlighter-rouge">nums</code> where <code class="language-plaintext highlighter-rouge">vali</code> is the value that is repeated <code class="language-plaintext highlighter-rouge">freqi</code> times. <ul> <li>For example, <code class="language-plaintext highlighter-rouge">nums = [1,1,1,2,2,2,2,2]</code> is represented by the <strong>run-length encoded</strong> array <code class="language-plaintext highlighter-rouge">encoded = [ [1,3],[2,5] ]</code>. Another way to read this is “three <code class="language-plaintext highlighter-rouge">1</code>’s followed by five <code class="language-plaintext highlighter-rouge">2</code>’s”.</li> </ul> </li> <li>The <strong>product</strong> of two run-length encoded arrays <code class="language-plaintext highlighter-rouge">encoded1</code> and <code class="language-plaintext highlighter-rouge">encoded2</code> can be calculated using the following steps: <ol> <li><strong>Expand</strong> both <code class="language-plaintext highlighter-rouge">encoded1</code> and <code class="language-plaintext highlighter-rouge">encoded2</code> into the full arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> respectively.</li> <li>Create a new array <code class="language-plaintext highlighter-rouge">prodNums</code> of length <code class="language-plaintext highlighter-rouge">nums1.length</code> and set <code class="language-plaintext highlighter-rouge">prodNums[i] = nums1[i] * nums2[i]</code>.</li> <li><strong>Compress</strong> <code class="language-plaintext highlighter-rouge">prodNums</code> into a run-length encoded array and return it.</li> </ol> </li> <li>You are given two <strong>run-length encoded</strong> arrays <code class="language-plaintext highlighter-rouge">encoded1</code> and <code class="language-plaintext highlighter-rouge">encoded2</code> representing full arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> respectively. Both <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> have the <strong>same length</strong>. Each <code class="language-plaintext highlighter-rouge">encoded1[i] = [vali, freqi]</code> describes the <code class="language-plaintext highlighter-rouge">ith</code> segment of <code class="language-plaintext highlighter-rouge">nums1</code>, and each <code class="language-plaintext highlighter-rouge">encoded2[j] = [valj, freqj]</code> describes the <code class="language-plaintext highlighter-rouge">jth</code> segment of <code class="language-plaintext highlighter-rouge">nums2</code>.</li> <li>Return <em>the <strong>product</strong> of</em> <code class="language-plaintext highlighter-rouge">encoded1</code> <em>and</em> <code class="language-plaintext highlighter-rouge">encoded2</code>.</li> <li><strong>Note:</strong> Compression should be done such that the run-length encoded array has the <strong>minimum</strong> possible length.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: encoded1 = [ [1,3],[2,3] ], encoded2 = [ [6,3],[3,3] ]
Output: [ [6,6] ]
Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3].
prodNums = [6,6,6,6,6,6], which is compressed into the run-length encoded array [ [6,6] ].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: encoded1 = [ [1,3],[2,1],[3,2] ], encoded2 = [ [2,3],[3,3] ]
Output: [ [2,3],[6,1],[9,2] ]
Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3].
prodNums = [2,2,2,6,9,9], which is compressed into the run-length encoded array [ [2,3],[6,1],[9,2] ].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductOfTwoRunLengthEncodedArrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">findRLEArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for traversing encoded1</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for traversing encoded2</span>
        <span class="kt">int</span> <span class="n">pos1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Remaining frequency count in current segment of encoded1</span>
        <span class="kt">int</span> <span class="n">pos2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Remaining frequency count in current segment of encoded2</span>

        <span class="c1">// Process both arrays until we reach the end of either array</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">encoded1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">encoded2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Get current values from both arrays</span>
            <span class="kt">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">encoded1</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// Current value from encoded1</span>
            <span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">encoded2</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// Current value from encoded2</span>

            <span class="c1">// If pos1 is 0, get new frequency from encoded1</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">pos1</span> <span class="o">=</span> <span class="n">encoded1</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// If pos2 is 0, get new frequency from encoded2</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">pos2</span> <span class="o">=</span> <span class="n">encoded2</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// Calculate the product of current values and the overlap length</span>
            <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">val1</span> <span class="o">*</span> <span class="n">val2</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">overlap</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">pos1</span><span class="o">,</span> <span class="n">pos2</span><span class="o">);</span>   <span class="c1">// Get minimum frequency between two current segments</span>

            <span class="c1">// Handle the result:</span>
            <span class="c1">// If result is empty OR current product is different from the last product in result</span>
            <span class="k">if</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">!=</span> <span class="n">product</span><span class="o">){</span>
                <span class="c1">// Add new entry with current product and overlap frequency</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">product</span><span class="o">,</span> <span class="n">overlap</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current product equals last product in result, merge frequencies</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update frequency by adding the overlap</span>
                <span class="c1">// last.get(1) gets current frequency, overlap adds new frequency</span>
                <span class="n">last</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">last</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">overlap</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Update remaining frequencies</span>
            <span class="n">pos1</span> <span class="o">-=</span> <span class="n">overlap</span><span class="o">;</span>
            <span class="n">pos2</span> <span class="o">-=</span> <span class="n">overlap</span><span class="o">;</span>

            <span class="c1">// Move pointer i if we've used up current segment in encoded1</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Move pointer j if we've used up current segment in encoded2</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with same length arrays</span>
        <span class="c1">// Expected result: [ [6,6] ] (as 1×6=6 three times, and 2×3=6 three times)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">findRLEArray</span><span class="o">(</span><span class="n">encoded1</span><span class="o">,</span> <span class="n">encoded2</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Different length arrays</span>
        <span class="c1">// Expected result: [ [2,3], [6,1], [9,2] ]</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded4</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">findRLEArray</span><span class="o">(</span><span class="n">encoded3</span><span class="o">,</span> <span class="n">encoded4</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Case with same products requiring merging</span>
        <span class="c1">// Expected result: [ [6,5], [4,1] ]</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded5</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded6</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded6</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">findRLEArray</span><span class="o">(</span><span class="n">encoded5</span><span class="o">,</span> <span class="n">encoded6</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Run-length encoding is a compression algorithm that allows for an integer array nums with many segments of consecutive repeated numbers to be represented by a (generally smaller) 2D array encoded. Each encoded[i] = [vali, freqi] describes the ith segment of repeated numbers in nums where vali is the value that is repeated freqi times. For example, nums=[1,1,1,2,2,2,2,2] is represented by the run-length encoded array encoded=[ [1,3],[2,5] ]. Another way to read this is “three 1’s followed by five 2’s”. The product of two run-length encoded arrays encoded1 and encoded2 can be calculated using the following steps: Expand both encoded1 and encoded2 into the full arrays nums1 and nums2 respectively. Create a new array prodNums of length nums1.length and set prodNums[i] = nums1[i] * nums2[i]. Compress prodNums into a run-length encoded array and return it. You are given two run-length encoded arrays encoded1 and encoded2 representing full arrays nums1 and nums2 respectively. Both nums1 and nums2 have the same length. Each encoded1[i] = [vali, freqi] describes the ith segment of nums1, and each encoded2[j] = [valj, freqj] describes the jth segment of nums2. Return the product of encoded1 and encoded2. Note: Compression should be done such that the run-length encoded array has the minimum possible length.]]></summary></entry><entry><title type="html">443. String Compression</title><link href="https://zhengstar94.github.io//blog/2024/StringCompression/" rel="alternate" type="text/html" title="443. String Compression"/><published>2024-11-16T00:00:00+00:00</published><updated>2024-11-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/StringCompression</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/StringCompression/"><![CDATA[<ul> <li>Given an array of characters <code class="language-plaintext highlighter-rouge">chars</code>, compress it using the following algorithm:</li> <li>Begin with an empty string <code class="language-plaintext highlighter-rouge">s</code>. For each group of <strong>consecutive repeating characters</strong> in <code class="language-plaintext highlighter-rouge">chars</code>: <ul> <li>If the group’s length is <code class="language-plaintext highlighter-rouge">1</code>, append the character to <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Otherwise, append the character followed by the group’s length.</li> </ul> </li> <li>The compressed string <code class="language-plaintext highlighter-rouge">s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code class="language-plaintext highlighter-rouge">chars</code></strong>. Note that group lengths that are <code class="language-plaintext highlighter-rouge">10</code> or longer will be split into multiple characters in <code class="language-plaintext highlighter-rouge">chars</code>.</li> <li>After you are done <strong>modifying the input array,</strong> return <em>the new length of the array</em>.</li> <li>You must write an algorithm that uses only constant extra space.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: chars = [ "a","a","b","b","c","c","c" ]
Output: Return 6, and the first 6 characters of the input array should be: [ "a","2","b","2","c","3" ]
Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: chars = [ "a" ]
Output: Return 1, and the first character of the input array should be: [ "a" ]
Explanation: The only group is "a", which remains uncompressed since it's a single character.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: chars = [ "a","b","b","b","b","b","b","b","b","b","b","b","b" ]
Output: Return 4, and the first 4 characters of the input array should be: [ "a","b","1","2" ].
Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringCompression</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">compress</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// writeIndex: points to the position where we should write next character</span>
        <span class="c1">// index: points to the current character being processed</span>
        <span class="kt">int</span> <span class="n">writeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Process each character in the array</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Store the current character for consecutive count</span>
            <span class="kt">char</span> <span class="n">currentChar</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// Count consecutive occurrences of the current character</span>
            <span class="c1">// Key Logic: Keep moving index forward as long as we see the same character</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">==</span> <span class="n">currentChar</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">index</span><span class="o">++;</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Write the character at writeIndex position and increment writeIndex</span>
            <span class="n">chars</span><span class="o">[</span><span class="n">writeIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">currentChar</span><span class="o">;</span>

            <span class="c1">// If count &gt; 1, we need to write the count after the character</span>
            <span class="c1">// Important: Handle multi-digit numbers correctly</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Convert count to string to handle multi-digit numbers</span>
                <span class="nc">String</span> <span class="n">countStr</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
                <span class="c1">// Write each digit of the count individually</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">countStr</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">chars</span><span class="o">[</span><span class="n">writeIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the length of the compressed array</span>
        <span class="k">return</span> <span class="n">writeIndex</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple characters with different frequencies</span>
        <span class="c1">// Expected output: "a2b2c3"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span> <span class="sc">'a'</span><span class="o">,</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'c'</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">compress</span><span class="o">(</span><span class="n">test1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Compressed length: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Single character</span>
        <span class="c1">// Expected output: "a"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span> <span class="sc">'a'</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">compress</span><span class="o">(</span><span class="n">test2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Compressed length: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Character with double-digit frequency</span>
        <span class="c1">// Expected output: "ab12"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span> <span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">compress</span><span class="o">(</span><span class="n">test3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Compressed length: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s. For each group of consecutive repeating characters in chars: If the group’s length is 1, append the character to s. Otherwise, append the character followed by the group’s length. The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars. After you are done modifying the input array, return the new length of the array. You must write an algorithm that uses only constant extra space.]]></summary></entry><entry><title type="html">26. Remove Duplicates from Sorted Array</title><link href="https://zhengstar94.github.io//blog/2024/RemoveDuplicatesFromSortedArray/" rel="alternate" type="text/html" title="26. Remove Duplicates from Sorted Array"/><published>2024-11-14T00:00:00+00:00</published><updated>2024-11-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RemoveDuplicatesFromSortedArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RemoveDuplicatesFromSortedArray/"><![CDATA[<ul> <li> <p>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>. Then return <em>the number of unique elements in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</p> </li> <li> <p>Consider the number of unique elements of <code class="language-plaintext highlighter-rouge">nums</code> to be <code class="language-plaintext highlighter-rouge">k</code>, to get accepted, you need to do the following things:</p> <ul> <li>Change the array <code class="language-plaintext highlighter-rouge">nums</code> such that the first <code class="language-plaintext highlighter-rouge">k</code> elements of <code class="language-plaintext highlighter-rouge">nums</code> contain the unique elements in the order they were present in <code class="language-plaintext highlighter-rouge">nums</code> initially. The remaining elements of <code class="language-plaintext highlighter-rouge">nums</code> are not important as well as the size of <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> </li> <li> <p><strong>Custom Judge:</strong></p> <p>The judge will test your solution with the following code:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length
  
int k = removeDuplicates(nums); // Calls your implementation
  
assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre></div> </div> <p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveDuplicatesFromSortedArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the array is null or has no elements, return 0 as there are no elements to process</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize a variable k to track the position of the next unique element; start from 1 as the first element is always unique</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Loop through the array starting from the second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current element is not equal to the previous one, it is unique</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Place the unique element at the position k, then increment k</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the count of unique elements, which is stored in k</span>
        <span class="k">return</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test array with sorted elements including duplicates</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>

        <span class="c1">// Call removeDuplicates to get the count of unique elements and modify the array in place</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unique count: "</span> <span class="o">+</span> <span class="n">k</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Modified array: "</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.]]></summary></entry></feed>