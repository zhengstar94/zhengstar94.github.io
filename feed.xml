<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-31T04:33:37+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2134. Minimum Swaps to Group All 1’s Together II</title><link href="https://zhengstar94.github.io//blog/2024/MinimumSwapsToGroupAll1sTogetherII/" rel="alternate" type="text/html" title="2134. Minimum Swaps to Group All 1’s Together II"/><published>2024-12-31T00:00:00+00:00</published><updated>2024-12-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MinimumSwapsToGroupAll1sTogetherII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MinimumSwapsToGroupAll1sTogetherII/"><![CDATA[<ul> <li>A <strong>swap</strong> is defined as taking two <strong>distinct</strong> positions in an array and swapping the values in them.</li> <li>A <strong>circular</strong> array is defined as an array where we consider the <strong>first</strong> element and the <strong>last</strong> element to be <strong>adjacent</strong>.</li> <li>Given a <strong>binary</strong> <strong>circular</strong> array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the minimum number of swaps required to group all</em> <code class="language-plaintext highlighter-rouge">1</code><em>’s present in the array together at <strong>any location</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0,1,1,0,0]
Output: 1
Explanation: Here are a few of the ways to group all the 1's together:
[0,0,1,1,1,0,0] using 1 swap.
[0,1,1,1,0,0,0] using 1 swap.
[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).
There is no way to group all 1's together with 0 swaps.
Thus, the minimum number of swaps required is 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,1,1,0,0,1,1,0]
Output: 2
Explanation: Here are a few of the ways to group all the 1's together:
[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).
[1,1,1,1,1,0,0,0,0] using 2 swaps.
There is no way to group all 1's together with 0 or 1 swaps.
Thus, the minimum number of swaps required is 2.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,0,1]
Output: 0
Explanation: All the 1's are already grouped together due to the circular property of the array.
Thus, the minimum number of swaps required is 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumSwapsToGroupAll1sTogetherII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minSwaps</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if array is null or length less than 2, no swaps needed</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 1: Count the number of 1's in the array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">onesCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">onesCount</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If there are 0 or 1 ones, no swaps needed</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">onesCount</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Create double-length array to handle circular nature</span>
        <span class="c1">// Example: [1,0,1] -&gt; [1,0,1,1,0,1]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">doubleNums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// Copy first half to second half</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Initialize the first window</span>
        <span class="c1">// Count zeros in the first window of size onesCount</span>
        <span class="kt">int</span> <span class="n">windowZeros</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Tracks number of zeros in current window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">onesCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">windowZeros</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Initialize minZeros with first window's zero count</span>
        <span class="kt">int</span> <span class="n">minZeros</span> <span class="o">=</span> <span class="n">windowZeros</span><span class="o">;</span>

        <span class="c1">// Step 4: Slide the window and find minimum zeros</span>
        <span class="c1">// Example: For array [1,0,1,0,1] with onesCount = 3</span>
        <span class="c1">// Windows: [1,0,1], [0,1,0], [1,0,1], [0,1,1], etc.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">onesCount</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">onesCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Remove leftmost element from window</span>
            <span class="c1">// If it's 0, decrease window's zero count</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">onesCount</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">windowZeros</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Add rightmost element to window</span>
            <span class="c1">// If it's 0, increase window's zero count</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">windowZeros</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="cm">/* Update minimum zeros if current window has fewer zeros
             * Why this represents minimum swaps:
             * 1. Each window of size onesCount represents a potential position for grouped 1's
             * 2. Number of zeros in window = number of swaps needed for that position
             * Example: Window [1,0,1] has 1 zero
             * - Need 1 swap to make it [1,1,1]
             * Window [0,1,0] has 2 zeros
             * - Need 2 swaps to make it [1,1,1]
             * Therefore, minimum zeros across all windows = minimum swaps needed
             */</span>
            <span class="n">minZeros</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minZeros</span><span class="o">,</span> <span class="n">windowZeros</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum number of zeros found in any window</span>
        <span class="c1">// This equals the minimum number of swaps needed</span>
        <span class="k">return</span> <span class="n">minZeros</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: [1,0,1,0,1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: All ones</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: [1,1,1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: All zeros</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: [0,0,0]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Multiple swaps needed</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: [1,0,1,0,1,0]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Edge case - empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test5</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: []"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[A swap is defined as taking two distinct positions in an array and swapping the values in them. A circular array is defined as an array where we consider the first element and the last element to be adjacent. Given a binary circular array nums, return the minimum number of swaps required to group all 1’s present in the array together at any location.]]></summary></entry><entry><title type="html">1367. Linked List in Binary Tree</title><link href="https://zhengstar94.github.io//blog/2024/LinkedListInBinaryTree/" rel="alternate" type="text/html" title="1367. Linked List in Binary Tree"/><published>2024-12-30T00:00:00+00:00</published><updated>2024-12-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LinkedListInBinaryTree</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LinkedListInBinaryTree/"><![CDATA[<ul> <li>Given a binary tree <code class="language-plaintext highlighter-rouge">root</code> and a linked list with <code class="language-plaintext highlighter-rouge">head</code> as the first node.</li> <li>Return True if all the elements in the linked list starting from the <code class="language-plaintext highlighter-rouge">head</code> correspond to some <em>downward path</em> connected in the binary tree otherwise return False.</li> <li>In this context downward path means a path that starts at some node and goes downwards.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: false
Explanation: There is no path in the binary tree that contains all the elements of the linked list from head.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(N × min(L, H)) time | O(H) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="cm">/**
* @author zhengxingxing
* @date 2024/12/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedListInBinaryTree</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSubPath</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Empty list is always a valid path</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Empty tree can't contain any path</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// First, try to match the entire linked list starting from current tree node</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">root</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * If current node doesn't lead to a match, try finding a match in left or right subtrees.
         * This is different from the DFS below because:
         * 1. It looks for a completely new starting point for the entire linked list
         * 2. It resets back to the head of the linked list for each new tree node
         * 3. It explores every possible starting point in the tree
         * Example: If we're looking for [4,2,8] and current node is 1, we check if either
         * the left or right subtree contains the entire sequence [4,2,8] starting from any node
         */</span>
        <span class="k">return</span> <span class="nf">isSubPath</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">||</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Matched entire linked list</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Reached end of tree path without full match</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Current nodes must match to continue</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Continue matching the rest of the linked list with either left or right child.
         * This is different from the isSubPath recursion above because:
         * 1. It continues an existing match (uses head.next instead of head)
         * 2. Only looks for the next value in the current path
         * 3. Doesn't try to restart the sequence from the beginning
         * Example: If we matched first node 4, we only look for the next value 2
         * in the immediate children of current node
         */</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">||</span> <span class="n">dfs</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test Case 1: Example from the problem statement</span>
        <span class="nc">TreeNode</span> <span class="n">root1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">head1</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Expected: true"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head1</span><span class="o">,</span> <span class="n">root1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Simple tree with matching path</span>
        <span class="nc">TreeNode</span> <span class="n">root2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root2</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root2</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">root2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">head2</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Expected: true"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head2</span><span class="o">,</span> <span class="n">root2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: No matching path</span>
        <span class="nc">TreeNode</span> <span class="n">root3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root3</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root3</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">head3</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Expected: false"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head3</span><span class="o">,</span> <span class="n">root3</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ListNode</span> <span class="nf">createLinkedList</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">values</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">ListNode</span><span class="o">()</span> <span class="o">{}</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="o">}</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><category term="Medium"/><summary type="html"><![CDATA[Given a binary tree root and a linked list with head as the first node. Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False. In this context downward path means a path that starts at some node and goes downwards.]]></summary></entry><entry><title type="html">1297. Maximum Number of Occurrences of a Substring</title><link href="https://zhengstar94.github.io//blog/2024/MaximumNumberOfOccurrencesOfASubstring/" rel="alternate" type="text/html" title="1297. Maximum Number of Occurrences of a Substring"/><published>2024-12-30T00:00:00+00:00</published><updated>2024-12-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumNumberOfOccurrencesOfASubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumNumberOfOccurrencesOfASubstring/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return the maximum number of occurrences of <strong>any</strong> substring under the following rules: <ul> <li>The number of unique characters in the substring must be less than or equal to <code class="language-plaintext highlighter-rouge">maxLetters</code>.</li> <li>The substring size must be between <code class="language-plaintext highlighter-rouge">minSize</code> and <code class="language-plaintext highlighter-rouge">maxSize</code> inclusive.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
Output: 2
Explanation: Substring "aab" has 2 occurrences in the original string.
It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
Output: 2
Explanation: Substring "aaa" occur 2 times in the string. It can overlap.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * minSize) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfOccurrencesOfASubstring</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxFreq</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxLetters</span><span class="o">,</span> <span class="kt">int</span> <span class="n">minSize</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the string is null or its length is less than the minimum size, return 0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">minSize</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// A map to store the frequency of each valid substring</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// An array to track the count of characters in the current sliding window</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">charCount</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

        <span class="c1">// The number of unique characters in the current window</span>
        <span class="kt">int</span> <span class="n">uniqueChars</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Step 1: Initialize the first window by processing the first (minSize-1) characters</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">minSize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Get the character at the current index</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="c1">// Increment the count for this character and check if it is a new unique character</span>
            <span class="k">if</span><span class="o">(</span><span class="n">charCount</span><span class="o">[</span><span class="n">c</span><span class="o">]++</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">uniqueChars</span><span class="o">++;</span>  <span class="c1">// If it's the first occurrence of this character, increment uniqueChars</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Start sliding the window across the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">minSize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="c1">// Add the current character to the sliding window</span>
            <span class="kt">char</span> <span class="n">addChar</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">charCount</span><span class="o">[</span><span class="n">addChar</span><span class="o">]++</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">uniqueChars</span><span class="o">++;</span>  <span class="c1">// If this character is new to the window, increment uniqueChars</span>
            <span class="o">}</span>

            <span class="c1">// If the number of unique characters in the window is within the allowed limit</span>
            <span class="k">if</span><span class="o">(</span><span class="n">uniqueChars</span> <span class="o">&lt;=</span> <span class="n">maxLetters</span><span class="o">){</span>
                <span class="c1">// Extract the current substring (from index i-minSize+1 to i+1) and add it to the map</span>
                <span class="nc">String</span> <span class="n">subStr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">minSize</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update the frequency of this substring in the map</span>
                <span class="n">count</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">subStr</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Step 3: Remove the character that is sliding out of the window from the left</span>
            <span class="kt">char</span> <span class="n">removeChar</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">minSize</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">// Decrement the count of the character and check if it’s now no longer in the window</span>
            <span class="k">if</span> <span class="o">(--</span><span class="n">charCount</span><span class="o">[</span><span class="n">removeChar</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">uniqueChars</span><span class="o">--;</span>  <span class="c1">// If the character's count reaches 0, decrement uniqueChars</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 4: Return the highest frequency of any valid substring, or 0 if no valid substrings were found</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example input string and parameters</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"aababcaab"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLetters</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// Maximum allowed distinct characters in each substring</span>
        <span class="kt">int</span> <span class="n">minSize</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>    <span class="c1">// Minimum length of substrings to consider</span>
        <span class="kt">int</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>    <span class="c1">// Maximum length of substrings (not used in this solution)</span>

        <span class="c1">// Print the input parameters</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input String: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"maxLetters: "</span> <span class="o">+</span> <span class="n">maxLetters</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"minSize: "</span> <span class="o">+</span> <span class="n">minSize</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"maxSize: "</span> <span class="o">+</span> <span class="n">maxSize</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nProcessing...\n"</span><span class="o">);</span>

        <span class="c1">// Call the method and print the result</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maxFreq</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">maxLetters</span><span class="o">,</span> <span class="n">minSize</span><span class="o">,</span> <span class="n">maxSize</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nFinal Result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, return the maximum number of occurrences of any substring under the following rules: The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive.]]></summary></entry><entry><title type="html">1652. Defuse the Bomb</title><link href="https://zhengstar94.github.io//blog/2024/DefuseTheBomb/" rel="alternate" type="text/html" title="1652. Defuse the Bomb"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DefuseTheBomb</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DefuseTheBomb/"><![CDATA[<ul> <li>You have a bomb to defuse, and your time is running out! Your informer will provide you with a <strong>circular</strong> array <code class="language-plaintext highlighter-rouge">code</code> of length of <code class="language-plaintext highlighter-rouge">n</code> and a key <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>To decrypt the code, you must replace every number. All the numbers are replaced <strong>simultaneously</strong>. <ul> <li>If <code class="language-plaintext highlighter-rouge">k &gt; 0</code>, replace the <code class="language-plaintext highlighter-rouge">ith</code> number with the sum of the <strong>next</strong> <code class="language-plaintext highlighter-rouge">k</code> numbers.</li> <li>If <code class="language-plaintext highlighter-rouge">k &lt; 0</code>, replace the <code class="language-plaintext highlighter-rouge">ith</code> number with the sum of the <strong>previous</strong> <code class="language-plaintext highlighter-rouge">k</code> numbers.</li> <li>If <code class="language-plaintext highlighter-rouge">k == 0</code>, replace the <code class="language-plaintext highlighter-rouge">ith</code> number with <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> </li> <li>As <code class="language-plaintext highlighter-rouge">code</code> is circular, the next element of <code class="language-plaintext highlighter-rouge">code[n-1]</code> is <code class="language-plaintext highlighter-rouge">code[0]</code>, and the previous element of <code class="language-plaintext highlighter-rouge">code[0]</code> is <code class="language-plaintext highlighter-rouge">code[n-1]</code>.</li> <li>Given the <strong>circular</strong> array <code class="language-plaintext highlighter-rouge">code</code> and an integer key <code class="language-plaintext highlighter-rouge">k</code>, return <em>the decrypted code to defuse the bomb</em>!</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: code = [5,7,1,4], k = 3
Output: [12,10,16,13]
Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: code = [1,2,3,4], k = 0
Output: [0,0,0,0]
Explanation: When k is zero, the numbers are replaced by 0. 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: code = [2,4,9,3], k = -2
Output: [12,5,6,13]
Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefuseTheBomb</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">code</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>  <span class="c1">// Store the result array</span>

        <span class="c1">// Initialize the right boundary 'r'</span>
        <span class="c1">// If k &gt; 0: r = k + 1 (points to the position after the first window)</span>
        <span class="c1">// If k &lt; 0: r = n (points to the end of array)</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Take absolute value of k to handle both positive and negative cases uniformly</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>

        <span class="c1">// Initialize sum for first position</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// First loop: Calculate sum for the initial window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For k &gt; 0: directly sum the next k numbers</span>
            <span class="c1">// For k &lt; 0: using modulo to wrap around and sum the previous k numbers</span>
            <span class="c1">// Example for k = 3: sums code[1] + code[2] + code[3]</span>
            <span class="c1">// Example for k = -3: sums code[3] + code[4] + code[5] (using i % n)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">code</span><span class="o">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Second loop: Slide the window to calculate sums for all positions</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Store current window sum in result array</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>

            <span class="c1">// Slide window by:</span>
            <span class="c1">// 1. Adding new element (code[r % n])</span>
            <span class="c1">// 2. Removing leftmost element (code[(r - k) % n])</span>
            <span class="c1">// Example: if current sum is [1,4,1], next sum will be [4,1,5]</span>
            <span class="c1">// by adding code[4]=5 and removing code[1]=1</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">code</span><span class="o">[</span><span class="n">r</span> <span class="o">%</span> <span class="n">n</span><span class="o">]</span> <span class="o">-</span> <span class="n">code</span><span class="o">[(</span><span class="n">r</span> <span class="o">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">%</span> <span class="n">n</span><span class="o">];</span>
            <span class="n">r</span><span class="o">++;</span>  <span class="c1">// Move window right by one position</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution with example cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: k &gt; 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">code1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">code1</span><span class="o">,</span> <span class="n">k1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 (k &gt; 0):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: code = [5,7,1,4], k = 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Output: ["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">result1</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">","</span> <span class="o">:</span> <span class="s">""</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>  <span class="c1">// Expected: [12,10,16,13]</span>

        <span class="c1">// Test Case 2: k = 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">code2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">code2</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2 (k = 0):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: code = [1,2,3,4], k = 0"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Output: ["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">result2</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">","</span> <span class="o">:</span> <span class="s">""</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>  <span class="c1">// Expected: [0,0,0,0]</span>

        <span class="c1">// Test Case 3: k &lt; 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">code3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">code3</span><span class="o">,</span> <span class="n">k3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3 (k &lt; 0):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: code = [2,4,9,3], k = -2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Output: ["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result3</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result3</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">result3</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">","</span> <span class="o">:</span> <span class="s">""</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>  <span class="c1">// Expected: [12,5,6,13]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k. To decrypt the code, you must replace every number. All the numbers are replaced simultaneously. If k &gt; 0, replace the ith number with the sum of the next k numbers. If k &lt; 0, replace the ith number with the sum of the previous k numbers. If k== 0, replace the ith number with 0. As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1]. Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!]]></summary></entry><entry><title type="html">1366. Rank Teams by Votes</title><link href="https://zhengstar94.github.io//blog/2024/RankTeamsByVotes/" rel="alternate" type="text/html" title="1366. Rank Teams by Votes"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RankTeamsByVotes</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RankTeamsByVotes/"><![CDATA[<ul> <li>In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition.</li> <li>The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.</li> <li>You are given an array of strings <code class="language-plaintext highlighter-rouge">votes</code> which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.</li> <li>Return <em>a string of all teams <strong>sorted</strong> by the ranking system</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: votes = ["ABC","ACB","ABC","ACB","ACB"]
Output: "ACB"
Explanation: 
Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team.
Team B was ranked second by 2 voters and ranked third by 3 voters.
Team C was ranked second by 3 voters and ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team, and team B is the third.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: votes = ["WXYZ","XYZW"]
Output: "XWYZ"
Explanation:
X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: votes = ["ZMNAGUEDSJYLBOPHRQICWFXTVK"]
Output: "ZMNAGUEDSJYLBOPHRQICWFXTVK"
Explanation: Only one voter, so their votes are used for the ranking.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(N * K + M * log M) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RankTeamsByVotes</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">rankTeams</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">votes</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: empty input or null</span>
        <span class="k">if</span><span class="o">(</span><span class="n">votes</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">votes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If there's only one vote, return it directly</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">votes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">votes</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Create a 2D array to store vote counts</span>
        <span class="c1">// First dimension [26]: represents teams (A-Z)</span>
        <span class="c1">// Second dimension [26]: represents positions (0 to 25)</span>
        <span class="c1">// count[team][position] stores how many votes a team got for that position</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">][</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Array to track which teams participated in voting</span>
        <span class="c1">// teams[i] will be true if team (A+i) received any votes</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">teams</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">teamCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/* First Important Section: Vote Counting Loop
         * Outer loop: Iterates through each vote (ballot)
         * Inner loop: Processes each position in the current vote
         *
         * For example, if vote is "ABC":
         * - First iteration (i=0): Increment count for A in position 0
         * - Second iteration (i=1): Increment count for B in position 1
         * - Third iteration (i=2): Increment count for C in position 2
         *
         * Also marks teams as participating when they first appear
         */</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">vote</span> <span class="o">:</span> <span class="n">votes</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vote</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">team</span> <span class="o">=</span> <span class="n">vote</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>  <span class="c1">// Convert character to 0-25 index</span>
                <span class="n">count</span><span class="o">[</span><span class="n">team</span><span class="o">][</span><span class="n">i</span><span class="o">]++;</span>                 <span class="c1">// Increment vote count for team at position i</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">teams</span><span class="o">[</span><span class="n">team</span><span class="o">])</span> <span class="o">{</span>               <span class="c1">// If this is first time seeing this team</span>
                    <span class="n">teams</span><span class="o">[</span><span class="n">team</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>           <span class="c1">// Mark team as participating</span>
                    <span class="n">teamCount</span><span class="o">++;</span>                  <span class="c1">// Increment total number of teams</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Create array to store participating teams as characters</span>
        <span class="nc">Character</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Character</span><span class="o">[</span><span class="n">teamCount</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">teams</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="sc">'A'</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/* Second Important Section: Custom Sorting Logic
         * This comparator implements the ranking rules:
         * 1. Primary Rule: Teams are ranked by votes at each position, starting from position 0
         * 2. Secondary Rule: If teams tie in all positions, sort alphabetically
         *
         * For example, comparing teams A and B:
         * - First checks votes in position 0
         * - If tied, checks position 1
         * - If tied, checks position 2
         * - If tied in all positions, compares team names (A vs B)
         *
         * The subtraction (count[teamB][i] - count[teamA][i]) ensures:
         * - Positive result: teamB ranks higher (has more votes)
         * - Negative result: teamA ranks higher
         * - Zero: tied at this position, continue checking
         */</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">teamA</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">teamB</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>

            <span class="c1">// Compare votes at each position</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">teamA</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">count</span><span class="o">[</span><span class="n">teamB</span><span class="o">][</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">count</span><span class="o">[</span><span class="n">teamB</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">count</span><span class="o">[</span><span class="n">teamA</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// Higher votes first</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// If all positions are tied, sort alphabetically</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="c1">// Convert result array to string</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Multiple votes with clear preference</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">votes1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"ABC"</span><span class="o">,</span><span class="s">"ACB"</span><span class="o">,</span><span class="s">"ABC"</span><span class="o">,</span><span class="s">"ACB"</span><span class="o">,</span><span class="s">"ACB"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">votes1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">rankTeams</span><span class="o">(</span><span class="n">votes1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: ACB"</span><span class="o">);</span>

        <span class="c1">// Test case 2: Minimal votes with different preferences</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">votes2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"WXYZ"</span><span class="o">,</span><span class="s">"XYZW"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">votes2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">rankTeams</span><span class="o">(</span><span class="n">votes2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: XWYZ"</span><span class="o">);</span>

        <span class="c1">// Test case 3: Single vote with all letters</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">votes3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"ZMNAGUEDSJYLBOPHRQICWFXTVK"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">votes3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">rankTeams</span><span class="o">(</span><span class="n">votes3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: ZMNAGUEDSJYLBOPHRQICWFXTVK"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition. The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter. You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above. Return a string of all teams sorted by the ranking system.]]></summary></entry><entry><title type="html">1423. Maximum Points You Can Obtain from Cards</title><link href="https://zhengstar94.github.io//blog/2024/MaximumPointsYouCanObtainFromCards/" rel="alternate" type="text/html" title="1423. Maximum Points You Can Obtain from Cards"/><published>2024-12-28T00:00:00+00:00</published><updated>2024-12-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumPointsYouCanObtainFromCards</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumPointsYouCanObtainFromCards/"><![CDATA[<ul> <li>There are several cards <strong>arranged in a row</strong>, and each card has an associated number of points. The points are given in the integer array <code class="language-plaintext highlighter-rouge">cardPoints</code>.</li> <li>In one step, you can take one card from the beginning or from the end of the row. You have to take exactly <code class="language-plaintext highlighter-rouge">k</code> cards.</li> <li>Your score is the sum of the points of the cards you have taken.</li> <li>Given the integer array <code class="language-plaintext highlighter-rouge">cardPoints</code> and the integer <code class="language-plaintext highlighter-rouge">k</code>, return the <em>maximum score</em> you can obtain.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumPointsYouCanObtainFromCards</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cardPoints</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Total number of cards.</span>

        <span class="c1">// Calculate the total points of all cards.</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">point</span> <span class="o">:</span> <span class="n">cardPoints</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">point</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If `k` equals the total number of cards, return the total sum of the array.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">total</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Determine the size of the window to exclude from the selection.</span>
        <span class="c1">// This window contains the cards that are *not* part of the chosen `k` cards.</span>
        <span class="kt">int</span> <span class="n">windowSize</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span>

        <span class="c1">// Calculate the initial sum of the first `windowSize` cards.</span>
        <span class="kt">int</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">windowSize</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Initialize the minimum window sum to the sum of the first `windowSize` cards.</span>
        <span class="kt">int</span> <span class="n">minWindowSum</span> <span class="o">=</span> <span class="n">windowSum</span><span class="o">;</span>

        <span class="c1">// Slide the window across the array, updating the window sum and tracking the minimum.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">windowSize</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add the next card in the window and remove the first card of the previous window.</span>
            <span class="n">windowSum</span> <span class="o">=</span> <span class="n">windowSum</span> <span class="o">+</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">windowSize</span><span class="o">];</span>

            <span class="c1">// Update the minimum window sum if the current window sum is smaller.</span>
            <span class="n">minWindowSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minWindowSum</span><span class="o">,</span> <span class="n">windowSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// The maximum score is the total sum minus the smallest sum of the excluded window.</span>
        <span class="k">return</span> <span class="n">total</span> <span class="o">-</span> <span class="n">minWindowSum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">cardPoints1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: 12</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">cardPoints2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">cardPoints3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected: 55</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain.]]></summary></entry><entry><title type="html">3046. Split the Array</title><link href="https://zhengstar94.github.io//blog/2024/SplitTheArray/" rel="alternate" type="text/html" title="3046. Split the Array"/><published>2024-12-28T00:00:00+00:00</published><updated>2024-12-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/SplitTheArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/SplitTheArray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of <strong>even</strong> length. You have to split the array into two parts <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> such that: <ul> <li><code class="language-plaintext highlighter-rouge">nums1.length == nums2.length == nums.length / 2</code>.</li> <li><code class="language-plaintext highlighter-rouge">nums1</code> should contain <strong>distinct</strong> elements.</li> <li><code class="language-plaintext highlighter-rouge">nums2</code> should also contain <strong>distinct</strong> elements.</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to split the array, and</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise**.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2,2,3,4]
Output: true
Explanation: One of the possible ways to split nums is nums1 = [1,2,3] and nums2 = [1,2,4].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1]
Output: false
Explanation: The only possible way to split nums is nums1 = [1,1] and nums2 = [1,1]. Both nums1 and nums2 do not contain distinct elements. Therefore, we return false.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SplitTheArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPossibleToSplit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create counting array for numbers 1-100 (given constraint)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">101</span><span class="o">];</span>

        <span class="c1">// Count frequency of each number and check if any number appears more than twice</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">num</span><span class="o">]++;</span>
            <span class="c1">// If any number appears more than twice, it's impossible to split</span>
            <span class="c1">// because each part can contain at most one occurrence of each number</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">num</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we reach here, no number appears more than twice</span>
        <span class="c1">// so we can split the array (one occurrence per part if needed)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Valid split possible</span>
        <span class="c1">// Can be split into [1,2,3] and [1,2,4]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: true"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">isPossibleToSplit</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Invalid case - number appears more than twice</span>
        <span class="c1">// Cannot be split as '1' appears four times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: false"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">isPossibleToSplit</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Edge case - all distinct elements</span>
        <span class="c1">// Can be split into [1,2] and [3,4]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: true"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">isPossibleToSplit</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums of even length. You have to split the array into two parts nums1 and nums2 such that: nums1.length == nums2.length == nums.length / 2. nums1 should contain distinct elements. nums2 should also contain distinct elements. Return true if it is possible to split the array, and false otherwise**.]]></summary></entry><entry><title type="html">1014. Best Sightseeing Pair</title><link href="https://zhengstar94.github.io//blog/2024/BestSightseeingPair/" rel="alternate" type="text/html" title="1014. Best Sightseeing Pair"/><published>2024-12-27T00:00:00+00:00</published><updated>2024-12-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/BestSightseeingPair</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/BestSightseeingPair/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">values</code> where values[i] represents the value of the <code class="language-plaintext highlighter-rouge">ith</code> sightseeing spot. Two sightseeing spots <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> have a <strong>distance</strong> <code class="language-plaintext highlighter-rouge">j - i</code> between them.</li> <li>The score of a pair (<code class="language-plaintext highlighter-rouge">i &lt; j</code>) of sightseeing spots is <code class="language-plaintext highlighter-rouge">values[i] + values[j] + i - j</code>: the sum of the values of the sightseeing spots, minus the distance between them.</li> <li>Return <em>the maximum score of a pair of sightseeing spots</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: values = [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: values = [1,2]
Output: 2
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BestSightseeingPair</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxScoreSightseeingPair</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Keep track of maximum values[i] + i encountered so far</span>
        <span class="kt">int</span> <span class="n">maxPrev</span> <span class="o">=</span> <span class="n">values</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the maximum score found</span>
        <span class="kt">int</span> <span class="n">maxScore</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through array starting from second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update maximum score using current position and previous maximum</span>
            <span class="n">maxScore</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxScore</span><span class="o">,</span> <span class="n">maxPrev</span> <span class="o">+</span> <span class="n">values</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">j</span><span class="o">);</span>
            <span class="c1">// Update the maximum values[i] + i for next iterations</span>
            <span class="n">maxPrev</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxPrev</span><span class="o">,</span> <span class="n">values</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">j</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxScore</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output is 11 (i=0, j=2)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 expected: 11"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 actual: "</span> <span class="o">+</span> <span class="n">maxScoreSightseeingPair</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Expected output is 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 expected: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 actual: "</span> <span class="o">+</span> <span class="n">maxScoreSightseeingPair</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Additional test case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">maxScoreSightseeingPair</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them. The score of a pair (i &lt; j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots.]]></summary></entry><entry><title type="html">3159. Find Occurrences of an Element in an Array</title><link href="https://zhengstar94.github.io//blog/2024/FindOccurrencesOfAnElementInAnArray/" rel="alternate" type="text/html" title="3159. Find Occurrences of an Element in an Array"/><published>2024-12-27T00:00:00+00:00</published><updated>2024-12-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/FindOccurrencesOfAnElementInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/FindOccurrencesOfAnElementInAnArray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, an integer array <code class="language-plaintext highlighter-rouge">queries</code>, and an integer <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>For each <code class="language-plaintext highlighter-rouge">queries[i]</code>, you need to find the index of the <code class="language-plaintext highlighter-rouge">queries[i]th</code> occurrence of <code class="language-plaintext highlighter-rouge">x</code> in the <code class="language-plaintext highlighter-rouge">nums</code> array. If there are fewer than <code class="language-plaintext highlighter-rouge">queries[i]</code> occurrences of <code class="language-plaintext highlighter-rouge">x</code>, the answer should be -1 for that query.</li> <li>Return an integer array <code class="language-plaintext highlighter-rouge">answer</code> containing the answers to all queries.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1

Output: [0,-1,2,-1]

Explanation:

For the 1st query, the first occurrence of 1 is at index 0.
For the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.
For the 3rd query, the second occurrence of 1 is at index 2.
For the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3], queries = [10], x = 5

Output: [-1]

Explanation:

For the 1st query, 5 doesn't exist in nums, so the answer is -1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(q+n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindOccurrencesOfAnElementInAnArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findIndices</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">queries</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Store all positions where x appears in nums array</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">positions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// First pass: record all positions where x appears</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">positions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Create array to store answers for each query</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">queries</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="c1">// Process each query</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queries</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Convert from 1-based counting (human-readable) to 0-based indexing (computer-readable)</span>
            <span class="c1">// Example:</span>
            <span class="c1">// If queries[i] = 1, we want first occurrence, so we need positions.get(0)</span>
            <span class="c1">// If queries[i] = 2, we want second occurrence, so we need positions.get(1)</span>
            <span class="c1">// Therefore, we subtract 1 to convert query number to array index</span>
            <span class="kt">int</span> <span class="n">occurrence</span> <span class="o">=</span> <span class="n">queries</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Check if we have enough occurrences in our positions list</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">occurrence</span> <span class="o">&gt;=</span> <span class="n">positions</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// Not enough occurrences found</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">occurrence</span><span class="o">);</span>  <span class="c1">// Return the index of the requested occurrence</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queries1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">findIndices</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">queries1</span><span class="o">,</span> <span class="n">x1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nOutput: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>  <span class="c1">// Expected: [0,-1,2,-1]</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queries2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Input: nums = [1,2,3], queries = [10], x = 5"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">findIndices</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">queries2</span><span class="o">,</span> <span class="n">x2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nOutput: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>  <span class="c1">// Expected: [-1]</span>

        <span class="c1">// Additional Test Case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queries3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Input: nums = [1,1,1,1], queries = [1,2,3,4,5], x = 1"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">findIndices</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">queries3</span><span class="o">,</span> <span class="n">x3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nOutput: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result3</span><span class="o">));</span>  <span class="c1">// Expected: [0,1,2,3,-1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums, an integer array queries, and an integer x. For each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query. Return an integer array answer containing the answers to all queries.]]></summary></entry><entry><title type="html">2461. Maximum Sum of Distinct Subarrays With Length K</title><link href="https://zhengstar94.github.io//blog/2024/MaximumSumOfDistinctSubarraysWithLengthK/" rel="alternate" type="text/html" title="2461. Maximum Sum of Distinct Subarrays With Length K"/><published>2024-12-27T00:00:00+00:00</published><updated>2024-12-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumSumOfDistinctSubarraysWithLengthK</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumSumOfDistinctSubarraysWithLengthK/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>. Find the maximum subarray sum of all the subarrays of <code class="language-plaintext highlighter-rouge">nums</code> that meet the following conditions: <ul> <li>The length of the subarray is <code class="language-plaintext highlighter-rouge">k</code>, and</li> <li>All the elements of the subarray are <strong>distinct</strong>.</li> </ul> </li> <li>Return <em>the maximum subarray sum of all the subarrays that meet the conditions**.</em> If no subarray meets the conditions, return <code class="language-plaintext highlighter-rouge">0</code>.</li> <li><em>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,5,4,2,9,9,9], k = 3
Output: 15
Explanation: The subarrays of nums with length 3 are:
- [1,5,4] which meets the requirements and has a sum of 10.
- [5,4,2] which meets the requirements and has a sum of 11.
- [4,2,9] which meets the requirements and has a sum of 15.
- [2,9,9] which does not meet the requirements because the element 9 is repeated.
- [9,9,9] which does not meet the requirements because the element 9 is repeated.
We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,4,4], k = 3
Output: 0
Explanation: The subarrays of nums with length 3 are:
- [4,4,4] which does not meet the requirements because the element 4 is repeated.
We return 0 because no subarrays meet the conditions.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumSumOfDistinctSubarraysWithLengthK</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumSubarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Map to store frequency of elements in current window</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Sum of elements in current window</span>
        <span class="kt">long</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Maximum sum found so far</span>
        <span class="kt">long</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to window and update its frequency in map</span>
            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span> <span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="c1">// Skip until we have a complete window of size k</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If number of distinct elements equals k, update maximum sum</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">windowSum</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Remove leftmost element from window</span>
            <span class="kt">int</span> <span class="n">out</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
            <span class="c1">// Decrease its frequency in map</span>
            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">out</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">// If frequency becomes 0, remove element from map to maintain correct distinct count</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">out</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">count</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Subtract the removed element from window sum</span>
            <span class="n">windowSum</span> <span class="o">-=</span> <span class="n">out</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Contains distinct and repeated elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Output: "</span> <span class="o">+</span> <span class="n">maximumSubarraySum</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected output: 15</span>

        <span class="c1">// Test Case 2: All elements are same</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Output: "</span> <span class="o">+</span> <span class="n">maximumSubarraySum</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 3: All elements are distinct</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Output: "</span> <span class="o">+</span> <span class="n">maximumSubarraySum</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected output: 12</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions: The length of the subarray is k, and All the elements of the subarray are distinct. Return the maximum subarray sum of all the subarrays that meet the conditions**. If no subarray meets the conditions, return 0. A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry></feed>