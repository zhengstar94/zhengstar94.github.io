<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-27T04:24:34+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2210. Count Hills and Valleys in an Array</title><link href="https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray/" rel="alternate" type="text/html" title="2210. Count Hills and Valleys in an Array"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountHillsAndValleysInAnArray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>. An index <code class="language-plaintext highlighter-rouge">i</code> is part of a <strong>hill</strong> in <code class="language-plaintext highlighter-rouge">nums</code> if the closest non-equal neighbors of <code class="language-plaintext highlighter-rouge">i</code> are smaller than <code class="language-plaintext highlighter-rouge">nums[i]</code>. Similarly, an index <code class="language-plaintext highlighter-rouge">i</code> is part of a <strong>valley</strong> in <code class="language-plaintext highlighter-rouge">nums</code> if the closest non-equal neighbors of <code class="language-plaintext highlighter-rouge">i</code> are larger than <code class="language-plaintext highlighter-rouge">nums[i]</code>. Adjacent indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> are part of the <strong>same</strong> hill or valley if <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code>.</li> <li>Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on <strong>both</strong> the left and right of the index.</li> <li>Return <em>the number of hills and valleys in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 &gt; 2 and 4 &gt; 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 &gt; 1 and 6 &gt; 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 &lt; 5 and 4 &gt; 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountHillsAndValleysInAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countPeaksAndValleys</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the total number of peaks and valleys found.</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Start from the second element, since the first element cannot be a peak or valley.</span>

        <span class="c1">// Loop through the array, but skip the first and last elements,</span>
        <span class="c1">// because they cannot be peaks or valleys (they don't have both neighbors).</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
            <span class="c1">// If the current element is equal to the previous one,</span>
            <span class="c1">// skip it to avoid counting the same peak/valley multiple times.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Find the closest non-equal neighbor to the left of nums[i].</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Move left pointer to the left until a different value is found or the start of the array is reached.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">left</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Find the closest non-equal neighbor to the right of nums[i].</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Move right pointer to the right until a different value is found or the end of the array is reached.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">right</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Only check for peak/valley if both left and right non-equal neighbors exist.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
                <span class="c1">// Check if nums[i] is a peak:</span>
                <span class="c1">// It is a peak if it is greater than both its closest non-equal neighbors.</span>
                <span class="c1">// Check if nums[i] is a valley:</span>
                <span class="c1">// It is a valley if it is less than both its closest non-equal neighbors.</span>
                <span class="k">if</span><span class="o">((</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])){</span>
                    <span class="n">count</span><span class="o">++;</span> <span class="c1">// Found a peak or valley, increment the counter.</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Move i to the next different element to avoid counting the same peak/valley multiple times.</span>
            <span class="c1">// This is important for handling consecutive equal elements as a single peak or valley.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countPeaksAndValleys</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j]. Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index. Return the number of hills and valleys in nums.]]></summary></entry><entry><title type="html">1679. Max Number of K-Sum Pairs</title><link href="https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs/" rel="alternate" type="text/html" title="1679. Max Number of K-Sum Pairs"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxNumberOfKSumPairs/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>In one operation, you can pick two numbers from the array whose sum equals <code class="language-plaintext highlighter-rouge">k</code> and remove them from the array.</li> <li>Return <em>the maximum number of operations you can perform on the array</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [112,131,411]

Output: -1

Explanation:

Each numbers largest digit in order is [2,3,4].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2536,1613,3366,162]

Output: 5902

Explanation:

All the numbers have 6 as their largest digit, so the answer is 2536 + 3366 = 5902.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [51,71,17,24,42]

Output: 88

Explanation:

Each number's largest digit in order is [5,7,7,4,4].

So we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxNumberOfKSumPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This HashMap will store the count of each number that has not yet been paired.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable counts the number of valid pairs found.</span>

        <span class="c1">// Iterate through each number in the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">num</span><span class="o">;</span> <span class="c1">// The number we need to pair with 'num' to sum to k.</span>

            <span class="c1">// Check if there is an available 'target' number that has not been paired yet.</span>
            <span class="c1">// countMap.getOrDefault(target, 0) &gt; 0 means there is at least one 'target' left to pair.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">result</span><span class="o">++;</span> <span class="c1">// We found a valid pair (num + target == k), so increment the result.</span>

                <span class="c1">// Since we've used one 'target' for pairing, decrease its count by 1.</span>
                <span class="c1">// This ensures each number is used at most once.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If there is no available 'target' to pair with 'num',</span>
                <span class="c1">// record 'num' in the map for possible pairing with future numbers.</span>
                <span class="c1">// Increase the count of 'num' by 1.</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After processing all numbers, 'result' contains the maximum number of valid pairs.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">6</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxOperations</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span> <span class="c1">// Output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array.]]></summary></entry><entry><title type="html">2815. Max Pair Sum in an Array</title><link href="https://zhengstar94.github.io//blog/2025/MaxPairSumInAnArray/" rel="alternate" type="text/html" title="2815. Max Pair Sum in an Array"/><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxPairSumInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxPairSumInAnArray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. You have to find the <strong>maximum</strong> sum of a pair of numbers from <code class="language-plaintext highlighter-rouge">nums</code> such that the <strong>largest digit</strong> in both numbers is equal.</li> <li>For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them.</li> <li>Return the <strong>maximum</strong> sum or -1 if no such pair exists.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [112,131,411]

Output: -1

Explanation:

Each numbers largest digit in order is [2,3,4].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2536,1613,3366,162]

Output: 5902

Explanation:

All the numbers have 6 as their largest digit, so the answer is 2536 + 3366 = 5902.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [51,71,17,24,42]

Output: 88

Explanation:

Each number's largest digit in order is [5,7,7,4,4].

So we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * k) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPairSumInAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This map stores, for each possible max digit (0~9), the largest number seen so far with that digit.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">maxNumForDigit</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">result</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// Initialize result as -1, which will be returned if no valid pair is found.</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">maxDigit</span> <span class="o">=</span> <span class="n">getMaxDigit</span><span class="o">(</span><span class="n">num</span><span class="o">);</span> <span class="c1">// Find the largest digit in the current number.</span>

            <span class="c1">// --- Key logic with detailed comments ---</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">)){</span>
                <span class="c1">// If there is already a number in the map with the same max digit,</span>
                <span class="c1">// it means we have found at least one previous number that can form a valid pair with the current number.</span>
                <span class="kt">int</span> <span class="n">pairSum</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">);</span> <span class="c1">// Calculate the sum of the current number and the previous max number with the same max digit.</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">pairSum</span><span class="o">);</span> <span class="c1">// Update the result if this pairSum is greater than the current result.</span>

                <span class="c1">// Update the stored number for this max digit in the map.</span>
                <span class="c1">// We always want to keep the largest number seen so far for each max digit,</span>
                <span class="c1">// because a larger number may form a larger sum with future numbers.</span>
                <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">)));</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If this is the first time we see this max digit,</span>
                <span class="c1">// just store the current number as the largest number for this digit.</span>
                <span class="n">maxNumForDigit</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getMaxDigit</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxDigit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxDigit</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDigit</span><span class="o">,</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">// Compare the current digit with maxDigit.</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// Move to the next digit.</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxDigit</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">51</span><span class="o">,</span> <span class="mi">71</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">42</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">39</span><span class="o">,</span> <span class="mi">93</span><span class="o">,</span> <span class="mi">99</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 88</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: -1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 192</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the largest digit in both numbers is equal. For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them. Return the maximum sum or -1 if no such pair exists.]]></summary></entry><entry><title type="html">2260. Minimum Consecutive Cards to Pick Up</title><link href="https://zhengstar94.github.io//blog/2025/MinimumConsecutiveCardsToPickUp/" rel="alternate" type="text/html" title="2260. Minimum Consecutive Cards to Pick Up"/><published>2025-07-26T00:00:00+00:00</published><updated>2025-07-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumConsecutiveCardsToPickUp</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumConsecutiveCardsToPickUp/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">cards</code> where <code class="language-plaintext highlighter-rouge">cards[i]</code> represents the <strong>value</strong> of the <code class="language-plaintext highlighter-rouge">ith</code> card. A pair of cards are <strong>matching</strong> if the cards have the <strong>same</strong> value.</li> <li>Return <em>the <strong>minimum</strong> number of <strong>consecutive</strong> cards you have to pick up to have a pair of <strong>matching</strong> cards among the picked cards.</em> If it is impossible to have matching cards, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cards = [3,4,2,3,4,7]
Output: 4
Explanation: We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cards = [1,0,5,3]
Output: -1
Explanation: There is no way to pick up a set of consecutive cards that contain a pair of matching cards.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumConsecutiveCardsToPickUp</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumCardPickup</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">cards</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store the last index where each card value appeared</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">lastIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Initialize the minimum length to a very large value</span>
        <span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Iterate through the cards array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cards</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current card value has appeared before</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastIndex</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">cards</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="c1">// Get the previous index where this card value appeared</span>
                <span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">=</span> <span class="n">lastIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cards</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="c1">// Calculate the length of the subarray between the two matching cards (inclusive)</span>
                <span class="n">minLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">prevIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Update the last seen index for the current card value</span>
            <span class="n">lastIndex</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cards</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// If minLen was not updated, return -1 (no matching pair found)</span>
        <span class="c1">// Otherwise, return the minimum length found</span>
        <span class="k">return</span> <span class="n">minLen</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">minLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: There is a matching pair (3 appears twice)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cards1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="c1">// Test case 2: No matching pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cards2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="c1">// Output the results for both test cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumCardPickup</span><span class="o">(</span><span class="n">cards1</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumCardPickup</span><span class="o">(</span><span class="n">cards2</span><span class="o">));</span> <span class="c1">// Output: -1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value. Return the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.]]></summary></entry><entry><title type="html">2001. Number of Pairs of Interchangeable Rectangles</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles/" rel="alternate" type="text/html" title="2001. Number of Pairs of Interchangeable Rectangles"/><published>2025-07-26T00:00:00+00:00</published><updated>2025-07-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles/"><![CDATA[<ul> <li>You are given <code class="language-plaintext highlighter-rouge">n</code> rectangles represented by a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">rectangles</code>, where <code class="language-plaintext highlighter-rouge">rectangles[i] = [widthi, heighti]</code> denotes the width and height of the <code class="language-plaintext highlighter-rouge">ith</code> rectangle.</li> <li>Two rectangles <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> (<code class="language-plaintext highlighter-rouge">i &lt; j</code>) are considered <strong>interchangeable</strong> if they have the <strong>same</strong> width-to-height ratio. More formally, two rectangles are <strong>interchangeable</strong> if <code class="language-plaintext highlighter-rouge">widthi/heighti == widthj/heightj</code> (using decimal division, not integer division).</li> <li>Return <em>the <strong>number</strong> of pairs of <strong>interchangeable</strong> rectangles in</em> <code class="language-plaintext highlighter-rouge">rectangles</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rectangles = [ [ 4,8],[3,6],[10,20],[15,30 ] ]
Output: 6
Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed):
- Rectangle 0 with rectangle 1: 4/8 == 3/6.
- Rectangle 0 with rectangle 2: 4/8 == 10/20.
- Rectangle 0 with rectangle 3: 4/8 == 15/30.
- Rectangle 1 with rectangle 2: 3/6 == 10/20.
- Rectangle 1 with rectangle 3: 3/6 == 15/30.
- Rectangle 2 with rectangle 3: 10/20 == 15/30.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rectangles = [ [ 4,5],[7,8 ] ]
Output: 0
Explanation: There are no interchangeable pairs of rectangles.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfPairsOfInterchangeableRectangles</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">interchangeableRectangles</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the final answer: the total number of interchangeable pairs.</span>

        <span class="c1">// This HashMap will store, for each unique ratio, how many times it has appeared so far.</span>
        <span class="c1">// Key: the ratio (width / height) as a double.</span>
        <span class="c1">// Value: the count of rectangles seen so far with this ratio.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each rectangle in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">rect:</span> <span class="n">rectangles</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the ratio of width to height for the current rectangle.</span>
            <span class="c1">// Multiplying by 1.0 ensures the division is floating-point, not integer division.</span>
            <span class="kt">double</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">rect</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rect</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// For the current rectangle, check how many rectangles with the same ratio have already been seen.</span>
            <span class="c1">// Each such rectangle can form a unique pair with the current one.</span>
            <span class="c1">// So, add the count of rectangles with this ratio to the answer.</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Update the map: increment the count for this ratio by 1,</span>
            <span class="c1">// because we've now seen one more rectangle with this ratio.</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After processing all rectangles, return the total number of interchangeable pairs found.</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: rectangles with the same ratio (4/8 = 3/6 = 10/20 = 15/30 = 0.5)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">},{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">},{</span><span class="mi">15</span><span class="o">,</span><span class="mi">30</span> <span class="o">}</span> <span class="o">};</span>
        <span class="c1">// Example 2: rectangles with different ratios (4/5 != 7/8)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">},{</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span> <span class="o">}</span> <span class="o">};</span>

        <span class="c1">// Output the results for both examples.</span>
        <span class="c1">// For rectangles1, the output should be 6 (all rectangles are interchangeable).</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">interchangeableRectangles</span><span class="o">(</span><span class="n">rectangles1</span><span class="o">));</span> <span class="c1">// Output: 6</span>

        <span class="c1">// For rectangles2, the output should be 0 (no interchangeable pairs).</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">interchangeableRectangles</span><span class="o">(</span><span class="n">rectangles2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle. Two rectangles i and j (i &lt; j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division). Return the number of pairs of interchangeable rectangles in rectangles.]]></summary></entry><entry><title type="html">3487. Maximum Unique Subarray Sum After Deletion</title><link href="https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion/" rel="alternate" type="text/html" title="3487. Maximum Unique Subarray Sum After Deletion"/><published>2025-07-25T00:00:00+00:00</published><updated>2025-07-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>You are allowed to delete any number of elements from <code class="language-plaintext highlighter-rouge">nums</code> without making it <strong>empty</strong>. After performing the deletions, select a subarray of <code class="language-plaintext highlighter-rouge">nums</code> such that: <ul> <li>All elements in the subarray are <strong>unique</strong>.</li> <li>The sum of the elements in the subarray is <strong>maximized</strong>.</li> </ul> </li> <li>Return the <strong>maximum sum</strong> of such a subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,5]
Output: 15

Explanation:

Select the entire array without deleting any element to obtain the maximum sum.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,1,1]
Output: 1

Explanation:

Delete the element nums[0] == 1, nums[1] == 1, nums[2] == 0, and nums[3] == 1. Select the entire array [1] to obtain the maximum sum.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,-1,-2,1,0,-1]
Output: 3

Explanation:

Delete the elements nums[2] == -1 and nums[3] == -2, and select the subarray [2, 1] from [1, 2, 1, 0, -1] to obtain the maximum sum.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumUniqueSubarraySumAfterDeletion</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This set is used to store unique positive numbers encountered in the array.</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// This variable accumulates the sum of all unique positive numbers.</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// This variable keeps track of the largest negative number in the array.</span>
        <span class="c1">// It is initialized to the smallest possible integer value.</span>
        <span class="kt">int</span> <span class="n">maxNegative</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="c1">// Traverse each element in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current number is negative, update maxNegative if this number is larger.</span>
                <span class="c1">// This is important for the case where all numbers are negative.</span>
                <span class="n">maxNegative</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxNegative</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If the current number is non-negative and not already in the set (i.e., unique),</span>
                <span class="c1">// add it to the set and add its value to the sum.</span>
                <span class="c1">// Only the first occurrence of each positive number is counted.</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If the number is non-negative but already in the set, it is skipped (no duplicate allowed).</span>
        <span class="o">}</span>

        <span class="c1">// If the set is empty, it means there were no non-negative numbers in the array.</span>
        <span class="c1">// In this case, return the largest negative number found.</span>
        <span class="c1">// Otherwise, return the sum of all unique positive numbers.</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="n">maxNegative</span> <span class="o">:</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">};</span>

        <span class="c1">// Test case 1: All unique positive numbers, should return 15 (1+2+3+4+5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 15</span>

        <span class="c1">// Test case 2: Only one unique non-negative number (1), should return 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 3: Mixed numbers, unique non-negative numbers are 1, 2, 0, sum is 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 3</span>

        <span class="c1">// Test case 4: All negative numbers, should return the largest one (-2)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Output: -2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums. You are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that: All elements in the subarray are unique. The sum of the elements in the subarray is maximized. Return the maximum sum of such a subarray.]]></summary></entry><entry><title type="html">2441. Largest Positive Integer That Exists With Its Negative</title><link href="https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative/" rel="alternate" type="text/html" title="2441. Largest Positive Integer That Exists With Its Negative"/><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> that <strong>does not contain</strong> any zeros, find <strong>the largest positive</strong> integer <code class="language-plaintext highlighter-rouge">k</code> such that <code class="language-plaintext highlighter-rouge">-k</code> also exists in the array.</li> <li>Return <em>the positive integer</em> <code class="language-plaintext highlighter-rouge">k</code>. If there is no such integer, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,2,-3,3]
Output: 3
Explanation: 3 is the only valid k we can find in the array.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,10,6,7,-7,1]
Output: 7
Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-10,8,6,7,-2,-3]
Output: -1
Explanation: There is no a single valid k, we return -1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LargestPositiveIntegerThatExistsWithItsNegative</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashSet to store all numbers seen so far for quick lookup</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Initialize maxK to -1, which will be returned if no valid k is found</span>
        <span class="kt">int</span> <span class="n">maxK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if the opposite number (-num) has already been seen</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(-</span><span class="n">num</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If so, update maxK to the larger value between current maxK and |num|</span>
                <span class="c1">// Math.abs(num) ensures we always consider the positive value</span>
                <span class="n">maxK</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxK</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="c1">// Add the current number to the set for future lookups</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After checking all numbers, return the result</span>
        <span class="k">return</span> <span class="n">maxK</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: Both 3 and -3 exist, so the answer is 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="c1">// Example 2: Both 7 and -7 exist, so the answer is 7</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Example 3: No number has its negative, so the answer is -1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">10</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">};</span>

        <span class="c1">// Print the results of each test case</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 7</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: -1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array. Return the positive integer k. If there is no such integer, return -1.]]></summary></entry><entry><title type="html">1512. Number of Good Pairs</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfGoodPairs/" rel="alternate" type="text/html" title="1512. Number of Good Pairs"/><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfGoodPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfGoodPairs/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the number of <strong>good pairs</strong></em>.</li> <li>A pair <code class="language-plaintext highlighter-rouge">(i, j)</code> is called <em>good</em> if <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code> and <code class="language-plaintext highlighter-rouge">i</code> &lt; <code class="language-plaintext highlighter-rouge">j</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1]
Output: 6
Explanation: Each pair in the array are good.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfGoodPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numIdenticalPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to store the count of each number encountered so far.</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// This variable will store the total number of good pairs found.</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For the current number, get how many times it has appeared before.</span>
            <span class="c1">// Each previous occurrence can form a good pair with the current index.</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Update the count of the current number in the map.</span>
            <span class="c1">// If the number is not present, start from 0 and add 1.</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After processing all numbers, return the total count of good pairs.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: There are 4 good pairs: (0,3), (0,4), (3,4), (2,5)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="c1">// Test case 2: All pairs are good, total is 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Test case 3: No good pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>

        <span class="c1">// Print the results for each test case</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIdenticalPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIdenticalPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 6</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIdenticalPairs</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i &lt; j.]]></summary></entry><entry><title type="html">1233. Remove Sub-Folders from the Filesystem</title><link href="https://zhengstar94.github.io//blog/2025/RemoveSubFoldersFromTheFilesystem/" rel="alternate" type="text/html" title="1233. Remove Sub-Folders from the Filesystem"/><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RemoveSubFoldersFromTheFilesystem</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RemoveSubFoldersFromTheFilesystem/"><![CDATA[<ul> <li>Given a list of folders <code class="language-plaintext highlighter-rouge">folder</code>, return <em>the folders after removing all <strong>sub-folders</strong> in those folders</em>. You may return the answer in <strong>any order</strong>.</li> <li>If a <code class="language-plaintext highlighter-rouge">folder[i]</code> is located within another <code class="language-plaintext highlighter-rouge">folder[j]</code>, it is called a <strong>sub-folder</strong> of it. A sub-folder of <code class="language-plaintext highlighter-rouge">folder[j]</code> must start with <code class="language-plaintext highlighter-rouge">folder[j]</code>, followed by a <code class="language-plaintext highlighter-rouge">"/"</code>. For example, <code class="language-plaintext highlighter-rouge">"/a/b"</code> is a sub-folder of <code class="language-plaintext highlighter-rouge">"/a"</code>, but <code class="language-plaintext highlighter-rouge">"/b"</code> is not a sub-folder of <code class="language-plaintext highlighter-rouge">"/a/b/c"</code>.</li> <li>The format of a path is one or more concatenated strings of the form: <code class="language-plaintext highlighter-rouge">'/'</code> followed by one or more lowercase English letters. <ul> <li>For example, <code class="language-plaintext highlighter-rouge">"/leetcode"</code> and <code class="language-plaintext highlighter-rouge">"/leetcode/problems"</code> are valid paths while an empty string and <code class="language-plaintext highlighter-rouge">"/"</code> are not.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
Output: ["/a","/c/d","/c/f"]
Explanation: Folders "/a/b" is a subfolder of "/a" and "/c/d/e" is inside of folder "/c/d" in our filesystem.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: folder = ["/a","/a/b/c","/a/b/d"]
Output: ["/a"]
Explanation: Folders "/a/b/c" and "/a/b/d" will be removed because they are subfolders of "/a".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
Output: ["/a/b/c","/a/b/ca","/a/b/d"]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n * m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveSubFoldersFromTheFilesystem</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">removeSubfolders</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">folder</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Sort the folder paths lexicographically.</span>
        <span class="c1">// This ensures that any parent folder comes before its subfolders.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">folder</span><span class="o">);</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// This variable keeps track of the last added parent folder.</span>
        <span class="nc">String</span> <span class="n">prev</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

        <span class="c1">// Step 2: Iterate through each folder path.</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">path</span> <span class="o">:</span> <span class="n">folder</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Key logic:</span>
            <span class="c1">// If 'prev' is empty, this is the first folder, so add it directly.</span>
            <span class="c1">// Otherwise, check if the current path is NOT a subfolder of 'prev'.</span>
            <span class="c1">// To be a subfolder, the path must start with 'prev' followed by a '/'.</span>
            <span class="c1">// Example: prev = "/a", path = "/a/b" -&gt; "/a/b".startsWith("/a/") == true (subfolder)</span>
            <span class="c1">//          prev = "/a", path = "/ab"  -&gt; "/ab".startsWith("/a/") == false (not a subfolder)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prev</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">path</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="n">prev</span> <span class="o">+</span> <span class="s">"/"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If not a subfolder, add to result and update 'prev'</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">path</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If it is a subfolder (startsWith(prev + "/")), skip it.</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Return the filtered list of folders.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Some folders are subfolders of others</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/a"</span><span class="o">,</span><span class="s">"/a/b"</span><span class="o">,</span><span class="s">"/c/d"</span><span class="o">,</span><span class="s">"/c/d/e"</span><span class="o">,</span><span class="s">"/c/f"</span><span class="o">};</span>
        <span class="c1">// Expected output: ["/a", "/c/d", "/c/f"]</span>

        <span class="c1">// Test case 2: All folders are subfolders of the first one</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/a"</span><span class="o">,</span><span class="s">"/a/b/c"</span><span class="o">,</span><span class="s">"/a/b/d"</span><span class="o">};</span>
        <span class="c1">// Expected output: ["/a"]</span>

        <span class="c1">// Test case 3: No folder is a subfolder of another</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/a/b/c"</span><span class="o">,</span><span class="s">"/a/b/ca"</span><span class="o">,</span><span class="s">"/a/b/d"</span><span class="o">};</span>
        <span class="c1">// Expected output: ["/a/b/c", "/a/b/ca", "/a/b/d"]</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeSubfolders</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Output: ["/a", "/c/d", "/c/f"]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeSubfolders</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Output: ["/a"]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeSubfolders</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// Output: ["/a/b/c", "/a/b/ca", "/a/b/d"]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. A sub-folder of folder[j] must start with folder[j], followed by a "/". For example, "/a/b" is a sub-folder of "/a", but "/b" is not a sub-folder of "/a/b/c". The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters. For example, "/leetcode" and "/leetcode/problems" are valid paths while an empty string and "/" are not.]]></summary></entry><entry><title type="html">3136. Valid Word</title><link href="https://zhengstar94.github.io//blog/2025/ValidWord/" rel="alternate" type="text/html" title="3136. Valid Word"/><published>2025-07-15T00:00:00+00:00</published><updated>2025-07-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ValidWord</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ValidWord/"><![CDATA[<ul> <li>A word is considered <strong>valid</strong> if: <ul> <li>It contains a <strong>minimum</strong> of 3 characters.</li> <li>It contains only digits (0-9), and English letters (uppercase and lowercase).</li> <li>It includes <strong>at least</strong> one <strong>vowel</strong>.</li> <li>It includes <strong>at least</strong> one <strong>consonant</strong>.</li> </ul> </li> <li>You are given a string <code class="language-plaintext highlighter-rouge">word</code>.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">word</code> is valid, otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> <li><strong>Notes:</strong> <ul> <li><code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'e'</code>, <code class="language-plaintext highlighter-rouge">'i'</code>, <code class="language-plaintext highlighter-rouge">'o'</code>, <code class="language-plaintext highlighter-rouge">'u'</code>, and their uppercases are <strong>vowels</strong>.</li> <li>A <strong>consonant</strong> is an English letter that is not a vowel.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "234Adas"

Output: true

Explanation:

This word satisfies the conditions.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "b3"

Output: false

Explanation:

The length of this word is fewer than 3, and does not have a vowel.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "a3$e"

Output: false

Explanation:

This word contains a '$' character and does not have a consonant.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidWord</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the word has fewer than 3 characters, it is automatically invalid.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Flags to track if at least one vowel and one consonant are present.</span>
        <span class="kt">boolean</span> <span class="n">hasVowel</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">hasConsonant</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="c1">// String containing all vowels (both lowercase and uppercase).</span>
        <span class="nc">String</span> <span class="n">vowels</span> <span class="o">=</span> <span class="s">"aeiouAEIOU"</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the word.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Check if the character is a letter.</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// If the character is a vowel, set hasVowel to true.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">vowels</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">hasVowel</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// If the character is a letter but not a vowel, it's a consonant.</span>
                    <span class="n">hasConsonant</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// If the character is neither a letter nor a digit, the word is invalid.</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If the character is a digit, do nothing (digits are allowed).</span>
        <span class="o">}</span>

        <span class="c1">// The word is valid only if it contains at least one vowel and one consonant.</span>
        <span class="c1">// Note: Use logical AND (&amp;&amp;) to ensure both conditions are met.</span>
        <span class="k">return</span> <span class="n">hasVowel</span> <span class="o">&amp;&amp;</span> <span class="n">hasConsonant</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to verify the implementation.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"234Adas"</span><span class="o">));</span> <span class="c1">// true: meets all conditions</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"b3"</span><span class="o">));</span>      <span class="c1">// false: too short and no vowel</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"a3$e"</span><span class="o">));</span>    <span class="c1">// false: contains invalid character '$'</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[A word is considered valid if: It contains a minimum of 3 characters. It contains only digits (0-9), and English letters (uppercase and lowercase). It includes at least one vowel. It includes at least one consonant. You are given a string word. Return true if word is valid, otherwise, return false. Notes: 'a', 'e', 'i', 'o', 'u', and their uppercases are vowels. A consonant is an English letter that is not a vowel.]]></summary></entry></feed>