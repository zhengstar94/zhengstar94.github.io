<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-02T04:13:27+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">132. Palindrome Partitioning II</title><link href="https://zhengstar94.github.io//blog/2025/PalindromePartitioningII/" rel="alternate" type="text/html" title="132. Palindrome Partitioning II"/><published>2025-03-02T00:00:00+00:00</published><updated>2025-03-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PalindromePartitioningII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PalindromePartitioningII/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, partition <code class="language-plaintext highlighter-rouge">s</code> such that every substring of the partition is a palindrome.</li> <li>Return <em>the <strong>minimum</strong> cuts needed for a palindrome partitioning of</em> <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aab"
Output: 1
Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "a"
Output: 0
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "ab"
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n²) time | O(n²) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PalindromePartitioningII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minCut</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: empty string or single character string needs 0 cuts</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// dp[i] represents the minimum cuts needed for substring(0,i)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>

        <span class="c1">// isPalindrome[i][j] represents whether substring from index i to j is palindrome</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">isPalindrome</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">len</span><span class="o">][</span><span class="n">len</span><span class="o">];</span>

        <span class="c1">// Initialize dp array with worst case scenario</span>
        <span class="c1">// For string length i, worst case needs i cuts (cutting after each character)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// For example: "abcd" worst case is "a|b|c|d" (3 cuts)</span>
        <span class="o">}</span>

        <span class="c1">// Main loop: j is the right boundary of the substring we're examining</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// i is the left boundary, checking all possible left boundaries up to j</span>
            <span class="c1">// For example, when j=2 (checking "abc"):</span>
            <span class="c1">// i=0: check "abc"</span>
            <span class="c1">// i=1: check "bc"</span>
            <span class="c1">// i=2: check "c"</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Check if substring from i to j is palindrome:</span>
                <span class="c1">// 1. First and last characters must be same</span>
                <span class="c1">// 2. Either the substring length &lt;= 3 (like "a", "aa", "aba")</span>
                <span class="c1">// 3. Or the inner substring (i+1 to j-1) must be palindrome</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">isPalindrome</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="c1">// Mark this substring as palindrome</span>
                    <span class="n">isPalindrome</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

                    <span class="c1">// Case 1: If substring starts from index 0</span>
                    <span class="c1">// No cuts needed as the whole substring is palindrome</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">// Case 2: If substring starts after index 0</span>
                    <span class="c1">// Need to decide: either keep current minimum cuts</span>
                    <span class="c1">// or use (minimum cuts for substring(0,i-1) + 1 cut at position i)</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="c1">// dp[i-1] represents minimum cuts needed for substring(0,i-1)</span>
                        <span class="c1">// +1 represents one additional cut at position i</span>
                        <span class="c1">// Example: for "aab", when i=2,j=2:</span>
                        <span class="c1">// dp[1]("aa") = 0, so dp[2] = min(dp[2], 0+1) = 1</span>
                        <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return minimum cuts needed for the entire string</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: "aab" -&gt; "aa|b" (1 cut)</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"aab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minCut</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 2: "a" -&gt; "a" (0 cuts)</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minCut</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: 0</span>

        <span class="c1">// Test Case 3: "ab" -&gt; "a|b" (1 cut)</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">minCut</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 4: "aaaa" -&gt; "aaaa" (0 cuts as it's already palindrome)</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"aaaa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">minCut</span><span class="o">(</span><span class="n">s4</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Hard"/><summary type="html"><![CDATA[Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.]]></summary></entry><entry><title type="html">2460. Apply Operations to an Array</title><link href="https://zhengstar94.github.io//blog/2025/ApplyOperationsToAnArray/" rel="alternate" type="text/html" title="2460. Apply Operations to an Array"/><published>2025-03-01T00:00:00+00:00</published><updated>2025-03-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ApplyOperationsToAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ApplyOperationsToAnArray/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code> consisting of <strong>non-negative</strong> integers.</li> <li>You need to apply <code class="language-plaintext highlighter-rouge">n - 1</code> operations to this array where, in the <code class="language-plaintext highlighter-rouge">ith</code> operation (<strong>0-indexed</strong>), you will apply the following on the <code class="language-plaintext highlighter-rouge">ith</code> element of <code class="language-plaintext highlighter-rouge">nums</code>: <ul> <li>If <code class="language-plaintext highlighter-rouge">nums[i] == nums[i + 1]</code>, then multiply <code class="language-plaintext highlighter-rouge">nums[i]</code> by <code class="language-plaintext highlighter-rouge">2</code> and set <code class="language-plaintext highlighter-rouge">nums[i + 1]</code> to <code class="language-plaintext highlighter-rouge">0</code>. Otherwise, you skip this operation.</li> </ul> </li> <li>After performing <strong>all</strong> the operations, <strong>shift</strong> all the <code class="language-plaintext highlighter-rouge">0</code>’s to the <strong>end</strong> of the array. <ul> <li>For example, the array <code class="language-plaintext highlighter-rouge">[1,0,2,0,0,1]</code> after shifting all its <code class="language-plaintext highlighter-rouge">0</code>’s to the end, is <code class="language-plaintext highlighter-rouge">[1,2,1,0,0,0]</code>.</li> </ul> </li> <li>Return <em>the resulting array</em>.</li> <li><strong>Note</strong> that the operations are applied <strong>sequentially</strong>, not all at once.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,2,1,1,0]
Output: [1,4,2,0,0,0]
Explanation: We do the following operations:
- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.
- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].
- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.
- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].
- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].
After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1]
Output: [1,0]
Explanation: No operation can be applied, we just shift the 0 to the end.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplyOperationsToAnArray</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">applyOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Step 1: Apply multiplication operations</span>
        <span class="c1">// If adjacent elements are equal, multiply first by 2 and set second to 0</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">;</span>          <span class="c1">// Double the current element</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// Set next element to zero</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Move all non-zero elements to front using two-pointer technique</span>
        <span class="c1">// nonZero pointer keeps track of where next non-zero element should go</span>
        <span class="kt">int</span> <span class="n">nonZero</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Swap current element with element at nonZero position</span>
                <span class="c1">// When i equals nonZero, element swaps with itself (no effect)</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nonZero</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">nonZero</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="n">nonZero</span><span class="o">++;</span>    <span class="c1">// Move nonZero pointer to next position</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with duplicates and zero</span>
        <span class="c1">// Expected: [1,4,2,0,0,0]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">applyOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">)));</span>

        <span class="c1">// Test Case 2: Minimal array with zero</span>
        <span class="c1">// Expected: [1,0]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">applyOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">)));</span>

        <span class="c1">// Test Case 3: Array with all same elements</span>
        <span class="c1">// Expected: [2,2,0,0]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">applyOperations</span><span class="o">(</span><span class="n">nums3</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums: If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation. After performing all the operations, shift all the 0’s to the end of the array. For example, the array [1,0,2,0,0,1] after shifting all its 0’s to the end, is [1,2,1,0,0,0]. Return the resulting array. Note that the operations are applied sequentially, not all at once.]]></summary></entry><entry><title type="html">131. Palindrome Partitioning</title><link href="https://zhengstar94.github.io//blog/2025/PalindromePartitioning/" rel="alternate" type="text/html" title="131. Palindrome Partitioning"/><published>2025-03-01T00:00:00+00:00</published><updated>2025-03-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PalindromePartitioning</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PalindromePartitioning/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, partition <code class="language-plaintext highlighter-rouge">s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return <em>all possible palindrome partitioning of</em> <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aab"
Output: [ [ "a","a","b"],["aa","b" ] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "a"
Output: [ [ "a" ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * 2<span class="p">^</span>n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PalindromePartitioning</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">partition</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>  <span class="c1">// Store all valid partitioning results</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span> <span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>     <span class="c1">// Start backtracking from index 0</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Backtracking method to find all possible palindrome partitions
     *
     * @param result   List to store all valid partitioning results
     * @param tempList Current list storing the palindrome substrings in this path
     * @param s        Original input string
     * @param start    Current starting position for partitioning
     *
     * Example for string "aaba":
     * 1st recursion (start=0): considers "a", "aa", "aab", "aaba"
     * 2nd recursion (start=1): considers "a", "ab", "aba"
     * 3rd recursion (start=2): considers "b", "ba"
     * 4th recursion (start=3): considers "a"
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tempList</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: if we've reached the end of the string</span>
        <span class="c1">// This means we've found a valid partition (all substrings are palindromes)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">tempList</span><span class="o">));</span>  <span class="c1">// Add a deep copy of current partition to result</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Try all possible substrings starting from 'start' position</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if substring from start to i is palindrome</span>
            <span class="c1">// Example: for "aaba", when start=0, i=1</span>
            <span class="c1">// First checks "a", then "aa", then "aab", then "aaba"</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Add current palindrome substring to tempList</span>
                <span class="c1">// Example: if "aa" is palindrome, tempList = ["aa"]</span>
                <span class="n">tempList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>

                <span class="c1">// Recursively process the rest of the string</span>
                <span class="c1">// Example: after adding "aa", next recursion starts at position 2</span>
                <span class="c1">// This means we'll now look for palindromes in "ba"</span>
                <span class="n">backtrack</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">tempList</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

                <span class="c1">// Backtrack: remove the last added substring to try other possibilities</span>
                <span class="c1">// Example: after trying "aa" + "b" + "a", remove "a" to try other combinations</span>
                <span class="c1">// This is crucial for exploring all possible partitions</span>
                <span class="n">tempList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">tempList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">end</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">start</span><span class="o">++;</span>
            <span class="n">end</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: "aab" -&gt; [ [ "a","a","b"], ["aa","b" ] ]</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"aab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 input: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 output: "</span> <span class="o">+</span> <span class="n">partition</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>

        <span class="c1">// Test case 2: "a" -&gt; [ [ "a" ] ]</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 input: "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 output: "</span> <span class="o">+</span> <span class="n">partition</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.]]></summary></entry><entry><title type="html">1574. Shortest Subarray to be Removed to Make Array Sorted</title><link href="https://zhengstar94.github.io//blog/2025/ShortestSubarrayToBeRemovedToMakeArraySorted/" rel="alternate" type="text/html" title="1574. Shortest Subarray to be Removed to Make Array Sorted"/><published>2025-03-01T00:00:00+00:00</published><updated>2025-03-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ShortestSubarrayToBeRemovedToMakeArraySorted</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ShortestSubarrayToBeRemovedToMakeArraySorted/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">arr</code>, remove a subarray (can be empty) from <code class="language-plaintext highlighter-rouge">arr</code> such that the remaining elements in <code class="language-plaintext highlighter-rouge">arr</code> are <strong>non-decreasing</strong>.</li> <li>Return <em>the length of the shortest subarray to remove</em>.</li> <li>A <strong>subarray</strong> is a contiguous subsequence of the array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,3,10,4,2,3,5]
Output: 3
Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [5,4,3,2,1]
Output: 4
Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,3]
Output: 0
Explanation: The array is already non-decreasing. We do not need to remove any elements.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.SingleSeqTwoPointersForward</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestSubarrayToBeRemovedToMakeArraySorted</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findLengthOfShortestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Find the end position of the left increasing sequence</span>
        <span class="c1">// Keep moving right while the array is increasing</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// If the entire array is already sorted (increasing)</span>
        <span class="c1">// then we don't need to remove any elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Find the start position of the right increasing sequence</span>
        <span class="c1">// Keep moving left while the array is increasing from the right</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize the minimum length to remove</span>
        <span class="c1">// Two basic options:</span>
        <span class="c1">// 1. n - left - 1: remove elements after the left increasing sequence</span>
        <span class="c1">// 2. right: remove elements before the right increasing sequence</span>
        <span class="c1">// The -1 in (n - left - 1) is because we want to keep the last element of left sequence</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>

        <span class="c1">// Use two pointers to try to merge left and right increasing sequences</span>
        <span class="c1">// i: points to elements in left increasing sequence</span>
        <span class="c1">// j: points to elements in right increasing sequence</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Current combination is valid because arr[i] &lt;= arr[j]</span>
                <span class="c1">// This means we can keep elements from [0...i] and [j...n-1]</span>
                <span class="c1">// Need to remove elements between i and j, which is (j-i-1) elements</span>
                <span class="c1">// Update result if this removal length is smaller</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">i</span><span class="o">++;</span> <span class="c1">// Try next element from left sequence</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Current arr[i] &gt; arr[j], which breaks increasing order</span>
                <span class="c1">// Move j to find a larger element in right sequence</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases to verify the solution</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Array with middle portion to be removed</span>
        <span class="c1">// Expected result: 3 (can remove [10,4,2] or [3,10,4])</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">findLengthOfShortestSubarray</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Strictly decreasing array</span>
        <span class="c1">// Expected result: 4 (need to remove all but one element)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">findLengthOfShortestSubarray</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span>

        <span class="c1">// Test case 3: Already sorted array</span>
        <span class="c1">// Expected result: 0 (no need to remove any elements)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">findLengthOfShortestSubarray</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SingleSeqTwoPointersForward"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing. Return the length of the shortest subarray to remove. A subarray is a contiguous subsequence of the array.]]></summary></entry><entry><title type="html">1498. Number of Subsequences That Satisfy the Given Sum Condition</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfSubsequencesThatSatisfyTheGivenSumCondition/" rel="alternate" type="text/html" title="1498. Number of Subsequences That Satisfy the Given Sum Condition"/><published>2025-02-27T00:00:00+00:00</published><updated>2025-02-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfSubsequencesThatSatisfyTheGivenSumCondition</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfSubsequencesThatSatisfyTheGivenSumCondition/"><![CDATA[<ul> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">target</code>.</li> <li>Return <em>the number of <strong>non-empty</strong> subsequences of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>such that the sum of the minimum and maximum element on it is less or equal to</em> <code class="language-plaintext highlighter-rouge">target</code>. Since the answer may be too large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">10^9 + 7</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.
[3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9)
[3,5] -&gt; (3 + 5 &lt;= 9)
[3,5,6] -&gt; (3 + 6 &lt;= 9)
[3,6] -&gt; (3 + 6 &lt;= 9)
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSubsequencesThatSatisfyTheGivenSumCondition</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numSubseq</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Define the modulus to handle large numbers</span>
        <span class="c1">// We use this to prevent integer overflow as per problem requirements</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1_000_000_007</span><span class="o">;</span>

        <span class="c1">// Sort the array to use two pointer technique</span>
        <span class="c1">// After sorting, left pointer will always point to minimum value</span>
        <span class="c1">// and right pointer will always point to maximum value in any subsequence</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Pre-calculate powers of 2 to optimize performance</span>
        <span class="c1">// pow[i] will store (2^i) % MOD</span>
        <span class="c1">// This array helps us calculate the number of possible subsequences quickly</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">pow</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">pow</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// 2^0 = 1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For each index i, calculate 2^i by multiplying previous value by 2</span>
            <span class="c1">// Take modulus to prevent overflow</span>
            <span class="c1">// Example: pow[3] = 8 means there are 8 possible combinations for 3 numbers</span>
            <span class="n">pow</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">pow</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize two pointers and result</span>
        <span class="c1">// left points to potential minimum values</span>
        <span class="c1">// right points to potential maximum values</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Process all possible valid subsequences</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if current min and max sum is within target</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If condition is satisfied:</span>
                <span class="c1">// 1. nums[left] will be the minimum value</span>
                <span class="c1">// 2. nums[right] will be the maximum value</span>
                <span class="c1">// 3. For numbers between left and right (exclusive):</span>
                <span class="c1">//    - Each number can either be included or not</span>
                <span class="c1">//    - If there are k numbers between left and right</span>
                <span class="c1">//    - Total combinations will be 2^k</span>
                <span class="c1">//    - We get this value from pow[right-left]</span>
                <span class="c1">// Example: for array [2,3,3,4,6,7] when left=0(value=2) and right=5(value=7)</span>
                <span class="c1">// - There are 4 numbers between them (3,3,4,6)</span>
                <span class="c1">// - Each of these 4 numbers can be included or not</span>
                <span class="c1">// - Total combinations = 2^4 = 16</span>
                <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">result</span> <span class="o">+</span> <span class="n">pow</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">])</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If sum is too large, move right pointer to decrease max value</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output is 4</span>
        <span class="c1">// Valid subsequences are: [3], [3,5], [3,5,6], [3,6]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">9</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numSubseq</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expected output is 6</span>
        <span class="c1">// Valid subsequences include duplicates: [3], [3], [3,3], [3,6], [3,6], [3,3,6]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numSubseq</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expected output is 61</span>
        <span class="c1">// This case demonstrates handling of larger numbers and multiple combinations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">12</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numSubseq</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SingleSeqTwoPointersInward"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given an array of integers nums and an integer target. Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 10^9 + 7.]]></summary></entry><entry><title type="html">1472. Design Browser History</title><link href="https://zhengstar94.github.io//blog/2025/BrowserHistory/" rel="alternate" type="text/html" title="1472. Design Browser History"/><published>2025-02-26T00:00:00+00:00</published><updated>2025-02-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BrowserHistory</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BrowserHistory/"><![CDATA[<ul> <li>You have a <strong>browser</strong> of one tab where you start on the <code class="language-plaintext highlighter-rouge">homepage</code> and you can visit another <code class="language-plaintext highlighter-rouge">url</code>, get back in the history number of <code class="language-plaintext highlighter-rouge">steps</code> or move forward in the history number of <code class="language-plaintext highlighter-rouge">steps</code>.</li> <li>Implement the <code class="language-plaintext highlighter-rouge">BrowserHistory</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">BrowserHistory(string homepage)</code> Initializes the object with the <code class="language-plaintext highlighter-rouge">homepage</code> of the browser.</li> <li><code class="language-plaintext highlighter-rouge">void visit(string url)</code> Visits <code class="language-plaintext highlighter-rouge">url</code> from the current page. It clears up all the forward history.</li> <li><code class="language-plaintext highlighter-rouge">string back(int steps)</code> Move <code class="language-plaintext highlighter-rouge">steps</code> back in history. If you can only return <code class="language-plaintext highlighter-rouge">x</code> steps in the history and <code class="language-plaintext highlighter-rouge">steps &gt; x</code>, you will return only <code class="language-plaintext highlighter-rouge">x</code> steps. Return the current <code class="language-plaintext highlighter-rouge">url</code> after moving back in history <strong>at most</strong> <code class="language-plaintext highlighter-rouge">steps</code>.</li> <li><code class="language-plaintext highlighter-rouge">string forward(int steps)</code> Move <code class="language-plaintext highlighter-rouge">steps</code> forward in history. If you can only forward <code class="language-plaintext highlighter-rouge">x</code> steps in the history and <code class="language-plaintext highlighter-rouge">steps &gt; x</code>, you will forward only <code class="language-plaintext highlighter-rouge">x</code> steps. Return the current <code class="language-plaintext highlighter-rouge">url</code> after forwarding in history <strong>at most</strong> <code class="language-plaintext highlighter-rouge">steps</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
Output:
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

Explanation:
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // You are in "leetcode.com". Visit "google.com"
browserHistory.visit("facebook.com");     // You are in "google.com". Visit "facebook.com"
browserHistory.visit("youtube.com");      // You are in "facebook.com". Visit "youtube.com"
browserHistory.back(1);                   // You are in "youtube.com", move back to "facebook.com" return "facebook.com"
browserHistory.back(1);                   // You are in "facebook.com", move back to "google.com" return "google.com"
browserHistory.forward(1);                // You are in "google.com", move forward to "facebook.com" return "facebook.com"
browserHistory.visit("linkedin.com");     // You are in "facebook.com". Visit "linkedin.com"
browserHistory.forward(2);                // You are in "linkedin.com", you cannot move forward any steps.
browserHistory.back(2);                   // You are in "linkedin.com", move back two steps to "facebook.com" then to "google.com". return "google.com"
browserHistory.back(7);                   // You are in "google.com", you can move back only one step to "leetcode.com". return "leetcode.com"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BrowserHistory</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">history</span><span class="o">;</span> <span class="c1">// Store browser history</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">current</span><span class="o">;</span>              <span class="c1">// Current position index</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>                 <span class="c1">// Valid history size</span>

    <span class="cm">/**
     * Initialize browser history with homepage
     * @param homepage Initial homepage URL
     */</span>
    <span class="kd">public</span> <span class="nf">BrowserHistory</span><span class="o">(</span><span class="nc">String</span> <span class="n">homepage</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">history</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">history</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">homepage</span><span class="o">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Visit a new URL
     * @param url URL to visit
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">current</span><span class="o">++;</span>
        <span class="c1">// If current exceeds ArrayList size, add new element</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">history</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">history</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">history</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Update valid history size</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Move back in history
     * @param steps Number of steps to move back
     * @return URL after moving back
     */</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">back</span><span class="o">(</span><span class="kt">int</span> <span class="n">steps</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">current</span> <span class="o">-</span> <span class="n">steps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">history</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Move forward in history
     * @param steps Number of steps to move forward
     * @return URL after moving forward
     */</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">forward</span><span class="o">(</span><span class="kt">int</span> <span class="n">steps</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">current</span> <span class="o">+</span> <span class="n">steps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">history</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BrowserHistory</span> <span class="n">browserHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BrowserHistory</span><span class="o">(</span><span class="s">"leetcode.com"</span><span class="o">);</span>
        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"google.com"</span><span class="o">);</span>
        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"facebook.com"</span><span class="o">);</span>
        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"youtube.com"</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// Returns "facebook.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// Returns "google.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span> <span class="c1">// Returns "facebook.com"</span>

        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"linkedin.com"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span> <span class="c1">// Returns "linkedin.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>    <span class="c1">// Returns "google.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">7</span><span class="o">));</span>    <span class="c1">// Returns "leetcode.com"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps. Implement the BrowserHistory class: BrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history. If you can only return x steps in the history and steps &gt; x, you will return only x steps. Return the current url after moving back in history at most steps. string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps &gt; x, you will forward only x steps. Return the current url after forwarding in history at most steps.]]></summary></entry><entry><title type="html">1749. Maximum Absolute Sum of Any Subarray</title><link href="https://zhengstar94.github.io//blog/2025/MaximumAbsoluteSumOfAnySubarray/" rel="alternate" type="text/html" title="1749. Maximum Absolute Sum of Any Subarray"/><published>2025-02-26T00:00:00+00:00</published><updated>2025-02-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumAbsoluteSumOfAnySubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumAbsoluteSumOfAnySubarray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. The <strong>absolute sum</strong> of a subarray <code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> is <code class="language-plaintext highlighter-rouge">abs(numsl + numsl+1 + ... + numsr-1 + numsr)</code>.</li> <li>Return <em>the <strong>maximum</strong> absolute sum of any <strong>(possibly empty)</strong> subarray of</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Note that <code class="language-plaintext highlighter-rouge">abs(x)</code> is defined as follows: <ul> <li>If <code class="language-plaintext highlighter-rouge">x</code> is a negative integer, then <code class="language-plaintext highlighter-rouge">abs(x) = -x</code>.</li> <li>If <code class="language-plaintext highlighter-rouge">x</code> is a non-negative integer, then <code class="language-plaintext highlighter-rouge">abs(x) = x</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,-3,2,3,-4]
Output: 5
Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,-5,1,-4,3,-2]
Output: 8
Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumAbsoluteSumOfAnySubarray</span> <span class="o">{</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxAbsoluteSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize variables to track maximum and minimum sums</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">minSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Variable to maintain running sum (prefix sum)</span>
        <span class="kt">int</span> <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array once</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Add current number to running sum</span>
            <span class="n">currSum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
            <span class="c1">// Update maximum sum if current sum is larger</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">currSum</span><span class="o">);</span>
            <span class="c1">// Update minimum sum if current sum is smaller</span>
            <span class="n">minSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minSum</span><span class="o">,</span> <span class="n">currSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the difference between maximum and minimum sums</span>
        <span class="c1">// This difference represents the maximum absolute sum possible</span>
        <span class="k">return</span> <span class="n">maxSum</span> <span class="o">-</span> <span class="n">minSum</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed positive and negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 2: Another mixed case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 8</span>

        <span class="c1">// Test Case 3: All positive numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>

        <span class="c1">// Test Case 4: All negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr). Return the maximum absolute sum of any (possibly empty) subarray of nums. Note that abs(x) is defined as follows: If x is a negative integer, then abs(x) = -x. If x is a non-negative integer, then abs(x) = x.]]></summary></entry><entry><title type="html">1616. Split Two Strings to Make Palindrome</title><link href="https://zhengstar94.github.io//blog/2025/SplitTwoStringsToMakePalindrome/" rel="alternate" type="text/html" title="1616. Split Two Strings to Make Palindrome"/><published>2025-02-26T00:00:00+00:00</published><updated>2025-02-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SplitTwoStringsToMakePalindrome</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SplitTwoStringsToMakePalindrome/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> of the same length. Choose an index and split both strings <strong>at the same index</strong>, splitting <code class="language-plaintext highlighter-rouge">a</code> into two strings: <code class="language-plaintext highlighter-rouge">aprefix</code> and <code class="language-plaintext highlighter-rouge">asuffix</code> where <code class="language-plaintext highlighter-rouge">a = aprefix + asuffix</code>, and splitting <code class="language-plaintext highlighter-rouge">b</code> into two strings: <code class="language-plaintext highlighter-rouge">bprefix</code> and <code class="language-plaintext highlighter-rouge">bsuffix</code> where <code class="language-plaintext highlighter-rouge">b = bprefix + bsuffix</code>. Check if <code class="language-plaintext highlighter-rouge">aprefix + bsuffix</code> or <code class="language-plaintext highlighter-rouge">bprefix + asuffix</code> forms a palindrome.</li> <li>When you split a string <code class="language-plaintext highlighter-rouge">s</code> into <code class="language-plaintext highlighter-rouge">sprefix</code> and <code class="language-plaintext highlighter-rouge">ssuffix</code>, either <code class="language-plaintext highlighter-rouge">ssuffix</code> or <code class="language-plaintext highlighter-rouge">sprefix</code> is allowed to be empty. For example, if <code class="language-plaintext highlighter-rouge">s = "abc"</code>, then <code class="language-plaintext highlighter-rouge">"" + "abc"</code>, <code class="language-plaintext highlighter-rouge">"a" + "bc"</code>, <code class="language-plaintext highlighter-rouge">"ab" + "c"</code> , and <code class="language-plaintext highlighter-rouge">"abc" + ""</code> are valid splits.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to form</em> <em>a palindrome string, otherwise return</em> <code class="language-plaintext highlighter-rouge">false</code>.</li> <li><strong>Notice</strong> that <code class="language-plaintext highlighter-rouge">x + y</code> denotes the concatenation of strings <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = "x", b = "y"
Output: true
Explaination: If either a or b are palindromes the answer is true since you can split in the following way:
aprefix = "", asuffix = "x"
bprefix = "", bsuffix = "y"
Then, aprefix + bsuffix = "" + "y" = "y", which is a palindrome.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = "xbdef", b = "xecab"
Output: false
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = "ulacfd", b = "jizalu"
Output: true
Explaination: Split them at index 3:
aprefix = "ula", asuffix = "cfd"
bprefix = "jiz", bsuffix = "alu"
Then, aprefix + bsuffix = "ula" + "alu" = "ulaalu", which is a palindrome.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SplitTwoStringsToMakePalindrome</span> <span class="o">{</span>

    <span class="cm">/**
     * Main method to check if it's possible to form a palindrome by splitting and combining strings
     * This method tries both combinations:
     * 1. prefix of a + suffix of b
     * 2. prefix of b + suffix of a
     *
     * @param a First input string
     * @param b Second input string
     * @return true if a palindrome can be formed, false otherwise
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkPalindromeFormation</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Try both combinations and return true if either works</span>
        <span class="k">return</span> <span class="nf">checkPalindrome</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">||</span> <span class="n">checkPalindrome</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to check if one combination can form a palindrome
     * Uses two-pointer technique to check characters from both ends
     *
     * Key algorithm steps:
     * 1. Match characters from both ends until mismatch is found
     * 2. If pointers cross or meet, we've found a palindrome
     * 3. Otherwise, check if remaining substring in either string is palindrome
     *
     * @param a String to use for prefix
     * @param b String to use for suffix
     * @return true if a palindrome can be formed
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers: left starts from beginning, right from end</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// First phase: Match characters from both ends</span>
        <span class="c1">// Continue while pointers haven't met and characters match</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="c1">// If pointers have met or crossed, we've found a palindrome</span>
        <span class="c1">// This means all characters matched successfully</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Second phase: Check if remaining substring in either string is palindrome</span>
        <span class="c1">// We only need one of them to be palindrome to succeed</span>
        <span class="k">return</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">||</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to check if a substring is palindrome
     * Uses two-pointer technique to compare characters from both ends
     *
     * @param s String to check
     * @param left Start index of substring
     * @param right End index of substring
     * @return true if the substring is palindrome
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Continue checking while pointers haven't met</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If characters don't match, it's not a palindrome</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">// If we get here, the substring is palindrome</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Single character strings</span>
        <span class="nc">String</span> <span class="n">a1</span> <span class="o">=</span> <span class="s">"x"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b1</span> <span class="o">=</span> <span class="s">"y"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 2: No palindrome possible</span>
        <span class="nc">String</span> <span class="n">a2</span> <span class="o">=</span> <span class="s">"xbdef"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b2</span> <span class="o">=</span> <span class="s">"xecab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test Case 3: Palindrome possible with prefix/suffix combination</span>
        <span class="nc">String</span> <span class="n">a3</span> <span class="o">=</span> <span class="s">"ulacfd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b3</span> <span class="o">=</span> <span class="s">"jizalu"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a3</span><span class="o">,</span> <span class="n">b3</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 4: Palindrome possible with partial matching</span>
        <span class="nc">String</span> <span class="n">a4</span> <span class="o">=</span> <span class="s">"abdef"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b4</span> <span class="o">=</span> <span class="s">"fecab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a4</span><span class="o">,</span> <span class="n">b4</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 5: Palindrome possible with longer strings</span>
        <span class="nc">String</span> <span class="n">a5</span> <span class="o">=</span> <span class="s">"abadef"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b5</span> <span class="o">=</span> <span class="s">"fedcba"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a5</span><span class="o">,</span> <span class="n">b5</span><span class="o">));</span> <span class="c1">// Expected: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SingleSeqTwoPointersInward"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two strings a and b of the same length. Choose an index and split both strings at the same index, splitting a into two strings: aprefix and asuffix where a=aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b=bprefix + bsuffix. Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome. When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. For example, if s="abc", then "" + "abc", "a" + "bc", "ab" + "c" , and "abc" + "" are valid splits. Return true if it is possible to form a palindrome string, otherwise return false. Notice that x + y denotes the concatenation of strings x and y.]]></summary></entry><entry><title type="html">948. Bag of Tokens</title><link href="https://zhengstar94.github.io//blog/2025/BagOfTokens/" rel="alternate" type="text/html" title="948. Bag of Tokens"/><published>2025-02-25T00:00:00+00:00</published><updated>2025-02-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BagOfTokens</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BagOfTokens/"><![CDATA[<ul> <li>You start with an initial <strong>power</strong> of <code class="language-plaintext highlighter-rouge">power</code>, an initial <strong>score</strong> of <code class="language-plaintext highlighter-rouge">0</code>, and a bag of tokens given as an integer array <code class="language-plaintext highlighter-rouge">tokens</code>, where each <code class="language-plaintext highlighter-rouge">tokens[i]</code> denotes the value of token<em>i</em>.</li> <li>Your goal is to <strong>maximize</strong> the total <strong>score</strong> by strategically playing these tokens. In one move, you can play an <strong>unplayed</strong> token in one of the two ways (but not both for the same token): <ul> <li><strong>Face-up</strong>: If your current power is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">tokens[i]</code>, you may play token<em>i</em>, losing <code class="language-plaintext highlighter-rouge">tokens[i]</code> power and gaining <code class="language-plaintext highlighter-rouge">1</code> score.</li> <li><strong>Face-down</strong>: If your current score is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">1</code>, you may play token<em>i</em>, gaining <code class="language-plaintext highlighter-rouge">tokens[i]</code> power and losing <code class="language-plaintext highlighter-rouge">1</code> score.</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> possible score you can achieve after playing <strong>any</strong> number of tokens</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = [100], power = 50

Output: 0

Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0] (100).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = [200,100], power = 150

Output: 1

Explanation: Play token1 (100) face-up, reducing your power to 50 and increasing your score to 1.

There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = [100,200,300,400], power = 200

Output: 2

Explanation: Play the tokens in this order to get a score of 2:

Play token0 (100) face-up, reducing power to 100 and increasing score to 1.
Play token3 (400) face-down, increasing power to 500 and reducing score to 0.
Play token1 (200) face-up, reducing power to 300 and increasing score to 1.
Play token2 (300) face-up, reducing power to 0 and increasing score to 2.
The maximum score achievable is 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BagOfTokens</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bagOfTokensScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tokens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">power</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or empty array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tokens</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tokens</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort tokens in ascending order to optimize token usage</span>
        <span class="c1">// Smallest tokens will be used for face-up plays</span>
        <span class="c1">// Largest tokens will be used for face-down plays</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">tokens</span><span class="o">);</span>

        <span class="c1">// Initialize two pointers:</span>
        <span class="c1">// left: points to the smallest unused token</span>
        <span class="c1">// right: points to the largest unused token</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tokens</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Track both current and maximum scores</span>
        <span class="c1">// currentScore: score at current state</span>
        <span class="c1">// maxScore: highest score achieved so far</span>
        <span class="kt">int</span> <span class="n">currentScore</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxScore</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/* Main game loop:
         * Continue while there are tokens to play (left &lt;= right) AND
         * either we have enough power to play face-up (power &gt;= tokens[left])
         * or we have score to play face-down (currentScore &gt; 0)
         */</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">power</span> <span class="o">&gt;=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">||</span> <span class="n">currentScore</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
            <span class="cm">/* Face-up play loop:
             * While we have enough power, keep playing tokens face-up
             * This maximizes our current score using minimum power
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">power</span> <span class="o">&gt;=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">power</span> <span class="o">-=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>    <span class="c1">// Spend power</span>
                <span class="n">currentScore</span><span class="o">++;</span>           <span class="c1">// Gain one score</span>
                <span class="n">left</span><span class="o">++;</span>                   <span class="c1">// Move to next smallest token</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum score achieved after face-up plays</span>
            <span class="n">maxScore</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxScore</span><span class="o">,</span> <span class="n">currentScore</span><span class="o">);</span>

            <span class="cm">/* Face-down play:
             * If we can't play face-up but have score to spend,
             * play the largest remaining token face-down to gain more power
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">currentScore</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">power</span> <span class="o">+=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>   <span class="c1">// Gain power</span>
                <span class="n">currentScore</span><span class="o">--;</span>           <span class="c1">// Spend one score</span>
                <span class="n">right</span><span class="o">--;</span>                  <span class="c1">// Move to next largest token</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxScore</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Cannot play any token</span>
        <span class="c1">// Expected output: 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tokens1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">power1</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">bagOfTokensScore</span><span class="o">(</span><span class="n">tokens1</span><span class="o">,</span> <span class="n">power1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Can play one token face-up</span>
        <span class="c1">// Expected output: 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tokens2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">200</span><span class="o">,</span> <span class="mi">100</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">power2</span> <span class="o">=</span> <span class="mi">150</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">bagOfTokensScore</span><span class="o">(</span><span class="n">tokens2</span><span class="o">,</span> <span class="n">power2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Complex case with multiple plays</span>
        <span class="c1">// Expected output: 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tokens3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100</span><span class="o">,</span> <span class="mi">200</span><span class="o">,</span> <span class="mi">300</span><span class="o">,</span> <span class="mi">400</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">power3</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">bagOfTokensScore</span><span class="o">(</span><span class="n">tokens3</span><span class="o">,</span> <span class="n">power3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SingleSeqTwoPointersInward"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] denotes the value of tokeni. Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token): Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score. Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score. Return the maximum possible score you can achieve after playing any number of tokens.]]></summary></entry><entry><title type="html">1524. Number of Sub-arrays With Odd Sum</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfSubArraysWithOddSum/" rel="alternate" type="text/html" title="1524. Number of Sub-arrays With Odd Sum"/><published>2025-02-25T00:00:00+00:00</published><updated>2025-02-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfSubArraysWithOddSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfSubArraysWithOddSum/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">arr</code>, return <em>the number of subarrays with an <strong>odd</strong> sum</em>.</li> <li>Since the answer can be very large, return it modulo <code class="language-plaintext highlighter-rouge">10^9 + 7</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,3,5]
Output: 4
Explanation: All subarrays are [ [ 1],[1,3],[1,3,5],[3],[3,5],[5 ] ]
All sub-arrays sum are [1,4,9,3,8,5].
Odd sums are [1,9,3,5] so the answer is 4.

</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,4,6]
Output: 0
Explanation: All subarrays are [ [ 2],[2,4],[2,4,6],[4],[4,6],[6 ] ]
All sub-arrays sum are [2,6,12,4,10,6].
All sub-arrays have even sum and the answer is 0.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,3,4,5,6,7]
Output: 16
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSubArraysWithOddSum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numOfSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Define the modulo constant to handle large numbers</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="no">MODULO</span> <span class="o">=</span> <span class="mi">1000000007</span><span class="o">;</span>

        <span class="c1">// odd: count of prefix sums that are odd</span>
        <span class="c1">// even: count of prefix sums that are even, initialized to 1 (empty array sum is 0, which is even)</span>
        <span class="kt">int</span> <span class="n">odd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">even</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Variable to store the total count of subarrays with odd sum</span>
        <span class="kt">int</span> <span class="n">subarrays</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Variable to store the running prefix sum</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to prefix sum</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="cm">/* Key Logic:
             * 1. If current prefix sum is even:
             *    - To get odd sum subarray, we need previous odd prefix sums
             *    - Because even - odd = odd
             * 2. If current prefix sum is odd:
             *    - To get odd sum subarray, we need previous even prefix sums
             *    - Because odd - even = odd
             */</span>
            <span class="n">subarrays</span> <span class="o">=</span> <span class="o">(</span><span class="n">subarrays</span> <span class="o">+</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">odd</span> <span class="o">:</span> <span class="n">even</span><span class="o">))</span> <span class="o">%</span> <span class="no">MODULO</span><span class="o">;</span>

            <span class="c1">// Update the counts of odd and even prefix sums</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If current prefix sum is even, increment even count</span>
                <span class="n">even</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current prefix sum is odd, increment odd count</span>
                <span class="n">odd</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">subarrays</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output is 4</span>
        <span class="c1">// Subarrays with odd sum: [1], [1,3,5], [3], [5]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numOfSubarrays</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expected output is 0</span>
        <span class="c1">// All subarrays have even sum</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numOfSubarrays</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expected output is 16</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numOfSubarrays</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[Given an array of integers arr, return the number of subarrays with an odd sum. Since the answer can be very large, return it modulo 10^9 + 7.]]></summary></entry></feed>