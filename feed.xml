<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-22T07:45:00+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">453.Minimum Moves to Equal Array Elements</title><link href="https://zhengstar94.github.io//blog/2024/MinimumMovesToEqualArrayElements/" rel="alternate" type="text/html" title="453.Minimum Moves to Equal Array Elements"/><published>2024-10-22T00:00:00+00:00</published><updated>2024-10-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MinimumMovesToEqualArrayElements</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MinimumMovesToEqualArrayElements/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.</li> <li>In one move, you can increment <code class="language-plaintext highlighter-rouge">n - 1</code> elements of the array by <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumMovesToEqualArrayElements</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minMoves</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or array with length &lt;= 1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 1: Find the minimum value in the array</span>
        <span class="c1">// This is our target value that all other elements will eventually equal to</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Calculate the total moves needed</span>
        <span class="c1">// For each element, we need (current value - minimum value) moves to reach the minimum</span>
        <span class="kt">int</span> <span class="n">moves</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">moves</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">-</span> <span class="n">min</span><span class="o">;</span>  <span class="c1">// Add the difference between current element and minimum</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">moves</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test Case </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 8</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 6</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><summary type="html"><![CDATA[Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment n - 1 elements of the array by 1.]]></summary></entry><entry><title type="html">122. Best Time to Buy and Sell Stock II</title><link href="https://zhengstar94.github.io//blog/2024/BestTimeToBuyAndSellStockII/" rel="alternate" type="text/html" title="122. Best Time to Buy and Sell Stock II"/><published>2024-10-21T00:00:00+00:00</published><updated>2024-10-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/BestTimeToBuyAndSellStockII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/BestTimeToBuyAndSellStockII/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">prices</code> where <code class="language-plaintext highlighter-rouge">prices[i]</code> is the price of a given stock on the <code class="language-plaintext highlighter-rouge">ith</code> day.</li> <li>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</li> <li>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [ 7,1,5,3,6,4 ]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [ 1,2,3,4,5 ]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prices = [ 7,6,4,3,1 ]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/03/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BestTimeToBuyAndSellStockII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: If array is null or has less than 2 elements, no profit can be made</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Variable to keep track of total profit from all transactions</span>
        <span class="kt">int</span> <span class="n">totalProfit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array starting from index 1 to compare with previous day</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If today's price is higher than yesterday's price</span>
            <span class="c1">// We can make a profit by buying yesterday and selling today</span>
            <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="c1">// Add the price difference to our total profit</span>
                <span class="c1">// This is equivalent to buying at yesterday's price and selling at today's price</span>
                <span class="n">totalProfit</span> <span class="o">+=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">totalProfit</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution with example cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">prices1</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxProfit</span><span class="o">(</span><span class="n">prices1</span><span class="o">));</span>  <span class="c1">// Output: 7</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">prices2</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxProfit</span><span class="o">(</span><span class="n">prices2</span><span class="o">));</span>  <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><summary type="html"><![CDATA[You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.]]></summary></entry><entry><title type="html">377.Combination Sum IV</title><link href="https://zhengstar94.github.io//blog/2024/CombinationSumIV/" rel="alternate" type="text/html" title="377.Combination Sum IV"/><published>2024-10-20T00:00:00+00:00</published><updated>2024-10-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CombinationSumIV</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CombinationSumIV/"><![CDATA[<ul> <li>Given an array of <strong>distinct</strong> integers <code class="language-plaintext highlighter-rouge">nums</code> and a target integer <code class="language-plaintext highlighter-rouge">target</code>, return <em>the number of possible combinations that add up to</em> <code class="language-plaintext highlighter-rouge">target</code>.</li> <li>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [ 1,2,3 ], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [9], target = 3
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * target) time | O(target) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinationSumIV</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">combinationSum4</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a DP array where dp[i] will store the number of combinations to reach the sum i.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Base case: There is one way to make the sum 0, which is to choose nothing.</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each possible sum from 1 to the target.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For each number in the provided nums array.</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current sum i is greater than or equal to num,</span>
                <span class="c1">// it means we can use this num to help form the sum i.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Add the number of combinations to form the sum (i - num)</span>
                    <span class="c1">// to the current sum i. This is because each combination</span>
                    <span class="c1">// that makes up (i - num) can be extended to form the sum i</span>
                    <span class="c1">// by adding the current num.</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">num</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total combinations to reach the target sum.</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">target</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: nums = [ 1, 2, 3 ], target = 4</span>
        <span class="c1">// Expected output: 7</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">combinationSum4</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span> <span class="c1">// Output: 7</span>

        <span class="c1">// Test case 2: nums = [ 2, 1 ], target = 5</span>
        <span class="c1">// Expected output: 8</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">combinationSum4</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span> <span class="c1">// Output: 8</span>

        <span class="c1">// Test case 3: nums = [ 1 ], target = 0</span>
        <span class="c1">// Expected output: 1 (there is one way to sum to zero: choose nothing)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">combinationSum4</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 4: nums = [ 3, 5, 8 ], target = 10</span>
        <span class="c1">// Expected output: 1 (the only way is to choose 2 threes and one one, or two fives)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">target4</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">combinationSum4</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">target4</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 5: nums = [ 1, 4, 5 ], target = 6</span>
        <span class="c1">// Expected output: 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">target5</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">combinationSum4</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">target5</span><span class="o">));</span> <span class="c1">// Output: 6</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target. The test cases are generated so that the answer can fit in a 32-bit integer.]]></summary></entry><entry><title type="html">215.Kth Largest Element in an Array</title><link href="https://zhengstar94.github.io//blog/2024/KthLargestElementInAnArray/" rel="alternate" type="text/html" title="215.Kth Largest Element in an Array"/><published>2024-10-19T00:00:00+00:00</published><updated>2024-10-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/KthLargestElementInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/KthLargestElementInAnArray/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">kth</code> <em>largest element in the array</em>.</li> <li>Note that it is the <code class="language-plaintext highlighter-rouge">kth</code> largest element in the sorted order, not the <code class="language-plaintext highlighter-rouge">kth</code> distinct element.</li> <li>Can you solve it without sorting?</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(k)) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KthLargestElementInAnArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findKthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a min-heap (PriorityQueue by default is a min-heap)</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">minHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through all the elements in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Add the current number to the min-heap</span>
            <span class="n">minHeap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>

            <span class="c1">// If the heap size exceeds k, remove the smallest element from the heap</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">minHeap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">minHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The top element of the heap is the kth largest element</span>
        <span class="k">return</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">findKthLargest</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Output: 5</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">findKthLargest</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Output: 4</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">15</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">findKthLargest</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Output: 10</span>

        <span class="c1">// Test case 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">findKthLargest</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 5 (single element)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">99</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">findKthLargest</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">k5</span><span class="o">));</span> <span class="c1">// Output: 99</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><summary type="html"><![CDATA[Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?]]></summary></entry><entry><title type="html">236. Lowest Common Ancestor of a Binary Tree</title><link href="https://zhengstar94.github.io//blog/2024/LowestCommonAncestorOfABinaryTree/" rel="alternate" type="text/html" title="236. Lowest Common Ancestor of a Binary Tree"/><published>2024-10-19T00:00:00+00:00</published><updated>2024-10-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LowestCommonAncestorOfABinaryTree</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LowestCommonAncestorOfABinaryTree/"><![CDATA[<ul> <li>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</li> <li>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">q</code> as the lowest node in <code class="language-plaintext highlighter-rouge">T</code> that has both <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [ 3,5,1,6,2,0,8,null,null,7,4 ], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [ 3,5,1,6,2,0,8,null,null,7,4 ], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,2], p = 1, q = 2
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(h) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LowestCommonAncestorOfABinaryTree</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="nf">lowestCommonAncestor</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: If root is null or root matches either p or q, return root</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">root</span> <span class="o">||</span> <span class="n">q</span> <span class="o">==</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Recursively search for LCA in the left subtree</span>
        <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>

        <span class="c1">// Recursively search for LCA in the right subtree</span>
        <span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>

        <span class="c1">// If both left and right are not null, it means p and q are found in</span>
        <span class="c1">// different subtrees of the current root. Thus, the current root is the LCA.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span> <span class="c1">// Current root is the LCA</span>
        <span class="o">}</span>

        <span class="c1">// If one of the subtrees returned a non-null value, it means both p and q</span>
        <span class="c1">// are located in that subtree. If both are null, return null.</span>
        <span class="c1">// This will effectively return the found node (either left or right) or null.</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Build the binary tree</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node5</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node6</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node8</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node7</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

        <span class="c1">// Construct the tree by linking nodes</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node5</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
        <span class="n">node5</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node6</span><span class="o">;</span>
        <span class="n">node5</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
        <span class="n">node1</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node0</span><span class="o">;</span>
        <span class="n">node1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node8</span><span class="o">;</span>
        <span class="n">node2</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node7</span><span class="o">;</span>
        <span class="n">node2</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node4</span><span class="o">;</span>

        <span class="c1">// Test case 1: LCA of 5 and 0</span>
        <span class="nc">TreeNode</span> <span class="n">lca1</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">node5</span><span class="o">,</span> <span class="n">node0</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LCA of 5 and 0: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">lca1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lca1</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="s">"null"</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 2: LCA of 5 and 4</span>
        <span class="nc">TreeNode</span> <span class="n">lca2</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">node5</span><span class="o">,</span> <span class="n">node4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LCA of 5 and 4: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">lca2</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lca2</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="s">"null"</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 3: LCA of 6 and 4</span>
        <span class="nc">TreeNode</span> <span class="n">lca3</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">node6</span><span class="o">,</span> <span class="n">node4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LCA of 6 and 4: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">lca3</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lca3</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="s">"null"</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 4: LCA of 7 and 4</span>
        <span class="nc">TreeNode</span> <span class="n">lca4</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">node7</span><span class="o">,</span> <span class="n">node4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LCA of 7 and 4: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">lca4</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lca4</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="s">"null"</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 5: LCA of 2 and 4</span>
        <span class="nc">TreeNode</span> <span class="n">lca5</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">node2</span><span class="o">,</span> <span class="n">node4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LCA of 2 and 4: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">lca5</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lca5</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="s">"null"</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><summary type="html"><![CDATA[Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”]]></summary></entry><entry><title type="html">386.Lexicographical Numbers</title><link href="https://zhengstar94.github.io//blog/2024/LexicographicalNumbers/" rel="alternate" type="text/html" title="386.Lexicographical Numbers"/><published>2024-10-18T00:00:00+00:00</published><updated>2024-10-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LexicographicalNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LexicographicalNumbers/"><![CDATA[<ul> <li>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, return all the numbers in the range <code class="language-plaintext highlighter-rouge">[1, n]</code> sorted in lexicographical order.</li> <li>You must write an algorithm that runs in <code class="language-plaintext highlighter-rouge">O(n)</code> time and uses <code class="language-plaintext highlighter-rouge">O(1)</code> extra space.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 13
Output: [ 1,10,11,12,13,2,3,4,5,6,7,8,9 ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2
Output: [ 1,2 ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LexicographicalNumbers</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">lexicalOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a list to store the result</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Start DFS from each digit from 1 to 9</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> <span class="c1">// Return the result list</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Performs a depth-first search to generate numbers in lexicographical order.
     *
     * @param current the current number being formed
     * @param n the upper limit for valid numbers
     * @param result the list to store the valid lexicographical numbers
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">current</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the current number exceeds n, terminate this branch of recursion</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Add the current number to the result list</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>

        <span class="c1">// Attempt to extend the current number by adding digits 0 to 9</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Generate the next number by appending the digit i</span>
            <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">current</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// If the next number exceeds n, stop further exploration</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Recursively call dfs with the next number</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">next</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: n = 13</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">13</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">lexicalOrder</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 (n = 13): "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><summary type="html"><![CDATA[Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order. You must write an algorithm that runs in O(n) time and uses O(1) extra space.]]></summary></entry><entry><title type="html">349.Intersection of Two Arrays</title><link href="https://zhengstar94.github.io//blog/2024/IntersectionOfTwoArrays/" rel="alternate" type="text/html" title="349.Intersection of Two Arrays"/><published>2024-10-16T00:00:00+00:00</published><updated>2024-10-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/IntersectionOfTwoArrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/IntersectionOfTwoArrays/"><![CDATA[<ul> <li>Given two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [ 1,2,2,1 ], nums2 = [ 2,2 ]
Output: [2]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [ 4,9,5 ], nums2 = [ 9,4,9,8,4 ]
Output: [9,4]
Explanation: [4,9] is also accepted.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(min(n, m)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntersectionOfTwoArrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashSet to store unique elements from nums1</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Create a HashSet to store the intersection elements</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Add all elements from nums1 to set1 (automatically removes duplicates)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">set1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Check each element in nums2</span>
        <span class="c1">// If it exists in set1, it's an intersection element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set1</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">)){</span>
                <span class="n">resultSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert HashSet to array for return value</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">resultSet</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">resultSet</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method containing test cases
     * @param args command line arguments (not used)
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic test with duplicates</span>
        <span class="c1">// Expected output: [2]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: No intersection</span>
        <span class="c1">// Expected output: []</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">nums4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Multiple intersections</span>
        <span class="c1">// Expected output: [4,9]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums6</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">nums6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Empty array</span>
        <span class="c1">// Expected output: []</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums7</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums8</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums7</span><span class="o">,</span> <span class="n">nums8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Identical arrays</span>
        <span class="c1">// Expected output: [1,2,3]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums9</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums10</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result5</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums9</span><span class="o">,</span> <span class="n">nums10</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><summary type="html"><![CDATA[Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.]]></summary></entry><entry><title type="html">2. Add Two Numbers</title><link href="https://zhengstar94.github.io//blog/2024/AddTwoNumbers/" rel="alternate" type="text/html" title="2. Add Two Numbers"/><published>2024-10-14T00:00:00+00:00</published><updated>2024-10-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/AddTwoNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/AddTwoNumbers/"><![CDATA[<ul> <li>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</li> <li>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: l1 = [0], l2 = [0]
Output: [0]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(max(n, m)) time | O(max(n, m)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.LinkList</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddTwoNumbers</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a dummy head node to simplify the addition process</span>
        <span class="nc">ListNode</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="o">;</span>

        <span class="c1">// Initialize carry to 0</span>
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue loop while there are digits in either list or there's a carry</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Get the value of the current digit from l1, or 0 if l1 is null</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="c1">// Get the value of the current digit from l2, or 0 if l2 is null</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// Calculate the sum of current digits and the carry from the previous addition</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>

            <span class="c1">// Calculate the new carry for the next iteration</span>
            <span class="c1">// If sum &gt;= 10, carry will be 1; otherwise, it will be 0</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>

            <span class="c1">// Create a new node with the ones digit of the sum (sum % 10)</span>
            <span class="c1">// This effectively keeps only the ones digit and "carries" the tens digit</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

            <span class="c1">// Move to the next digits in the input lists, if available</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// After the main loop, check if there's still a carry left</span>
        <span class="c1">// This handles cases where the sum results in an additional digit</span>
        <span class="c1">// For example: 999 + 1 = 1000, so we need to add the final '1'</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the result, skipping the dummy head</span>
        <span class="k">return</span> <span class="n">dummyHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create the first linked list: 2 -&gt; 4 -&gt; 3 (representing 342)</span>
        <span class="nc">ListNode</span> <span class="n">l1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">l1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

        <span class="c1">// Create the second linked list: 5 -&gt; 6 -&gt; 4 (representing 465)</span>
        <span class="nc">ListNode</span> <span class="n">l2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">l2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
        <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

        <span class="c1">// Add the two numbers</span>
        <span class="nc">ListNode</span> <span class="n">result</span> <span class="o">=</span> <span class="n">addTwoNumbers</span><span class="o">(</span><span class="n">l1</span><span class="o">,</span> <span class="n">l2</span><span class="o">);</span>

        <span class="c1">// Print the result</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Result: "</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Expected output: 7 0 8 (representing 807, which is 342 + 465)</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode LinkedList"/><summary type="html"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.]]></summary></entry><entry><title type="html">138.Copy List with Random Pointer</title><link href="https://zhengstar94.github.io//blog/2024/CopyListWithRandomPointer/" rel="alternate" type="text/html" title="138.Copy List with Random Pointer"/><published>2024-10-13T00:00:00+00:00</published><updated>2024-10-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CopyListWithRandomPointer</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CopyListWithRandomPointer/"><![CDATA[<ul> <li>A linked list of length <code class="language-plaintext highlighter-rouge">n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code class="language-plaintext highlighter-rouge">null</code>.</li> <li>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code class="language-plaintext highlighter-rouge">n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code class="language-plaintext highlighter-rouge">next</code> and <code class="language-plaintext highlighter-rouge">random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</li> <li>For example, if there are two nodes <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> in the original list, where <code class="language-plaintext highlighter-rouge">X.random --&gt; Y</code>, then for the corresponding two nodes <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in the copied list, <code class="language-plaintext highlighter-rouge">x.random --&gt; y</code>.</li> <li>Return <em>the head of the copied linked list</em>.</li> <li>The linked list is represented in the input/output as a list of <code class="language-plaintext highlighter-rouge">n</code> nodes. Each node is represented as a pair of <code class="language-plaintext highlighter-rouge">[val, random_index]</code> where: <ul> <li><code class="language-plaintext highlighter-rouge">val</code>: an integer representing <code class="language-plaintext highlighter-rouge">Node.val</code></li> <li><code class="language-plaintext highlighter-rouge">random_index</code>: the index of the node (range from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>) that the <code class="language-plaintext highlighter-rouge">random</code> pointer points to, or <code class="language-plaintext highlighter-rouge">null</code> if it does not point to any node.</li> </ul> </li> <li>Your code will <strong>only</strong> be given the <code class="language-plaintext highlighter-rouge">head</code> of the original linked list.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [ [7,null],[13,0],[11,4],[10,2],[1,0] ]
Output: [ [7,null],[13,0],[11,4],[10,2],[1,0] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [ [1,1],[2,1] ]
Output: [ [1,1],[2,1] ]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [ [3,null],[3,0],[3,null] ]
Output: [ [3,null],[3,0],[3,null] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.LinkList</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyListWithRandomPointer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Node</span> <span class="nf">copyRandomList</span><span class="o">(</span><span class="nc">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> 
        <span class="o">}</span>

        <span class="c1">// Step 1: Create copy nodes and insert them after original nodes</span>
        <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Create a new node with the same value as the current node</span>
            <span class="nc">Node</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="c1">// Insert the new node right after the current node</span>
            <span class="n">copy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">copy</span><span class="o">;</span>
            <span class="c1">// Move to the next original node</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Set random pointers for the copy nodes</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the original node has a random pointer, set the copy's random pointer</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// curr.next is the copy of curr</span>
                <span class="c1">// curr.random.next is the copy of curr.random</span>
                <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">random</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Move to the next original node</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Separate the original and copied lists</span>
        <span class="nc">Node</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// Dummy node to start the copied list</span>
        <span class="nc">Node</span> <span class="n">copyCurr</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Connect the copy nodes</span>
            <span class="n">copyCurr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// Restore the original list connection</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// Move both pointers</span>
            <span class="n">copyCurr</span> <span class="o">=</span> <span class="n">copyCurr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Return the head of the copied list</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: [ [ 7,null],[13,0],[11,4],[10,2],[1,0] ]</span>
        <span class="nc">Node</span> <span class="n">head1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node13</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">13</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node11</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node10</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node13</span><span class="o">;</span>
        <span class="n">node13</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node11</span><span class="o">;</span>
        <span class="n">node11</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node10</span><span class="o">;</span>
        <span class="n">node10</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">node13</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">head1</span><span class="o">;</span>
        <span class="n">node11</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
        <span class="n">node10</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node11</span><span class="o">;</span>
        <span class="n">node1</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">head1</span><span class="o">;</span>

        <span class="nc">Node</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 passed: "</span> <span class="o">+</span> <span class="n">validateCopy</span><span class="o">(</span><span class="n">head1</span><span class="o">,</span> <span class="n">result1</span><span class="o">));</span>

        <span class="c1">// Test case 2: [ [ 1,1],[2,1] ]</span>
        <span class="nc">Node</span> <span class="n">head2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">head2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
        <span class="n">head2</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
        <span class="n">node2</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>

        <span class="nc">Node</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 passed: "</span> <span class="o">+</span> <span class="n">validateCopy</span><span class="o">(</span><span class="n">head2</span><span class="o">,</span> <span class="n">result2</span><span class="o">));</span>

        <span class="c1">// Test case 3: [ [ 3,null],[3,0],[3,null] ]</span>
        <span class="nc">Node</span> <span class="n">head3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node3_2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node3_3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">head3</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node3_2</span><span class="o">;</span>
        <span class="n">node3_2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node3_3</span><span class="o">;</span>
        <span class="n">head3</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">node3_2</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">head3</span><span class="o">;</span>
        <span class="n">node3_3</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="nc">Node</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 passed: "</span> <span class="o">+</span> <span class="n">validateCopy</span><span class="o">(</span><span class="n">head3</span><span class="o">,</span> <span class="n">result3</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validateCopy</span><span class="o">(</span><span class="nc">Node</span> <span class="n">original</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">copy</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">original</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">copy</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">original</span><span class="o">.</span><span class="na">random</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span><span class="o">.</span><span class="na">random</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">original</span><span class="o">.</span><span class="na">random</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">copy</span><span class="o">.</span><span class="na">random</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">original</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">original</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">random</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode LinkedList"/><summary type="html"><![CDATA[A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random --&gt; y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list.]]></summary></entry><entry><title type="html">567.Permutation in String</title><link href="https://zhengstar94.github.io//blog/2024/PermutationInString/" rel="alternate" type="text/html" title="567.Permutation in String"/><published>2024-10-12T00:00:00+00:00</published><updated>2024-10-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PermutationInString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PermutationInString/"><![CDATA[<ul> <li>Given two strings <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code>, return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">s2</code> contains a permutation of <code class="language-plaintext highlighter-rouge">s1</code>, or <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li> <li>In other words, return <code class="language-plaintext highlighter-rouge">true</code> if one of <code class="language-plaintext highlighter-rouge">s1</code>’s permutations is the substring of <code class="language-plaintext highlighter-rouge">s2</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "ab", s2 = "eidboaoo"
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PermutationInString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkInclusion</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If s1 is longer than s2, it's impossible for s1's permutation to be in s2</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Arrays to store character frequencies</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Count the frequency of characters in s1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s1</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count1</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Sliding window approach</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add the current character to count2</span>
            <span class="n">count2</span><span class="o">[</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>

            <span class="c1">// IMPORTANT: Remove the leftmost character of the previous window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// i - s1.length() gives the index of the character to be removed</span>
                <span class="c1">// This ensures that we maintain a window of size s1.length()</span>
                <span class="n">count2</span><span class="o">[</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the current window is a permutation of s1</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">count1</span><span class="o">,</span> <span class="n">count2</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no permutation is found</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"eidbaooo"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 2</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"eidboaoo"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test case 3</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"adc"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"dcda"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 4</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"ooolleoooleh"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test case 5</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><summary type="html"><![CDATA[Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1’s permutations is the substring of s2.]]></summary></entry></feed>