<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-26T04:26:31+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2001. Number of Pairs of Interchangeable Rectangles</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles/" rel="alternate" type="text/html" title="2001. Number of Pairs of Interchangeable Rectangles"/><published>2025-07-26T00:00:00+00:00</published><updated>2025-07-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfPairsOfInterchangeableRectangles/"><![CDATA[<ul> <li>You are given <code class="language-plaintext highlighter-rouge">n</code> rectangles represented by a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">rectangles</code>, where <code class="language-plaintext highlighter-rouge">rectangles[i] = [widthi, heighti]</code> denotes the width and height of the <code class="language-plaintext highlighter-rouge">ith</code> rectangle.</li> <li>Two rectangles <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> (<code class="language-plaintext highlighter-rouge">i &lt; j</code>) are considered <strong>interchangeable</strong> if they have the <strong>same</strong> width-to-height ratio. More formally, two rectangles are <strong>interchangeable</strong> if <code class="language-plaintext highlighter-rouge">widthi/heighti == widthj/heightj</code> (using decimal division, not integer division).</li> <li>Return <em>the <strong>number</strong> of pairs of <strong>interchangeable</strong> rectangles in</em> <code class="language-plaintext highlighter-rouge">rectangles</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rectangles = [ [ 4,8],[3,6],[10,20],[15,30 ] ]
Output: 6
Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed):
- Rectangle 0 with rectangle 1: 4/8 == 3/6.
- Rectangle 0 with rectangle 2: 4/8 == 10/20.
- Rectangle 0 with rectangle 3: 4/8 == 15/30.
- Rectangle 1 with rectangle 2: 3/6 == 10/20.
- Rectangle 1 with rectangle 3: 3/6 == 15/30.
- Rectangle 2 with rectangle 3: 10/20 == 15/30.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rectangles = [ [ 4,5],[7,8 ] ]
Output: 0
Explanation: There are no interchangeable pairs of rectangles.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfPairsOfInterchangeableRectangles</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">interchangeableRectangles</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the final answer: the total number of interchangeable pairs.</span>

        <span class="c1">// This HashMap will store, for each unique ratio, how many times it has appeared so far.</span>
        <span class="c1">// Key: the ratio (width / height) as a double.</span>
        <span class="c1">// Value: the count of rectangles seen so far with this ratio.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each rectangle in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">rect:</span> <span class="n">rectangles</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the ratio of width to height for the current rectangle.</span>
            <span class="c1">// Multiplying by 1.0 ensures the division is floating-point, not integer division.</span>
            <span class="kt">double</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">rect</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rect</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// For the current rectangle, check how many rectangles with the same ratio have already been seen.</span>
            <span class="c1">// Each such rectangle can form a unique pair with the current one.</span>
            <span class="c1">// So, add the count of rectangles with this ratio to the answer.</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Update the map: increment the count for this ratio by 1,</span>
            <span class="c1">// because we've now seen one more rectangle with this ratio.</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After processing all rectangles, return the total number of interchangeable pairs found.</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: rectangles with the same ratio (4/8 = 3/6 = 10/20 = 15/30 = 0.5)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">},{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">},{</span><span class="mi">15</span><span class="o">,</span><span class="mi">30</span> <span class="o">}</span> <span class="o">};</span>
        <span class="c1">// Example 2: rectangles with different ratios (4/5 != 7/8)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">rectangles2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">},{</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span> <span class="o">}</span> <span class="o">};</span>

        <span class="c1">// Output the results for both examples.</span>
        <span class="c1">// For rectangles1, the output should be 6 (all rectangles are interchangeable).</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">interchangeableRectangles</span><span class="o">(</span><span class="n">rectangles1</span><span class="o">));</span> <span class="c1">// Output: 6</span>

        <span class="c1">// For rectangles2, the output should be 0 (no interchangeable pairs).</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">interchangeableRectangles</span><span class="o">(</span><span class="n">rectangles2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle. Two rectangles i and j (i &lt; j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division). Return the number of pairs of interchangeable rectangles in rectangles.]]></summary></entry><entry><title type="html">3487. Maximum Unique Subarray Sum After Deletion</title><link href="https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion/" rel="alternate" type="text/html" title="3487. Maximum Unique Subarray Sum After Deletion"/><published>2025-07-25T00:00:00+00:00</published><updated>2025-07-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumUniqueSubarraySumAfterDeletion/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>You are allowed to delete any number of elements from <code class="language-plaintext highlighter-rouge">nums</code> without making it <strong>empty</strong>. After performing the deletions, select a subarray of <code class="language-plaintext highlighter-rouge">nums</code> such that: <ul> <li>All elements in the subarray are <strong>unique</strong>.</li> <li>The sum of the elements in the subarray is <strong>maximized</strong>.</li> </ul> </li> <li>Return the <strong>maximum sum</strong> of such a subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,5]
Output: 15

Explanation:

Select the entire array without deleting any element to obtain the maximum sum.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,1,1]
Output: 1

Explanation:

Delete the element nums[0] == 1, nums[1] == 1, nums[2] == 0, and nums[3] == 1. Select the entire array [1] to obtain the maximum sum.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,-1,-2,1,0,-1]
Output: 3

Explanation:

Delete the elements nums[2] == -1 and nums[3] == -2, and select the subarray [2, 1] from [1, 2, 1, 0, -1] to obtain the maximum sum.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumUniqueSubarraySumAfterDeletion</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This set is used to store unique positive numbers encountered in the array.</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// This variable accumulates the sum of all unique positive numbers.</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// This variable keeps track of the largest negative number in the array.</span>
        <span class="c1">// It is initialized to the smallest possible integer value.</span>
        <span class="kt">int</span> <span class="n">maxNegative</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="c1">// Traverse each element in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current number is negative, update maxNegative if this number is larger.</span>
                <span class="c1">// This is important for the case where all numbers are negative.</span>
                <span class="n">maxNegative</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxNegative</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If the current number is non-negative and not already in the set (i.e., unique),</span>
                <span class="c1">// add it to the set and add its value to the sum.</span>
                <span class="c1">// Only the first occurrence of each positive number is counted.</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If the number is non-negative but already in the set, it is skipped (no duplicate allowed).</span>
        <span class="o">}</span>

        <span class="c1">// If the set is empty, it means there were no non-negative numbers in the array.</span>
        <span class="c1">// In this case, return the largest negative number found.</span>
        <span class="c1">// Otherwise, return the sum of all unique positive numbers.</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="n">maxNegative</span> <span class="o">:</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">};</span>

        <span class="c1">// Test case 1: All unique positive numbers, should return 15 (1+2+3+4+5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 15</span>

        <span class="c1">// Test case 2: Only one unique non-negative number (1), should return 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 3: Mixed numbers, unique non-negative numbers are 1, 2, 0, sum is 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 3</span>

        <span class="c1">// Test case 4: All negative numbers, should return the largest one (-2)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Output: -2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums. You are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that: All elements in the subarray are unique. The sum of the elements in the subarray is maximized. Return the maximum sum of such a subarray.]]></summary></entry><entry><title type="html">2441. Largest Positive Integer That Exists With Its Negative</title><link href="https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative/" rel="alternate" type="text/html" title="2441. Largest Positive Integer That Exists With Its Negative"/><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LargestPositiveIntegerThatExistsWithItsNegative/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> that <strong>does not contain</strong> any zeros, find <strong>the largest positive</strong> integer <code class="language-plaintext highlighter-rouge">k</code> such that <code class="language-plaintext highlighter-rouge">-k</code> also exists in the array.</li> <li>Return <em>the positive integer</em> <code class="language-plaintext highlighter-rouge">k</code>. If there is no such integer, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,2,-3,3]
Output: 3
Explanation: 3 is the only valid k we can find in the array.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,10,6,7,-7,1]
Output: 7
Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-10,8,6,7,-2,-3]
Output: -1
Explanation: There is no a single valid k, we return -1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LargestPositiveIntegerThatExistsWithItsNegative</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashSet to store all numbers seen so far for quick lookup</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Initialize maxK to -1, which will be returned if no valid k is found</span>
        <span class="kt">int</span> <span class="n">maxK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if the opposite number (-num) has already been seen</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(-</span><span class="n">num</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If so, update maxK to the larger value between current maxK and |num|</span>
                <span class="c1">// Math.abs(num) ensures we always consider the positive value</span>
                <span class="n">maxK</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxK</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="c1">// Add the current number to the set for future lookups</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After checking all numbers, return the result</span>
        <span class="k">return</span> <span class="n">maxK</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: Both 3 and -3 exist, so the answer is 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="c1">// Example 2: Both 7 and -7 exist, so the answer is 7</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Example 3: No number has its negative, so the answer is -1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">10</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">};</span>

        <span class="c1">// Print the results of each test case</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 7</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findMaxK</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: -1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array. Return the positive integer k. If there is no such integer, return -1.]]></summary></entry><entry><title type="html">1512. Number of Good Pairs</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfGoodPairs/" rel="alternate" type="text/html" title="1512. Number of Good Pairs"/><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfGoodPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfGoodPairs/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the number of <strong>good pairs</strong></em>.</li> <li>A pair <code class="language-plaintext highlighter-rouge">(i, j)</code> is called <em>good</em> if <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code> and <code class="language-plaintext highlighter-rouge">i</code> &lt; <code class="language-plaintext highlighter-rouge">j</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1]
Output: 6
Explanation: Each pair in the array are good.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfGoodPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numIdenticalPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to store the count of each number encountered so far.</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// This variable will store the total number of good pairs found.</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For the current number, get how many times it has appeared before.</span>
            <span class="c1">// Each previous occurrence can form a good pair with the current index.</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Update the count of the current number in the map.</span>
            <span class="c1">// If the number is not present, start from 0 and add 1.</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// After processing all numbers, return the total count of good pairs.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: There are 4 good pairs: (0,3), (0,4), (3,4), (2,5)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="c1">// Test case 2: All pairs are good, total is 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Test case 3: No good pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>

        <span class="c1">// Print the results for each test case</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIdenticalPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIdenticalPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Output: 6</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIdenticalPairs</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i &lt; j.]]></summary></entry><entry><title type="html">1233. Remove Sub-Folders from the Filesystem</title><link href="https://zhengstar94.github.io//blog/2025/RemoveSubFoldersFromTheFilesystem/" rel="alternate" type="text/html" title="1233. Remove Sub-Folders from the Filesystem"/><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RemoveSubFoldersFromTheFilesystem</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RemoveSubFoldersFromTheFilesystem/"><![CDATA[<ul> <li>Given a list of folders <code class="language-plaintext highlighter-rouge">folder</code>, return <em>the folders after removing all <strong>sub-folders</strong> in those folders</em>. You may return the answer in <strong>any order</strong>.</li> <li>If a <code class="language-plaintext highlighter-rouge">folder[i]</code> is located within another <code class="language-plaintext highlighter-rouge">folder[j]</code>, it is called a <strong>sub-folder</strong> of it. A sub-folder of <code class="language-plaintext highlighter-rouge">folder[j]</code> must start with <code class="language-plaintext highlighter-rouge">folder[j]</code>, followed by a <code class="language-plaintext highlighter-rouge">"/"</code>. For example, <code class="language-plaintext highlighter-rouge">"/a/b"</code> is a sub-folder of <code class="language-plaintext highlighter-rouge">"/a"</code>, but <code class="language-plaintext highlighter-rouge">"/b"</code> is not a sub-folder of <code class="language-plaintext highlighter-rouge">"/a/b/c"</code>.</li> <li>The format of a path is one or more concatenated strings of the form: <code class="language-plaintext highlighter-rouge">'/'</code> followed by one or more lowercase English letters. <ul> <li>For example, <code class="language-plaintext highlighter-rouge">"/leetcode"</code> and <code class="language-plaintext highlighter-rouge">"/leetcode/problems"</code> are valid paths while an empty string and <code class="language-plaintext highlighter-rouge">"/"</code> are not.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
Output: ["/a","/c/d","/c/f"]
Explanation: Folders "/a/b" is a subfolder of "/a" and "/c/d/e" is inside of folder "/c/d" in our filesystem.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: folder = ["/a","/a/b/c","/a/b/d"]
Output: ["/a"]
Explanation: Folders "/a/b/c" and "/a/b/d" will be removed because they are subfolders of "/a".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
Output: ["/a/b/c","/a/b/ca","/a/b/d"]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n * m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveSubFoldersFromTheFilesystem</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">removeSubfolders</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">folder</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Sort the folder paths lexicographically.</span>
        <span class="c1">// This ensures that any parent folder comes before its subfolders.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">folder</span><span class="o">);</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// This variable keeps track of the last added parent folder.</span>
        <span class="nc">String</span> <span class="n">prev</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

        <span class="c1">// Step 2: Iterate through each folder path.</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">path</span> <span class="o">:</span> <span class="n">folder</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Key logic:</span>
            <span class="c1">// If 'prev' is empty, this is the first folder, so add it directly.</span>
            <span class="c1">// Otherwise, check if the current path is NOT a subfolder of 'prev'.</span>
            <span class="c1">// To be a subfolder, the path must start with 'prev' followed by a '/'.</span>
            <span class="c1">// Example: prev = "/a", path = "/a/b" -&gt; "/a/b".startsWith("/a/") == true (subfolder)</span>
            <span class="c1">//          prev = "/a", path = "/ab"  -&gt; "/ab".startsWith("/a/") == false (not a subfolder)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prev</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">path</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="n">prev</span> <span class="o">+</span> <span class="s">"/"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If not a subfolder, add to result and update 'prev'</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">path</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If it is a subfolder (startsWith(prev + "/")), skip it.</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Return the filtered list of folders.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Some folders are subfolders of others</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/a"</span><span class="o">,</span><span class="s">"/a/b"</span><span class="o">,</span><span class="s">"/c/d"</span><span class="o">,</span><span class="s">"/c/d/e"</span><span class="o">,</span><span class="s">"/c/f"</span><span class="o">};</span>
        <span class="c1">// Expected output: ["/a", "/c/d", "/c/f"]</span>

        <span class="c1">// Test case 2: All folders are subfolders of the first one</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/a"</span><span class="o">,</span><span class="s">"/a/b/c"</span><span class="o">,</span><span class="s">"/a/b/d"</span><span class="o">};</span>
        <span class="c1">// Expected output: ["/a"]</span>

        <span class="c1">// Test case 3: No folder is a subfolder of another</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/a/b/c"</span><span class="o">,</span><span class="s">"/a/b/ca"</span><span class="o">,</span><span class="s">"/a/b/d"</span><span class="o">};</span>
        <span class="c1">// Expected output: ["/a/b/c", "/a/b/ca", "/a/b/d"]</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeSubfolders</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Output: ["/a", "/c/d", "/c/f"]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeSubfolders</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Output: ["/a"]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeSubfolders</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// Output: ["/a/b/c", "/a/b/ca", "/a/b/d"]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. A sub-folder of folder[j] must start with folder[j], followed by a "/". For example, "/a/b" is a sub-folder of "/a", but "/b" is not a sub-folder of "/a/b/c". The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters. For example, "/leetcode" and "/leetcode/problems" are valid paths while an empty string and "/" are not.]]></summary></entry><entry><title type="html">3136. Valid Word</title><link href="https://zhengstar94.github.io//blog/2025/ValidWord/" rel="alternate" type="text/html" title="3136. Valid Word"/><published>2025-07-15T00:00:00+00:00</published><updated>2025-07-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ValidWord</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ValidWord/"><![CDATA[<ul> <li>A word is considered <strong>valid</strong> if: <ul> <li>It contains a <strong>minimum</strong> of 3 characters.</li> <li>It contains only digits (0-9), and English letters (uppercase and lowercase).</li> <li>It includes <strong>at least</strong> one <strong>vowel</strong>.</li> <li>It includes <strong>at least</strong> one <strong>consonant</strong>.</li> </ul> </li> <li>You are given a string <code class="language-plaintext highlighter-rouge">word</code>.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">word</code> is valid, otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> <li><strong>Notes:</strong> <ul> <li><code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'e'</code>, <code class="language-plaintext highlighter-rouge">'i'</code>, <code class="language-plaintext highlighter-rouge">'o'</code>, <code class="language-plaintext highlighter-rouge">'u'</code>, and their uppercases are <strong>vowels</strong>.</li> <li>A <strong>consonant</strong> is an English letter that is not a vowel.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "234Adas"

Output: true

Explanation:

This word satisfies the conditions.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "b3"

Output: false

Explanation:

The length of this word is fewer than 3, and does not have a vowel.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "a3$e"

Output: false

Explanation:

This word contains a '$' character and does not have a consonant.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidWord</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the word has fewer than 3 characters, it is automatically invalid.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Flags to track if at least one vowel and one consonant are present.</span>
        <span class="kt">boolean</span> <span class="n">hasVowel</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">hasConsonant</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="c1">// String containing all vowels (both lowercase and uppercase).</span>
        <span class="nc">String</span> <span class="n">vowels</span> <span class="o">=</span> <span class="s">"aeiouAEIOU"</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the word.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Check if the character is a letter.</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// If the character is a vowel, set hasVowel to true.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">vowels</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">hasVowel</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// If the character is a letter but not a vowel, it's a consonant.</span>
                    <span class="n">hasConsonant</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// If the character is neither a letter nor a digit, the word is invalid.</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If the character is a digit, do nothing (digits are allowed).</span>
        <span class="o">}</span>

        <span class="c1">// The word is valid only if it contains at least one vowel and one consonant.</span>
        <span class="c1">// Note: Use logical AND (&amp;&amp;) to ensure both conditions are met.</span>
        <span class="k">return</span> <span class="n">hasVowel</span> <span class="o">&amp;&amp;</span> <span class="n">hasConsonant</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to verify the implementation.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"234Adas"</span><span class="o">));</span> <span class="c1">// true: meets all conditions</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"b3"</span><span class="o">));</span>      <span class="c1">// false: too short and no vowel</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"a3$e"</span><span class="o">));</span>    <span class="c1">// false: contains invalid character '$'</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[A word is considered valid if: It contains a minimum of 3 characters. It contains only digits (0-9), and English letters (uppercase and lowercase). It includes at least one vowel. It includes at least one consonant. You are given a string word. Return true if word is valid, otherwise, return false. Notes: 'a', 'e', 'i', 'o', 'u', and their uppercases are vowels. A consonant is an English letter that is not a vowel.]]></summary></entry><entry><title type="html">1290. Convert Binary Number in a Linked List to Integer</title><link href="https://zhengstar94.github.io//blog/2025/ConvertBinaryNumberInALinkedListToInteger/" rel="alternate" type="text/html" title="1290. Convert Binary Number in a Linked List to Integer"/><published>2025-07-14T00:00:00+00:00</published><updated>2025-07-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ConvertBinaryNumberInALinkedListToInteger</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ConvertBinaryNumberInALinkedListToInteger/"><![CDATA[<ul> <li>Given <code class="language-plaintext highlighter-rouge">head</code> which is a reference node to a singly-linked list. The value of each node in the linked list is either <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">1</code>. The linked list holds the binary representation of a number.</li> <li>Return the <em>decimal value</em> of the number in the linked list.</li> <li>The <strong>most significant bit</strong> is at the head of the linked list.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [0]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.LinkList</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/14
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConvertBinaryNumberInALinkedListToInteger</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getDecimalValue</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the final decimal result.</span>

        <span class="c1">// Traverse the linked list from head to tail.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Shift the current result left by 1 bit (multiply by 2).</span>
            <span class="c1">// This makes space for the next bit at the least significant position.</span>
            <span class="c1">// Then add the current node's value (0 or 1) to the result.</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

            <span class="c1">// Move to the next node in the list.</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// After traversing all nodes, 'res' contains the decimal value.</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: Linked list [1,0,1] represents binary 101, which is 5 in decimal.</span>
        <span class="nc">ListNode</span> <span class="n">head1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getDecimalValue</span><span class="o">(</span><span class="n">head1</span><span class="o">));</span> <span class="c1">// Output: 5</span>

        <span class="c1">// Example 2: Linked list [0] represents binary 0, which is 0 in decimal.</span>
        <span class="nc">ListNode</span> <span class="n">head2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getDecimalValue</span><span class="o">(</span><span class="n">head2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode LinkedList"/><category term="Easy"/><summary type="html"><![CDATA[Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list.]]></summary></entry><entry><title type="html">2410. Maximum Matching of Players With Trainers</title><link href="https://zhengstar94.github.io//blog/2025/MaximumMatchingOfPlayersWithTrainers/" rel="alternate" type="text/html" title="2410. Maximum Matching of Players With Trainers"/><published>2025-07-13T00:00:00+00:00</published><updated>2025-07-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumMatchingOfPlayersWithTrainers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumMatchingOfPlayersWithTrainers/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">players</code>, where <code class="language-plaintext highlighter-rouge">players[i]</code> represents the <strong>ability</strong> of the <code class="language-plaintext highlighter-rouge">ith</code> player.</li> <li>You are also given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">trainers</code>, where <code class="language-plaintext highlighter-rouge">trainers[j]</code> represents the <strong>training capacity</strong> of the <code class="language-plaintext highlighter-rouge">jth</code> trainer.</li> <li>The <code class="language-plaintext highlighter-rouge">ith</code> player can <strong>match</strong> with the <code class="language-plaintext highlighter-rouge">jth</code> trainer if the player’s ability is <strong>less than or equal to</strong> the trainer’s training capacity. Additionally, the <code class="language-plaintext highlighter-rouge">ith</code> player can be matched with at most one trainer, and the <code class="language-plaintext highlighter-rouge">jth</code> trainer can be matched with at most one player.</li> <li>Return <em>the <strong>maximum</strong> number of matchings between</em> <code class="language-plaintext highlighter-rouge">players</code> <em>and</em> <code class="language-plaintext highlighter-rouge">trainers</code> <em>that satisfy these conditions.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: players = [4,7,9], trainers = [8,2,5,8]
Output: 2
Explanation:
One of the ways we can form two matchings is as follows:
- players[0] can be matched with trainers[0] since 4 &lt;= 8.
- players[1] can be matched with trainers[3] since 7 &lt;= 8.
It can be proven that 2 is the maximum number of matchings that can be formed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: players = [1,1,1], trainers = [10]
Output: 1
Explanation:
The trainer can be matched with any of the 3 players.
Each player can only be matched with one trainer, so the maximum answer is 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn + mlogm) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumMatchingOfPlayersWithTrainers</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">matchPlayersAndTrainers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">players</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">trainers</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort both arrays in ascending order.</span>
        <span class="c1">// This allows us to use the greedy strategy: always try to match the weakest available player</span>
        <span class="c1">// with the weakest available trainer who can train them.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">players</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">trainers</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for players array</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for trainers array</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Counter for successful matchings</span>

        <span class="c1">// Use two pointers to traverse both arrays</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">players</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">trainers</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the current player can be matched with the current trainer</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">players</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">trainers</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Successful match: increment the count</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="c1">// Move to the next player and the next trainer</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If the current trainer is too weak for the current player,</span>
                <span class="c1">// try the next trainer (since trainers are sorted, no later trainer will be weaker)</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the total number of successful matchings</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output is 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">players1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">trainers1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">matchPlayersAndTrainers</span><span class="o">(</span><span class="n">players1</span><span class="o">,</span> <span class="n">trainers1</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="c1">// Test case 2: Expected output is 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">players2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">trainers2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">matchPlayersAndTrainers</span><span class="o">(</span><span class="n">players2</span><span class="o">,</span> <span class="n">trainers2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer. The ith player can match with the jth trainer if the player’s ability is less than or equal to the trainer’s training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player. Return the maximum number of matchings between players and trainers that satisfy these conditions.]]></summary></entry><entry><title type="html">3169. Count Days Without Meetings</title><link href="https://zhengstar94.github.io//blog/2025/CountDaysWithoutMeetings/" rel="alternate" type="text/html" title="3169. Count Days Without Meetings"/><published>2025-07-11T00:00:00+00:00</published><updated>2025-07-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountDaysWithoutMeetings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountDaysWithoutMeetings/"><![CDATA[<ul> <li>You are given a positive integer <code class="language-plaintext highlighter-rouge">days</code> representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array <code class="language-plaintext highlighter-rouge">meetings</code> of size <code class="language-plaintext highlighter-rouge">n</code> where, <code class="language-plaintext highlighter-rouge">meetings[i] = [start_i, end_i]</code> represents the starting and ending days of meeting <code class="language-plaintext highlighter-rouge">i</code> (inclusive).</li> <li>Return the count of days when the employee is available for work but no meetings are scheduled.</li> <li><strong>Note:</strong> The meetings may overlap.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: days = 10, meetings = [ [ 5,7],[1,3],[9,10 ] ]

Output: 2

Explanation:

There is no meeting scheduled on the 4th and 8th days.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: days = 5, meetings = [ [ 2,4],[1,3 ] ]

Output: 1

Explanation:

There is no meeting scheduled on the 5th day.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: days = 6, meetings = [ [ 1,6 ] ]

Output: 0

Explanation:

Meetings are scheduled for all working days.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountDaysWithoutMeetings</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countDays</span><span class="o">(</span><span class="kt">int</span> <span class="n">days</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the meetings by their start day in ascending order.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">meetings</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">q</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// 'start' and 'end' represent the current merged meeting interval.</span>
        <span class="c1">// Initialize 'start' to 1 (the first day), and 'end' to 0 (no interval yet).</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each meeting interval.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">p</span> <span class="o">:</span> <span class="n">meetings</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the current meeting starts after the end of the last merged interval,</span>
            <span class="c1">// it means there is a gap (no meeting) between intervals.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">end</span><span class="o">){</span>
                <span class="c1">// Subtract the number of days covered by the previous merged interval from 'days'.</span>
                <span class="c1">// (end - start + 1) is the length of the previous interval.</span>
                <span class="n">days</span> <span class="o">-=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="c1">// Start a new merged interval from the current meeting's start day.</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">p</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="c1">// Extend the end of the current merged interval if needed.</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">p</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">// After the loop, subtract the days covered by the last merged interval.</span>
        <span class="n">days</span> <span class="o">-=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// The remaining 'days' is the number of days without any meetings.</span>
        <span class="k">return</span> <span class="n">days</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span> <span class="n">days1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countDays</span><span class="o">(</span><span class="n">days1</span><span class="o">,</span> <span class="n">meetings1</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span> <span class="n">days2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countDays</span><span class="o">(</span><span class="n">days2</span><span class="o">,</span> <span class="n">meetings2</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span> <span class="n">days3</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">6</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countDays</span><span class="o">(</span><span class="n">days3</span><span class="o">,</span> <span class="n">meetings3</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive). Return the count of days when the employee is available for work but no meetings are scheduled. Note: The meetings may overlap.]]></summary></entry><entry><title type="html">3439. Reschedule Meetings for Maximum Free Time I</title><link href="https://zhengstar94.github.io//blog/2025/RescheduleMeetingsForMaximumFreeTimeI/" rel="alternate" type="text/html" title="3439. Reschedule Meetings for Maximum Free Time I"/><published>2025-07-09T00:00:00+00:00</published><updated>2025-07-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RescheduleMeetingsForMaximumFreeTimeI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RescheduleMeetingsForMaximumFreeTimeI/"><![CDATA[<ul> <li> <p>You are given an integer <code class="language-plaintext highlighter-rouge">eventTime</code> denoting the duration of an event, where the event occurs from time <code class="language-plaintext highlighter-rouge">t = 0</code> to time <code class="language-plaintext highlighter-rouge">t = eventTime</code>.</p> </li> <li> <p>You are also given two integer arrays <code class="language-plaintext highlighter-rouge">startTime</code> and <code class="language-plaintext highlighter-rouge">endTime</code>, each of length <code class="language-plaintext highlighter-rouge">n</code>. These represent the start and end time of <code class="language-plaintext highlighter-rouge">n</code> <strong>non-overlapping</strong> meetings, where the <code class="language-plaintext highlighter-rouge">ith</code> meeting occurs during the time <code class="language-plaintext highlighter-rouge">[startTime[i], endTime[i]]</code>.</p> </li> <li> <p>You can reschedule <strong>at most</strong> <code class="language-plaintext highlighter-rouge">k</code> meetings by moving their start time while maintaining the <strong>same duration</strong>, to <strong>maximize</strong> the <strong>longest</strong> <em>continuous period of free time</em> during the event.</p> </li> <li> <p>The <strong>relative</strong> order of all the meetings should stay the <em>same</em> and they should remain non-overlapping.</p> <p>Return the <strong>maximum</strong> amount of free time possible after rearranging the meetings.</p> <p><strong>Note</strong> that the meetings can <strong>not</strong> be rescheduled to a time outside the event.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: eventTime = 5, k = 1, startTime = [1,3], endTime = [2,5]
Output: 2

Explanation:

Reschedule the meeting at [1, 2] to [2, 3], leaving no meetings during the time [0, 2].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: eventTime = 10, k = 1, startTime = [0,2,9], endTime = [1,4,10]

Output: 6

Explanation:

Reschedule the meeting at [2, 4] to [1, 3], leaving no meetings during the time [3, 9].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: eventTime = 5, k = 2, startTime = [0,1,2,3,4], endTime = [1,2,3,4,5]

Output: 0

Explanation:

There is no time during the event not occupied by meetings.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/09
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RescheduleMeetingsForMaximumFreeTimeI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxFreeTime</span><span class="o">(</span><span class="kt">int</span> <span class="n">eventTime</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">startTime</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">endTime</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">startTime</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// The gaps array stores all free time intervals between meetings and at the boundaries.</span>
        <span class="c1">// gaps[0]: Free time from the start of the event to the first meeting.</span>
        <span class="c1">// gaps[i]: Free time between the end of meeting i-1 and the start of meeting i.</span>
        <span class="c1">// gaps[n]: Free time from the end of the last meeting to the end of the event.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">gaps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="n">gaps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">startTime</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Free time before the first meeting.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">gaps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">startTime</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">endTime</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// Free time between consecutive meetings.</span>
        <span class="o">}</span>
        <span class="n">gaps</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">eventTime</span> <span class="o">-</span> <span class="n">endTime</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// Free time after the last meeting.</span>

        <span class="c1">// Use a sliding window of size k+1 to merge k+1 consecutive free intervals.</span>
        <span class="kt">int</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Calculate the sum of the first window.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">gaps</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">windowSum</span><span class="o">;</span>
        <span class="c1">// Slide the window across the gaps array, updating the sum and tracking the maximum.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gaps</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">gaps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">gaps</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">windowSum</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">eventTime</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">startTime</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">endTime</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="c1">// Expected output: 6</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxFreeTime</span><span class="o">(</span><span class="n">eventTime</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">startTime</span><span class="o">,</span> <span class="n">endTime</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer eventTime denoting the duration of an event, where the event occurs from time t=0 to time t=eventTime.]]></summary></entry></feed>