<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-27T05:32:28+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">3392. Count Subarrays of Length Three With a Condition</title><link href="https://zhengstar94.github.io//blog/2025/CountSubarraysOfLengthThreeWithACondition/" rel="alternate" type="text/html" title="3392. Count Subarrays of Length Three With a Condition"/><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubarraysOfLengthThreeWithACondition</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubarraysOfLengthThreeWithACondition/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return the number of subarrays of length 3 such that the sum of the first and third numbers equals <em>exactly</em> half of the second number.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,1,4,1]

Output: 1

Explanation:

Only the subarray [1,4,1] contains exactly 3 elements where the sum of the first and third numbers equals half the middle number.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]

Output: 0

Explanation:

[1,1,1] is the only subarray of length 3. However, its first and third numbers do not add to half the middle number.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubarraysOfLengthThreeWithACondition</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countSubArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Return 0 if array length is less than 3 as we need at least 3 elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Use sliding window of size 3 to check each subarray</span>
        <span class="c1">// Loop runs from first element to last possible position for a size-3 window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if sum of first and third number equals half of middle number</span>
            <span class="c1">// nums[i]: first number</span>
            <span class="c1">// nums[i + 1]: middle number</span>
            <span class="c1">// nums[i + 2]: third number</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with valid subarray</span>
        <span class="c1">// Expected output: 1 (subarray [1,4,1] satisfies the condition)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Array with no valid subarray</span>
        <span class="c1">// Expected output: 0 (no subarray satisfies the condition)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Empty array</span>
        <span class="c1">// Expected output: 0 (array length less than 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Array with length less than 3</span>
        <span class="c1">// Expected output: 0 (array length less than 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array nums, return the number of subarrays of length 3 such that the sum of the first and third numbers equals exactly half of the second number.]]></summary></entry><entry><title type="html">1818. Minimum Absolute Sum Difference</title><link href="https://zhengstar94.github.io//blog/2025/MinimumAbsoluteSumDifference/" rel="alternate" type="text/html" title="1818. Minimum Absolute Sum Difference"/><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumAbsoluteSumDifference</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumAbsoluteSumDifference/"><![CDATA[<ul> <li>You are given two positive integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>, both of length <code class="language-plaintext highlighter-rouge">n</code>.</li> <li>The <strong>absolute sum difference</strong> of arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> is defined as the <strong>sum</strong> of <code class="language-plaintext highlighter-rouge">|nums1[i] - nums2[i]|</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; n</code> (<strong>0-indexed</strong>).</li> <li>You can replace <strong>at most one</strong> element of <code class="language-plaintext highlighter-rouge">nums1</code> with <strong>any</strong> other element in <code class="language-plaintext highlighter-rouge">nums1</code> to <strong>minimize</strong> the absolute sum difference.</li> <li>Return the <em>minimum absolute sum difference <strong>after</strong> replacing at most one element in the array <code class="language-plaintext highlighter-rouge">nums1</code>.</em> Since the answer may be large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">10^9 + 7</code>.</li> <li><code class="language-plaintext highlighter-rouge">|x|</code> is defined as: <ul> <li><code class="language-plaintext highlighter-rouge">x</code> if <code class="language-plaintext highlighter-rouge">x &gt;= 0</code>, or</li> <li><code class="language-plaintext highlighter-rouge">-x</code> if <code class="language-plaintext highlighter-rouge">x &lt; 0</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,7,5], nums2 = [2,3,5]
Output: 3
Explanation: There are two possible optimal solutions:
- Replace the second element with the first: [1,7,5] =&gt; [1,1,5], or
- Replace the second element with the third: [1,7,5] =&gt; [1,5,5].
Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
Output: 0
Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an 
absolute sum difference of 0.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
Output: 20
Explanation: Replace the first element with the second: [1,10,4,4,2,7] =&gt; [10,10,4,4,2,7].
This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumAbsoluteSumDifference</span> <span class="o">{</span>
    <span class="c1">// Modulo constant to handle large numbers</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1_000_000_007</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minAbsoluteSumDiff</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create a sorted copy of nums1 for binary search</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sortedNums1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">sortedNums1</span><span class="o">);</span>

        <span class="c1">// Calculate the initial total absolute difference</span>
        <span class="kt">long</span> <span class="n">totalDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">totalDiff</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// Find the maximum improvement possible by replacing one element</span>
        <span class="kt">long</span> <span class="n">maxImprovement</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate current absolute difference at position i</span>
            <span class="kt">int</span> <span class="n">originalDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Find the closest value in sorted nums1 to nums2[i]</span>
            <span class="kt">int</span> <span class="n">closest</span> <span class="o">=</span> <span class="n">findClosest</span><span class="o">(</span><span class="n">sortedNums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// Calculate new difference if we replace with the closest value</span>
            <span class="kt">int</span> <span class="n">newDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">closest</span> <span class="o">-</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Update maximum improvement if current replacement gives better result</span>
            <span class="n">maxImprovement</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxImprovement</span><span class="o">,</span> <span class="n">originalDiff</span> <span class="o">-</span> <span class="n">newDiff</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return final result: (original sum - maximum improvement) % MOD</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="n">totalDiff</span> <span class="o">-</span> <span class="n">maxImprovement</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Handle edge cases where target is outside array bounds</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>  <span class="c1">// Target is smaller than or equal to smallest element</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">];</span> <span class="c1">// Target is larger than or equal to largest element</span>
        <span class="o">}</span>

        <span class="c1">// Binary search process</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// Avoid potential overflow</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span> <span class="c1">// Exact match found</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Search in right half</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Search in left half</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Compare the two closest values and return the one with smaller absolute difference</span>
        <span class="c1">// left and right have crossed, so arr[right] &lt; target &lt; arr[left]</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">-</span> <span class="n">target</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">-</span> <span class="n">target</span><span class="o">)</span> <span class="o">?</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">:</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with replacement needed</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1_1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2_1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minAbsoluteSumDiff</span><span class="o">(</span><span class="n">nums1_1</span><span class="o">,</span> <span class="n">nums2_1</span><span class="o">));</span>
        <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 2: Arrays are identical, no replacement needed</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1_2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2_2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minAbsoluteSumDiff</span><span class="o">(</span><span class="n">nums1_2</span><span class="o">,</span> <span class="n">nums2_2</span><span class="o">));</span>
        <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 3: Complex case with larger numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1_3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2_3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">minAbsoluteSumDiff</span><span class="o">(</span><span class="n">nums1_3</span><span class="o">,</span> <span class="n">nums2_3</span><span class="o">));</span>
        <span class="c1">// Expected output: 20</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Binary Search"/><category term="Medium"/><summary type="html"><![CDATA[You are given two positive integer arrays nums1 and nums2, both of length n. The absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 &lt;= i &lt; n (0-indexed). You can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference. Return the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 10^9 + 7. |x| is defined as: x if x &gt;= 0, or -x if x &lt; 0.]]></summary></entry><entry><title type="html">981. Time Based Key-Value Store</title><link href="https://zhengstar94.github.io//blog/2025/TimeBasedKeyValueStore/" rel="alternate" type="text/html" title="981. Time Based Key-Value Store"/><published>2025-04-26T00:00:00+00:00</published><updated>2025-04-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TimeBasedKeyValueStore</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TimeBasedKeyValueStore/"><![CDATA[<ul> <li>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key’s value at a certain timestamp.</li> <li>Implement the <code class="language-plaintext highlighter-rouge">TimeMap</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">TimeMap()</code> Initializes the object of the data structure.</li> <li><code class="language-plaintext highlighter-rouge">void set(String key, String value, int timestamp)</code> Stores the key <code class="language-plaintext highlighter-rouge">key</code> with the value <code class="language-plaintext highlighter-rouge">value</code> at the given time <code class="language-plaintext highlighter-rouge">timestamp</code>.</li> <li><code class="language-plaintext highlighter-rouge">String get(String key, int timestamp)</code> Returns a value such that <code class="language-plaintext highlighter-rouge">set</code> was called previously, with <code class="language-plaintext highlighter-rouge">timestamp_prev &lt;= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code class="language-plaintext highlighter-rouge">timestamp_prev</code>. If there are no values, it returns <code class="language-plaintext highlighter-rouge">""</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["TimeMap", "set", "get", "get", "set", "get", "get"]
[ [], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5] ]
Output
[null, null, "bar", "bar", null, "bar2", "bar2"]

Explanation
TimeMap timeMap = new TimeMap();
timeMap.set("foo", "bar", 1);  // store the key "foo" and value "bar" along with timestamp = 1.
timeMap.get("foo", 1);         // return "bar"
timeMap.get("foo", 3);         // return "bar", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is "bar".
timeMap.set("foo", "bar2", 4); // store the key "foo" and value "bar2" along with timestamp = 4.
timeMap.get("foo", 4);         // return "bar2"
timeMap.get("foo", 5);         // return "bar2"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(set O(1), get O(logn)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TimeMap</span> <span class="o">{</span>
    <span class="cm">/**
     * Custom Pair class to store timestamp-value pairs
     * @param &lt;K&gt; Type of key (timestamp)
     * @param &lt;V&gt; Type of value (string)
     */</span>
    <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="no">K</span> <span class="n">key</span><span class="o">;</span>
        <span class="kd">private</span> <span class="no">V</span> <span class="n">value</span><span class="o">;</span>

        <span class="cm">/**
         * Constructor to create a new Pair
         * @param key The timestamp
         * @param value The value associated with the timestamp
         */</span>
        <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="no">V</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// HashMap to store key to timestamp-value pairs mapping</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;&gt;&gt;</span> <span class="n">map</span><span class="o">;</span>

    <span class="cm">/**
     * Initialize TimeMap data structure
     */</span>
    <span class="kd">public</span> <span class="nf">TimeMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Stores the key, value pair at the given timestamp
     * @param key The key to store
     * @param value The value to store
     * @param timestamp The timestamp at which to store the key-value pair
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;())</span>
                <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">timestamp</span><span class="o">,</span> <span class="n">value</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Gets the value associated with the key at the maximum timestamp less than or equal to the given timestamp
     * @param key The key to look up
     * @param timestamp The timestamp to search for
     * @return The value associated with the key at the greatest timestamp &lt;= given timestamp, or "" if not found
     */</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">get</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Binary search to find the value at the greatest timestamp &lt;= target timestamp
     * @param list List of timestamp-value pairs
     * @param timestamp Target timestamp
     * @return Value at the greatest timestamp &lt;= target timestamp, or "" if not found
     */</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// If smallest timestamp is greater than target, return empty string</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left</span><span class="o">).</span><span class="na">getKey</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Binary search to find the largest timestamp &lt;= target</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mid</span><span class="o">).</span><span class="na">getKey</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left</span><span class="o">).</span><span class="na">getValue</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic operations</span>
        <span class="nc">TimeMap</span> <span class="n">timeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TimeMap</span><span class="o">();</span>
        <span class="n">timeMap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>  <span class="c1">// Returns "bar"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>  <span class="c1">// Returns "bar"</span>
        <span class="n">timeMap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar2"</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span>  <span class="c1">// Returns "bar2"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// Returns "bar2"</span>

        <span class="c1">// Test case 2: Multiple timestamps for same key</span>
        <span class="nc">TimeMap</span> <span class="n">timeMap2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TimeMap</span><span class="o">();</span>
        <span class="n">timeMap2</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"love"</span><span class="o">,</span> <span class="s">"high"</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
        <span class="n">timeMap2</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"love"</span><span class="o">,</span> <span class="s">"low"</span><span class="o">,</span> <span class="mi">20</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"love"</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>   <span class="c1">// Returns ""</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"love"</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>  <span class="c1">// Returns "high"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"love"</span><span class="o">,</span> <span class="mi">15</span><span class="o">));</span>  <span class="c1">// Returns "high"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"love"</span><span class="o">,</span> <span class="mi">20</span><span class="o">));</span>  <span class="c1">// Returns "low"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">timeMap2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"love"</span><span class="o">,</span> <span class="mi">25</span><span class="o">));</span>  <span class="c1">// Returns "low"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Binary Search"/><category term="Medium"/><summary type="html"><![CDATA[Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key’s value at a certain timestamp. Implement the TimeMap class: TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &lt;= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns "".]]></summary></entry><entry><title type="html">2389. Longest Subsequence With Limited Sum</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubsequenceWithLimitedSum/" rel="alternate" type="text/html" title="2389. Longest Subsequence With Limited Sum"/><published>2025-04-25T00:00:00+00:00</published><updated>2025-04-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubsequenceWithLimitedSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubsequenceWithLimitedSum/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code>, and an integer array <code class="language-plaintext highlighter-rouge">queries</code> of length <code class="language-plaintext highlighter-rouge">m</code>.</li> <li>Return <em>an array</em> <code class="language-plaintext highlighter-rouge">answer</code> <em>of length</em> <code class="language-plaintext highlighter-rouge">m</code> <em>where</em> <code class="language-plaintext highlighter-rouge">answer[i]</code> <em>is the <strong>maximum</strong> size of a <strong>subsequence</strong> that you can take from</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>such that the <strong>sum</strong> of its elements is less than or equal to</em> <code class="language-plaintext highlighter-rouge">queries[i]</code>.</li> <li>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,5,2,1], queries = [3,10,21]
Output: [2,3,4]
Explanation: We answer the queries as follows:
- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.
- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.
- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,4,5], queries = [1]
Output: [0]
Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubsequenceWithLimitedSum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">answerQueries</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort array first since we only care about sum, not order</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">queries</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Create prefix sum array to store cumulative sums</span>
        <span class="c1">// preSum[i] represents sum of first (i+1) smallest numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// First element is same as nums[0]</span>

        <span class="c1">// Calculate prefix sum for rest of the array</span>
        <span class="c1">// preSum[i] = sum of all elements from index 0 to i</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Process each query using binary search</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For each query, find the longest subsequence with sum &lt;= query value</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">preSum</span><span class="o">,</span> <span class="n">queries</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preSum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point avoiding overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">preSum</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If current sum is too large, look in left half</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current sum is &lt;= target, look in right half</span>
                <span class="c1">// We add 1 to left because we know mid is valid</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 'left' will be the position of first element &gt; target</span>
        <span class="c1">// This means we can use 'left' numbers in our subsequence</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output [2,3,4]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queries1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">21</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">answerQueries</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">queries1</span><span class="o">)));</span>

        <span class="c1">// Test case 2: Expected output [0]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queries2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">answerQueries</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">queries2</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Binary Search"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array nums of length n, and an integer array queries of length m. Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i]. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.]]></summary></entry><entry><title type="html">2529. Maximum Count of Positive Integer and Negative Integer</title><link href="https://zhengstar94.github.io//blog/2025/MaximumCountOfPositiveIntegerAndNegativeInteger/" rel="alternate" type="text/html" title="2529. Maximum Count of Positive Integer and Negative Integer"/><published>2025-04-23T00:00:00+00:00</published><updated>2025-04-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumCountOfPositiveIntegerAndNegativeInteger</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumCountOfPositiveIntegerAndNegativeInteger/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code> sorted in <strong>non-decreasing</strong> order, return <em>the maximum between the number of positive integers and the number of negative integers.</em> <ul> <li>In other words, if the number of positive integers in <code class="language-plaintext highlighter-rouge">nums</code> is <code class="language-plaintext highlighter-rouge">pos</code> and the number of negative integers is <code class="language-plaintext highlighter-rouge">neg</code>, then return the maximum of <code class="language-plaintext highlighter-rouge">pos</code> and <code class="language-plaintext highlighter-rouge">neg</code>.</li> </ul> </li> <li><strong>Note</strong> that <code class="language-plaintext highlighter-rouge">0</code> is neither positive nor negative.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-2,-1,-1,1,2,3]
Output: 3
Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-3,-2,-1,0,0,1,2]
Output: 3
Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,20,66,1314]
Output: 4
Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumCountOfPositiveIntegerAndNegativeInteger</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumCount</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: empty array or null input</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Find the position of first non-negative number (&gt;= 0) using binary search</span>
        <span class="kt">int</span> <span class="n">firstNonNeg</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="c1">// Find the position of first positive number (&gt; 0) using binary search</span>
        <span class="kt">int</span> <span class="n">firstPos</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Calculate counts:</span>
        <span class="c1">// Number of negative integers = position of first non-negative</span>
        <span class="c1">// Number of positive integers = total length - position of first positive</span>
        <span class="kt">int</span> <span class="n">negCount</span> <span class="o">=</span> <span class="n">firstNonNeg</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">posCount</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">firstPos</span><span class="o">;</span>

        <span class="c1">// Return the maximum of the two counts</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">negCount</span><span class="o">,</span> <span class="n">posCount</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers for binary search</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Standard binary search loop</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point avoiding integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">// If middle element is less than target, search in right half</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If middle element is &gt;= target, search in left half</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the position where element should be inserted</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Equal number of positive and negative integers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 (Expected 3): "</span> <span class="o">+</span> <span class="n">maximumCount</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Array with zeros and unequal positive/negative counts</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">3</span><span class="o">,-</span><span class="mi">2</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 (Expected 3): "</span> <span class="o">+</span> <span class="n">maximumCount</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Array with only positive integers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">66</span><span class="o">,</span><span class="mi">1314</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Expected 4): "</span> <span class="o">+</span> <span class="n">maximumCount</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Array with only zeros</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 (Expected 0): "</span> <span class="o">+</span> <span class="n">maximumCount</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Array with only negative integers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">5</span><span class="o">,-</span><span class="mi">4</span><span class="o">,-</span><span class="mi">3</span><span class="o">,-</span><span class="mi">2</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 (Expected 5): "</span> <span class="o">+</span> <span class="n">maximumCount</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Binary Search"/><category term="Easy"/><summary type="html"><![CDATA[Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers. In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg. Note that 0 is neither positive nor negative.]]></summary></entry><entry><title type="html">2300. Successful Pairs of Spells and Potions</title><link href="https://zhengstar94.github.io//blog/2025/SuccessfulPairsOfSpellsAndPotions/" rel="alternate" type="text/html" title="2300. Successful Pairs of Spells and Potions"/><published>2025-04-23T00:00:00+00:00</published><updated>2025-04-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SuccessfulPairsOfSpellsAndPotions</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SuccessfulPairsOfSpellsAndPotions/"><![CDATA[<ul> <li>You are given two positive integer arrays <code class="language-plaintext highlighter-rouge">spells</code> and <code class="language-plaintext highlighter-rouge">potions</code>, of length <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code> respectively, where <code class="language-plaintext highlighter-rouge">spells[i]</code> represents the strength of the <code class="language-plaintext highlighter-rouge">ith</code> spell and <code class="language-plaintext highlighter-rouge">potions[j]</code> represents the strength of the <code class="language-plaintext highlighter-rouge">jth</code> potion.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">success</code>.</li> <li>Return <em>an integer array</em> <code class="language-plaintext highlighter-rouge">pairs</code> <em>of length</em> <code class="language-plaintext highlighter-rouge">n</code> <em>where</em> <code class="language-plaintext highlighter-rouge">pairs[i]</code> <em>is the number of <strong>potions</strong> that will form a successful pair with the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>spell.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]
Explanation:
- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
Thus, [4,0,3] is returned.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]
Explanation:
- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.
- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. 
Thus, [2,0,2] is returned.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,20,66,1314]
Output: 4
Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O((n + m) log m) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SuccessfulPairsOfSpellsAndPotions</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">successfulPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">spells</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">potions</span><span class="o">,</span> <span class="kt">long</span> <span class="n">success</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort potions array in ascending order to enable binary search</span>
        <span class="c1">// Time complexity: O(mlogm)</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">potions</span><span class="o">);</span>

        <span class="c1">// Initialize variables for array lengths and result array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">spells</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>  <span class="c1">// number of spells</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">potions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// number of potions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Process each spell to find successful combinations</span>
        <span class="c1">// Time complexity: O(nlogm)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate minimum potion value needed for current spell</span>
            <span class="c1">// Formula: ceil(success/spell) = (success + spell - 1) / spell</span>
            <span class="c1">// This ensures we get ceiling value without using Math.ceil()</span>
            <span class="kt">long</span> <span class="n">minPotion</span> <span class="o">=</span> <span class="o">(</span><span class="n">success</span> <span class="o">+</span> <span class="n">spells</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">spells</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="c1">// Use binary search to find the first potion that when combined</span>
            <span class="c1">// with current spell produces value &gt;= success</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">potions</span><span class="o">,</span> <span class="n">minPotion</span><span class="o">);</span>

            <span class="c1">// Calculate number of successful combinations:</span>
            <span class="c1">// Total potions - index of first valid potion</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">index</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">long</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize search boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                <span class="c1">// Start of search range</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>      <span class="c1">// End of search range (exclusive)</span>

        <span class="c1">// Continue searching while boundaries haven't crossed</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point</span>
            <span class="c1">// Use (right-left)/2 to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If middle element is less than target</span>
            <span class="c1">// Search in right half: [mid+1, right]</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If middle element is &gt;= target</span>
            <span class="c1">// Search in left half including mid: [left, mid]</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return position where element should be inserted</span>
        <span class="c1">// This is either the index of first element &gt;= target</span>
        <span class="c1">// or arr.length if no such element exists</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed positive numbers with multiple successful combinations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spells1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">potions1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">long</span> <span class="n">success1</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">successfulPairs</span><span class="o">(</span><span class="n">spells1</span><span class="o">,</span> <span class="n">potions1</span><span class="o">,</span> <span class="n">success1</span><span class="o">)));</span> <span class="c1">// Expected: [4,0,3]</span>

        <span class="c1">// Test Case 2: Larger numbers testing overflow handling</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spells2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">potions2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">};</span>
        <span class="kt">long</span> <span class="n">success2</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">successfulPairs</span><span class="o">(</span><span class="n">spells2</span><span class="o">,</span> <span class="n">potions2</span><span class="o">,</span> <span class="n">success2</span><span class="o">)));</span> <span class="c1">// Expected: [2,0,2]</span>

        <span class="c1">// Test Case 3: Sequential numbers testing boundary conditions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spells3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">potions3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">long</span> <span class="n">success3</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">successfulPairs</span><span class="o">(</span><span class="n">spells3</span><span class="o">,</span> <span class="n">potions3</span><span class="o">,</span> <span class="n">success3</span><span class="o">)));</span> <span class="c1">// Expected: [0,0,1,2,3]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Binary Search"/><category term="Medium"/><summary type="html"><![CDATA[You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion. You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success. Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.]]></summary></entry><entry><title type="html">3499. Maximize Active Section with Trade I</title><link href="https://zhengstar94.github.io//blog/2025/MaximizeActiveSectionWithTradeI/" rel="alternate" type="text/html" title="3499. Maximize Active Section with Trade I"/><published>2025-04-22T00:00:00+00:00</published><updated>2025-04-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximizeActiveSectionWithTradeI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximizeActiveSectionWithTradeI/"><![CDATA[<ul> <li>You are given a binary string <code class="language-plaintext highlighter-rouge">s</code> of length <code class="language-plaintext highlighter-rouge">n</code>, where: <ul> <li><code class="language-plaintext highlighter-rouge">'1'</code> represents an <strong>active</strong> section.</li> <li><code class="language-plaintext highlighter-rouge">'0'</code> represents an <strong>inactive</strong> section.</li> </ul> </li> <li>You can perform <strong>at most one trade</strong> to maximize the number of active sections in <code class="language-plaintext highlighter-rouge">s</code>. In a trade, you: <ul> <li>Convert a contiguous block of <code class="language-plaintext highlighter-rouge">'1'</code>s that is surrounded by <code class="language-plaintext highlighter-rouge">'0'</code>s to all <code class="language-plaintext highlighter-rouge">'0'</code>s.</li> <li>Afterward, convert a contiguous block of <code class="language-plaintext highlighter-rouge">'0'</code>s that is surrounded by <code class="language-plaintext highlighter-rouge">'1'</code>s to all <code class="language-plaintext highlighter-rouge">'1'</code>s.</li> </ul> </li> <li>Return the <strong>maximum</strong> number of active sections in <code class="language-plaintext highlighter-rouge">s</code> after making the optimal trade.</li> <li><strong>Note:</strong> Treat <code class="language-plaintext highlighter-rouge">s</code> as if it is <strong>augmented</strong> with a <code class="language-plaintext highlighter-rouge">'1'</code> at both ends, forming <code class="language-plaintext highlighter-rouge">t = '1' + s + '1'</code>. The augmented <code class="language-plaintext highlighter-rouge">'1'</code>s <strong>do not</strong> contribute to the final count.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "01"

Output: 1

Explanation:

Because there is no block of '1's surrounded by '0's, no valid trade is possible. The maximum number of active sections is 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "0100"

Output: 4

Explanation:

String "0100" → Augmented to "101001".
Choose "0100", convert "101001" → "100001" → "111111".
The final string without augmentation is "1111". The maximum number of active sections is 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1000100"

Output: 7

Explanation:

String "1000100" → Augmented to "110001001".
Choose "000100", convert "110001001" → "110000001" → "111111111".
The final string without augmentation is "1111111". The maximum number of active sections is 7.
</code></pre></div></div> <p><strong>Example 4</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "01010"

Output: 4

Explanation:

String "01010" → Augmented to "1010101".
Choose "010", convert "1010101" → "1000101" → "1111101".
The final string without augmentation is "11110". The maximum number of active sections is 4.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximizeActiveSectionWithTradeI</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert string to char array for easier manipulation</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Variables to track:</span>
        <span class="c1">// total1: counts the total number of 1's in the original string</span>
        <span class="c1">// mx: stores the maximum convertible area (sum of two consecutive sequences of 0's)</span>
        <span class="c1">// pre0: stores the length of the previous sequence of 0's</span>
        <span class="kt">int</span> <span class="n">total1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Initialize pre0 to MIN_VALUE to handle the first sequence of 0's</span>
        <span class="kt">int</span> <span class="n">pre0</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Mark the start of current consecutive sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Find the end of current consecutive sequence of same characters</span>
            <span class="c1">// This is a grouped loop pattern to handle consecutive identical elements</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate the length of current consecutive sequence</span>
            <span class="kt">int</span> <span class="n">groupLength</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>

            <span class="c1">// Process the current sequence based on its type (0's or 1's)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If current sequence is 1's, add its length to total count of 1's</span>
                <span class="n">total1</span> <span class="o">+=</span> <span class="n">groupLength</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current sequence is 0's:</span>
                <span class="c1">// mx = Math.max(mx, pre0 + groupLength) finds the maximum convertible area</span>
                <span class="c1">// by comparing current maximum with sum of current and previous 0 sequences</span>
                <span class="c1">// This is crucial because we can potentially convert two adjacent 0 sequences into 1's</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">pre0</span> <span class="o">+</span> <span class="n">groupLength</span><span class="o">);</span>
                <span class="c1">// Update pre0 for next iteration</span>
                <span class="n">pre0</span> <span class="o">=</span> <span class="n">groupLength</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the final result:</span>
        <span class="c1">// total1: original count of 1's</span>
        <span class="c1">// mx: maximum additional 1's we can get through one trade operation</span>
        <span class="c1">// The sum represents the maximum possible 1's after one trade</span>
        <span class="k">return</span> <span class="n">total1</span> <span class="o">+</span> <span class="n">mx</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Simple case with one 0 and one 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"01"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 2: Case where trade can convert multiple positions</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"0100"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 3: Case with longer consecutive 0's</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"1000100"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected: 7</span>

        <span class="c1">// Test Case 4: Alternating 0's and 1's</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"01010"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxActiveSectionsAfterTrade</span><span class="o">(</span><span class="n">s4</span><span class="o">));</span> <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[You are given a binary string s of length n, where: '1' represents an active section. '0' represents an inactive section. You can perform at most one trade to maximize the number of active sections in s. In a trade, you: Convert a contiguous block of '1's that is surrounded by '0's to all '0's. Afterward, convert a contiguous block of '0's that is surrounded by '1's to all '1's. Return the maximum number of active sections in s after making the optimal trade. Note: Treat s as if it is augmented with a '1' at both ends, forming t='1' + s + '1'. The augmented '1's do not contribute to the final count.]]></summary></entry><entry><title type="html">2145. Count the Hidden Sequences</title><link href="https://zhengstar94.github.io//blog/2025/CountTheHiddenSequences/" rel="alternate" type="text/html" title="2145. Count the Hidden Sequences"/><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountTheHiddenSequences</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountTheHiddenSequences/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array of <code class="language-plaintext highlighter-rouge">n</code> integers <code class="language-plaintext highlighter-rouge">differences</code>, which describes the <strong>differences</strong> between each pair of <strong>consecutive</strong> integers of a <strong>hidden</strong> sequence of length <code class="language-plaintext highlighter-rouge">(n + 1)</code>. More formally, call the hidden sequence <code class="language-plaintext highlighter-rouge">hidden</code>, then we have that <code class="language-plaintext highlighter-rouge">differences[i] = hidden[i + 1] - hidden[i]</code>.</li> <li>You are further given two integers <code class="language-plaintext highlighter-rouge">lower</code> and <code class="language-plaintext highlighter-rouge">upper</code> that describe the <strong>inclusive</strong> range of values <code class="language-plaintext highlighter-rouge">[lower, upper]</code> that the hidden sequence can contain. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">differences = [1, -3, 4]</code>, <code class="language-plaintext highlighter-rouge">lower = 1</code>, <code class="language-plaintext highlighter-rouge">upper = 6</code>, the hidden sequence is a sequence of length <code class="language-plaintext highlighter-rouge">4</code> whose elements are in between <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">6</code> (<strong>inclusive</strong>). <ul> <li><code class="language-plaintext highlighter-rouge">[3, 4, 1, 5]</code> and <code class="language-plaintext highlighter-rouge">[4, 5, 2, 6]</code> are possible hidden sequences.</li> <li><code class="language-plaintext highlighter-rouge">[5, 6, 3, 7]</code> is not possible since it contains an element greater than <code class="language-plaintext highlighter-rouge">6</code>.</li> <li><code class="language-plaintext highlighter-rouge">[1, 2, 3, 4]</code> is not possible since the differences are not correct.</li> </ul> </li> </ul> </li> <li>Return <em>the number of <strong>possible</strong> hidden sequences there are.</em> If there are no possible sequences, return <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: differences = [1,-3,4], lower = 1, upper = 6
Output: 2
Explanation: The possible hidden sequences are:
- [3, 4, 1, 5]
- [4, 5, 2, 6]
Thus, we return 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5
Output: 4
Explanation: The possible hidden sequences are:
- [-3, 0, -4, 1, 2, 0]
- [-2, 1, -3, 2, 3, 1]
- [-1, 2, -2, 3, 4, 2]
- [0, 3, -1, 4, 5, 3]
Thus, we return 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: differences = [4,-7,2], lower = 3, upper = 6
Output: 0
Explanation: There are no possible hidden sequences. Thus, we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountTheHiddenSequences</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">differences</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize tracking variables</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Minimum cumulative difference</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Maximum cumulative difference</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Current cumulative difference</span>

        <span class="c1">// Iterate through the differences array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">d:</span> <span class="n">differences</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Update current cumulative difference</span>
            <span class="n">cur</span> <span class="o">+=</span> <span class="n">d</span><span class="o">;</span>

            <span class="c1">// Update minimum and maximum cumulative differences</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>  <span class="c1">// Track how far below start we go</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>  <span class="c1">// Track how far above start we go</span>

            <span class="c1">// If the required range (y-x) exceeds the allowed range (upper-lower),</span>
            <span class="c1">// it's impossible to construct a valid array</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="o">){</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Calculate the number of possible starting values that would create valid arrays</span>
        <span class="c1">// (upper - lower): total allowed range</span>
        <span class="c1">// (y - x): minimum required range</span>
        <span class="c1">// +1: account for inclusive bounds</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Example with possible solutions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">differences1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countArray</span><span class="o">(</span><span class="n">differences1</span><span class="o">,</span> <span class="n">lower1</span><span class="o">,</span> <span class="n">upper1</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test Case 2: Example with more possible solutions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">differences2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countArray</span><span class="o">(</span><span class="n">differences2</span><span class="o">,</span> <span class="n">lower2</span><span class="o">,</span> <span class="n">upper2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 3: Example with no possible solutions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">differences3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper3</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countArray</span><span class="o">(</span><span class="n">differences3</span><span class="o">,</span> <span class="n">lower3</span><span class="o">,</span> <span class="n">upper3</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i]. You are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain. For example, given differences=[1, -3, 4], lower=1, upper=6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive). [3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences. [5, 6, 3, 7] is not possible since it contains an element greater than 6. [1, 2, 3, 4] is not possible since the differences are not correct. Return the number of possible hidden sequences there are. If there are no possible sequences, return 0.]]></summary></entry><entry><title type="html">467. Unique Substrings in Wraparound String</title><link href="https://zhengstar94.github.io//blog/2025/UniqueSubstringsInWraparoundString/" rel="alternate" type="text/html" title="467. Unique Substrings in Wraparound String"/><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/UniqueSubstringsInWraparoundString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/UniqueSubstringsInWraparoundString/"><![CDATA[<ul> <li>We define the string <code class="language-plaintext highlighter-rouge">base</code> to be the infinite wraparound string of <code class="language-plaintext highlighter-rouge">"abcdefghijklmnopqrstuvwxyz"</code>, so <code class="language-plaintext highlighter-rouge">base</code> will look like this: <ul> <li><code class="language-plaintext highlighter-rouge">"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...."</code>.</li> </ul> </li> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the number of <strong>unique non-empty substrings</strong> of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>are present in</em> <code class="language-plaintext highlighter-rouge">base</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "a"
Output: 1
Explanation: Only the substring "a" of s is in base.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cac"
Output: 2
Explanation: There are two substrings ("a", "c") of s in base.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "zab"
Output: 6
Explanation: There are six substrings ("z", "a", "b", "za", "ab", and "zab") of s in base.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UniqueSubstringsInWraparoundString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findSubstringInWraproundString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// dp[i] stores the maximum length of continuous substring ending with character (i+'a')</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Outer loop: process the entire string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Mark the start of current continuous group</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Inner loop: extend the current group as far as possible</span>
            <span class="c1">// A group continues if:</span>
            <span class="c1">// 1. Next character is one more than current (e.g., 'a' to 'b')</span>
            <span class="c1">// 2. Current is 'z' and next is 'a'</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
                            <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'z'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'a'</span><span class="o">)))</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current continuous group</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Process each character in the current group</span>
            <span class="c1">// For each character, update the maximum length of continuous substring ending with it</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Calculate index in dp array (0 for 'a', 1 for 'b', etc.)</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>

                <span class="c1">// len-j represents number of possible substrings ending at current character</span>
                <span class="c1">// Example: for "abc", at 'a':</span>
                <span class="c1">// - len=3, j=0: dp['a'] = max(dp['a'], 3) for substrings "a", "ab", "abc"</span>
                <span class="c1">// at 'b':</span>
                <span class="c1">// - len=3, j=1: dp['b'] = max(dp['b'], 2) for substrings "b", "bc"</span>
                <span class="c1">// at 'c':</span>
                <span class="c1">// - len=3, j=2: dp['c'] = max(dp['c'], 1) for substring "c"</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">idx</span><span class="o">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Move to next character</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Calculate sum of all unique substring counts</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="n">dp</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">count</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Single character</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">findSubstringInWraproundString</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 2: Non-continuous characters</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"cac"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">findSubstringInWraproundString</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test Case 3: Continuous characters including wraparound</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"zab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">findSubstringInWraproundString</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[We define the string base to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so base will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Given a string s, return the number of unique non-empty substrings of s are present in base.]]></summary></entry><entry><title type="html">3350. Adjacent Increasing Subarrays Detection II</title><link href="https://zhengstar94.github.io//blog/2025/AdjacentIncreasingSubarraysDetectionII/" rel="alternate" type="text/html" title="3350. Adjacent Increasing Subarrays Detection II"/><published>2025-04-20T00:00:00+00:00</published><updated>2025-04-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AdjacentIncreasingSubarraysDetectionII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AdjacentIncreasingSubarraysDetectionII/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code> of <code class="language-plaintext highlighter-rouge">n</code> integers, your task is to find the <strong>maximum</strong> value of <code class="language-plaintext highlighter-rouge">k</code> for which there exist <strong>two</strong> adjacent subarrays of length <code class="language-plaintext highlighter-rouge">k</code> each, such that both subarrays are <strong>strictly</strong> <strong>increasing</strong>. Specifically, check if there are <strong>two</strong> subarrays of length <code class="language-plaintext highlighter-rouge">k</code> starting at indices <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> (<code class="language-plaintext highlighter-rouge">a &lt; b</code>), where: <ul> <li>Both subarrays <code class="language-plaintext highlighter-rouge">nums[a..a + k - 1]</code> and <code class="language-plaintext highlighter-rouge">nums[b..b + k - 1]</code> are <strong>strictly increasing</strong>.</li> <li>The subarrays must be <strong>adjacent</strong>, meaning <code class="language-plaintext highlighter-rouge">b = a + k</code>.</li> </ul> </li> <li>Return the <strong>maximum</strong> <em>possible</em> value of <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,5,7,8,9,2,3,4,3,1]

Output: 3

Explanation:

The subarray starting at index 2 is [7, 8, 9], which is strictly increasing.
The subarray starting at index 5 is [2, 3, 4], which is also strictly increasing.
These two subarrays are adjacent, and 3 is the maximum possible value of k for which two such adjacent strictly increasing subarrays exist.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,4,4,4,5,6,7]

Output: 2

Explanation:

The subarray starting at index 0 is [1, 2], which is strictly increasing.
The subarray starting at index 2 is [3, 4], which is also strictly increasing.
These two subarrays are adjacent, and 2 is the maximum possible value of k for which two such adjacent strictly increasing subarrays exist.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdjacentIncreasingSubarraysDetectionII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxIncreasingSubarrays</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize variables to track maximum length found so far</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Length of previous strictly increasing sequence</span>
        <span class="kt">int</span> <span class="n">preCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Current position in array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

        <span class="c1">// Process array using grouped loop approach</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="c1">// Mark start of current increasing sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Find end of current strictly increasing sequence</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate length of current increasing sequence</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Case 1: Split current sequence into two equal parts</span>
            <span class="kt">int</span> <span class="n">splitLen</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">// Case 2: Use adjacent sequences (current and previous)</span>
            <span class="kt">int</span> <span class="n">adjacentLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">preCnt</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
            <span class="c1">// Take maximum of the two cases</span>
            <span class="kt">int</span> <span class="n">currentMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">splitLen</span><span class="o">,</span> <span class="n">adjacentLen</span><span class="o">);</span>
            <span class="c1">// Update global maximum if necessary</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">currentMax</span><span class="o">);</span>

            <span class="c1">// Current sequence becomes previous sequence for next iteration</span>
            <span class="n">preCnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Sequence with multiple increasing subarrays</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Processing demonstration:"</span><span class="o">);</span>
        <span class="n">printProcess</span><span class="o">(</span><span class="n">test1</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Sequence with one long increasing subarray</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nProcessing demonstration:"</span><span class="o">);</span>
        <span class="n">printProcess</span><span class="o">(</span><span class="n">test2</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printProcess</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">preCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Find current increasing sequence</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Print current sequence being processed</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nCurrent sequence: "</span> <span class="o">+</span> <span class="n">nums</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Current sequence length (cnt): "</span> <span class="o">+</span> <span class="n">cnt</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Previous sequence length (preCnt): "</span> <span class="o">+</span> <span class="n">preCnt</span><span class="o">);</span>

            <span class="c1">// Print calculations for both cases</span>
            <span class="kt">int</span> <span class="n">splitLen</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Case 1 (Split current sequence) = "</span> <span class="o">+</span> <span class="n">splitLen</span><span class="o">);</span>

            <span class="kt">int</span> <span class="n">adjacentLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">preCnt</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Case 2 (Use adjacent sequences) = "</span> <span class="o">+</span> <span class="n">adjacentLen</span><span class="o">);</span>

            <span class="kt">int</span> <span class="n">currentMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">splitLen</span><span class="o">,</span> <span class="n">adjacentLen</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Current maximum = "</span> <span class="o">+</span> <span class="n">currentMax</span><span class="o">);</span>

            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">currentMax</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Updated global maximum = "</span> <span class="o">+</span> <span class="n">ans</span><span class="o">);</span>

            <span class="c1">// Update for next iteration</span>
            <span class="n">preCnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Medium"/><summary type="html"><![CDATA[Given an array nums of n integers, your task is to find the maximum value of k for which there exist two adjacent subarrays of length k each, such that both subarrays are strictly increasing. Specifically, check if there are two subarrays of length k starting at indices a and b (a &lt; b), where: Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly increasing. The subarrays must be adjacent, meaning b=a + k. Return the maximum possible value of k. A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry></feed>