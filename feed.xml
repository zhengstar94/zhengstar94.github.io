<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-13T04:36:30+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2730. Find the Longest Semi-Repetitive Substring</title><link href="https://zhengstar94.github.io//blog/2025/FindTheLongestSemiRepetitiveSubstring/" rel="alternate" type="text/html" title="2730. Find the Longest Semi-Repetitive Substring"/><published>2025-01-13T00:00:00+00:00</published><updated>2025-01-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheLongestSemiRepetitiveSubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheLongestSemiRepetitiveSubstring/"><![CDATA[<ul> <li>You are given a digit string <code class="language-plaintext highlighter-rouge">s</code> that consists of digits from 0 to 9.</li> <li>A string is called <strong>semi-repetitive</strong> if there is <strong>at most</strong> one adjacent pair of the same digit. For example, <code class="language-plaintext highlighter-rouge">"0010"</code>, <code class="language-plaintext highlighter-rouge">"002020"</code>, <code class="language-plaintext highlighter-rouge">"0123"</code>, <code class="language-plaintext highlighter-rouge">"2002"</code>, and <code class="language-plaintext highlighter-rouge">"54944"</code> are semi-repetitive while the following are not: <code class="language-plaintext highlighter-rouge">"00101022"</code> (adjacent same digit pairs are 00 and 22), and <code class="language-plaintext highlighter-rouge">"1101234883"</code> (adjacent same digit pairs are 11 and 88).</li> <li>Return the length of the <strong>longest semi-repetitive substring</strong> of <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "52233"
Output: 4

Explanation:

The longest semi-repetitive substring is "5223". Picking the whole string "52233" has two adjacent same digit pairs 22 and 33, but at most one is allowed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "5494"
Output: 4

Explanation:

s is a semi-repetitive string.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1111111"
Output: 2

Explanation:

The longest semi-repetitive substring is "11". Picking the substring "111" has two adjacent same digit pairs, but at most one is allowed.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheLongestSemiRepetitiveSubstring</span> <span class="o">{</span>

    <span class="cm">/**
     * This function finds the length of the longest "semi-repetitive" substring.
     * A "semi-repetitive" substring allows at most one pair of consecutive, identical characters.
     *
     * @param s The input string consisting of alphanumeric characters.
     * @return The length of the longest semi-repetitive substring.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestSemiRepetitiveSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the input string length is less than or equal to 2, the substring will always have the same length</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Variable to store the maximum length of the semi-repetitive substring we have found so far</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// `start` is the beginning index of the current substring that satisfies the condition</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// `lastPair` stores the index of the first element of the most recent pair of consecutive identical characters</span>
        <span class="kt">int</span> <span class="n">lastPair</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// Initially set to -1 because no pair has been found yet</span>

        <span class="c1">// Traverse the string from the second character to the last character</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if the current character is equal to the previous character</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>

                <span class="cm">/**
                 * If this is the second occurrence of a consecutive pair (i.e., we already encountered a pair before):
                 * - We adjust `start` to the second element of the first consecutive pair (i.e., `lastPair + 1`).
                 * - This ensures the new substring being processed doesn't include more than one pair.
                 */</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">lastPair</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">lastPair</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Update `lastPair` to the current location of the first element in the new pair</span>
                <span class="n">lastPair</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Calculate the length of the current semi-repetitive substring:
             * - It's the distance from `start` to the current index `i` (inclusive).
             * Update `maxLength` if this substring is longer.
             */</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the length of the longest semi-repetitive substring found</span>
        <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Input string contains two pairs of consecutive identical characters</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"5224336"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 4"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">longestSemiRepetitiveSubstring</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>

        <span class="c1">// Uncomment other test cases to validate the implementation:</span>
        <span class="c1">// Test case 2</span>
        <span class="c1">// String s2 = "5494";</span>
        <span class="c1">// System.out.println("\nTest Case 2: " + s2);</span>
        <span class="c1">// System.out.println("Expected Output: 4");</span>
        <span class="c1">// System.out.println("Actual Output: " + longestSemiRepetitiveSubstring(s2));</span>
        <span class="c1">//</span>
        <span class="c1">// // Test case 3</span>
        <span class="c1">// String s3 = "1111111";</span>
        <span class="c1">// System.out.println("\nTest Case 3: " + s3);</span>
        <span class="c1">// System.out.println("Expected Output: 2");</span>
        <span class="c1">// System.out.println("Actual Output: " + longestSemiRepetitiveSubstring(s3));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given a digit string s that consists of digits from 0 to 9. A string is called semi-repetitive if there is at most one adjacent pair of the same digit. For example, "0010", "002020", "0123", "2002", and "54944" are semi-repetitive while the following are not: "00101022" (adjacent same digit pairs are 00 and 22), and "1101234883" (adjacent same digit pairs are 11 and 88). Return the length of the longest semi-repetitive substring of s.]]></summary></entry><entry><title type="html">1208. Get Equal Substrings Within Budget</title><link href="https://zhengstar94.github.io//blog/2025/GetEqualSubstringsWithinBudget/" rel="alternate" type="text/html" title="1208. Get Equal Substrings Within Budget"/><published>2025-01-13T00:00:00+00:00</published><updated>2025-01-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/GetEqualSubstringsWithinBudget</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/GetEqualSubstringsWithinBudget/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> of the same length and an integer <code class="language-plaintext highlighter-rouge">maxCost</code>.</li> <li>You want to change <code class="language-plaintext highlighter-rouge">s</code> to <code class="language-plaintext highlighter-rouge">t</code>. Changing the <code class="language-plaintext highlighter-rouge">ith</code> character of <code class="language-plaintext highlighter-rouge">s</code> to <code class="language-plaintext highlighter-rouge">ith</code> character of <code class="language-plaintext highlighter-rouge">t</code> costs <code class="language-plaintext highlighter-rouge">|s[i] - t[i]|</code> (i.e., the absolute difference between the ASCII values of the characters).</li> <li>Return <em>the maximum length of a substring of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that can be changed to be the same as the corresponding substring of</em> <code class="language-plaintext highlighter-rouge">t</code> <em>with a cost less than or equal to</em> <code class="language-plaintext highlighter-rouge">maxCost</code>. If there is no substring from <code class="language-plaintext highlighter-rouge">s</code> that can be changed to its corresponding substring from <code class="language-plaintext highlighter-rouge">t</code>, return <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd".
That costs 3, so the maximum length is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", t = "cdef", maxCost = 3
Output: 1
Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You cannot make any change, so the maximum length is 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GetEqualSubstringsWithinBudget</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">equalSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxCost</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// Array to store the conversion cost for each character</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Calculate the cost of changing each character from s to t</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">costs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Track the maximum valid substring length</span>
        <span class="kt">int</span> <span class="n">currentCost</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Track the current window's total cost</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>         <span class="c1">// Left pointer of the window</span>

        <span class="c1">// Iterate through the string with right pointer (end)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Enter Window: Add cost of current character to window</span>
            <span class="n">currentCost</span> <span class="o">+=</span> <span class="n">costs</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>

            <span class="c1">// 2. Exit Window: Shrink window while cost exceeds budget</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">currentCost</span> <span class="o">&gt;</span> <span class="n">maxCost</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">currentCost</span> <span class="o">-=</span> <span class="n">costs</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
                <span class="n">start</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// 3. Update Answer: Update maximum length of valid substring</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple characters can be changed within budget</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t1</span> <span class="o">=</span> <span class="s">"bcdf"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxCost1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">equalSubstring</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">maxCost1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 2: High conversion cost limits substring length</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t2</span> <span class="o">=</span> <span class="s">"cdef"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxCost2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">equalSubstring</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">t2</span><span class="o">,</span> <span class="n">maxCost2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 3: Zero budget allows only identical characters</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t3</span> <span class="o">=</span> <span class="s">"acde"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxCost3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">equalSubstring</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">t3</span><span class="o">,</span> <span class="n">maxCost3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given two strings s and t of the same length and an integer maxCost. You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters). Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.]]></summary></entry><entry><title type="html">3223. Minimum Length of String After Operations</title><link href="https://zhengstar94.github.io//blog/2025/MinimumLengthOfStringAfterOperations/" rel="alternate" type="text/html" title="3223. Minimum Length of String After Operations"/><published>2025-01-13T00:00:00+00:00</published><updated>2025-01-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumLengthOfStringAfterOperations</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumLengthOfStringAfterOperations/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>You can perform the following process on <code class="language-plaintext highlighter-rouge">s</code> <strong>any</strong> number of times: <ul> <li>Choose an index <code class="language-plaintext highlighter-rouge">i</code> in the string such that there is <strong>at least</strong> one character to the left of index <code class="language-plaintext highlighter-rouge">i</code> that is equal to <code class="language-plaintext highlighter-rouge">s[i]</code>, and <strong>at least</strong> one character to the right that is also equal to <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> <li>Delete the <strong>closest</strong> character to the <strong>left</strong> of index <code class="language-plaintext highlighter-rouge">i</code> that is equal to <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> <li>Delete the <strong>closest</strong> character to the <strong>right</strong> of index <code class="language-plaintext highlighter-rouge">i</code> that is equal to <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> </ul> </li> <li>Return the <strong>minimum</strong> length of the final string <code class="language-plaintext highlighter-rouge">s</code> that you can achieve.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abaacbcbb"

Output: 5

Explanation:
We do the following operations:

Choose index 2, then remove the characters at indices 0 and 3. The resulting string is s = "bacbcbb".
Choose index 3, then remove the characters at indices 0 and 5. The resulting string is s = "acbcb".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aa"

Output: 2

Explanation:
We cannot perform any operations, so we return the length of the original string.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumLengthOfStringAfterOperations</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumLength</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to count frequency of each lowercase letter (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Count the frequency of each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">ch:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>  <span class="c1">// Convert char to index (e.g., 'a'-&gt;0, 'b'-&gt;1, etc.)</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Process each character's frequency to determine its contribution to final length</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">count:</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/* Mathematical formula explanation:
                 * (count - 1) % 2 + 1 determines how many characters will remain:
                 *
                 * For count = 1: (1-1)%2 + 1 = 0%2 + 1 = 1  (one char remains)
                 * For count = 2: (2-1)%2 + 1 = 1%2 + 1 = 2  (two chars remain)
                 * For count = 3: (3-1)%2 + 1 = 2%2 + 1 = 1  (one char remains)
                 * For count = 4: (4-1)%2 + 1 = 3%2 + 1 = 2  (two chars remain)
                 *
                 * Pattern:
                 * - Odd counts (1,3,5,...)  -&gt; 1 char remains
                 * - Even counts (2,4,6,...) -&gt; 2 chars remain
                 *
                 * This works because:
                 * 1. We can delete 3 chars at a time
                 * 2. For odd counts, we can delete all but one char
                 * 3. For even counts, we must leave two chars
                 */</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abaacbcbb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected output: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual output: "</span> <span class="o">+</span> <span class="n">minimumLength</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"aa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2: "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual output: "</span> <span class="o">+</span> <span class="n">minimumLength</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aaaaa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3: "</span> <span class="o">+</span> <span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected output: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual output: "</span> <span class="o">+</span> <span class="n">minimumLength</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s. You can perform the following process on s any number of times: Choose an index i in the string such that there is at least one character to the left of index i that is equal to s[i], and at least one character to the right that is also equal to s[i]. Delete the closest character to the left of index i that is equal to s[i]. Delete the closest character to the right of index i that is equal to s[i]. Return the minimum length of the final string s that you can achieve.]]></summary></entry><entry><title type="html">2116. Check if a Parentheses String Can Be Valid</title><link href="https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid/" rel="alternate" type="text/html" title="2116. Check if a Parentheses String Can Be Valid"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid/"><![CDATA[<ul> <li>A parentheses string is a <strong>non-empty</strong> string consisting only of <code class="language-plaintext highlighter-rouge">'('</code> and <code class="language-plaintext highlighter-rouge">')'</code>. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>: <ul> <li>It is <code class="language-plaintext highlighter-rouge">()</code>.</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">AB</code> (<code class="language-plaintext highlighter-rouge">A</code> concatenated with <code class="language-plaintext highlighter-rouge">B</code>), where <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are valid parentheses strings.</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">(A)</code>, where <code class="language-plaintext highlighter-rouge">A</code> is a valid parentheses string.</li> </ul> </li> <li>You are given a parentheses string <code class="language-plaintext highlighter-rouge">s</code> and a string <code class="language-plaintext highlighter-rouge">locked</code>, both of length <code class="language-plaintext highlighter-rouge">n</code>. <code class="language-plaintext highlighter-rouge">locked</code> is a binary string consisting only of <code class="language-plaintext highlighter-rouge">'0'</code>s and <code class="language-plaintext highlighter-rouge">'1'</code>s. For <strong>each</strong> index <code class="language-plaintext highlighter-rouge">i</code> of <code class="language-plaintext highlighter-rouge">locked</code>, <ul> <li>If <code class="language-plaintext highlighter-rouge">locked[i]</code> is <code class="language-plaintext highlighter-rouge">'1'</code>, you <strong>cannot</strong> change <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> <li>But if <code class="language-plaintext highlighter-rouge">locked[i]</code> is <code class="language-plaintext highlighter-rouge">'0'</code>, you <strong>can</strong> change <code class="language-plaintext highlighter-rouge">s[i]</code> to either <code class="language-plaintext highlighter-rouge">'('</code> or <code class="language-plaintext highlighter-rouge">')'</code>.</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if you can make <code class="language-plaintext highlighter-rouge">s</code> a valid parentheses string</em>. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " ) ) ( ) ) ) ", locked = "010100"
Output: true
Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].
We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " ( ) ( ) ", locked = "0000"
Output: true
Explanation: We do not need to make any changes because s is already valid.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = ")", locked = "0"
Output: false
Explanation: locked permits  us to change s[0]. 
Changing s[0] to either '(' or ')' will not make s valid.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckIfAParenthesesStringCanBeValid</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canBeValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">locked</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the length is odd, it's impossible to form valid parentheses</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// First pass: Left to right scan to check for excess right parentheses</span>
        <span class="c1">// balance: tracks the difference between left and right parentheses for locked positions</span>
        <span class="c1">// wild: counts the number of modifiable positions that can be used to fix imbalances</span>
        <span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">wild</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Scan from left to right to ensure we never have too many right parentheses</span>
        <span class="c1">// This pass ensures that at each position, we can convert enough characters</span>
        <span class="c1">// to left parentheses to match any right parentheses we've seen</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">locked</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Position is modifiable, increment wild counter</span>
                <span class="n">wild</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Locked left parenthesis, increment balance</span>
                <span class="n">balance</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Locked right parenthesis, decrement balance</span>
                <span class="n">balance</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// If balance + wild &lt; 0, we have too many right parentheses</span>
            <span class="c1">// that cannot be fixed even using all modifiable positions</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">+</span> <span class="n">wild</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Second pass: Right to left scan to check for excess left parentheses</span>
        <span class="c1">// Reset counters for the reverse scan</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">wild</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Scan from right to left to ensure we never have too many left parentheses</span>
        <span class="c1">// This pass ensures that at each position (working backwards),</span>
        <span class="c1">// we can convert enough characters to right parentheses to match any left</span>
        <span class="c1">// parentheses we've seen</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">locked</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Position is modifiable, increment wild counter</span>
                <span class="n">wild</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Locked right parenthesis, increment balance</span>
                <span class="n">balance</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Locked left parenthesis, decrement balance</span>
                <span class="n">balance</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// If balance + wild &lt; 0, we have too many left parentheses</span>
            <span class="c1">// that cannot be fixed even using all modifiable positions</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">+</span> <span class="n">wild</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If both passes succeed, the string can be made valid</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String can be made valid by modifying unlocked positions</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">" ) ) ( ) ) )"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked1</span> <span class="o">=</span> <span class="s">"010100"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">locked1</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 2: Already valid string with all positions modifiable</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">" ( ) ( ) "</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked2</span> <span class="o">=</span> <span class="s">"0000"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">locked2</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 3: Single character cannot form valid parentheses</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">")"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked3</span> <span class="o">=</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">locked3</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 4: Additional test case with all positions modifiable</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">" ( ) ) "</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked4</span> <span class="o">=</span> <span class="s">"000"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s4</span><span class="o">,</span> <span class="n">locked4</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Medium"/><summary type="html"><![CDATA[A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true: It is (). It can be written as AB (A concatenated with B), where A and B are valid parentheses strings. It can be written as (A), where A is a valid parentheses string. You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked, If locked[i] is '1', you cannot change s[i]. But if locked[i] is '0', you can change s[i] to either '(' or ')'. Return true if you can make s a valid parentheses string. Otherwise, return false.]]></summary></entry><entry><title type="html">Dynamic-Length Sliding Window</title><link href="https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow/" rel="alternate" type="text/html" title="Dynamic-Length Sliding Window"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DynamicLengthSlidingWindow/"><![CDATA[<p>The sliding window is a powerful and efficient algorithmic technique for solving problems involving subarrays or substrings. It is particularly useful for problems requiring dynamic adjustments to window size, moving away from brute-force solutions. With sliding window techniques, the time complexity is reduced from O(n^2) to O(n)by avoiding unnecessary recalculations.</p> <p>This document provides a detailed explanation of the core concept, step-by-step implementation, and practical applications of dynamic-length sliding windows.</p> <h2 id="core-concept">Core Concept</h2> <p>The sliding window technique helps efficiently compute subarray (or substring) properties by <strong>dynamically adjusting window boundaries (start and end points)</strong>. The general process involves three key steps:</p> <ol> <li><strong>Window Expansion</strong>: Expand the window by moving the right boundary to include more elements while updating required properties dynamically (e.g., frequency, sum, or count).</li> <li><strong>Condition Validation</strong>: After every expansion, check whether the current window satisfies the required conditions.</li> <li><strong>Window Contraction</strong>: If the condition is violated, shrink the window from the left while recalculating the required properties until the condition is restored.</li> </ol> <p>By focusing only on valid windows, this methodology avoids redundant calculations, significantly improving efficiency.</p> <h2 id="example-problem">Example Problem</h2> <p><strong>Problem</strong>:</p> <p>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code> containing only <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code>, delete <strong>exactly one element</strong>, and return the length of the longest subarray that consists only of <code class="language-plaintext highlighter-rouge">1</code>.</p> <p><strong>Input</strong>: nums = [1, 1, 0, 1]</p> <p><strong>output</strong>: 3</p> <h2 id="dynamic-sliding-window-steps">Dynamic Sliding Window Steps</h2> <p>For this problem, we apply the sliding window pattern as follows:</p> <ol> <li><strong>Enter Window</strong>: Track the count of zeros as we expand the window.</li> <li><strong>Validate Condition</strong>: Ensure we don’t have more than one zero in our window.</li> <li><strong>Exit Window</strong>: Shrink the window when we exceed our zero limit.</li> </ol> <h3 id="example-walkthrough">Example Walkthrough</h3> <p>Using <code class="language-plaintext highlighter-rouge">nums = [1, 1, 0, 1]</code>:</p> <ol> <li><strong>Initialize</strong>: <ul> <li>Window start: <code class="language-plaintext highlighter-rouge">start = 0</code></li> <li>Zero counter: <code class="language-plaintext highlighter-rouge">zeroCount = 0</code></li> <li>Maximum length: <code class="language-plaintext highlighter-rouge">maxLength = 0</code></li> </ul> </li> <li><strong>Process Array</strong>: <ul> <li><strong>At end = 0</strong> (<code class="language-plaintext highlighter-rouge">nums[0] = 1</code>): Window: <code class="language-plaintext highlighter-rouge">[1]</code>, zeros = 0, <code class="language-plaintext highlighter-rouge">maxLength = 1</code></li> <li><strong>At end = 1</strong> (<code class="language-plaintext highlighter-rouge">nums[1] = 1</code>): Window: <code class="language-plaintext highlighter-rouge">[1, 1]</code>, zeros = 0, <code class="language-plaintext highlighter-rouge">maxLength = 2</code></li> <li><strong>At end = 2</strong> (<code class="language-plaintext highlighter-rouge">nums[2] = 0</code>): Window: <code class="language-plaintext highlighter-rouge">[1, 1, 0]</code>, zeros = 1, <code class="language-plaintext highlighter-rouge">maxLength = 3</code></li> <li><strong>At end = 3</strong> (<code class="language-plaintext highlighter-rouge">nums[3] = 1</code>): Window: <code class="language-plaintext highlighter-rouge">[1, 1, 0, 1]</code>, zeros = 1, <code class="language-plaintext highlighter-rouge">maxLength = 4</code></li> </ul> </li> </ol> <h2 id="implementation">Implementation</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">zeroCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Count of zeros in current window</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Length of longest valid subarray</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Start of current window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Expand window: Add current element</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zeroCount</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// 2. Contract window: Remove elements when condition violated</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">zeroCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">zeroCount</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="n">start</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// 3. Update result: Calculate current valid window length</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Handle edge case: all ones array</span>
        <span class="k">return</span> <span class="n">maxLength</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">maxLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <h3 id="explanation-of-key-steps">Explanation of Key Steps</h3> <ol> <li><strong>Enter Window</strong>: Add the current element to the window and update the zero count.</li> <li><strong>Exit Window</strong>: When the number of zeros exceeds 1, shrink the window from the left while reducing the zero count.</li> <li><strong>Update Answer</strong>: Continuously calculate the size of the valid window and keep track of the maximum length.</li> </ol> <h2 id="complexity-analysis">Complexity Analysis</h2> <ol> <li><strong>Time Complexity</strong>: <ul> <li>O(n): Each element is processed at most twice—once when entering the window and once when exiting.</li> </ul> </li> <li><strong>Space Complexity</strong>: <ul> <li>O(1): Only a few extra variables are used to track the window’s start and end, with no additional data structures.</li> </ul> </li> </ol> <h2 id="applications-and-scenarios">Applications and Scenarios</h2> <p>Dynamic sliding windows are highly versatile and applicable across a wide range of problems. Some common scenarios include:</p> <ol> <li><strong>Longest Subarray Problems</strong>: <ul> <li>Example: Finding the longest substring with at most K distinct characters.</li> </ul> </li> <li><strong>Frequency or Condition Checks</strong>: <ul> <li>Example: Tracking the frequency of a specific element within a window, ensuring it does not exceed a certain limit.</li> </ul> </li> <li><strong>Subarray/Substring Property Calculation</strong>: <ul> <li>Example: Dynamically calculating sums, products, or maximum/minimum values within sliding windows.</li> </ul> </li> <li><strong>Pattern Matching</strong>: <ul> <li>Example: Detecting valid substrings or subarrays that meet complex pattern requirements.</li> </ul> </li> </ol> <p>Mastering the dynamic sliding window technique allows you to efficiently solve various problems with changing constraints, optimizing your algorithmic performance.</p> <h2 id="edge-cases">Edge Cases</h2> <p>When utilizing the sliding window technique, it’s essential to consider edge cases to avoid errors in extreme scenarios. Key edge cases for this problem include:</p> <ol> <li><strong>All Ones</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[1, 1, 1]</code></li> <li>Output: Must subtract one, resulting in length <code class="language-plaintext highlighter-rouge">len(nums) - 1</code>.</li> </ul> </li> <li><strong>All Zeros</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[0, 0, 0]</code></li> <li>Output: No valid subarrays exist, resulting in output <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> </li> <li><strong>Empty Input</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[]</code></li> <li>Output: Should return <code class="language-plaintext highlighter-rouge">0</code> as there are no valid subarrays.</li> </ul> </li> <li><strong>Single Element</strong>: <ul> <li>Input: <code class="language-plaintext highlighter-rouge">[1]</code> or <code class="language-plaintext highlighter-rouge">[0]</code></li> <li>Output: Results in <code class="language-plaintext highlighter-rouge">0</code> due to the removal leaving no elements.</li> </ul> </li> </ol> <h2 id="summary">Summary</h2> <p>By mastering the dynamic sliding window approach, you can efficiently solve a wide variety of problems that require handling variable-sized subarrays or substrings. Its flexibility and high efficiency make it a crucial technique for algorithmic problem-solving.</p>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[The sliding window is a powerful and efficient algorithmic technique for solving problems involving subarrays or substrings. It is particularly useful for problems requiring dynamic adjustments to window size, moving away from brute-force solutions. With sliding window techniques, the time complexity is reduced from O(n^2) to O(n)by avoiding unnecessary recalculations.]]></summary></entry><entry><title type="html">2275. Largest Combination With Bitwise AND Greater Than Zero</title><link href="https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero/" rel="alternate" type="text/html" title="2275. Largest Combination With Bitwise AND Greater Than Zero"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero/"><![CDATA[<ul> <li>The <strong>bitwise AND</strong> of an array <code class="language-plaintext highlighter-rouge">nums</code> is the bitwise AND of all integers in <code class="language-plaintext highlighter-rouge">nums</code>. <ul> <li>For example, for <code class="language-plaintext highlighter-rouge">nums = [1, 5, 3]</code>, the bitwise AND is equal to <code class="language-plaintext highlighter-rouge">1 &amp; 5 &amp; 3 = 1</code>.</li> <li>Also, for <code class="language-plaintext highlighter-rouge">nums = [7]</code>, the bitwise AND is <code class="language-plaintext highlighter-rouge">7</code>.</li> </ul> </li> <li>You are given an array of positive integers <code class="language-plaintext highlighter-rouge">candidates</code>. Compute the <strong>bitwise AND</strong> for all possible <strong>combinations</strong> of elements in the <code class="language-plaintext highlighter-rouge">candidates</code> array.</li> <li>Return <em>the size of the <strong>largest</strong> combination of</em> <code class="language-plaintext highlighter-rouge">candidates</code> <em>with a bitwise AND <strong>greater</strong> than</em> <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [16,17,71,62,12,24,14]
Output: 4
Explanation: The combination [16,17,62,24] has a bitwise AND of 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0.
The size of the combination is 4.
It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.
Note that more than one combination may have the largest size.
For example, the combination [62,12,24,14] has a bitwise AND of 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [8,8]
Output: 2
Explanation: The largest combination [8,8] has a bitwise AND of 8 &amp; 8 = 8 &gt; 0.
The size of the combination is 2, so we return 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogU) time | O(logU) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LargestCombinationWithBitwiseANDGreaterThanZero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">largestCombination</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create an array to store the count of 1s at each binary position (0-23)</span>
        <span class="c1">// Size is 24 because the constraint states candidates[i] &lt;= 10^7 &lt; 2^24</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">24</span><span class="o">];</span>

        <span class="c1">// Iterate through each number in the candidates array</span>
        <span class="c1">// For each number, we'll count how many 1s appear at each binary position</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Process each bit of the current number until it becomes 0</span>
            <span class="c1">// i represents the current bit position (0-based, from right to left)</span>
            <span class="c1">// The loop continues as long as there are 1s remaining in x</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// x &amp; 1 extracts the rightmost bit (0 or 1)</span>
                <span class="c1">// Add this bit to the count at position i</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Right shift x by 1 to process the next bit in the next iteration</span>
                <span class="c1">// This effectively removes the rightmost bit we just processed</span>
                <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Find the maximum count across all bit positions</span>
        <span class="c1">// This represents the size of the largest possible combination</span>
        <span class="c1">// where all numbers have 1 at the same position</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">cnt</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example with multiple valid combinations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">16</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">71</span><span class="o">,</span><span class="mi">62</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">24</span><span class="o">,</span><span class="mi">14</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2: Example with identical numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 3: Example with large numbers using bit shifting</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates3</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[The bitwise AND of an array nums is the bitwise AND of all integers in nums. For example, for nums=[1, 5, 3], the bitwise AND is equal to 1 &amp; 5 &amp; 3=1. Also, for nums=[7], the bitwise AND is 7. You are given an array of positive integers candidates. Compute the bitwise AND for all possible combinations of elements in the candidates array. Return the size of the largest combination of candidates with a bitwise AND greater than 0.]]></summary></entry><entry><title type="html">1493. Longest Subarray of 1’s After Deleting One Element</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement/" rel="alternate" type="text/html" title="1493. Longest Subarray of 1’s After Deleting One Element"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code>, you should delete one element from it.</li> <li>Return <em>the size of the longest non-empty subarray containing only</em> <code class="language-plaintext highlighter-rouge">1</code><em>’s in the resulting array</em>. Return <code class="language-plaintext highlighter-rouge">0</code> if there is no such subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubarrayOf1sAfteDeletingOneElement</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">zeroCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Keeps track of the number of zeros in the current window</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Tracks the length of the longest subarray found</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Left boundary of the sliding window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Enter window: The current element is added to the window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zeroCount</span><span class="o">++;</span> <span class="c1">// Increment zero count if the current element is 0</span>
            <span class="o">}</span>

            <span class="c1">// 2. Exit window: Adjust the window to ensure the condition (at most one zero) is satisfied</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">zeroCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// If there are more than one zero in the window</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">zeroCount</span><span class="o">--;</span> <span class="c1">// Decrement zero count if the leftmost element is 0</span>
                <span class="o">}</span>
                <span class="n">start</span><span class="o">++;</span> <span class="c1">// Move the left boundary of the window to the right</span>
            <span class="o">}</span>

            <span class="c1">// 3. Update answer: Update the maximum length for a valid subarray</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span> <span class="c1">// Calculate the current valid window size</span>
        <span class="o">}</span>

        <span class="c1">// Special case: If the array consists entirely of 1s, the result should exclude one element</span>
        <span class="k">return</span> <span class="n">maxLength</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">maxLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Additional test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Additional test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a binary array nums, you should delete one element from it. Return the size of the longest non-empty subarray containing only 1’s in the resulting array. Return 0 if there is no such subarray.]]></summary></entry><entry><title type="html">1400. Construct K Palindrome Strings</title><link href="https://zhengstar94.github.io//blog/2025/ConstructKPalindromeStrings/" rel="alternate" type="text/html" title="1400. Construct K Palindrome Strings"/><published>2025-01-11T00:00:00+00:00</published><updated>2025-01-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ConstructKPalindromeStrings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ConstructKPalindromeStrings/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if you can use all the characters in</em> <code class="language-plaintext highlighter-rouge">s</code> <em>to construct</em> <code class="language-plaintext highlighter-rouge">k</code> <em>palindrome strings or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "annabelle", k = 2
Output: true
Explanation: You can construct two palindromes using all characters in s.
Some possible constructions "anna" + "elble", "anbna" + "elle", "anellena" + "b"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "leetcode", k = 3
Output: false
Explanation: It is impossible to construct 3 palindromes using all the characters of s.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "true", k = 4
Output: true
Explanation: The only possible solution is to put each character in a separate  string.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstructKPalindromeStrings</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canConstruct</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If k is greater than the string length, it's impossible to construct</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Count the frequency of each character</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Count the number of characters that appear odd times</span>
        <span class="kt">int</span> <span class="n">oddCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oddCount</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If the number of characters appearing odd times is greater than k,</span>
        <span class="c1">// we cannot construct k palindrome strings</span>
        <span class="c1">// If k=1, we can have any number of odd frequency characters</span>
        <span class="c1">// If k&gt;1, the number of odd frequency characters cannot exceed k</span>
        <span class="k">return</span> <span class="n">oddCount</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"annabelle"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">canConstruct</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Should output true</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"leetcode"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">canConstruct</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Should output false</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"true"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">canConstruct</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Should output true</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.]]></summary></entry><entry><title type="html">3270. Find the Key of the Numbers</title><link href="https://zhengstar94.github.io//blog/2025/FindTheKeyOfTheNumbers/" rel="alternate" type="text/html" title="3270. Find the Key of the Numbers"/><published>2025-01-11T00:00:00+00:00</published><updated>2025-01-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheKeyOfTheNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheKeyOfTheNumbers/"><![CDATA[<ul> <li>You are given three <strong>positive</strong> integers <code class="language-plaintext highlighter-rouge">num1</code>, <code class="language-plaintext highlighter-rouge">num2</code>, and <code class="language-plaintext highlighter-rouge">num3</code>.</li> <li>The <code class="language-plaintext highlighter-rouge">key</code> of <code class="language-plaintext highlighter-rouge">num1</code>, <code class="language-plaintext highlighter-rouge">num2</code>, and <code class="language-plaintext highlighter-rouge">num3</code> is defined as a four-digit number such that: <ul> <li>Initially, if any number has <strong>less than</strong> four digits, it is padded with <strong>leading zeros</strong>.</li> <li>The <code class="language-plaintext highlighter-rouge">ith</code> digit (<code class="language-plaintext highlighter-rouge">1 &lt;= i &lt;= 4</code>) of the <code class="language-plaintext highlighter-rouge">key</code> is generated by taking the <strong>smallest</strong> digit among the <code class="language-plaintext highlighter-rouge">ith</code> digits of <code class="language-plaintext highlighter-rouge">num1</code>, <code class="language-plaintext highlighter-rouge">num2</code>, and <code class="language-plaintext highlighter-rouge">num3</code>.</li> </ul> </li> <li>Return the <code class="language-plaintext highlighter-rouge">key</code> of the three numbers <strong>without</strong> leading zeros (<em>if any</em>).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 1, num2 = 10, num3 = 1000

Output: 0

Explanation:

On padding, num1 becomes "0001", num2 becomes "0010", and num3 remains "1000".

The 1st digit of the key is min(0, 0, 1).
The 2nd digit of the key is min(0, 0, 0).
The 3rd digit of the key is min(0, 1, 0).
The 4th digit of the key is min(1, 0, 0).
Hence, the key is "0000", i.e. 0.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 987, num2 = 879, num3 = 798

Output: 777
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 1, num2 = 2, num3 = 3

Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheKeyOfTheNumbers</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findKey</span><span class="o">(</span><span class="kt">int</span> <span class="n">num1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num3</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert numbers to 4-digit strings with leading zeros</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%04d"</span><span class="o">,</span> <span class="n">num1</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%04d"</span><span class="o">,</span> <span class="n">num2</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%04d"</span><span class="o">,</span> <span class="n">num3</span><span class="o">);</span>

        <span class="nc">StringBuilder</span> <span class="n">key</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// Iterate through each digit and find the minimum value</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                            <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">,</span>
                            <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">),</span>
                    <span class="n">s3</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span>
            <span class="o">);</span>
            <span class="n">key</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">digit</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Convert to integer and return</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">num1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: num1 = "</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="s">", num2 = "</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="s">", num3 = "</span> <span class="o">+</span> <span class="n">num3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKey</span><span class="o">(</span><span class="n">num1</span><span class="o">,</span> <span class="n">num2</span><span class="o">,</span> <span class="n">num3</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2:"</span><span class="o">);</span>
        <span class="n">num1</span> <span class="o">=</span> <span class="mi">987</span><span class="o">;</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">879</span><span class="o">;</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">798</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: num1 = "</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="s">", num2 = "</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="s">", num3 = "</span> <span class="o">+</span> <span class="n">num3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKey</span><span class="o">(</span><span class="n">num1</span><span class="o">,</span> <span class="n">num2</span><span class="o">,</span> <span class="n">num3</span><span class="o">));</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3:"</span><span class="o">);</span>
        <span class="n">num1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: num1 = "</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="s">", num2 = "</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="s">", num3 = "</span> <span class="o">+</span> <span class="n">num3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKey</span><span class="o">(</span><span class="n">num1</span><span class="o">,</span> <span class="n">num2</span><span class="o">,</span> <span class="n">num3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are given three positive integers num1, num2, and num3. The key of num1, num2, and num3 is defined as a four-digit number such that: Initially, if any number has less than four digits, it is padded with leading zeros. The ith digit (1 &lt;= i &lt;= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3. Return the key of the three numbers without leading zeros (if any).]]></summary></entry><entry><title type="html">3. Longest Substring Without Repeating Characters</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubstringWithoutRepeatingCharacters/" rel="alternate" type="text/html" title="3. Longest Substring Without Repeating Characters"/><published>2025-01-11T00:00:00+00:00</published><updated>2025-01-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubstringWithoutRepeatingCharacters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubstringWithoutRepeatingCharacters/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, find the length of the <strong>longest</strong> <strong>substring</strong> without repeating characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n)time∣O(m)space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/03/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubstringWithoutRepeatingCharacters</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="c1">// Use array instead of HashMap to store the last position of each character</span>
    <span class="c1">// Array index is the character's ASCII value (0-127)</span>
    <span class="c1">// Array value is the last position where this character appeared</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">lastSeen</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

    <span class="c1">// Initialize all positions to -1, meaning no character has been seen yet</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">lastSeen</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

    <span class="c1">// Variable to store the length of longest substring found so far</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// Variable to mark the start position of current window</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="c1">// 1. Window Entry Check:</span>
      <span class="c1">// Check if current character causes window to shrink</span>
      <span class="c1">// If the last occurrence of current character is within or at the start of our window,</span>
      <span class="c1">// we need to move the window start to avoid repeating characters</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">lastSeen</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">lastSeen</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Move start to just after the last occurrence</span>
      <span class="o">}</span>

      <span class="c1">// 2. Update Answer:</span>
      <span class="c1">// Current window size is (i - start + 1)</span>
      <span class="c1">// Update max length if current window is longer</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

      <span class="c1">// 3. Update Character Position:</span>
      <span class="c1">// Record the current position of character for future reference</span>
      <span class="c1">// This helps us detect repeating characters in future iterations</span>
      <span class="n">lastSeen</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Test the function with example string "abcabcbb"</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcabcbb"</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>  <span class="c1">// Output: 3</span>

    <span class="c1">// Test the function with example string "bbbbb"</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"bbbbb"</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>  <span class="c1">// Output: 1</span>

    <span class="c1">// Test the function with example string "pwwkew"</span>
    <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"pwwkew"</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span>  <span class="c1">// Output: 3</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, find the length of the longest substring without repeating characters.]]></summary></entry></feed>