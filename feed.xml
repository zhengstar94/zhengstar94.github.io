<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-26T05:21:23+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1472. Design Browser History</title><link href="https://zhengstar94.github.io//blog/2025/BrowserHistory/" rel="alternate" type="text/html" title="1472. Design Browser History"/><published>2025-02-26T00:00:00+00:00</published><updated>2025-02-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BrowserHistory</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BrowserHistory/"><![CDATA[<ul> <li>You have a <strong>browser</strong> of one tab where you start on the <code class="language-plaintext highlighter-rouge">homepage</code> and you can visit another <code class="language-plaintext highlighter-rouge">url</code>, get back in the history number of <code class="language-plaintext highlighter-rouge">steps</code> or move forward in the history number of <code class="language-plaintext highlighter-rouge">steps</code>.</li> <li>Implement the <code class="language-plaintext highlighter-rouge">BrowserHistory</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">BrowserHistory(string homepage)</code> Initializes the object with the <code class="language-plaintext highlighter-rouge">homepage</code> of the browser.</li> <li><code class="language-plaintext highlighter-rouge">void visit(string url)</code> Visits <code class="language-plaintext highlighter-rouge">url</code> from the current page. It clears up all the forward history.</li> <li><code class="language-plaintext highlighter-rouge">string back(int steps)</code> Move <code class="language-plaintext highlighter-rouge">steps</code> back in history. If you can only return <code class="language-plaintext highlighter-rouge">x</code> steps in the history and <code class="language-plaintext highlighter-rouge">steps &gt; x</code>, you will return only <code class="language-plaintext highlighter-rouge">x</code> steps. Return the current <code class="language-plaintext highlighter-rouge">url</code> after moving back in history <strong>at most</strong> <code class="language-plaintext highlighter-rouge">steps</code>.</li> <li><code class="language-plaintext highlighter-rouge">string forward(int steps)</code> Move <code class="language-plaintext highlighter-rouge">steps</code> forward in history. If you can only forward <code class="language-plaintext highlighter-rouge">x</code> steps in the history and <code class="language-plaintext highlighter-rouge">steps &gt; x</code>, you will forward only <code class="language-plaintext highlighter-rouge">x</code> steps. Return the current <code class="language-plaintext highlighter-rouge">url</code> after forwarding in history <strong>at most</strong> <code class="language-plaintext highlighter-rouge">steps</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
Output:
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

Explanation:
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // You are in "leetcode.com". Visit "google.com"
browserHistory.visit("facebook.com");     // You are in "google.com". Visit "facebook.com"
browserHistory.visit("youtube.com");      // You are in "facebook.com". Visit "youtube.com"
browserHistory.back(1);                   // You are in "youtube.com", move back to "facebook.com" return "facebook.com"
browserHistory.back(1);                   // You are in "facebook.com", move back to "google.com" return "google.com"
browserHistory.forward(1);                // You are in "google.com", move forward to "facebook.com" return "facebook.com"
browserHistory.visit("linkedin.com");     // You are in "facebook.com". Visit "linkedin.com"
browserHistory.forward(2);                // You are in "linkedin.com", you cannot move forward any steps.
browserHistory.back(2);                   // You are in "linkedin.com", move back two steps to "facebook.com" then to "google.com". return "google.com"
browserHistory.back(7);                   // You are in "google.com", you can move back only one step to "leetcode.com". return "leetcode.com"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BrowserHistory</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">history</span><span class="o">;</span> <span class="c1">// Store browser history</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">current</span><span class="o">;</span>              <span class="c1">// Current position index</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>                 <span class="c1">// Valid history size</span>

    <span class="cm">/**
     * Initialize browser history with homepage
     * @param homepage Initial homepage URL
     */</span>
    <span class="kd">public</span> <span class="nf">BrowserHistory</span><span class="o">(</span><span class="nc">String</span> <span class="n">homepage</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">history</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">history</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">homepage</span><span class="o">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Visit a new URL
     * @param url URL to visit
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">current</span><span class="o">++;</span>
        <span class="c1">// If current exceeds ArrayList size, add new element</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">history</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">history</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">history</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Update valid history size</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Move back in history
     * @param steps Number of steps to move back
     * @return URL after moving back
     */</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">back</span><span class="o">(</span><span class="kt">int</span> <span class="n">steps</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">current</span> <span class="o">-</span> <span class="n">steps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">history</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Move forward in history
     * @param steps Number of steps to move forward
     * @return URL after moving forward
     */</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">forward</span><span class="o">(</span><span class="kt">int</span> <span class="n">steps</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">current</span> <span class="o">+</span> <span class="n">steps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">history</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BrowserHistory</span> <span class="n">browserHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BrowserHistory</span><span class="o">(</span><span class="s">"leetcode.com"</span><span class="o">);</span>
        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"google.com"</span><span class="o">);</span>
        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"facebook.com"</span><span class="o">);</span>
        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"youtube.com"</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// Returns "facebook.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// Returns "google.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span> <span class="c1">// Returns "facebook.com"</span>

        <span class="n">browserHistory</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="s">"linkedin.com"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span> <span class="c1">// Returns "linkedin.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>    <span class="c1">// Returns "google.com"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">browserHistory</span><span class="o">.</span><span class="na">back</span><span class="o">(</span><span class="mi">7</span><span class="o">));</span>    <span class="c1">// Returns "leetcode.com"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps. Implement the BrowserHistory class: BrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history. If you can only return x steps in the history and steps &gt; x, you will return only x steps. Return the current url after moving back in history at most steps. string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps &gt; x, you will forward only x steps. Return the current url after forwarding in history at most steps.]]></summary></entry><entry><title type="html">1749. Maximum Absolute Sum of Any Subarray</title><link href="https://zhengstar94.github.io//blog/2025/MaximumAbsoluteSumOfAnySubarray/" rel="alternate" type="text/html" title="1749. Maximum Absolute Sum of Any Subarray"/><published>2025-02-26T00:00:00+00:00</published><updated>2025-02-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumAbsoluteSumOfAnySubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumAbsoluteSumOfAnySubarray/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. The <strong>absolute sum</strong> of a subarray <code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> is <code class="language-plaintext highlighter-rouge">abs(numsl + numsl+1 + ... + numsr-1 + numsr)</code>.</li> <li>Return <em>the <strong>maximum</strong> absolute sum of any <strong>(possibly empty)</strong> subarray of</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Note that <code class="language-plaintext highlighter-rouge">abs(x)</code> is defined as follows: <ul> <li>If <code class="language-plaintext highlighter-rouge">x</code> is a negative integer, then <code class="language-plaintext highlighter-rouge">abs(x) = -x</code>.</li> <li>If <code class="language-plaintext highlighter-rouge">x</code> is a non-negative integer, then <code class="language-plaintext highlighter-rouge">abs(x) = x</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,-3,2,3,-4]
Output: 5
Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,-5,1,-4,3,-2]
Output: 8
Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumAbsoluteSumOfAnySubarray</span> <span class="o">{</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxAbsoluteSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize variables to track maximum and minimum sums</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">minSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Variable to maintain running sum (prefix sum)</span>
        <span class="kt">int</span> <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array once</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Add current number to running sum</span>
            <span class="n">currSum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
            <span class="c1">// Update maximum sum if current sum is larger</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">currSum</span><span class="o">);</span>
            <span class="c1">// Update minimum sum if current sum is smaller</span>
            <span class="n">minSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minSum</span><span class="o">,</span> <span class="n">currSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the difference between maximum and minimum sums</span>
        <span class="c1">// This difference represents the maximum absolute sum possible</span>
        <span class="k">return</span> <span class="n">maxSum</span> <span class="o">-</span> <span class="n">minSum</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed positive and negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 2: Another mixed case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 8</span>

        <span class="c1">// Test Case 3: All positive numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>

        <span class="c1">// Test Case 4: All negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxAbsoluteSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr). Return the maximum absolute sum of any (possibly empty) subarray of nums. Note that abs(x) is defined as follows: If x is a negative integer, then abs(x) = -x. If x is a non-negative integer, then abs(x) = x.]]></summary></entry><entry><title type="html">1616. Split Two Strings to Make Palindrome</title><link href="https://zhengstar94.github.io//blog/2025/SplitTwoStringsToMakePalindrome/" rel="alternate" type="text/html" title="1616. Split Two Strings to Make Palindrome"/><published>2025-02-26T00:00:00+00:00</published><updated>2025-02-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SplitTwoStringsToMakePalindrome</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SplitTwoStringsToMakePalindrome/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> of the same length. Choose an index and split both strings <strong>at the same index</strong>, splitting <code class="language-plaintext highlighter-rouge">a</code> into two strings: <code class="language-plaintext highlighter-rouge">aprefix</code> and <code class="language-plaintext highlighter-rouge">asuffix</code> where <code class="language-plaintext highlighter-rouge">a = aprefix + asuffix</code>, and splitting <code class="language-plaintext highlighter-rouge">b</code> into two strings: <code class="language-plaintext highlighter-rouge">bprefix</code> and <code class="language-plaintext highlighter-rouge">bsuffix</code> where <code class="language-plaintext highlighter-rouge">b = bprefix + bsuffix</code>. Check if <code class="language-plaintext highlighter-rouge">aprefix + bsuffix</code> or <code class="language-plaintext highlighter-rouge">bprefix + asuffix</code> forms a palindrome.</li> <li>When you split a string <code class="language-plaintext highlighter-rouge">s</code> into <code class="language-plaintext highlighter-rouge">sprefix</code> and <code class="language-plaintext highlighter-rouge">ssuffix</code>, either <code class="language-plaintext highlighter-rouge">ssuffix</code> or <code class="language-plaintext highlighter-rouge">sprefix</code> is allowed to be empty. For example, if <code class="language-plaintext highlighter-rouge">s = "abc"</code>, then <code class="language-plaintext highlighter-rouge">"" + "abc"</code>, <code class="language-plaintext highlighter-rouge">"a" + "bc"</code>, <code class="language-plaintext highlighter-rouge">"ab" + "c"</code> , and <code class="language-plaintext highlighter-rouge">"abc" + ""</code> are valid splits.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to form</em> <em>a palindrome string, otherwise return</em> <code class="language-plaintext highlighter-rouge">false</code>.</li> <li><strong>Notice</strong> that <code class="language-plaintext highlighter-rouge">x + y</code> denotes the concatenation of strings <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = "x", b = "y"
Output: true
Explaination: If either a or b are palindromes the answer is true since you can split in the following way:
aprefix = "", asuffix = "x"
bprefix = "", bsuffix = "y"
Then, aprefix + bsuffix = "" + "y" = "y", which is a palindrome.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = "xbdef", b = "xecab"
Output: false
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = "ulacfd", b = "jizalu"
Output: true
Explaination: Split them at index 3:
aprefix = "ula", asuffix = "cfd"
bprefix = "jiz", bsuffix = "alu"
Then, aprefix + bsuffix = "ula" + "alu" = "ulaalu", which is a palindrome.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SplitTwoStringsToMakePalindrome</span> <span class="o">{</span>

    <span class="cm">/**
     * Main method to check if it's possible to form a palindrome by splitting and combining strings
     * This method tries both combinations:
     * 1. prefix of a + suffix of b
     * 2. prefix of b + suffix of a
     *
     * @param a First input string
     * @param b Second input string
     * @return true if a palindrome can be formed, false otherwise
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkPalindromeFormation</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Try both combinations and return true if either works</span>
        <span class="k">return</span> <span class="nf">checkPalindrome</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">||</span> <span class="n">checkPalindrome</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to check if one combination can form a palindrome
     * Uses two-pointer technique to check characters from both ends
     *
     * Key algorithm steps:
     * 1. Match characters from both ends until mismatch is found
     * 2. If pointers cross or meet, we've found a palindrome
     * 3. Otherwise, check if remaining substring in either string is palindrome
     *
     * @param a String to use for prefix
     * @param b String to use for suffix
     * @return true if a palindrome can be formed
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers: left starts from beginning, right from end</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// First phase: Match characters from both ends</span>
        <span class="c1">// Continue while pointers haven't met and characters match</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="c1">// If pointers have met or crossed, we've found a palindrome</span>
        <span class="c1">// This means all characters matched successfully</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Second phase: Check if remaining substring in either string is palindrome</span>
        <span class="c1">// We only need one of them to be palindrome to succeed</span>
        <span class="k">return</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">||</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to check if a substring is palindrome
     * Uses two-pointer technique to compare characters from both ends
     *
     * @param s String to check
     * @param left Start index of substring
     * @param right End index of substring
     * @return true if the substring is palindrome
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Continue checking while pointers haven't met</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If characters don't match, it's not a palindrome</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">// If we get here, the substring is palindrome</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Single character strings</span>
        <span class="nc">String</span> <span class="n">a1</span> <span class="o">=</span> <span class="s">"x"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b1</span> <span class="o">=</span> <span class="s">"y"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 2: No palindrome possible</span>
        <span class="nc">String</span> <span class="n">a2</span> <span class="o">=</span> <span class="s">"xbdef"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b2</span> <span class="o">=</span> <span class="s">"xecab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test Case 3: Palindrome possible with prefix/suffix combination</span>
        <span class="nc">String</span> <span class="n">a3</span> <span class="o">=</span> <span class="s">"ulacfd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b3</span> <span class="o">=</span> <span class="s">"jizalu"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a3</span><span class="o">,</span> <span class="n">b3</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 4: Palindrome possible with partial matching</span>
        <span class="nc">String</span> <span class="n">a4</span> <span class="o">=</span> <span class="s">"abdef"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b4</span> <span class="o">=</span> <span class="s">"fecab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a4</span><span class="o">,</span> <span class="n">b4</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 5: Palindrome possible with longer strings</span>
        <span class="nc">String</span> <span class="n">a5</span> <span class="o">=</span> <span class="s">"abadef"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b5</span> <span class="o">=</span> <span class="s">"fedcba"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">checkPalindromeFormation</span><span class="o">(</span><span class="n">a5</span><span class="o">,</span> <span class="n">b5</span><span class="o">));</span> <span class="c1">// Expected: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><summary type="html"><![CDATA[You are given two strings a and b of the same length. Choose an index and split both strings at the same index, splitting a into two strings: aprefix and asuffix where a=aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b=bprefix + bsuffix. Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome. When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. For example, if s="abc", then "" + "abc", "a" + "bc", "ab" + "c" , and "abc" + "" are valid splits. Return true if it is possible to form a palindrome string, otherwise return false. Notice that x + y denotes the concatenation of strings x and y.]]></summary></entry><entry><title type="html">948. Bag of Tokens</title><link href="https://zhengstar94.github.io//blog/2025/BagOfTokens/" rel="alternate" type="text/html" title="948. Bag of Tokens"/><published>2025-02-25T00:00:00+00:00</published><updated>2025-02-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BagOfTokens</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BagOfTokens/"><![CDATA[<ul> <li>You start with an initial <strong>power</strong> of <code class="language-plaintext highlighter-rouge">power</code>, an initial <strong>score</strong> of <code class="language-plaintext highlighter-rouge">0</code>, and a bag of tokens given as an integer array <code class="language-plaintext highlighter-rouge">tokens</code>, where each <code class="language-plaintext highlighter-rouge">tokens[i]</code> denotes the value of token<em>i</em>.</li> <li>Your goal is to <strong>maximize</strong> the total <strong>score</strong> by strategically playing these tokens. In one move, you can play an <strong>unplayed</strong> token in one of the two ways (but not both for the same token): <ul> <li><strong>Face-up</strong>: If your current power is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">tokens[i]</code>, you may play token<em>i</em>, losing <code class="language-plaintext highlighter-rouge">tokens[i]</code> power and gaining <code class="language-plaintext highlighter-rouge">1</code> score.</li> <li><strong>Face-down</strong>: If your current score is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">1</code>, you may play token<em>i</em>, gaining <code class="language-plaintext highlighter-rouge">tokens[i]</code> power and losing <code class="language-plaintext highlighter-rouge">1</code> score.</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> possible score you can achieve after playing <strong>any</strong> number of tokens</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = [100], power = 50

Output: 0

Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0] (100).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = [200,100], power = 150

Output: 1

Explanation: Play token1 (100) face-up, reducing your power to 50 and increasing your score to 1.

There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = [100,200,300,400], power = 200

Output: 2

Explanation: Play the tokens in this order to get a score of 2:

Play token0 (100) face-up, reducing power to 100 and increasing score to 1.
Play token3 (400) face-down, increasing power to 500 and reducing score to 0.
Play token1 (200) face-up, reducing power to 300 and increasing score to 1.
Play token2 (300) face-up, reducing power to 0 and increasing score to 2.
The maximum score achievable is 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BagOfTokens</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bagOfTokensScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tokens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">power</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or empty array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tokens</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tokens</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort tokens in ascending order to optimize token usage</span>
        <span class="c1">// Smallest tokens will be used for face-up plays</span>
        <span class="c1">// Largest tokens will be used for face-down plays</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">tokens</span><span class="o">);</span>

        <span class="c1">// Initialize two pointers:</span>
        <span class="c1">// left: points to the smallest unused token</span>
        <span class="c1">// right: points to the largest unused token</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tokens</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Track both current and maximum scores</span>
        <span class="c1">// currentScore: score at current state</span>
        <span class="c1">// maxScore: highest score achieved so far</span>
        <span class="kt">int</span> <span class="n">currentScore</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxScore</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/* Main game loop:
         * Continue while there are tokens to play (left &lt;= right) AND
         * either we have enough power to play face-up (power &gt;= tokens[left])
         * or we have score to play face-down (currentScore &gt; 0)
         */</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">power</span> <span class="o">&gt;=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">||</span> <span class="n">currentScore</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
            <span class="cm">/* Face-up play loop:
             * While we have enough power, keep playing tokens face-up
             * This maximizes our current score using minimum power
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">power</span> <span class="o">&gt;=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">power</span> <span class="o">-=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>    <span class="c1">// Spend power</span>
                <span class="n">currentScore</span><span class="o">++;</span>           <span class="c1">// Gain one score</span>
                <span class="n">left</span><span class="o">++;</span>                   <span class="c1">// Move to next smallest token</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum score achieved after face-up plays</span>
            <span class="n">maxScore</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxScore</span><span class="o">,</span> <span class="n">currentScore</span><span class="o">);</span>

            <span class="cm">/* Face-down play:
             * If we can't play face-up but have score to spend,
             * play the largest remaining token face-down to gain more power
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">currentScore</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">power</span> <span class="o">+=</span> <span class="n">tokens</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>   <span class="c1">// Gain power</span>
                <span class="n">currentScore</span><span class="o">--;</span>           <span class="c1">// Spend one score</span>
                <span class="n">right</span><span class="o">--;</span>                  <span class="c1">// Move to next largest token</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxScore</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Cannot play any token</span>
        <span class="c1">// Expected output: 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tokens1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">power1</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">bagOfTokensScore</span><span class="o">(</span><span class="n">tokens1</span><span class="o">,</span> <span class="n">power1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Can play one token face-up</span>
        <span class="c1">// Expected output: 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tokens2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">200</span><span class="o">,</span> <span class="mi">100</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">power2</span> <span class="o">=</span> <span class="mi">150</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">bagOfTokensScore</span><span class="o">(</span><span class="n">tokens2</span><span class="o">,</span> <span class="n">power2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Complex case with multiple plays</span>
        <span class="c1">// Expected output: 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tokens3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100</span><span class="o">,</span> <span class="mi">200</span><span class="o">,</span> <span class="mi">300</span><span class="o">,</span> <span class="mi">400</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">power3</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">bagOfTokensScore</span><span class="o">(</span><span class="n">tokens3</span><span class="o">,</span> <span class="n">power3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><summary type="html"><![CDATA[You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] denotes the value of tokeni. Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token): Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score. Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score. Return the maximum possible score you can achieve after playing any number of tokens.]]></summary></entry><entry><title type="html">1524. Number of Sub-arrays With Odd Sum</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfSubArraysWithOddSum/" rel="alternate" type="text/html" title="1524. Number of Sub-arrays With Odd Sum"/><published>2025-02-25T00:00:00+00:00</published><updated>2025-02-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfSubArraysWithOddSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfSubArraysWithOddSum/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">arr</code>, return <em>the number of subarrays with an <strong>odd</strong> sum</em>.</li> <li>Since the answer can be very large, return it modulo <code class="language-plaintext highlighter-rouge">10^9 + 7</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,3,5]
Output: 4
Explanation: All subarrays are [ [ 1],[1,3],[1,3,5],[3],[3,5],[5 ] ]
All sub-arrays sum are [1,4,9,3,8,5].
Odd sums are [1,9,3,5] so the answer is 4.

</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,4,6]
Output: 0
Explanation: All subarrays are [ [ 2],[2,4],[2,4,6],[4],[4,6],[6 ] ]
All sub-arrays sum are [2,6,12,4,10,6].
All sub-arrays have even sum and the answer is 0.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,3,4,5,6,7]
Output: 16
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSubArraysWithOddSum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numOfSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Define the modulo constant to handle large numbers</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="no">MODULO</span> <span class="o">=</span> <span class="mi">1000000007</span><span class="o">;</span>

        <span class="c1">// odd: count of prefix sums that are odd</span>
        <span class="c1">// even: count of prefix sums that are even, initialized to 1 (empty array sum is 0, which is even)</span>
        <span class="kt">int</span> <span class="n">odd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">even</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Variable to store the total count of subarrays with odd sum</span>
        <span class="kt">int</span> <span class="n">subarrays</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Variable to store the running prefix sum</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to prefix sum</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="cm">/* Key Logic:
             * 1. If current prefix sum is even:
             *    - To get odd sum subarray, we need previous odd prefix sums
             *    - Because even - odd = odd
             * 2. If current prefix sum is odd:
             *    - To get odd sum subarray, we need previous even prefix sums
             *    - Because odd - even = odd
             */</span>
            <span class="n">subarrays</span> <span class="o">=</span> <span class="o">(</span><span class="n">subarrays</span> <span class="o">+</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">odd</span> <span class="o">:</span> <span class="n">even</span><span class="o">))</span> <span class="o">%</span> <span class="no">MODULO</span><span class="o">;</span>

            <span class="c1">// Update the counts of odd and even prefix sums</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If current prefix sum is even, increment even count</span>
                <span class="n">even</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current prefix sum is odd, increment odd count</span>
                <span class="n">odd</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">subarrays</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output is 4</span>
        <span class="c1">// Subarrays with odd sum: [1], [1,3,5], [3], [5]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numOfSubarrays</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expected output is 0</span>
        <span class="c1">// All subarrays have even sum</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numOfSubarrays</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expected output is 16</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numOfSubarrays</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[Given an array of integers arr, return the number of subarrays with an odd sum. Since the answer can be very large, return it modulo 10^9 + 7.]]></summary></entry><entry><title type="html">923. 3Sum With Multiplicity</title><link href="https://zhengstar94.github.io//blog/2025/ThreeSumWithMultiplicity/" rel="alternate" type="text/html" title="923. 3Sum With Multiplicity"/><published>2025-02-24T00:00:00+00:00</published><updated>2025-02-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ThreeSumWithMultiplicity</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ThreeSumWithMultiplicity/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">arr</code>, and an integer <code class="language-plaintext highlighter-rouge">target</code>, return the number of tuples <code class="language-plaintext highlighter-rouge">i, j, k</code> such that <code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code> and <code class="language-plaintext highlighter-rouge">arr[i] + arr[j] + arr[k] == target</code>.</li> <li>As the answer can be very large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">109 + 7</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8
Output: 20
Explanation: 
Enumerating by the values (arr[i], arr[j], arr[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,1,2,2,2,2], target = 5
Output: 12
Explanation: 
arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,1,3], target = 6
Output: 1
Explanation: (1, 2, 3) occured one time in the array so we return 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeSumWithMultiplicity</span> <span class="o">{</span>
    <span class="c1">// Constant for modulo operation as per problem requirement</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1000000007</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">threeSumMulti</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Count array to store frequency of each number</span>
        <span class="c1">// Since constraints mention array elements &lt;= 100, we use array size 101</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="mi">101</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">num</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Case 1: All three numbers are different (i != j != k)</span>
        <span class="c1">// Example: For target = 8, finding combinations like (1,2,5) where:</span>
        <span class="c1">// - i will be 1 (appears count[1] times)</span>
        <span class="c1">// - j will be 2 (appears count[2] times)</span>
        <span class="c1">// - k will be 5 (appears count[5] times)</span>
        <span class="c1">// Total combinations = count[1] * count[2] * count[5]</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">count</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">*</span> <span class="n">count</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Case 2: First two numbers are same (i == j != k)</span>
        <span class="c1">// Example: For target = 7, finding combinations like (2,2,3) where:</span>
        <span class="c1">// - Choose 2 numbers from count[i] numbers: C(count[i],2) = count[i] * (count[i]-1) / 2</span>
        <span class="c1">// - Then multiply by count[k] for the third different number</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">count</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Case 3: Last two numbers are same (i != j == k)</span>
        <span class="c1">// Example: For target = 7, finding combinations like (1,3,3) where:</span>
        <span class="c1">// - Choose one count[i]</span>
        <span class="c1">// - Then choose 2 numbers from count[j] numbers: C(count[j],2)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">target</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">count</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Case 4: All three numbers are same (i == j == k)</span>
        <span class="c1">// Example: For target = 6, finding combinations like (2,2,2) where:</span>
        <span class="c1">// - Choose 3 numbers from count[i] numbers: C(count[i],3)</span>
        <span class="c1">// - Formula: n * (n-1) * (n-2) / 6</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">target</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">/</span> <span class="mi">6</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return final result with modulo operation</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">result</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Multiple combinations of different numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threeSumMulti</span><span class="o">(</span><span class="n">arr1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span> <span class="c1">// Expected output: 20</span>

        <span class="c1">// Test case 2: Combinations with repeated numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threeSumMulti</span><span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span> <span class="c1">// Expected output: 12</span>

        <span class="c1">// Test case 3: Simple case with three different numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threeSumMulti</span><span class="o">(</span><span class="n">arr3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><summary type="html"><![CDATA[Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 109 + 7.]]></summary></entry><entry><title type="html">18. 4Sum</title><link href="https://zhengstar94.github.io//blog/2025/4Sum/" rel="alternate" type="text/html" title="18. 4Sum"/><published>2025-02-23T00:00:00+00:00</published><updated>2025-02-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/4Sum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/4Sum/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code> of <code class="language-plaintext highlighter-rouge">n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code class="language-plaintext highlighter-rouge">[nums[a], nums[b], nums[c], nums[d]]</code> such that: <ul> <li><code class="language-plaintext highlighter-rouge">0 &lt;= a, b, c, d &lt; n</code></li> <li><code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, and <code class="language-plaintext highlighter-rouge">d</code> are <strong>distinct</strong>.</li> <li><code class="language-plaintext highlighter-rouge">nums[a] + nums[b] + nums[c] + nums[d] == target</code></li> </ul> </li> <li>You may return the answer in <strong>any order</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [ [ -2,-1,1,2],[-2,0,0,2],[-1,0,0,1 ] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,2,2,2,2], target = 8
Output: [ [ 2,2,2,2 ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n³) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FourSum</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">fourSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Check for invalid input</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort array to use two-pointer technique and handle duplicates</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Fix first number</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Skip duplicates for first number</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Early termination if smallest possible sum is too large</span>
            <span class="k">if</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Skip if largest possible sum is too small</span>
            <span class="k">if</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Fix second number</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Skip duplicates for second number</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Early termination optimizations</span>
                <span class="k">if</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Use two pointers to find remaining two numbers</span>
                <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// Add valid quadruplet to result</span>
                        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]));</span>
                        <span class="c1">// Skip duplicates for third number</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                            <span class="n">left</span><span class="o">++;</span>
                        <span class="o">}</span>
                        <span class="c1">// Skip duplicates for fourth number</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                            <span class="n">right</span><span class="o">--;</span>
                        <span class="o">}</span>
                        <span class="n">left</span><span class="o">++;</span>
                        <span class="n">right</span><span class="o">--;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">left</span><span class="o">++;</span>  <span class="c1">// Sum too small, increase left pointer</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">right</span><span class="o">--;</span> <span class="c1">// Sum too large, decrease right pointer</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Standard case with multiple solutions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [1,0,-1,0,-2,2], target = 0"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">fourSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Array with all same elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [2,2,2,2,2], target = 8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">fourSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Large dataset with positive and negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Large Dataset):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">fourSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><summary type="html"><![CDATA[Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 &lt;= a, b, c, d &lt; n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order.]]></summary></entry><entry><title type="html">LCP 28. Procurement Plan</title><link href="https://zhengstar94.github.io//blog/2025/ProcurementPlan/" rel="alternate" type="text/html" title="LCP 28. Procurement Plan"/><published>2025-02-23T00:00:00+00:00</published><updated>2025-02-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ProcurementPlan</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ProcurementPlan/"><![CDATA[<ul> <li>Xiao Li stores the quotations of N parts in the array nums. Xiao Li’s budget is target. Assuming Xiao Li only purchases two parts, and the cost of purchasing parts must not exceed the budget, how many procurement plans does he have?</li> <li>Note: The answer needs to be modulo <code class="language-plaintext highlighter-rouge">1e9 + 7 (1000000007)</code>. For example: if the initial result is <code class="language-plaintext highlighter-rouge">1000000008</code>, please return <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,5,3,5], target = 6
Output: 1
Explanation: Within the budget, only nums[0] and nums[2] can be purchased.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,2,1,9], target = 10
Output: 4
Explanation: The procurement plans within budget are as follows:
nums[0] + nums[1] = 4
nums[0] + nums[2] = 3
nums[1] + nums[2] = 3
nums[2] + nums[3] = 10
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProcurementPlan</span> <span class="o">{</span>
    <span class="c1">// Constant for modulo operation to handle large numbers</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1000000007</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">purchasePlans</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort array to use two-pointer technique effectively</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// Initialize two pointers and result counter</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                      <span class="c1">// Left pointer starts from beginning</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>       <span class="c1">// Right pointer starts from end</span>
        <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                    <span class="c1">// Use long to prevent overflow during calculation</span>

        <span class="c1">// Continue until pointers meet</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If current combination is within budget</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add number of valid combinations with current left pointer</span>
                <span class="c1">// (right - left) represents all possible combinations with current left value</span>
                <span class="n">count</span> <span class="o">=</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
                <span class="n">left</span><span class="o">++;</span>    <span class="c1">// Move left pointer right to try next combination</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">right</span><span class="o">--;</span>   <span class="c1">// Sum too large, decrease right pointer to reduce sum</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with small numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [2,5,3,5], target = 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">purchasePlans</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Multiple valid combinations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [2,2,1,9], target = 10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">purchasePlans</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 4"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Large dataset to test performance and overflow handling</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100000</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums3</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">nums3</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">100000</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Large Dataset Test):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">purchasePlans</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Easy"/><summary type="html"><![CDATA[Xiao Li stores the quotations of N parts in the array nums. Xiao Li’s budget is target. Assuming Xiao Li only purchases two parts, and the cost of purchasing parts must not exceed the budget, how many procurement plans does he have? Note: The answer needs to be modulo 1e9 + 7 (1000000007). For example: if the initial result is 1000000008, please return 1.]]></summary></entry><entry><title type="html">611. Valid Triangle Number</title><link href="https://zhengstar94.github.io//blog/2025/ValidTriangleNumber/" rel="alternate" type="text/html" title="611. Valid Triangle Number"/><published>2025-02-23T00:00:00+00:00</published><updated>2025-02-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ValidTriangleNumber</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ValidTriangleNumber/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,3,4]
Output: 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n²) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidTriangleNumber</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">triangleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases - null array or insufficient elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort array to optimize the search process</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Iterate from largest possible side (right to left)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="c1">// Initialize two pointers for remaining two sides</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>          <span class="c1">// Pointer for smallest side</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>     <span class="c1">// Pointer for middle side</span>

            <span class="c1">// Use two pointer technique to find valid combinations</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Check if current combination forms valid triangle</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                    <span class="c1">// All numbers between left and right will also form valid triangles</span>
                    <span class="c1">// Because array is sorted and we're starting from largest side</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span>
                    <span class="c1">// Decrease right pointer to try smaller middle side</span>
                    <span class="n">right</span><span class="o">--;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Sum is too small, need to increase left pointer</span>
                    <span class="n">left</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with duplicate elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [2,2,3,4]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">triangleNumber</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>  <span class="c1">// Valid combinations: (2,2,3), (2,3,4), (2,3,4)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Array with duplicate maximum values</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [4,2,3,4]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">triangleNumber</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 4"</span><span class="o">);</span>  <span class="c1">// Valid combinations: (2,3,4), (2,4,4), (3,4,4)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><summary type="html"><![CDATA[Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.]]></summary></entry><entry><title type="html">2824. Count Pairs Whose Sum is Less than Target</title><link href="https://zhengstar94.github.io//blog/2025/CountPairsWhoseSumIsLessThanTarget/" rel="alternate" type="text/html" title="2824. Count Pairs Whose Sum is Less than Target"/><published>2025-02-22T00:00:00+00:00</published><updated>2025-02-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountPairsWhoseSumIsLessThanTarget</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountPairsWhoseSumIsLessThanTarget/"><![CDATA[<ul> <li>Given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code> and an integer <code class="language-plaintext highlighter-rouge">target</code>, return <em>the number of pairs</em> <code class="language-plaintext highlighter-rouge">(i, j)</code> <em>where</em> <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; n</code> <em>and</em> <code class="language-plaintext highlighter-rouge">nums[i] + nums[j] &lt; target</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,1,2,3,1], target = 2
Output: 3
Explanation: There are 3 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = 0 &lt; target
- (0, 2) since 0 &lt; 2 and nums[0] + nums[2] = 1 &lt; target 
- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = 0 &lt; target
Note that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
Output: 10
Explanation: There are 10 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = -4 &lt; target
- (0, 3) since 0 &lt; 3 and nums[0] + nums[3] = -8 &lt; target
- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = -13 &lt; target
- (0, 5) since 0 &lt; 5 and nums[0] + nums[5] = -7 &lt; target
- (0, 6) since 0 &lt; 6 and nums[0] + nums[6] = -3 &lt; target
- (1, 4) since 1 &lt; 4 and nums[1] + nums[4] = -5 &lt; target
- (3, 4) since 3 &lt; 4 and nums[3] + nums[4] = -9 &lt; target
- (3, 5) since 3 &lt; 5 and nums[3] + nums[5] = -3 &lt; target
- (4, 5) since 4 &lt; 5 and nums[4] + nums[5] = -8 &lt; target
- (4, 6) since 4 &lt; 6 and nums[4] + nums[6] = -4 &lt; target
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountPairsWhoseSumIsLessThanTarget</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countPairs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the list to enable two pointer approach</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Counter for valid pairs</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Left pointer starting from beginning</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Right pointer starting from end</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate current sum of elements at left and right pointers</span>
            <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">currentSum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If current sum is less than target:</span>
                <span class="c1">// All pairs between left and right will also be valid</span>
                <span class="c1">// Because array is sorted, nums[left] + nums[right-1] will be even smaller</span>
                <span class="c1">// We add (right - left) pairs to our count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span>
                <span class="c1">// Move left pointer to find more pairs</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current sum is &gt;= target:</span>
                <span class="c1">// Need to decrease sum, so move right pointer left</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case with positive and negative numbers</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 2: Case with more negative numbers</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(-</span><span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>

        <span class="c1">// Test Case 3: Edge case - empty list</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 4: Edge case - single element list</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">target4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">countPairs</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">target4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Easy"/><summary type="html"><![CDATA[Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 &lt;= i &lt; j &lt; n and nums[i] + nums[j] &lt; target.]]></summary></entry></feed>