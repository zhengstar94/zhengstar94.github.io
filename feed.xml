<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-11T04:20:57+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">3442. Maximum Difference Between Even and Odd Frequency I</title><link href="https://zhengstar94.github.io//blog/2025/MaximumDifferenceBetweenEvenAndOddFrequencyI/" rel="alternate" type="text/html" title="3442. Maximum Difference Between Even and Odd Frequency I"/><published>2025-06-10T00:00:00+00:00</published><updated>2025-06-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumDifferenceBetweenEvenAndOddFrequencyI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumDifferenceBetweenEvenAndOddFrequencyI/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> consisting of lowercase English letters.</li> <li>Your task is to find the <strong>maximum</strong> difference <code class="language-plaintext highlighter-rouge">diff = a1 - a2</code> between the frequency of characters <code class="language-plaintext highlighter-rouge">a1</code> and <code class="language-plaintext highlighter-rouge">a2</code> in the string such that: <ul> <li><code class="language-plaintext highlighter-rouge">a1</code> has an <strong>odd frequency</strong> in the string.</li> <li><code class="language-plaintext highlighter-rouge">a2</code> has an <strong>even frequency</strong> in the string.</li> </ul> </li> <li>Return this <strong>maximum</strong> difference.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaaaabbc"

Output: 3

Explanation:

The character 'a' has an odd frequency of 5, and 'b' has an even frequency of 2.
The maximum difference is 5 - 2 = 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcabcab"

Output: 1

Explanation:

The character 'a' has an odd frequency of 3, and 'c' has an even frequency of 2.
The maximum difference is 3 - 2 = 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumDifferenceBetweenEvenAndOddFrequencyI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxDifference</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Initialize frequency counter array for 26 lowercase letters</span>
        <span class="c1">// Index 0 represents 'a', index 1 represents 'b', ..., index 25 represents 'z'</span>
        <span class="c1">// Using array instead of HashMap for better performance and space efficiency</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Step 2: Count frequency of each character in the string</span>
        <span class="c1">// Convert string to character array for efficient iteration</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Map character to array index: 'a'-&gt;0, 'b'-&gt;1, ..., 'z'-&gt;25</span>
            <span class="c1">// Increment the frequency counter for this character</span>
            <span class="n">cnt</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Initialize variables to track maximum odd frequency and minimum even frequency</span>
        <span class="kt">int</span> <span class="n">max1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Maximum odd frequency found so far (initialize to 0 since frequencies are positive)</span>
        <span class="kt">int</span> <span class="n">min0</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>  <span class="c1">// Minimum even frequency found so far (initialize to max value)</span>

        <span class="c1">// Step 4: Iterate through all frequency counts to find max odd and min even</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">:</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if current frequency is odd (remainder when divided by 2 is greater than 0)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update maximum odd frequency if current frequency is larger</span>
                <span class="n">max1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max1</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Check if current frequency is even AND greater than 0 (exists in string)</span>
            <span class="c1">// We need c &gt; 0 condition to exclude characters that don't appear in the string</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update minimum even frequency if current frequency is smaller</span>
                <span class="n">min0</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min0</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 5: Return the maximum difference</span>
        <span class="c1">// This represents the largest possible difference between an odd frequency character</span>
        <span class="c1">// and an even frequency character in the string</span>
        <span class="k">return</span> <span class="n">max1</span> <span class="o">-</span> <span class="n">min0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: "aaaaabbc"</span>
        <span class="c1">// Character frequencies: a=5(odd), b=2(even), c=1(odd)</span>
        <span class="c1">// Maximum odd frequency: 5, Minimum even frequency: 2</span>
        <span class="c1">// Expected result: 5 - 2 = 3</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"aaaaabbc"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">maxDifference</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result1</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: "abcabcab"</span>
        <span class="c1">// Character frequencies: a=3(odd), b=3(odd), c=2(even)</span>
        <span class="c1">// Maximum odd frequency: 3, Minimum even frequency: 2</span>
        <span class="c1">// Expected result: 3 - 2 = 1</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcabcab"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">maxDifference</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result2</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s consisting of lowercase English letters. Your task is to find the maximum difference diff=a1 - a2 between the frequency of characters a1 and a2 in the string such that: a1 has an odd frequency in the string. a2 has an even frequency in the string. Return this maximum difference.]]></summary></entry><entry><title type="html">2454. Next Greater Element IV</title><link href="https://zhengstar94.github.io//blog/2025/NextGreaterElementIV/" rel="alternate" type="text/html" title="2454. Next Greater Element IV"/><published>2025-06-10T00:00:00+00:00</published><updated>2025-06-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NextGreaterElementIV</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NextGreaterElementIV/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array of non-negative integers <code class="language-plaintext highlighter-rouge">nums</code>. For each integer in <code class="language-plaintext highlighter-rouge">nums</code>, you must find its respective <strong>second greater</strong> integer.</li> <li>The <strong>second greater</strong> integer of <code class="language-plaintext highlighter-rouge">nums[i]</code> is <code class="language-plaintext highlighter-rouge">nums[j]</code> such that: <ul> <li><code class="language-plaintext highlighter-rouge">j &gt; i</code></li> <li><code class="language-plaintext highlighter-rouge">nums[j] &gt; nums[i]</code></li> <li>There exists <strong>exactly one</strong> index <code class="language-plaintext highlighter-rouge">k</code> such that <code class="language-plaintext highlighter-rouge">nums[k] &gt; nums[i]</code> and <code class="language-plaintext highlighter-rouge">i &lt; k &lt; j</code>.</li> </ul> </li> <li>If there is no such <code class="language-plaintext highlighter-rouge">nums[j]</code>, the second greater integer is considered to be <code class="language-plaintext highlighter-rouge">-1</code>. <ul> <li>For example, in the array <code class="language-plaintext highlighter-rouge">[1, 2, 4, 3]</code>, the second greater integer of <code class="language-plaintext highlighter-rouge">1</code> is <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">2</code> is <code class="language-plaintext highlighter-rouge">3</code>, and that of <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">4</code> is <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> </li> <li>Return <em>an integer array</em> <code class="language-plaintext highlighter-rouge">answer</code><em>, where</em> <code class="language-plaintext highlighter-rouge">answer[i]</code> <em>is the second greater integer of</em> <code class="language-plaintext highlighter-rouge">nums[i]</code><em>.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,0,9,6]
Output: [9,6,6,-1,-1]
Explanation:
0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.
1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.
2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.
3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.
4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.
Thus, we return [9,6,6,-1,-1].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3]
Output: [-1,-1]
Explanation:
We return [-1,-1] since neither integer has any integer greater than it.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NextGreaterElementIV</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">secondGreaterElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Initialize all positions to -1 (meaning no second greater element found yet)</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// stack1: stores indices of elements that are still waiting to find their FIRST greater element</span>
        <span class="c1">// These elements haven't found any greater element yet</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// stack2: stores indices of elements that have already found their FIRST greater element</span>
        <span class="c1">// and are now waiting to find their SECOND greater element</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Process each element in the array from left to right</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// STEP 1: Process stack2 - try to find the SECOND greater element</span>
            <span class="c1">// For elements in stack2, they have already found their first greater element</span>
            <span class="c1">// Now we check if current element nums[i] can be their second greater element</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack2</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">stack2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>  <span class="c1">// Get the index from stack2</span>
                <span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>   <span class="c1">// Current element is the SECOND greater element for nums[index]</span>
                <span class="c1">// This index is now complete - it has found both first and second greater elements</span>
            <span class="o">}</span>

            <span class="c1">// STEP 2: Collect elements from stack1 that found their FIRST greater element</span>
            <span class="c1">// We use a temporary list to store indices that will transition from stack1 to stack2</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// Process stack1 - try to find the FIRST greater element</span>
            <span class="c1">// For elements in stack1, they haven't found any greater element yet</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack1</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Current element nums[i] is the FIRST greater element for nums[stack1.peek()]</span>
                <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>  <span class="c1">// Remove from stack1 and add to temp</span>
                <span class="c1">// These indices will now start looking for their SECOND greater element</span>
            <span class="o">}</span>

            <span class="c1">// STEP 3: STATE TRANSITION - Move elements from "looking for first" to "looking for second"</span>
            <span class="c1">// Transfer the indices that just found their first greater element to stack2</span>
            <span class="c1">// CRITICAL: We insert in REVERSE ORDER to maintain monotonic property of stack2</span>
            <span class="c1">//</span>
            <span class="c1">// Why reverse order?</span>
            <span class="c1">// - Elements in temp are stored in the order they were popped from stack1 (larger elements first)</span>
            <span class="c1">// - To maintain monotonic increasing order in stack2 (from bottom to top)</span>
            <span class="c1">// - We need to reverse the insertion order</span>
            <span class="c1">//</span>
            <span class="c1">// Example: if temp = [idx_of_3, idx_of_2, idx_of_1] (popped in this order)</span>
            <span class="c1">// After reverse insertion: stack2 = [idx_of_1, idx_of_2, idx_of_3] (bottom to top)</span>
            <span class="c1">// This ensures stack2 maintains monotonic increasing property</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">stack2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="c1">// STEP 4: Add current index to stack1</span>
            <span class="c1">// Current element starts its journey by looking for its FIRST greater element</span>
            <span class="n">stack1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic example with mixed values</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">secondGreaterElement</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [9, 6, 6, -1, -1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result1</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">})</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: All elements are equal</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">secondGreaterElement</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [-1, -1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result2</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">})</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Hard"/><summary type="html"><![CDATA[You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer. The second greater integer of nums[i] is nums[j] such that: j &gt; i nums[j] &gt; nums[i] There exists exactly one index k such that nums[k] &gt; nums[i] and i &lt; k &lt; j. If there is no such nums[j], the second greater integer is considered to be -1. For example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3, and that of 3 and 4 is -1. Return an integer array answer, where answer[i] is the second greater integer of nums[i].]]></summary></entry><entry><title type="html">1944. Number of Visible People in a Queue</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfVisiblePeopleInAQueue/" rel="alternate" type="text/html" title="1944. Number of Visible People in a Queue"/><published>2025-06-10T00:00:00+00:00</published><updated>2025-06-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfVisiblePeopleInAQueue</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfVisiblePeopleInAQueue/"><![CDATA[<ul> <li>There are <code class="language-plaintext highlighter-rouge">n</code> people standing in a queue, and they numbered from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n - 1</code> in <strong>left to right</strong> order. You are given an array <code class="language-plaintext highlighter-rouge">heights</code> of <strong>distinct</strong> integers where <code class="language-plaintext highlighter-rouge">heights[i]</code> represents the height of the <code class="language-plaintext highlighter-rouge">ith</code> person.</li> <li>A person can <strong>see</strong> another person to their right in the queue if everybody in between is <strong>shorter</strong> than both of them. More formally, the <code class="language-plaintext highlighter-rouge">ith</code> person can see the <code class="language-plaintext highlighter-rouge">jth</code> person if <code class="language-plaintext highlighter-rouge">i &lt; j</code> and <code class="language-plaintext highlighter-rouge">min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>.</li> <li>Return <em>an array</em> <code class="language-plaintext highlighter-rouge">answer</code> <em>of length</em> <code class="language-plaintext highlighter-rouge">n</code> <em>where</em> <code class="language-plaintext highlighter-rouge">answer[i]</code> <em>is the <strong>number of people</strong> the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>person can <strong>see</strong> to their right in the queue</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: heights = [10,6,8,5,11,9]
Output: [3,1,2,1,1,0]
Explanation:
Person 0 can see person 1, 2, and 4.
Person 1 can see person 2.
Person 2 can see person 3 and 4.
Person 3 can see person 4.
Person 4 can see person 5.
Person 5 can see no one since nobody is to the right of them.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: heights = [5,1,2,3,10]
Output: [4,1,1,1,0]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfVisiblePeopleInAQueue</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">canSeePersonsCount</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">heights</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the total number of people in the queue</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Initialize result array to store the count for each person</span>
        <span class="c1">// result[i] will contain the number of people person i can see</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Create a monotonic decreasing stack using ArrayDeque</span>
        <span class="c1">// The stack stores INDICES (not heights) of people</span>
        <span class="c1">// Stack property: heights[stack.bottom] &gt;= heights[stack.top]</span>
        <span class="c1">// This means from bottom to top, the heights are in decreasing order</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// CRITICAL: Traverse from RIGHT to LEFT (i.e., from last person to first person)</span>
        <span class="c1">// Why backwards? Because we need to know about people on the right side first</span>
        <span class="c1">// before we can determine how many people the current person can see</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>

            <span class="c1">// Initialize count for current person at position i</span>
            <span class="c1">// This will store how many people person i can see to their right</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// PHASE 1: Count people shorter than current person</span>
            <span class="c1">// These shorter people will be "blocked" by the current person</span>
            <span class="c1">// We need to remove them from stack because they become invisible</span>
            <span class="c1">// to people on the left side of current person</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&lt;</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Remove the shorter person from stack (they get blocked)</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="c1">// Increment count because current person can see this shorter person</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// PHASE 2: Count the first person taller than or equal to current person</span>
            <span class="c1">// After the while loop, if stack is not empty, the top element represents</span>
            <span class="c1">// a person who is taller than or equal to the current person</span>
            <span class="c1">// The current person can see this taller person, but cannot see beyond them</span>
            <span class="c1">// because this taller person will block the view to anyone behind them</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// There's a taller person that current person can see</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Store the total count of people that person i can see</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>

            <span class="c1">// Add current person's index to the stack</span>
            <span class="c1">// This person might be visible to people on their left side</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the result array containing counts for all people</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed heights with multiple visibility scenarios</span>
        <span class="c1">// Expected behavior:</span>
        <span class="c1">// Person 0 (height 10): can see persons 1(6), 2(8), 4(11) = 3 people</span>
        <span class="c1">// Person 1 (height 6): can see person 2(8) = 1 person</span>
        <span class="c1">// Person 2 (height 8): can see persons 3(5), 4(11) = 2 people  </span>
        <span class="c1">// Person 3 (height 5): can see person 4(11) = 1 person</span>
        <span class="c1">// Person 4 (height 11): can see person 5(9) = 1 person</span>
        <span class="c1">// Person 5 (height 9): no one to the right = 0 people</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">heights1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">canSeePersonsCount</span><span class="o">(</span><span class="n">heights1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">heights1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [3, 1, 2, 1, 1, 0]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result1</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">})</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Scenario where first person can see everyone</span>
        <span class="c1">// Expected behavior:</span>
        <span class="c1">// Person 0 (height 5): can see all 4 people to the right = 4 people</span>
        <span class="c1">// Person 1 (height 1): can see person 2(2) = 1 person</span>
        <span class="c1">// Person 2 (height 2): can see person 3(3) = 1 person</span>
        <span class="c1">// Person 3 (height 3): can see person 4(10) = 1 person  </span>
        <span class="c1">// Person 4 (height 10): no one to the right = 0 people</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">heights2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">canSeePersonsCount</span><span class="o">(</span><span class="n">heights2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">heights2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [4, 1, 1, 1, 0]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result2</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">})</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Hard"/><summary type="html"><![CDATA[There are n people standing in a queue, and they numbered from 0 to n - 1 in left to right order. You are given an array heights of distinct integers where heights[i] represents the height of the ith person. A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the ith person can see the jth person if i &lt; j and min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1]). Return an array answer of length n where answer[i] is the number of people the ith person can see to their right in the queue.]]></summary></entry><entry><title type="html">3113. Find the Number of Subarrays Where Boundary Elements Are Maximum</title><link href="https://zhengstar94.github.io//blog/2025/FindTheNumberOfSubarraysWhereBoundaryElementsAreMaximum/" rel="alternate" type="text/html" title="3113. Find the Number of Subarrays Where Boundary Elements Are Maximum"/><published>2025-06-08T00:00:00+00:00</published><updated>2025-06-08T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheNumberOfSubarraysWhereBoundaryElementsAreMaximum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheNumberOfSubarraysWhereBoundaryElementsAreMaximum/"><![CDATA[<ul> <li>You are given an array of <strong>positive</strong> integers <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return the number of subarrays of <code class="language-plaintext highlighter-rouge">nums</code>, where the <strong>first</strong> and the <strong>last</strong> elements of the subarray are <em>equal</em> to the <strong>largest</strong> element in the subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,3,3,2]

Output: 6

Explanation:

There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:

subarray [1,4,3,3,2], with its largest element 1. The first element is 1 and the last element is also 1.
subarray [1,4,3,3,2], with its largest element 4. The first element is 4 and the last element is also 4.
subarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.
subarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.
subarray [1,4,3,3,2], with its largest element 2. The first element is 2 and the last element is also 2.
subarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.
Hence, we return 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,3]

Output: 6

Explanation:

There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:

subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
Hence, we return 6.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1]

Output: 1

Explanation:

There is a single subarray of nums which is [1], with its largest element 1. The first element is 1 and the last element is also 1.

Hence, we return 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/08
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheNumberOfSubarraysWhereBoundaryElementsAreMaximum</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">numberOfSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Initialize answer with array length</span>
        <span class="c1">// Every single element forms a valid subarray (first == last == max)</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Step 2: Initialize monotonic stack with sentinel value</span>
        <span class="c1">// Each stack element stores [value, count_of_occurrences]</span>
        <span class="c1">// Sentinel prevents empty stack checks and simplifies logic</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="mi">0</span><span class="o">});</span> <span class="c1">// Sentinel: [∞, 0]</span>

        <span class="c1">// Step 3: Process each element as potential right boundary</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// Phase 1: Maintain monotonic decreasing property</span>
            <span class="c1">// Remove all elements smaller than current element from stack</span>
            <span class="c1">// Why? Because if current element &gt; stack_top, then stack_top cannot</span>
            <span class="c1">// be the maximum in any subarray that includes current element</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span> <span class="c1">// Remove smaller elements</span>
            <span class="o">}</span>

            <span class="c1">// Phase 2: Handle current element</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Case 1: Current element equals stack top value</span>
                <span class="c1">// This means we found matching left boundaries for current right boundary</span>
                <span class="c1">// st.peek()[1] represents how many times this value appeared consecutively</span>

                <span class="c1">// Add contribution: each previous occurrence can pair with current element</span>
                <span class="c1">// to form a valid subarray (since all elements between them are &lt;= x)</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// Increment count for this value (current element becomes another occurrence)</span>
                <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">1</span><span class="o">]++;</span>

            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Case 2: Current element is smaller than stack top</span>
                <span class="c1">// Push current element as new potential left boundary</span>
                <span class="c1">// Start with count = 1 (this is the first occurrence at this "level")</span>
                <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Mixed values</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== Test Case 1: [1,4,3,3,2] ==="</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Algorithm Result: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Valid subarrays: [1], [4], [3], [3], [2], [3,3]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2: All same elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== Test Case 2: [3,3,3] ==="</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Algorithm Result: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Valid subarrays: [3], [3], [3], [3,3], [3,3], [3,3,3]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 3: Single element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== Test Case 3: [1] ==="</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Algorithm Result: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Valid subarrays: [1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 4: Strictly increasing array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== Test Case 4: [1,2,3,4,5] ==="</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Algorithm Result: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Valid subarrays: Only single elements [1], [2], [3], [4], [5]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 5: All identical elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== Test Case 5: [2,2,2,2] ==="</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Algorithm Result: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Calculation: 4 single + 3 pairs + 2 triplets + 1 quadruple = 10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Hard"/><summary type="html"><![CDATA[You are given an array of positive integers nums. Return the number of subarrays of nums, where the first and the last elements of the subarray are equal to the largest element in the subarray.]]></summary></entry><entry><title type="html">654. Maximum Binary Tree</title><link href="https://zhengstar94.github.io//blog/2025/MaximumBinaryTree/" rel="alternate" type="text/html" title="654. Maximum Binary Tree"/><published>2025-06-08T00:00:00+00:00</published><updated>2025-06-08T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumBinaryTree</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumBinaryTree/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code class="language-plaintext highlighter-rouge">nums</code> using the following algorithm: <ul> <li>Create a root node whose value is the maximum value in <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Recursively build the left subtree on the <strong>subarray prefix</strong> to the <strong>left</strong> of the maximum value.</li> <li>Recursively build the right subtree on the <strong>subarray suffix</strong> to the <strong>right</strong> of the maximum value.</li> </ul> </li> <li>Return <em>the <strong>maximum binary tree</strong> built from</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
Explanation: The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1]
Output: [3,null,2,null,1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/08
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumBinaryTree</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="nf">constructMaximumBinaryTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Call the recursive helper function with the entire array range</span>
        <span class="c1">// left boundary = 0 (first index)</span>
        <span class="c1">// right boundary = nums.length-1 (last index)</span>
        <span class="k">return</span> <span class="nf">construct</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="nf">construct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// BASE CASE: Check if the current range is invalid</span>
        <span class="c1">// This happens when we have an empty subarray</span>
        <span class="c1">// For example: left=3, right=2 means no elements to process</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// Return null for empty subtree</span>
        <span class="o">}</span>

        <span class="c1">// STEP 1: Find the index of the maximum element in current range</span>
        <span class="c1">// Initialize 'best' to the left boundary as our starting candidate</span>
        <span class="kt">int</span> <span class="n">best</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>

        <span class="c1">// LINEAR SEARCH: Iterate through the current range [left, right]</span>
        <span class="c1">// to find the index of the maximum element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Compare current element with the current maximum candidate</span>
            <span class="c1">// If current element is greater, update the best index</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">best</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// Update best to current index</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// After this loop, 'best' contains the index of maximum element</span>
        <span class="c1">// in the range [left, right]</span>

        <span class="c1">// STEP 2: Create the root node using the maximum value</span>
        <span class="c1">// nums[best] is guaranteed to be the maximum in current range</span>
        <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">best</span><span class="o">]);</span>

        <span class="c1">// STEP 3: DIVIDE AND CONQUER - Recursively build subtrees</span>

        <span class="c1">// Build LEFT SUBTREE:</span>
        <span class="c1">// Process all elements to the LEFT of the maximum element</span>
        <span class="c1">// Range: [left, best-1] (all indices before the maximum)</span>
        <span class="c1">// If best == left, then [left, best-1] = [left, left-1] which is empty</span>
        <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">construct</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">best</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Build RIGHT SUBTREE:</span>
        <span class="c1">// Process all elements to the RIGHT of the maximum element</span>
        <span class="c1">// Range: [best+1, right] (all indices after the maximum)</span>
        <span class="c1">// If best == right, then [best+1, right] = [right+1, right] which is empty</span>
        <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">construct</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">best</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>

        <span class="c1">// STEP 4: Return the constructed subtree</span>
        <span class="c1">// The node now has its left and right subtrees properly attached</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">levelOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize result list to store the traversal</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Handle edge case: empty tree</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span> <span class="c1">// Return empty list</span>
        <span class="o">}</span>

        <span class="c1">// Use a queue for BFS traversal</span>
        <span class="c1">// LinkedList implements Queue interface efficiently</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span> <span class="c1">// Add root to start traversal</span>

        <span class="c1">// BFS TRAVERSAL: Process nodes level by level</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Remove and get the front node from queue</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add the node's value to result</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

                <span class="c1">// Add children to queue for next level processing</span>
                <span class="c1">// Note: We add both left and right children regardless of null</span>
                <span class="c1">// This helps maintain the tree structure in output</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current node is null, add null to result</span>
                <span class="c1">// This represents missing nodes in the tree structure</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// CLEANUP: Remove trailing null values from the result</span>
        <span class="c1">// These trailing nulls don't add meaningful information</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">result</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TEST CASE 1: Standard example from the problem</span>
        <span class="c1">// Expected tree structure:</span>
        <span class="c1">//        6</span>
        <span class="c1">//       / \</span>
        <span class="c1">//      3   5</span>
        <span class="c1">//       \ /</span>
        <span class="c1">//        2 0</span>
        <span class="c1">//         \</span>
        <span class="c1">//          1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">TreeNode</span> <span class="n">root1</span> <span class="o">=</span> <span class="n">constructMaximumBinaryTree</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">levelOrder</span><span class="o">(</span><span class="n">root1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [6, 3, 5, null, 2, 0, null, null, 1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// TEST CASE 2: Monotonic decreasing sequence</span>
        <span class="c1">// Expected tree structure:</span>
        <span class="c1">//      3</span>
        <span class="c1">//       \</span>
        <span class="c1">//        2</span>
        <span class="c1">//         \</span>
        <span class="c1">//          1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">TreeNode</span> <span class="n">root2</span> <span class="o">=</span> <span class="n">constructMaximumBinaryTree</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">levelOrder</span><span class="o">(</span><span class="n">root2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [3, null, 2, null, 1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// TEST CASE 3: Single element (edge case)</span>
        <span class="c1">// Expected tree structure: just one node with value 5</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">TreeNode</span> <span class="n">root3</span> <span class="o">=</span> <span class="n">constructMaximumBinaryTree</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">levelOrder</span><span class="o">(</span><span class="n">root3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [5]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// TEST CASE 4: Monotonic increasing sequence (worst case for time complexity)</span>
        <span class="c1">// Expected tree structure:</span>
        <span class="c1">//          5</span>
        <span class="c1">//         /</span>
        <span class="c1">//        4</span>
        <span class="c1">//       /</span>
        <span class="c1">//      3</span>
        <span class="c1">//     /</span>
        <span class="c1">//    2</span>
        <span class="c1">//   /</span>
        <span class="c1">//  1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">TreeNode</span> <span class="n">root4</span> <span class="o">=</span> <span class="n">constructMaximumBinaryTree</span><span class="o">(</span><span class="n">nums4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">levelOrder</span><span class="o">(</span><span class="n">root4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [5, 4, null, 3, null, 2, null, 1]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm: Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value. Return the maximum binary tree built from nums.]]></summary></entry><entry><title type="html">503. Next Greater Element II</title><link href="https://zhengstar94.github.io//blog/2025/NextGreaterElementII/" rel="alternate" type="text/html" title="503. Next Greater Element II"/><published>2025-06-06T00:00:00+00:00</published><updated>2025-06-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NextGreaterElementII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NextGreaterElementII/"><![CDATA[<ul> <li>Given a circular integer array <code class="language-plaintext highlighter-rouge">nums</code> (i.e., the next element of <code class="language-plaintext highlighter-rouge">nums[nums.length - 1]</code> is <code class="language-plaintext highlighter-rouge">nums[0]</code>), return <em>the <strong>next greater number</strong> for every element in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>The <strong>next greater number</strong> of a number <code class="language-plaintext highlighter-rouge">x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, return <code class="language-plaintext highlighter-rouge">-1</code> for this number.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NextGreaterElementII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">nextGreaterElements</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Initialize result array with -1 (default value when no greater element found)</span>
        <span class="c1">// This handles the case where some elements don't have a next greater element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>  <span class="c1">// Fill all positions with -1 initially</span>

        <span class="c1">// Monotonic decreasing stack to store array indices</span>
        <span class="c1">// Stack property: elements corresponding to indices in stack are in decreasing order</span>
        <span class="c1">// from bottom to top. This allows us to efficiently find next greater elements.</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// CORE ALGORITHM: Traverse the array twice to simulate circular array behavior</span>
        <span class="c1">// First traversal (i = 0 to n-1): Handle normal cases and build the stack</span>
        <span class="c1">// Second traversal (i = n to 2n-1): Handle circular cases using the built stack</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate actual array index using modulo operation</span>
            <span class="c1">// This maps: 0,1,2,3,4,5,6,7,8,9 -&gt; 0,1,2,3,4,0,1,2,3,4 for n=5</span>
            <span class="kt">int</span> <span class="n">currentIndex</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="o">;</span>

            <span class="c1">// CRITICAL SECTION: Process stack while current element is greater than stack top</span>
            <span class="c1">// This is where we find the "next greater element" for previously seen smaller elements</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">currentIndex</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()])</span> <span class="o">{</span>
                <span class="c1">// Pop the index from stack - this element has found its next greater element</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="c1">// Set the result: nums[currentIndex] is the next greater element for nums[index]</span>
                <span class="c1">// This works because:</span>
                <span class="c1">// 1. All elements between index and currentIndex in the original traversal were smaller</span>
                <span class="c1">// 2. nums[currentIndex] is the first element greater than nums[index]</span>
                <span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">currentIndex</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// STACK BUILDING PHASE: Only push indices during first traversal</span>
            <span class="c1">// Second traversal is purely for finding answers, not for building stack</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Push current index to stack</span>
                <span class="c1">// This element is waiting to find its next greater element</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">currentIndex</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Note: During second traversal (i &gt;= n), we don't push to stack</span>
            <span class="c1">// We only use existing stack elements to find circular next greater elements</span>
        <span class="o">}</span>

        <span class="c1">// After both traversals, elements still in stack don't have next greater elements</span>
        <span class="c1">// Their result remains -1 (initialized value)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic circular case</span>
        <span class="c1">// nums[2] = 1 needs to look circularly to find next greater element nums[1] = 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [2, -1, 2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Mixed case with circular element</span>
        <span class="c1">// nums[4] = 3 finds next greater element nums[3] = 4 by going circularly</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [2, 3, 4, -1, 4]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: All elements are equal</span>
        <span class="c1">// No element has a next greater element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [-1, -1, -1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Single element</span>
        <span class="c1">// Single element cannot have next greater element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [-1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Strictly decreasing array</span>
        <span class="c1">// Each element (except first) finds next greater element by going circularly to the first element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result5</span> <span class="o">=</span> <span class="n">nextGreaterElements</span><span class="o">(</span><span class="n">nums5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [-1, 5, 5, 5, 5]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums. The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, return -1 for this number.]]></summary></entry><entry><title type="html">540. Single Element in a Sorted Array</title><link href="https://zhengstar94.github.io//blog/2025/SingleElementInASortedArray/" rel="alternate" type="text/html" title="540. Single Element in a Sorted Array"/><published>2025-06-06T00:00:00+00:00</published><updated>2025-06-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SingleElementInASortedArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SingleElementInASortedArray/"><![CDATA[<ul> <li>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</li> <li>Return <em>the single element that appears only once</em>.</li> <li>Your solution must run in <code class="language-plaintext highlighter-rouge">O(log n)</code> time and <code class="language-plaintext highlighter-rouge">O(1)</code> space.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,7,7,10,11,11]
Output: 10
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingleElementInASortedArray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">singleNonDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize binary search boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                    <span class="c1">// Start of search range</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>     <span class="c1">// End of search range</span>

        <span class="c1">// Continue binary search until we narrow down to a single element</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle index, avoiding integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="cm">/**
             * CRITICAL STEP: Ensure mid is at an even index
             *
             * Why this matters:
             * - In the portion before the single element, pairs start at even indices: (0,1), (2,3), (4,5)...
             * - In the portion after the single element, pairs start at odd indices due to shift
             *
             * By always checking from an even index, we can reliably determine:
             * - If nums[even] == nums[even+1]: we're in the "before single element" portion
             * - If nums[even] != nums[even+1]: we're in the "after single element" portion or at the single element
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mid</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mid</span><span class="o">--;</span>  <span class="c1">// Move to the previous even index</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Decision Logic:
             *
             * Case 1: nums[mid] == nums[mid + 1]
             * - This means we found a proper pair starting at an even index
             * - This indicates we're in the "before single element" portion
             * - The single element must be to the RIGHT of this pair
             * - Move left boundary to mid + 2 (skip this pair entirely)
             *
             * Case 2: nums[mid] != nums[mid + 1]
             * - This means the pair pattern is broken
             * - Either mid is the single element, or we're in the "after single element" portion
             * - The single element must be at mid or to the LEFT of mid
             * - Move right boundary to mid (include mid in next search)
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Single element is in the right half</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>  <span class="c1">// Skip the current pair and search right</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Single element is in the left half (including current position)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>     <span class="c1">// Include current position in next search</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the single element</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Single element in the middle</span>
        <span class="c1">// Array structure: [1,1] [2] [3,3] [4,4] [8,8]</span>
        <span class="c1">// Expected: 2 (breaks the pair pattern)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Single element towards the end</span>
        <span class="c1">// Array structure: [3,3] [7,7] [10] [11,11]</span>
        <span class="c1">// Expected: 10</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">11</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Single element at the beginning</span>
        <span class="c1">// Array structure: [1] [2,2] [3,3] [4,4] [8,8]</span>
        <span class="c1">// Expected: 1 (all subsequent pairs shift to odd start indices)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Single element at beginning):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Single element at the end</span>
        <span class="c1">// Array structure: [1,1] [2,2] [3,3] [4,4] [8]</span>
        <span class="c1">// Expected: 8 (last element has no pair)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 (Single element at end):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Edge case - single element array</span>
        <span class="c1">// Array structure: [1]</span>
        <span class="c1">// Expected: 1 (only one element exists)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 (Single element array):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">singleNonDuplicate</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 1"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch"/><category term="Medium"/><summary type="html"><![CDATA[You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in O(log n) time and O(1) space.]]></summary></entry><entry><title type="html">2434. Using a Robot to Print the Lexicographically Smallest String</title><link href="https://zhengstar94.github.io//blog/2025/UsingARobotToPrintTheLexicographicallySmallestString/" rel="alternate" type="text/html" title="2434. Using a Robot to Print the Lexicographically Smallest String"/><published>2025-06-06T00:00:00+00:00</published><updated>2025-06-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/UsingARobotToPrintTheLexicographicallySmallestString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/UsingARobotToPrintTheLexicographicallySmallestString/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> and a robot that currently holds an empty string <code class="language-plaintext highlighter-rouge">t</code>. Apply one of the following operations until <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> <strong>are both empty</strong>: <ul> <li>Remove the <strong>first</strong> character of a string <code class="language-plaintext highlighter-rouge">s</code> and give it to the robot. The robot will append this character to the string <code class="language-plaintext highlighter-rouge">t</code>.</li> <li>Remove the <strong>last</strong> character of a string <code class="language-plaintext highlighter-rouge">t</code> and give it to the robot. The robot will write this character on paper.</li> </ul> </li> <li>Return <em>the lexicographically smallest string that can be written on the paper.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "zza"
Output: "azz"
Explanation: Let p denote the written string.
Initially p="", s="zza", t="".
Perform first operation three times p="", s="", t="zza".
Perform second operation three times p="azz", s="", t="".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bac"
Output: "abc"
Explanation: Let p denote the written string.
Perform first operation twice p="", s="c", t="ba". 
Perform second operation twice p="ab", s="c", t="". 
Perform first operation p="ab", s="", t="c". 
Perform second operation p="abc", s="", t="".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bdda"
Output: "addb"
Explanation: Let p denote the written string.
Initially p="", s="bdda", t="".
Perform first operation four times p="", s="", t="bdda".
Perform second operation four times p="addb", s="", t="".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UsingARobotToPrintTheLexicographicallySmallestString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">robotWithString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Step 1: Preprocessing - Build suffix minimum array</span>
        <span class="c1">// sufMin[i] represents the minimum character from position i to the end of string</span>
        <span class="c1">// This helps us decide whether to wait for a smaller character or output current one</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">sufMin</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Set sentinel value to avoid boundary checking</span>
        <span class="c1">// When we reach the end, any character is &lt;= MAX_VALUE, so we can output everything</span>
        <span class="n">sufMin</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Build sufMin array from right to left</span>
        <span class="c1">// For each position i, sufMin[i] = min(current_char, min_of_remaining_suffix)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">sufMin</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sufMin</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">],</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Main algorithm execution</span>
        <span class="c1">// Initialize result builder with initial capacity for better performance</span>
        <span class="nc">StringBuilder</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

        <span class="c1">// Use ArrayDeque instead of Stack for better performance</span>
        <span class="c1">// This stack simulates the temporary string 't' in the problem</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Process each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Operation 1: Take character from string s and put it into stack t</span>
            <span class="c1">// Always push the current character first</span>
            <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>

            <span class="c1">// Operation 2: Decide when to pop characters from stack and write to paper</span>
            <span class="c1">// Key insight: Pop character if it's &lt;= minimum character in remaining suffix</span>
            <span class="c1">// This ensures we output smaller characters as early as possible</span>

            <span class="c1">// sufMin[i + 1] represents minimum character from next position to end</span>
            <span class="c1">// If current stack top &lt;= sufMin[i + 1], it means:</span>
            <span class="c1">// 1. Either no more characters left (sufMin[i+1] = MAX_VALUE), so output everything</span>
            <span class="c1">// 2. Or current character is not larger than any future character, safe to output</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">sufMin</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Pop from stack and append to result (write to paper)</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="c1">// At this point, both s and stack t should be empty</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: Example from problem statement</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"zza"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: azz"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2: Another example from problem statement</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"bac"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: abc"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 3: Third example from problem statement</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"bdda"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: addb"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 4: Edge case - single character</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: a"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 5: Already sorted string</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result5</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: abc"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 6: Reverse sorted string</span>
        <span class="nc">String</span> <span class="n">s6</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result6</span> <span class="o">=</span> <span class="n">robotWithString</span><span class="o">(</span><span class="n">s6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty: Remove the first character of a string s and give it to the robot. The robot will append this character to the string t. Remove the last character of a string t and give it to the robot. The robot will write this character on paper.]]></summary></entry><entry><title type="html">2929. Distribute Candies Among Children II</title><link href="https://zhengstar94.github.io//blog/2025/DistributeCandiesAmongChildrenII/" rel="alternate" type="text/html" title="2929. Distribute Candies Among Children II"/><published>2025-06-01T00:00:00+00:00</published><updated>2025-06-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DistributeCandiesAmongChildrenII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DistributeCandiesAmongChildrenII/"><![CDATA[<ul> <li>You are given two positive integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">limit</code>.</li> <li>Return <em>the <strong>total number</strong> of ways to distribute</em> <code class="language-plaintext highlighter-rouge">n</code> <em>candies among</em> <code class="language-plaintext highlighter-rouge">3</code> <em>children such that no child gets more than</em> <code class="language-plaintext highlighter-rouge">limit</code> <em>candies.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, limit = 2
Output: 3
Explanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 3, limit = 3
Output: 10
Explanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DistributeCandiesAmongChildrenII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">distributeCandies</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Using Inclusion-Exclusion Principle:</span>
        <span class="c1">// Valid solutions (≤ limit) = Total solutions - Invalid solutions (&gt; limit)</span>

        <span class="cm">/*
         * Breaking down the formula: c2(n + 2) - 3 * c2(n - limit + 1) + 3 * c2(n - 2 * limit) - c2(n - 3 * limit - 1)
         *
         * Term 1: c2(n + 2)
         * - Total ways to distribute n candies among 3 children without any limit
         * - Using stars and bars method: place n candies in 3 distinguishable boxes
         * - We have n+2 positions, choose 2 positions for dividers
         * - Formula: C(n+2, 2)
         *
         * Term 2: -3 * c2(n - limit + 1)
         * - Subtract cases where at least one child gets more than limit candies
         * - Set A: child 1 gets &gt; limit candies (we don't care about child 2 and 3)
         * - Set B: child 2 gets &gt; limit candies
         * - Set C: child 3 gets &gt; limit candies
         * - For Set A: child 1 gets at least (limit+1) candies
         *   Equivalent to: give child 1 exactly (limit+1) candies first,
         *   then distribute remaining (n-(limit+1)) candies among all 3 children
         * - Ways for Set A: C((n-(limit+1))+2, 2) = C(n-limit+1, 2)
         * - |A| = |B| = |C| = C(n-limit+1, 2), so total: 3 * C(n-limit+1, 2)
         *
         * Term 3: +3 * c2(n - 2 * limit)
         * - Add back cases where exactly two children get &gt; limit candies (inclusion-exclusion)
         * - Set A∩B: both child 1 and child 2 get &gt; limit candies
         * - Set A∩C: both child 1 and child 3 get &gt; limit candies
         * - Set B∩C: both child 2 and child 3 get &gt; limit candies
         * - For Set A∩B: both child 1 and child 2 get at least (limit+1) candies
         *   Give child 1 and child 2 each (limit+1) candies first,
         *   then distribute remaining (n-2*(limit+1)) candies among all 3 children
         * - Ways for Set A∩B: C((n-2*(limit+1))+2, 2) = C(n-2*limit, 2)
         * - |A∩B| = |A∩C| = |B∩C| = C(n-2*limit, 2), so total: 3 * C(n-2*limit, 2)
         *
         * Term 4: -c2(n - 3 * limit - 1)
         * - Subtract cases where all three children get &gt; limit candies
         * - Set A∩B∩C: all three children get &gt; limit candies
         * - Give each child (limit+1) candies first,
         *   then distribute remaining (n-3*(limit+1)) candies among all 3 children
         * - Ways: C((n-3*(limit+1))+2, 2) = C(n-3*limit-1, 2)
         *
         * Final formula by inclusion-exclusion principle:
         * |Valid| = |Total| - |A∪B∪C|
         * = |Total| - (|A|+|B|+|C| - |A∩B|-|A∩C|-|B∩C| + |A∩B∩C|)
         * = C(n+2,2) - 3*C(n-limit+1,2) + 3*C(n-2*limit,2) - C(n-3*limit-1,2)
         */</span>

        <span class="k">return</span> <span class="nf">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span>                    <span class="c1">// Total ways without constraint  C（n+2，2）</span>
                <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>        <span class="c1">// Subtract single violations  C（n-（limit+1）+2， 2）</span>
                <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">limit</span><span class="o">)</span>        <span class="c1">// Add back double violations  C(n-2*(limit+1)+2， 2)  </span>
                <span class="o">-</span> <span class="n">c2</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">limit</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>       <span class="c1">// Subtract triple violations  C(n-3*(limit+1)+2, 2)</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">c2</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">n</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: n=5, limit=2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"n=5, limit=2: "</span> <span class="o">+</span> <span class="n">distributeCandies</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Example 2: n=3, limit=3  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"n=3, limit=3: "</span> <span class="o">+</span> <span class="n">distributeCandies</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected: 10</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given two positive integers n and limit. Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.]]></summary></entry><entry><title type="html">1901. Find a Peak Element II</title><link href="https://zhengstar94.github.io//blog/2025/FindAPeakElementII/" rel="alternate" type="text/html" title="1901. Find a Peak Element II"/><published>2025-05-28T00:00:00+00:00</published><updated>2025-05-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindAPeakElementII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindAPeakElementII/"><![CDATA[<ul> <li>A <strong>peak</strong> element in a 2D grid is an element that is <strong>strictly greater</strong> than all of its <strong>adjacent</strong> neighbors to the left, right, top, and bottom.</li> <li>Given a <strong>0-indexed</strong> <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">mat</code> where <strong>no two adjacent cells are equal</strong>, find <strong>any</strong> peak element <code class="language-plaintext highlighter-rouge">mat[i][j]</code> and return <em>the length 2 array</em> <code class="language-plaintext highlighter-rouge">[i,j]</code>.</li> <li>You may assume that the entire matrix is surrounded by an <strong>outer perimeter</strong> with the value <code class="language-plaintext highlighter-rouge">-1</code> in each cell.</li> <li>You must write an algorithm that runs in <code class="language-plaintext highlighter-rouge">O(m log(n))</code> or <code class="language-plaintext highlighter-rouge">O(n log(m))</code> time.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: mat = [ [ 1,4],[3,2 ] ]
Output: [0,1]
Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: mat = [ [ 10,20,15],[21,30,14],[7,16,32 ] ]
Output: [1,1]
Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogm) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/05/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindAPeakElementII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findPeakGrid</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize binary search boundaries for rows</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                    <span class="c1">// Start from first row</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// End at last row</span>

        <span class="c1">// Perform binary search on rows</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Find middle row to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Find the column index of maximum element in current row i</span>
            <span class="c1">// This is crucial: the max element in a row is already a peak</span>
            <span class="c1">// in horizontal direction (left-right), we only need to check vertical</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indexOfMax</span><span class="o">(</span><span class="n">mat</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Compare current max element with the element directly below it</span>
            <span class="c1">// This comparison determines which direction to search next</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mat</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">mat</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Current element is greater than element below</span>
                <span class="c1">// This means:</span>
                <span class="c1">// 1. If current element is also &gt; element above, it's a peak</span>
                <span class="c1">// 2. If current element &lt;= element above, peak exists above</span>
                <span class="c1">// In both cases, peak exists in current row or above</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  <span class="c1">// Search in upper half (including current row)</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Current element &lt;= element below</span>
                <span class="c1">// This means there's a larger element below, so peak must be below</span>
                <span class="c1">// We can safely exclude current row and search below</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Search in lower half (excluding current row)</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the row containing a peak</span>
        <span class="c1">// Return the coordinates: [row_index, column_index_of_max_in_that_row]</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">left</span><span class="o">,</span> <span class="n">indexOfMax</span><span class="o">(</span><span class="n">mat</span><span class="o">[</span><span class="n">left</span><span class="o">])};</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">indexOfMax</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Initialize with first element's index</span>

        <span class="c1">// Iterate through the array to find maximum element's index</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If current element is greater than previously found max</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">idx</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  <span class="c1">// Update max element's index</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">idx</span><span class="o">;</span>  <span class="c1">// Return index of maximum element</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== LeetCode 1901: Find a Peak Element II ===\n"</span><span class="o">);</span>

        <span class="c1">// Test Case 1: Example from LeetCode</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input matrix:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">mat1</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">findPeakGrid</span><span class="o">(</span><span class="n">mat1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak found at: ["</span> <span class="o">+</span> <span class="n">result1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak value: "</span> <span class="o">+</span> <span class="n">mat1</span><span class="o">[</span><span class="n">result1</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">result1</span><span class="o">[</span><span class="mi">1</span><span class="o">]]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Verification: "</span> <span class="o">+</span> <span class="n">verifyPeak</span><span class="o">(</span><span class="n">mat1</span><span class="o">,</span> <span class="n">result1</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result1</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Example from LeetCode</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">15</span><span class="o">},</span> <span class="o">{</span><span class="mi">21</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">14</span><span class="o">},</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">32</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input matrix:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">mat2</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">findPeakGrid</span><span class="o">(</span><span class="n">mat2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak found at: ["</span> <span class="o">+</span> <span class="n">result2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Peak value: "</span> <span class="o">+</span> <span class="n">mat2</span><span class="o">[</span><span class="n">result2</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">result2</span><span class="o">[</span><span class="mi">1</span><span class="o">]]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Verification: "</span> <span class="o">+</span> <span class="n">verifyPeak</span><span class="o">(</span><span class="n">mat2</span><span class="o">,</span> <span class="n">result2</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result2</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%3d"</span><span class="o">,</span> <span class="n">row</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">verifyPeak</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>

        <span class="c1">// Check all four directions</span>
        <span class="c1">// Up</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Down</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Left</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Right</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  <span class="c1">// All adjacent elements are smaller</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch"/><category term="Medium"/><summary type="html"><![CDATA[A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom. Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j]. You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell. You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.]]></summary></entry></feed>