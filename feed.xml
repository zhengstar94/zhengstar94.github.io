<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-12T03:14:43+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2116. Check if a Parentheses String Can Be Valid</title><link href="https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid/" rel="alternate" type="text/html" title="2116. Check if a Parentheses String Can Be Valid"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CheckIfAParenthesesStringCanBeValid/"><![CDATA[<ul> <li>A parentheses string is a <strong>non-empty</strong> string consisting only of <code class="language-plaintext highlighter-rouge">'('</code> and <code class="language-plaintext highlighter-rouge">')'</code>. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>: <ul> <li>It is <code class="language-plaintext highlighter-rouge">()</code>.</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">AB</code> (<code class="language-plaintext highlighter-rouge">A</code> concatenated with <code class="language-plaintext highlighter-rouge">B</code>), where <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are valid parentheses strings.</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">(A)</code>, where <code class="language-plaintext highlighter-rouge">A</code> is a valid parentheses string.</li> </ul> </li> <li>You are given a parentheses string <code class="language-plaintext highlighter-rouge">s</code> and a string <code class="language-plaintext highlighter-rouge">locked</code>, both of length <code class="language-plaintext highlighter-rouge">n</code>. <code class="language-plaintext highlighter-rouge">locked</code> is a binary string consisting only of <code class="language-plaintext highlighter-rouge">'0'</code>s and <code class="language-plaintext highlighter-rouge">'1'</code>s. For <strong>each</strong> index <code class="language-plaintext highlighter-rouge">i</code> of <code class="language-plaintext highlighter-rouge">locked</code>, <ul> <li>If <code class="language-plaintext highlighter-rouge">locked[i]</code> is <code class="language-plaintext highlighter-rouge">'1'</code>, you <strong>cannot</strong> change <code class="language-plaintext highlighter-rouge">s[i]</code>.</li> <li>But if <code class="language-plaintext highlighter-rouge">locked[i]</code> is <code class="language-plaintext highlighter-rouge">'0'</code>, you <strong>can</strong> change <code class="language-plaintext highlighter-rouge">s[i]</code> to either <code class="language-plaintext highlighter-rouge">'('</code> or <code class="language-plaintext highlighter-rouge">')'</code>.</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if you can make <code class="language-plaintext highlighter-rouge">s</code> a valid parentheses string</em>. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " ) ) ( ) ) ) ", locked = "010100"
Output: true
Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].
We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = " ( ) ( ) ", locked = "0000"
Output: true
Explanation: We do not need to make any changes because s is already valid.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = ")", locked = "0"
Output: false
Explanation: locked permits  us to change s[0]. 
Changing s[0] to either '(' or ')' will not make s valid.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckIfAParenthesesStringCanBeValid</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canBeValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">locked</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the length is odd, it's impossible to form valid parentheses</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// First pass: Left to right scan to check for excess right parentheses</span>
        <span class="c1">// balance: tracks the difference between left and right parentheses for locked positions</span>
        <span class="c1">// wild: counts the number of modifiable positions that can be used to fix imbalances</span>
        <span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">wild</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Scan from left to right to ensure we never have too many right parentheses</span>
        <span class="c1">// This pass ensures that at each position, we can convert enough characters</span>
        <span class="c1">// to left parentheses to match any right parentheses we've seen</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">locked</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Position is modifiable, increment wild counter</span>
                <span class="n">wild</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Locked left parenthesis, increment balance</span>
                <span class="n">balance</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Locked right parenthesis, decrement balance</span>
                <span class="n">balance</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// If balance + wild &lt; 0, we have too many right parentheses</span>
            <span class="c1">// that cannot be fixed even using all modifiable positions</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">+</span> <span class="n">wild</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Second pass: Right to left scan to check for excess left parentheses</span>
        <span class="c1">// Reset counters for the reverse scan</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">wild</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Scan from right to left to ensure we never have too many left parentheses</span>
        <span class="c1">// This pass ensures that at each position (working backwards),</span>
        <span class="c1">// we can convert enough characters to right parentheses to match any left</span>
        <span class="c1">// parentheses we've seen</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">locked</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Position is modifiable, increment wild counter</span>
                <span class="n">wild</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Locked right parenthesis, increment balance</span>
                <span class="n">balance</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Locked left parenthesis, decrement balance</span>
                <span class="n">balance</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// If balance + wild &lt; 0, we have too many left parentheses</span>
            <span class="c1">// that cannot be fixed even using all modifiable positions</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">+</span> <span class="n">wild</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If both passes succeed, the string can be made valid</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String can be made valid by modifying unlocked positions</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">" ) ) ( ) ) )"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked1</span> <span class="o">=</span> <span class="s">"010100"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">locked1</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 2: Already valid string with all positions modifiable</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">" ( ) ( ) "</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked2</span> <span class="o">=</span> <span class="s">"0000"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">locked2</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 3: Single character cannot form valid parentheses</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">")"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked3</span> <span class="o">=</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">locked3</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 4: Additional test case with all positions modifiable</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">" ( ) ) "</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">locked4</span> <span class="o">=</span> <span class="s">"000"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">canBeValid</span><span class="o">(</span><span class="n">s4</span><span class="o">,</span> <span class="n">locked4</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Medium"/><summary type="html"><![CDATA[A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true: It is (). It can be written as AB (A concatenated with B), where A and B are valid parentheses strings. It can be written as (A), where A is a valid parentheses string. You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked, If locked[i] is '1', you cannot change s[i]. But if locked[i] is '0', you can change s[i] to either '(' or ')'. Return true if you can make s a valid parentheses string. Otherwise, return false.]]></summary></entry><entry><title type="html">2275. Largest Combination With Bitwise AND Greater Than Zero</title><link href="https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero/" rel="alternate" type="text/html" title="2275. Largest Combination With Bitwise AND Greater Than Zero"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LargestCombinationWithBitwiseANDGreaterThanZero/"><![CDATA[<ul> <li>The <strong>bitwise AND</strong> of an array <code class="language-plaintext highlighter-rouge">nums</code> is the bitwise AND of all integers in <code class="language-plaintext highlighter-rouge">nums</code>. <ul> <li>For example, for <code class="language-plaintext highlighter-rouge">nums = [1, 5, 3]</code>, the bitwise AND is equal to <code class="language-plaintext highlighter-rouge">1 &amp; 5 &amp; 3 = 1</code>.</li> <li>Also, for <code class="language-plaintext highlighter-rouge">nums = [7]</code>, the bitwise AND is <code class="language-plaintext highlighter-rouge">7</code>.</li> </ul> </li> <li>You are given an array of positive integers <code class="language-plaintext highlighter-rouge">candidates</code>. Compute the <strong>bitwise AND</strong> for all possible <strong>combinations</strong> of elements in the <code class="language-plaintext highlighter-rouge">candidates</code> array.</li> <li>Return <em>the size of the <strong>largest</strong> combination of</em> <code class="language-plaintext highlighter-rouge">candidates</code> <em>with a bitwise AND <strong>greater</strong> than</em> <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [16,17,71,62,12,24,14]
Output: 4
Explanation: The combination [16,17,62,24] has a bitwise AND of 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0.
The size of the combination is 4.
It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.
Note that more than one combination may have the largest size.
For example, the combination [62,12,24,14] has a bitwise AND of 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [8,8]
Output: 2
Explanation: The largest combination [8,8] has a bitwise AND of 8 &amp; 8 = 8 &gt; 0.
The size of the combination is 2, so we return 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogU) time | O(logU) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LargestCombinationWithBitwiseANDGreaterThanZero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">largestCombination</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create an array to store the count of 1s at each binary position (0-23)</span>
        <span class="c1">// Size is 24 because the constraint states candidates[i] &lt;= 10^7 &lt; 2^24</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">24</span><span class="o">];</span>

        <span class="c1">// Iterate through each number in the candidates array</span>
        <span class="c1">// For each number, we'll count how many 1s appear at each binary position</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Process each bit of the current number until it becomes 0</span>
            <span class="c1">// i represents the current bit position (0-based, from right to left)</span>
            <span class="c1">// The loop continues as long as there are 1s remaining in x</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// x &amp; 1 extracts the rightmost bit (0 or 1)</span>
                <span class="c1">// Add this bit to the count at position i</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Right shift x by 1 to process the next bit in the next iteration</span>
                <span class="c1">// This effectively removes the rightmost bit we just processed</span>
                <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Find the maximum count across all bit positions</span>
        <span class="c1">// This represents the size of the largest possible combination</span>
        <span class="c1">// where all numbers have 1 at the same position</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">cnt</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example with multiple valid combinations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">16</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">71</span><span class="o">,</span><span class="mi">62</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">24</span><span class="o">,</span><span class="mi">14</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2: Example with identical numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 3: Example with large numbers using bit shifting</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="o">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">largestCombination</span><span class="o">(</span><span class="n">candidates3</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[The bitwise AND of an array nums is the bitwise AND of all integers in nums. For example, for nums=[1, 5, 3], the bitwise AND is equal to 1 &amp; 5 &amp; 3=1. Also, for nums=[7], the bitwise AND is 7. You are given an array of positive integers candidates. Compute the bitwise AND for all possible combinations of elements in the candidates array. Return the size of the largest combination of candidates with a bitwise AND greater than 0.]]></summary></entry><entry><title type="html">1493. Longest Subarray of 1’s After Deleting One Element</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement/" rel="alternate" type="text/html" title="1493. Longest Subarray of 1’s After Deleting One Element"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubarrayOf1sAfteDeletingOneElement/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code>, you should delete one element from it.</li> <li>Return <em>the size of the longest non-empty subarray containing only</em> <code class="language-plaintext highlighter-rouge">1</code><em>’s in the resulting array</em>. Return <code class="language-plaintext highlighter-rouge">0</code> if there is no such subarray.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubarrayOf1sAfteDeletingOneElement</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">zeroCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Keeps track of the number of zeros in the current window</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Tracks the length of the longest subarray found</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Left boundary of the sliding window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Enter window: The current element is added to the window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zeroCount</span><span class="o">++;</span> <span class="c1">// Increment zero count if the current element is 0</span>
            <span class="o">}</span>

            <span class="c1">// 2. Exit window: Adjust the window to ensure the condition (at most one zero) is satisfied</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">zeroCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// If there are more than one zero in the window</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">zeroCount</span><span class="o">--;</span> <span class="c1">// Decrement zero count if the leftmost element is 0</span>
                <span class="o">}</span>
                <span class="n">start</span><span class="o">++;</span> <span class="c1">// Move the left boundary of the window to the right</span>
            <span class="o">}</span>

            <span class="c1">// 3. Update answer: Update the maximum length for a valid subarray</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span> <span class="c1">// Calculate the current valid window size</span>
        <span class="o">}</span>

        <span class="c1">// Special case: If the array consists entirely of 1s, the result should exclude one element</span>
        <span class="k">return</span> <span class="n">maxLength</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">maxLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Additional test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Additional test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">longestSubarray</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a binary array nums, you should delete one element from it. Return the size of the longest non-empty subarray containing only 1’s in the resulting array. Return 0 if there is no such subarray.]]></summary></entry><entry><title type="html">1400. Construct K Palindrome Strings</title><link href="https://zhengstar94.github.io//blog/2025/ConstructKPalindromeStrings/" rel="alternate" type="text/html" title="1400. Construct K Palindrome Strings"/><published>2025-01-11T00:00:00+00:00</published><updated>2025-01-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ConstructKPalindromeStrings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ConstructKPalindromeStrings/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if you can use all the characters in</em> <code class="language-plaintext highlighter-rouge">s</code> <em>to construct</em> <code class="language-plaintext highlighter-rouge">k</code> <em>palindrome strings or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "annabelle", k = 2
Output: true
Explanation: You can construct two palindromes using all characters in s.
Some possible constructions "anna" + "elble", "anbna" + "elle", "anellena" + "b"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "leetcode", k = 3
Output: false
Explanation: It is impossible to construct 3 palindromes using all the characters of s.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "true", k = 4
Output: true
Explanation: The only possible solution is to put each character in a separate  string.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstructKPalindromeStrings</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canConstruct</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If k is greater than the string length, it's impossible to construct</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Count the frequency of each character</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Count the number of characters that appear odd times</span>
        <span class="kt">int</span> <span class="n">oddCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oddCount</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If the number of characters appearing odd times is greater than k,</span>
        <span class="c1">// we cannot construct k palindrome strings</span>
        <span class="c1">// If k=1, we can have any number of odd frequency characters</span>
        <span class="c1">// If k&gt;1, the number of odd frequency characters cannot exceed k</span>
        <span class="k">return</span> <span class="n">oddCount</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"annabelle"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">canConstruct</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Should output true</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"leetcode"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">canConstruct</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Should output false</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"true"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">canConstruct</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Should output true</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.]]></summary></entry><entry><title type="html">3270. Find the Key of the Numbers</title><link href="https://zhengstar94.github.io//blog/2025/FindTheKeyOfTheNumbers/" rel="alternate" type="text/html" title="3270. Find the Key of the Numbers"/><published>2025-01-11T00:00:00+00:00</published><updated>2025-01-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheKeyOfTheNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheKeyOfTheNumbers/"><![CDATA[<ul> <li>You are given three <strong>positive</strong> integers <code class="language-plaintext highlighter-rouge">num1</code>, <code class="language-plaintext highlighter-rouge">num2</code>, and <code class="language-plaintext highlighter-rouge">num3</code>.</li> <li>The <code class="language-plaintext highlighter-rouge">key</code> of <code class="language-plaintext highlighter-rouge">num1</code>, <code class="language-plaintext highlighter-rouge">num2</code>, and <code class="language-plaintext highlighter-rouge">num3</code> is defined as a four-digit number such that: <ul> <li>Initially, if any number has <strong>less than</strong> four digits, it is padded with <strong>leading zeros</strong>.</li> <li>The <code class="language-plaintext highlighter-rouge">ith</code> digit (<code class="language-plaintext highlighter-rouge">1 &lt;= i &lt;= 4</code>) of the <code class="language-plaintext highlighter-rouge">key</code> is generated by taking the <strong>smallest</strong> digit among the <code class="language-plaintext highlighter-rouge">ith</code> digits of <code class="language-plaintext highlighter-rouge">num1</code>, <code class="language-plaintext highlighter-rouge">num2</code>, and <code class="language-plaintext highlighter-rouge">num3</code>.</li> </ul> </li> <li>Return the <code class="language-plaintext highlighter-rouge">key</code> of the three numbers <strong>without</strong> leading zeros (<em>if any</em>).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 1, num2 = 10, num3 = 1000

Output: 0

Explanation:

On padding, num1 becomes "0001", num2 becomes "0010", and num3 remains "1000".

The 1st digit of the key is min(0, 0, 1).
The 2nd digit of the key is min(0, 0, 0).
The 3rd digit of the key is min(0, 1, 0).
The 4th digit of the key is min(1, 0, 0).
Hence, the key is "0000", i.e. 0.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 987, num2 = 879, num3 = 798

Output: 777
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num1 = 1, num2 = 2, num3 = 3

Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheKeyOfTheNumbers</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findKey</span><span class="o">(</span><span class="kt">int</span> <span class="n">num1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num3</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert numbers to 4-digit strings with leading zeros</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%04d"</span><span class="o">,</span> <span class="n">num1</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%04d"</span><span class="o">,</span> <span class="n">num2</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%04d"</span><span class="o">,</span> <span class="n">num3</span><span class="o">);</span>

        <span class="nc">StringBuilder</span> <span class="n">key</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// Iterate through each digit and find the minimum value</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                            <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">,</span>
                            <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">),</span>
                    <span class="n">s3</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span>
            <span class="o">);</span>
            <span class="n">key</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">digit</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Convert to integer and return</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">num1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: num1 = "</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="s">", num2 = "</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="s">", num3 = "</span> <span class="o">+</span> <span class="n">num3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKey</span><span class="o">(</span><span class="n">num1</span><span class="o">,</span> <span class="n">num2</span><span class="o">,</span> <span class="n">num3</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2:"</span><span class="o">);</span>
        <span class="n">num1</span> <span class="o">=</span> <span class="mi">987</span><span class="o">;</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">879</span><span class="o">;</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">798</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: num1 = "</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="s">", num2 = "</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="s">", num3 = "</span> <span class="o">+</span> <span class="n">num3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKey</span><span class="o">(</span><span class="n">num1</span><span class="o">,</span> <span class="n">num2</span><span class="o">,</span> <span class="n">num3</span><span class="o">));</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3:"</span><span class="o">);</span>
        <span class="n">num1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: num1 = "</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="s">", num2 = "</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="s">", num3 = "</span> <span class="o">+</span> <span class="n">num3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKey</span><span class="o">(</span><span class="n">num1</span><span class="o">,</span> <span class="n">num2</span><span class="o">,</span> <span class="n">num3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are given three positive integers num1, num2, and num3. The key of num1, num2, and num3 is defined as a four-digit number such that: Initially, if any number has less than four digits, it is padded with leading zeros. The ith digit (1 &lt;= i &lt;= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3. Return the key of the three numbers without leading zeros (if any).]]></summary></entry><entry><title type="html">3. Longest Substring Without Repeating Characters</title><link href="https://zhengstar94.github.io//blog/2025/LongestSubstringWithoutRepeatingCharacters/" rel="alternate" type="text/html" title="3. Longest Substring Without Repeating Characters"/><published>2025-01-11T00:00:00+00:00</published><updated>2025-01-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestSubstringWithoutRepeatingCharacters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestSubstringWithoutRepeatingCharacters/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, find the length of the <strong>longest</strong> <strong>substring</strong> without repeating characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n)time∣O(m)space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/03/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestSubstringWithoutRepeatingCharacters</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="c1">// Use array instead of HashMap to store the last position of each character</span>
    <span class="c1">// Array index is the character's ASCII value (0-127)</span>
    <span class="c1">// Array value is the last position where this character appeared</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">lastSeen</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

    <span class="c1">// Initialize all positions to -1, meaning no character has been seen yet</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">lastSeen</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

    <span class="c1">// Variable to store the length of longest substring found so far</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// Variable to mark the start position of current window</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="c1">// 1. Window Entry Check:</span>
      <span class="c1">// Check if current character causes window to shrink</span>
      <span class="c1">// If the last occurrence of current character is within or at the start of our window,</span>
      <span class="c1">// we need to move the window start to avoid repeating characters</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">lastSeen</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">lastSeen</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Move start to just after the last occurrence</span>
      <span class="o">}</span>

      <span class="c1">// 2. Update Answer:</span>
      <span class="c1">// Current window size is (i - start + 1)</span>
      <span class="c1">// Update max length if current window is longer</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

      <span class="c1">// 3. Update Character Position:</span>
      <span class="c1">// Record the current position of character for future reference</span>
      <span class="c1">// This helps us detect repeating characters in future iterations</span>
      <span class="n">lastSeen</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Test the function with example string "abcabcbb"</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcabcbb"</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>  <span class="c1">// Output: 3</span>

    <span class="c1">// Test the function with example string "bbbbb"</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"bbbbb"</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>  <span class="c1">// Output: 1</span>

    <span class="c1">// Test the function with example string "pwwkew"</span>
    <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"pwwkew"</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span>  <span class="c1">// Output: 3</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, find the length of the longest substring without repeating characters.]]></summary></entry><entry><title type="html">3090. Maximum Length Substring With Two Occurrences</title><link href="https://zhengstar94.github.io//blog/2025/MaximumLengthSubstringWithTwoOccurrences/" rel="alternate" type="text/html" title="3090. Maximum Length Substring With Two Occurrences"/><published>2025-01-11T00:00:00+00:00</published><updated>2025-01-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumLengthSubstringWithTwoOccurrences</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumLengthSubstringWithTwoOccurrences/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return the <strong>maximum</strong> length of a substring such that it contains <em>at most two occurrences</em> of each character.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bcbbbcba"
Output: 4

Explanation:
The following substring has a length of 4 and contains at most two occurrences of each character: "bcbbbcba".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaaa"
Output: 2

Explanation:
The following substring has a length of 2 and contains at most two occurrences of each character: "aaaa".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumLengthSubstringWithTwoOccurrences</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumLengthSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span> <span class="c1">// Convert the input string to a character array for easier access.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span> <span class="c1">// Array to track the frequency of each character ('a' to 'z').</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Variable to store the maximum length of the substring found so far.</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Left pointer of the sliding window.</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Enter window</span>
            <span class="c1">// Increment the frequency of the current character as it enters the window.</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>

            <span class="c1">// 2. Maintain the condition: At most two occurrences of each character.</span>
            <span class="c1">// If the frequency of the current character exceeds 2, move the left pointer</span>
            <span class="c1">// to shrink the window until the condition is satisfied.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 3. Exit window</span>
                <span class="c1">// Decrease the frequency of the character that is leaving the window</span>
                <span class="c1">// and move the left pointer one step forward.</span>
                <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// 4. Update the maximum length</span>
            <span class="c1">// Calculate the length of the current valid window and update the maxLen if needed.</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span> <span class="c1">// Return the maximum length of the substring found.</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumLengthSubstring</span><span class="o">(</span><span class="s">"bcbbbcba"</span><span class="o">));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumLengthSubstring</span><span class="o">(</span><span class="s">"aaaa"</span><span class="o">));</span>     <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumLengthSubstring</span><span class="o">(</span><span class="s">"abcabc"</span><span class="o">));</span>   <span class="c1">// Output: 6</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumLengthSubstring</span><span class="o">(</span><span class="s">""</span><span class="o">));</span>         <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximumLengthSubstring</span><span class="o">(</span><span class="s">"aabbccdd"</span><span class="o">));</span> <span class="c1">// Output: 8</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Easy"/><summary type="html"><![CDATA[Given a string s, return the maximum length of a substring such that it contains at most two occurrences of each character.]]></summary></entry><entry><title type="html">220. Contains Duplicate III</title><link href="https://zhengstar94.github.io//blog/2025/ContainsDuplicateIII/" rel="alternate" type="text/html" title="220. Contains Duplicate III"/><published>2025-01-10T00:00:00+00:00</published><updated>2025-01-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ContainsDuplicateIII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ContainsDuplicateIII/"><![CDATA[<h1 id="220-contains-duplicate-iii">220. Contains Duplicate III</h1> <ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and two integers <code class="language-plaintext highlighter-rouge">indexDiff</code> and <code class="language-plaintext highlighter-rouge">valueDiff</code>.</li> <li>Find a pair of indices <code class="language-plaintext highlighter-rouge">(i, j)</code> such that: <ul> <li><code class="language-plaintext highlighter-rouge">i != j</code>,</li> <li><code class="language-plaintext highlighter-rouge">abs(i - j) &lt;= indexDiff</code>.</li> <li><code class="language-plaintext highlighter-rouge">abs(nums[i] - nums[j]) &lt;= valueDiff</code>, and</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if such pair exists or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0
Output: true
Explanation: We can choose (i, j) = (0, 3).
We satisfy the three conditions:
i != j --&gt; 0 != 3
abs(i - j) &lt;= indexDiff --&gt; abs(0 - 3) &lt;= 3
abs(nums[i] - nums[j]) &lt;= valueDiff --&gt; abs(1 - 1) &lt;= 0
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3
Output: false
Explanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(k)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.TreeSet</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContainsDuplicateIII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">indexDiff</span><span class="o">,</span> <span class="kt">int</span> <span class="n">valueDiff</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array, array length less than 2, invalid indexDiff or valueDiff</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">indexDiff</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">valueDiff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 1. Enter window</span>
            <span class="c1">// Convert current number to long to avoid integer overflow</span>
            <span class="nc">Long</span> <span class="n">curr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">// Find the smallest value greater than or equal to (curr - valueDiff)</span>
            <span class="nc">Long</span> <span class="n">ceiling</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="n">curr</span> <span class="o">-</span> <span class="n">valueDiff</span><span class="o">);</span>
            <span class="c1">// If such value exists and is within the valueDiff range, we found a valid pair</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ceiling</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ceiling</span> <span class="o">&lt;=</span> <span class="n">curr</span> <span class="o">+</span> <span class="n">valueDiff</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">curr</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">indexDiff</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Window size has not reached indexDiff yet</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 2. Update answer</span>
            <span class="c1">// No need to update answer here as we return true immediately when finding a valid pair</span>

            <span class="c1">// 3. Exit window</span>
            <span class="c1">// Remove the leftmost element from the window</span>
            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">indexDiff</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Should return true</span>
        <span class="c1">// Contains duplicate values (1) within indexDiff = 3 and valueDiff = 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">indexDiff1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">valueDiff1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">indexDiff1</span><span class="o">,</span> <span class="n">valueDiff1</span><span class="o">));</span>
        <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 2: Should return false</span>
        <span class="c1">// No pairs satisfy both indexDiff and valueDiff conditions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">indexDiff2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">valueDiff2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">indexDiff2</span><span class="o">,</span> <span class="n">valueDiff2</span><span class="o">));</span>
        <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 3: Edge case - single element array</span>
        <span class="c1">// Should return false as no pairs exist</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">indexDiff3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">valueDiff3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">indexDiff3</span><span class="o">,</span> <span class="n">valueDiff3</span><span class="o">));</span>
        <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Hard"/><summary type="html"><![CDATA[220. Contains Duplicate III]]></summary></entry><entry><title type="html">3298. Count Substrings That Can Be Rearranged to Contain a String II</title><link href="https://zhengstar94.github.io//blog/2025/CountSubstringsThatCanBeRearrangedToContainAStringII/" rel="alternate" type="text/html" title="3298. Count Substrings That Can Be Rearranged to Contain a String II"/><published>2025-01-10T00:00:00+00:00</published><updated>2025-01-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubstringsThatCanBeRearrangedToContainAStringII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubstringsThatCanBeRearrangedToContainAStringII/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">word1</code> and <code class="language-plaintext highlighter-rouge">word2</code>.</li> <li>A string <code class="language-plaintext highlighter-rouge">x</code> is called <strong>valid</strong> if <code class="language-plaintext highlighter-rouge">x</code> can be rearranged to have <code class="language-plaintext highlighter-rouge">word2</code> as a prefix.</li> <li>Return the total number of <strong>valid</strong> substrings of <code class="language-plaintext highlighter-rouge">word1</code>.</li> <li><strong>Note</strong> that the memory limits in this problem are <strong>smaller</strong> than usual, so you <strong>must</strong> implement a solution with a <em>linear</em> runtime complexity.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [90], k = 1
Output: 0
Explanation: There is one way to pick score(s) of one student:
- [90]. The difference between the highest and lowest score is 90 - 90 = 0.
The minimum possible difference is 0.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [9,4,1,7], k = 2
Output: 2
Explanation: There are six ways to pick score(s) of two students:
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.
- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.
The minimum possible difference is 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubstringsThatCanBeRearrangedToContainAStringII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">validSubstringCount</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Early return if word1 is shorter than word2, as no valid substring possible</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Convert strings to char arrays for efficient access</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="n">word1</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="c1">// Array to track the difference in character frequencies</span>
        <span class="c1">// diff[i] &gt; 0 means we need more of character i</span>
        <span class="c1">// diff[i] = 0 means we have exactly enough of character i</span>
        <span class="c1">// diff[i] &lt; 0 means we have excess of character i</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Initialize diff array with character frequencies from word2</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">diff</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Count how many characters we still need</span>
        <span class="c1">// less represents the number of unique characters we still need</span>
        <span class="kt">int</span> <span class="n">less</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">:</span> <span class="n">diff</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">less</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Variables to track results and window</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Total count of valid substrings</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Left boundary of sliding window</span>

        <span class="c1">// Process each character in word1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Add current character to window by decreasing its needed count</span>
            <span class="n">diff</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>

            <span class="c1">// If after adding this character, its frequency matches exactly what we need</span>
            <span class="c1">// (diff becomes 0), we have one less character to worry about</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">diff</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">less</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// When less == 0, we have all characters we need</span>
            <span class="c1">// Try to minimize the window by removing characters from left</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Get the character we're about to remove</span>
                <span class="kt">char</span> <span class="n">outChar</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">left</span><span class="o">++];</span>

                <span class="c1">// If this character's count was exactly what we needed (diff == 0)</span>
                <span class="c1">// removing it will make it deficient, so increase less</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">diff</span><span class="o">[</span><span class="n">outChar</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">less</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="c1">// Update diff array as we remove the character</span>
                <span class="n">diff</span><span class="o">[</span><span class="n">outChar</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
            <span class="o">}</span>

            <span class="c1">// Add left to answer - this is crucial!</span>
            <span class="c1">// left represents how many valid substrings end at the current position</span>
            <span class="c1">// because we can start the substring at any position from 0 to left-1</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expect 1 valid substring</span>
        <span class="nc">String</span> <span class="n">word1_1</span> <span class="o">=</span> <span class="s">"bcca"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word2_1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">validSubstringCount</span><span class="o">(</span><span class="n">word1_1</span><span class="o">,</span> <span class="n">word2_1</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test case 2: Expect 10 valid substrings</span>
        <span class="nc">String</span> <span class="n">word1_2</span> <span class="o">=</span> <span class="s">"abcabc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word2_2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">validSubstringCount</span><span class="o">(</span><span class="n">word1_2</span><span class="o">,</span> <span class="n">word2_2</span><span class="o">));</span> <span class="c1">// Expected: 10</span>

        <span class="c1">// Test case 3: Expect 0 valid substrings</span>
        <span class="nc">String</span> <span class="n">word1_3</span> <span class="o">=</span> <span class="s">"abcabc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word2_3</span> <span class="o">=</span> <span class="s">"aaabc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">validSubstringCount</span><span class="o">(</span><span class="n">word1_3</span><span class="o">,</span> <span class="n">word2_3</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Hard"/><summary type="html"><![CDATA[You are given two strings word1 and word2. A string x is called valid if x can be rearranged to have word2 as a prefix. Return the total number of valid substrings of word1. Note that the memory limits in this problem are smaller than usual, so you must implement a solution with a linear runtime complexity.]]></summary></entry><entry><title type="html">916. Word Subsets</title><link href="https://zhengstar94.github.io//blog/2025/WordSubsets/" rel="alternate" type="text/html" title="916. Word Subsets"/><published>2025-01-10T00:00:00+00:00</published><updated>2025-01-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/WordSubsets</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/WordSubsets/"><![CDATA[<ul> <li>You are given two string arrays <code class="language-plaintext highlighter-rouge">words1</code> and <code class="language-plaintext highlighter-rouge">words2</code>.</li> <li>A string <code class="language-plaintext highlighter-rouge">b</code> is a <strong>subset</strong> of string <code class="language-plaintext highlighter-rouge">a</code> if every letter in <code class="language-plaintext highlighter-rouge">b</code> occurs in <code class="language-plaintext highlighter-rouge">a</code> including multiplicity. <ul> <li>For example, <code class="language-plaintext highlighter-rouge">"wrr"</code> is a subset of <code class="language-plaintext highlighter-rouge">"warrior"</code> but is not a subset of <code class="language-plaintext highlighter-rouge">"world"</code>.</li> </ul> </li> <li>A string <code class="language-plaintext highlighter-rouge">a</code> from <code class="language-plaintext highlighter-rouge">words1</code> is <strong>universal</strong> if for every string <code class="language-plaintext highlighter-rouge">b</code> in <code class="language-plaintext highlighter-rouge">words2</code>, <code class="language-plaintext highlighter-rouge">b</code> is a subset of <code class="language-plaintext highlighter-rouge">a</code>.</li> <li>Return an array of all the <strong>universal</strong> strings in <code class="language-plaintext highlighter-rouge">words1</code>. You may return the answer in <strong>any order</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words1 = ["amazon","apple","facebook","google","leetcode"], words2 = ["e","o"]
Output: ["facebook","google","leetcode"]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words1 = ["amazon","apple","facebook","google","leetcode"], words2 = ["l","e"]
Output: ["apple","google","leetcode"]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * k1 + m * k2) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordSubsets</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">wordSubsets</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words1</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">words2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the maximum frequency required for each character (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">maxFreq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// First key loop: Process all strings in words2</span>
        <span class="c1">// Purpose: Find the maximum frequency required for each character across all strings in words2</span>
        <span class="c1">// For example, if words2 = ["wrr", "er"], we need max frequency of 'r' which is 2 (from "wrr")</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">word:</span> <span class="n">words2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Get frequency count of characters in current word</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">getFrequency</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>

            <span class="c1">// Update the maximum frequency required for each character</span>
            <span class="c1">// This creates a "combined frequency requirement" from all words2 strings</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">maxFreq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxFreq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">freq</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// List to store all universal strings found in words1</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Second key loop: Check each string in words1</span>
        <span class="c1">// Purpose: Determine which strings in words1 satisfy all character frequency requirements</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">words1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Get character frequency count of current word</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">getFrequency</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
            <span class="c1">// Initially assume this word is universal</span>
            <span class="kt">boolean</span> <span class="n">isUniversal</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

            <span class="c1">// Compare character frequencies</span>
            <span class="c1">// Check if current word has enough of each required character</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If current word doesn't have enough of any required character</span>
                <span class="c1">// For example: if we need 2 'r's but word only has 1 'r'</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">freq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">maxFreq</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">isUniversal</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>  <span class="c1">// Mark as non-universal</span>
                    <span class="k">break</span><span class="o">;</span>  <span class="c1">// No need to check further characters</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// If word satisfied all character frequency requirements, add it to result</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isUniversal</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getFrequency</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">freq</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">freq</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Finding words containing both 'e' and 'o'</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words1Test1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"amazon"</span><span class="o">,</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"facebook"</span><span class="o">,</span> <span class="s">"google"</span><span class="o">,</span> <span class="s">"leetcode"</span><span class="o">};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words2Test1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"e"</span><span class="o">,</span> <span class="s">"o"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">wordSubsets</span><span class="o">(</span><span class="n">words1Test1</span><span class="o">,</span> <span class="n">words2Test1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Finding words containing both 'l' and 'e'</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words1Test2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"amazon"</span><span class="o">,</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"facebook"</span><span class="o">,</span> <span class="s">"google"</span><span class="o">,</span> <span class="s">"leetcode"</span><span class="o">};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words2Test2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"l"</span><span class="o">,</span> <span class="s">"e"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">wordSubsets</span><span class="o">(</span><span class="n">words1Test2</span><span class="o">,</span> <span class="n">words2Test2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given two string arrays words1 and words2. A string b is a subset of string a if every letter in b occurs in a including multiplicity. For example, "wrr" is a subset of "warrior" but is not a subset of "world". A string a from words1 is universal if for every string b in words2, b is a subset of a. Return an array of all the universal strings in words1. You may return the answer in any order.]]></summary></entry></feed>