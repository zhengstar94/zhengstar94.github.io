<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-06T05:55:19+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1865. Finding Pairs With a Certain Sum</title><link href="https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum/" rel="alternate" type="text/html" title="1865. Finding Pairs With a Certain Sum"/><published>2025-07-06T00:00:00+00:00</published><updated>2025-07-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum/"><![CDATA[<ul> <li>You are given two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>. You are tasked to implement a data structure that supports queries of two types: <ul> <li><strong>Add</strong> a positive integer to an element of a given index in the array <code class="language-plaintext highlighter-rouge">nums2</code>.</li> <li><strong>Count</strong> the number of pairs <code class="language-plaintext highlighter-rouge">(i, j)</code> such that <code class="language-plaintext highlighter-rouge">nums1[i] + nums2[j]</code> equals a given value (<code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; nums1.length</code> and <code class="language-plaintext highlighter-rouge">0 &lt;= j &lt; nums2.length</code>).</li> </ul> </li> <li>Implement the <code class="language-plaintext highlighter-rouge">FindSumPairs</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">FindSumPairs(int[] nums1, int[] nums2)</code> Initializes the <code class="language-plaintext highlighter-rouge">FindSumPairs</code> object with two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>.</li> <li><code class="language-plaintext highlighter-rouge">void add(int index, int val)</code> Adds <code class="language-plaintext highlighter-rouge">val</code> to <code class="language-plaintext highlighter-rouge">nums2[index]</code>, i.e., apply <code class="language-plaintext highlighter-rouge">nums2[index] += val</code>.</li> <li><code class="language-plaintext highlighter-rouge">int count(int tot)</code> Returns the number of pairs <code class="language-plaintext highlighter-rouge">(i, j)</code> such that <code class="language-plaintext highlighter-rouge">nums1[i] + nums2[j] == tot</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
[ [ [ 1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4 ] ], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7 ] ]
Output
[null, 8, null, 2, 1, null, null, 11]

Explanation
FindSumPairs findSumPairs = new FindSumPairs( [ 1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4 ] );
findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4
findSumPairs.add(3, 2); // now nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5
findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1
findSumPairs.add(0, 1); // now nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // now nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m) time | O(m + q) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindingPairsWithACertainSum</span> <span class="o">{</span>
    <span class="c1">// Store the first array as is, since it is not modified after initialization</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">;</span>
    <span class="c1">// Store the second array, which can be modified by add operations</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">;</span>
    <span class="c1">// HashMap to record the frequency of each number in nums2</span>
    <span class="c1">// Key: number in nums2, Value: how many times it appears in nums2</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">FindingPairsWithACertainSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums1</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">;</span>
        <span class="c1">// Build the frequency map for nums2</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each number x in nums2, increment its count in the map by 1.</span>
            <span class="c1">// If x is not present, it will be added with value 1.</span>
            <span class="c1">// If x is already present, its value will be increased by 1.</span>
            <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Decrease the count of the old value at nums2[index] in the frequency map.</span>
        <span class="c1">// This is because the value at this index is about to change.</span>
        <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">index</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>

        <span class="c1">// Step 2: Update nums2[index] by adding val to it.</span>
        <span class="n">nums2</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>

        <span class="c1">// Step 3: Increase the count of the new value at nums2[index] in the frequency map.</span>
        <span class="c1">// This ensures the map is always up-to-date with the current nums2.</span>
        <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">index</span><span class="o">],</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">tot</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// For each element x in nums1, we want to find how many y in nums2 satisfy x + y == tot,</span>
        <span class="c1">// which is equivalent to y == tot - x.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// cnt.getOrDefault(tot - x, 0) gives the number of times (tot - x) appears in nums2.</span>
            <span class="c1">// Add this count to the answer.</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">tot</span> <span class="o">-</span> <span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Initialize the object with the given nums1 and nums2 arrays.</span>
        <span class="nc">FindingPairsWithACertainSum</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FindingPairsWithACertainSum</span><span class="o">(</span>
                <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">}</span>
        <span class="o">);</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// Constructor does not return a value.</span>

        <span class="c1">// Perform count and add operations as per the example.</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">7</span><span class="o">));</span> <span class="c1">// Returns 8</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// No return value</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">8</span><span class="o">));</span> <span class="c1">// Returns 2</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span> <span class="c1">// Returns 1</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// No return value</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// No return value</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">7</span><span class="o">));</span> <span class="c1">// Returns 11</span>

        <span class="c1">// Print the output list, which matches the expected output format.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types: Add a positive integer to an element of a given index in the array nums2. Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 &lt;= i &lt; nums1.length and 0 &lt;= j &lt; nums2.length). Implement the FindSumPairs class: FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2. void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val. int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums2[j] == tot.]]></summary></entry><entry><title type="html">1394. Find Lucky Integer in an Array</title><link href="https://zhengstar94.github.io//blog/2025/FindLuckyIntegerInAnArray/" rel="alternate" type="text/html" title="1394. Find Lucky Integer in an Array"/><published>2025-07-05T00:00:00+00:00</published><updated>2025-07-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindLuckyIntegerInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindLuckyIntegerInAnArray/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">arr</code>, a <strong>lucky integer</strong> is an integer that has a frequency in the array equal to its value.</li> <li>Return <em>the largest <strong>lucky integer</strong> in the array</em>. If there is no <strong>lucky integer</strong> return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindLuckyIntegerInAnArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findLucky</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to store the frequency of each integer in the array</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Iterate through the array and count the occurrences of each number</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If num is already in the map, increment its count by 1; otherwise, set it to 1</span>
            <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">freq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Initialize the result variable to -1 (default if no lucky integer is found)</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Iterate through all entries in the frequency map</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>    <span class="c1">// The integer value</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span> <span class="c1">// The frequency of this integer</span>
            <span class="c1">// Check if the integer is a lucky integer (its value equals its frequency)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update the result if this lucky integer is larger than the current result</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the largest lucky integer found, or -1 if none exists</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span> <span class="c1">// Output: -1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr4</span><span class="o">));</span> <span class="c1">// Output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value. Return the largest lucky integer in the array. If there is no lucky integer return -1.]]></summary></entry><entry><title type="html">1091. Shortest Path in Binary Matrix</title><link href="https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix/" rel="alternate" type="text/html" title="1091. Shortest Path in Binary Matrix"/><published>2025-07-04T00:00:00+00:00</published><updated>2025-07-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix/"><![CDATA[<ul> <li>Given an <code class="language-plaintext highlighter-rouge">n x n</code> binary matrix <code class="language-plaintext highlighter-rouge">grid</code>, return <em>the length of the shortest <strong>clear path</strong> in the matrix</em>. If there is no clear path, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> <li>A <strong>clear path</strong> in a binary matrix is a path from the <strong>top-left</strong> cell (i.e., <code class="language-plaintext highlighter-rouge">(0, 0)</code>) to the <strong>bottom-right</strong> cell (i.e., <code class="language-plaintext highlighter-rouge">(n - 1, n - 1)</code>) such that: <ul> <li>All the visited cells of the path are <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>All the adjacent cells of the path are <strong>8-directionally</strong> connected (i.e., they are different and they share an edge or a corner).</li> </ul> </li> <li>The <strong>length of a clear path</strong> is the number of visited cells of this path.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,1],[1,0 ] ]
Output: 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,0,0],[1,1,0],[1,1,0 ] ]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,0,0],[1,1,0],[1,1,0 ] ]
Output: -1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n²) time | O(n²) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BFS</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestPathInBinaryMatrix</span> <span class="o">{</span>
    <span class="c1">// Define the 8 possible directions for movement (up, down, left, right, and 4 diagonals)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">DIRS</span> <span class="o">=</span> <span class="o">{</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>   <span class="c1">// down</span>
            <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>  <span class="c1">// up</span>
            <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>   <span class="c1">// right</span>
            <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>  <span class="c1">// left</span>
            <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>  <span class="c1">// up-right</span>
            <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span> <span class="c1">// up-left</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>   <span class="c1">// down-right</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}</span>   <span class="c1">// down-left</span>
    <span class="o">};</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">shortestPathBinaryMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Special case: if the start or end cell is blocked, there is no valid path</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">grid</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Initialize the BFS queue. Each element is an array: [x, y, pathLength]</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Start from the top-left cell (0,0) with a path length of 1</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span>
        <span class="c1">// Mark the starting cell as visited by setting it to 1</span>
        <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Begin BFS traversal</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Remove the front element from the queue for processing</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">len</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="c1">// If we've reached the bottom-right cell, return the current path length</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">len</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Explore all 8 possible directions from the current cell</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">dir</span> <span class="o">:</span> <span class="no">DIRS</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                <span class="c1">// Check if the new cell is within bounds and is open (not blocked or visited)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">nx</span><span class="o">][</span><span class="n">ny</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Add the new cell to the queue with an incremented path length</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nx</span><span class="o">,</span> <span class="n">ny</span><span class="o">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span>
                    <span class="c1">// Mark the new cell as visited to prevent revisiting</span>
                    <span class="n">grid</span><span class="o">[</span><span class="n">nx</span><span class="o">][</span><span class="n">ny</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// If the queue is empty and we haven't reached the end, there is no valid path</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">shortestPathBinaryMatrix</span><span class="o">(</span><span class="n">copyGrid</span><span class="o">(</span><span class="n">grid1</span><span class="o">)));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">shortestPathBinaryMatrix</span><span class="o">(</span><span class="n">copyGrid</span><span class="o">(</span><span class="n">grid2</span><span class="o">)));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">shortestPathBinaryMatrix</span><span class="o">(</span><span class="n">copyGrid</span><span class="o">(</span><span class="n">grid3</span><span class="o">)));</span> <span class="c1">// Output: -1</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">copyGrid</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">copy</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BFS"/><category term="Medium"/><summary type="html"><![CDATA[Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path.]]></summary></entry><entry><title type="html">3304. Find the K-th Character in String Game I</title><link href="https://zhengstar94.github.io//blog/2025/FindTheKthCharacterInStringGameI/" rel="alternate" type="text/html" title="3304. Find the K-th Character in String Game I"/><published>2025-07-03T00:00:00+00:00</published><updated>2025-07-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheKthCharacterInStringGameI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheKthCharacterInStringGameI/"><![CDATA[<ul> <li>Alice and Bob are playing a game. Initially, Alice has a string <code class="language-plaintext highlighter-rouge">word = "a"</code>.</li> <li>You are given a <strong>positive</strong> integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Now Bob will ask Alice to perform the following operation <strong>forever</strong>: <ul> <li>Generate a new string by <strong>changing</strong> each character in <code class="language-plaintext highlighter-rouge">word</code> to its <strong>next</strong> character in the English alphabet, and <strong>append</strong> it to the <em>original</em> <code class="language-plaintext highlighter-rouge">word</code>.</li> </ul> </li> <li>For example, performing the operation on <code class="language-plaintext highlighter-rouge">"c"</code> generates <code class="language-plaintext highlighter-rouge">"cd"</code> and performing the operation on <code class="language-plaintext highlighter-rouge">"zb"</code> generates <code class="language-plaintext highlighter-rouge">"zbac"</code>.</li> <li>Return the value of the <code class="language-plaintext highlighter-rouge">kth</code> character in <code class="language-plaintext highlighter-rouge">word</code>, after enough operations have been done for <code class="language-plaintext highlighter-rouge">word</code> to have <strong>at least</strong> <code class="language-plaintext highlighter-rouge">k</code> characters.</li> <li><strong>Note</strong> that the character <code class="language-plaintext highlighter-rouge">'z'</code> can be changed to <code class="language-plaintext highlighter-rouge">'a'</code> in the operation.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: k = 5

Output: "b"

Explanation:

Initially, word = "a". We need to do the operation three times:

Generated string is "b", word becomes "ab".
Generated string is "bc", word becomes "abbc".
Generated string is "bccd", word becomes "abbcbccd".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: k = 10

Output: "c"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log k) time | O(log k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheKthCharacterInStringGameI</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">char</span> <span class="nf">kthCharacter</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Start the recursive search with offset 0 (no character has been shifted yet)</span>
        <span class="k">return</span> <span class="nf">helper</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">char</span> <span class="nf">helper</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: if k == 1, we are at the very first character of the current segment.</span>
        <span class="c1">// The character is 'a' shifted by 'offset' positions in the alphabet (with wrap-around).</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="sc">'a'</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">%</span> <span class="mi">26</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Find the largest power of 2 (len) such that len * 2 &lt; k.</span>
        <span class="c1">// This represents the length of the previous string before the current operation doubled it.</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">len</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If k is within the first half (&lt;= len), it means the character is from the previous string segment,</span>
        <span class="c1">// and has not been shifted in this operation. So, we recurse with the same offset.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">helper</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">offset</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// If k is in the second half (&gt; len), it corresponds to a character from the first half,</span>
            <span class="c1">// but shifted by one (i.e., "next letter" operation). So, we recurse for (k - len) and increment offset.</span>
            <span class="k">return</span> <span class="nf">helper</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">len</span><span class="o">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">kthCharacter</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span>   <span class="c1">// Output: b</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">kthCharacter</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>  <span class="c1">// Output: c</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[Alice and Bob are playing a game. Initially, Alice has a string word="a". You are given a positive integer k. Now Bob will ask Alice to perform the following operation forever: Generate a new string by changing each character in word to its next character in the English alphabet, and append it to the original word. For example, performing the operation on "c" generates "cd" and performing the operation on "zb" generates "zbac". Return the value of the kth character in word, after enough operations have been done for word to have at least k characters. Note that the character 'z' can be changed to 'a' in the operation.]]></summary></entry><entry><title type="html">Algorithm of Rate Limiter</title><link href="https://zhengstar94.github.io//blog/2025/AlgorithmOfRateLimiter/" rel="alternate" type="text/html" title="Algorithm of Rate Limiter"/><published>2025-07-01T00:00:00+00:00</published><updated>2025-07-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AlgorithmOfRateLimiter</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AlgorithmOfRateLimiter/"><![CDATA[<h2 id="introduction-to-rate-limiting">Introduction to Rate Limiting</h2> <p>Rate limiting is a mechanism to control the rate of incoming requests to a system, preventing overload and ensuring stability. It acts as a traffic regulator for servers, with the primary objectives of:</p> <ul> <li><strong>System Protection</strong>: Mitigating the impact of traffic spikes, such as during e-commerce flash sales.</li> <li><strong>Abuse Prevention</strong>: Blocking malicious requests, such as crawlers or denial-of-service attacks.</li> <li><strong>Cost Management</strong>: Regulating usage of pay-per-request resources, such as cloud APIs.</li> </ul> <p>This document details five prevalent rate-limiting algorithms, providing accessible explanations, technical analyses of advantages and disadvantages, applicable scenarios, Java implementations with comprehensive comments, and Mermaid diagrams to aid understanding.</p> <h2 id="overview-of-rate-limiting-algorithms">Overview of Rate-Limiting Algorithms</h2> <p>The following table compares five rate-limiting algorithms based on their advantages, disadvantages, use cases, and computational complexity:</p> <table> <thead> <tr> <th>Algorithm</th> <th>Advantages</th> <th>Disadvantages</th> <th>Use Cases</th> <th>Complexity</th> </tr> </thead> <tbody> <tr> <td>Token Bucket</td> <td>✅ Simple Implementation <br/>✅ Supports Bursty Traffic</td> <td>❌ Complex Parameter Tuning <br/>❌ Risk of Short-Term Overload</td> <td>E-commerce flash sales (e.g., Alibaba Double 11), API requests (e.g., X post limits)</td> <td>O(1) Time <br/>O(1) Space</td> </tr> <tr> <td>Leaky Bucket</td> <td>✅ Stable Output <br/>✅ Memory Efficient</td> <td>❌ No Support for Bursty Traffic <br/>❌ Increased Request Latency</td> <td>E-commerce APIs (e.g., Shopify order requests), stable traffic services</td> <td>O(1) Time <br/>O(n) Space</td> </tr> <tr> <td>Fixed Window Counter</td> <td>✅ Simple Implementation <br/>✅ Memory Efficient</td> <td>❌ Window Boundary Overload</td> <td>Simple rate limiting (e.g., 5 login attempts per minute), quota reset scenarios</td> <td>O(1) Time <br/>O(1) Space</td> </tr> <tr> <td>Sliding Window Log</td> <td>✅ High Precision <br/>✅ No Boundary Issues</td> <td>❌ High Memory Usage <br/>❌ Complex Implementation</td> <td>Financial transactions (e.g., stock trading), ad bidding, high-frequency trading</td> <td>O(n) Time <br/>O(n) Space</td> </tr> <tr> <td>Sliding Window Counter</td> <td>✅ Memory Efficient <br/>✅ Smooths Traffic Peaks</td> <td>❌ Limited Precision</td> <td>E-commerce promotions (e.g., JD 618), social media surges (e.g., TikTok trending events)</td> <td>O(1) Time <br/>O(n) Space</td> </tr> </tbody> </table> <blockquote> <p><strong>Note</strong>: Complexity <code class="language-plaintext highlighter-rouge">n</code> refers to the number of requests or timestamps.</p> </blockquote> <h2 id="detailed-analysis-and-java-implementations">Detailed Analysis and Java Implementations</h2> <h3 id="1-token-bucket">1. Token Bucket</h3> <p><strong>Accessible Explanation</strong>:<br/> The token bucket is akin to a ticket dispenser that issues tickets (tokens) at a fixed rate. Each request requires a token to proceed; if none are available, the request is denied. Tokens can accumulate in the bucket, enabling the system to handle bursts of requests, much like a theater allowing a surge of ticketed patrons during a premiere.</p> <p><strong>Principle</strong>: The bucket replenishes tokens at a constant rate. Requests consume tokens, and if insufficient tokens are available, requests are rejected. This supports bursty traffic.</p> <p><strong>Mermaid Diagram</strong>:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/07/1-480.webp 480w,/assets/img/2025/07/1-800.webp 800w,/assets/img/2025/07/1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/07/1.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Advantages</strong>:</p> <ul> <li><strong>Simple Implementation</strong>: Straightforward logic and coding, addressing the challenge of complex rate-limiting designs.</li> <li><strong>Supports Bursty Traffic</strong>: Accumulated tokens allow handling short-term traffic spikes, ideal for scenarios like flash sales.</li> </ul> <p><strong>Disadvantages</strong>:</p> <ul> <li><strong>Complex Parameter Tuning</strong>: The token generation rate and bucket capacity require precise adjustment based on traffic patterns. Incorrect settings may lead to excessive request denials (if the rate is too low) or system overload (if capacity is too high). For example, an improperly tuned bucket in a flash sale may reject legitimate users or overwhelm servers.</li> <li><strong>Risk of Short-Term Overload</strong>: A burst consuming all tokens may allow subsequent requests to pass briefly, causing momentary traffic spikes beyond the intended rate. For instance, a target of 100 requests/sec might see 120 requests in a second during a burst.</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li><strong>E-commerce Flash Sales</strong>: Limiting 1000 purchase requests per second during Alibaba’s Double 11.</li> <li><strong>API Requests</strong>: Restricting 100 post submissions per minute on X.</li> <li><strong>AI APIs</strong>: Capping 10 model invocations per second for OpenAI.</li> </ul> <p><strong>Java Implementation</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TokenBucket</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">capacity</span><span class="o">;</span> <span class="c1">// Maximum number of tokens the bucket can hold</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">rate</span><span class="o">;</span> <span class="c1">// Token generation rate (tokens per second)</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">tokens</span><span class="o">;</span> <span class="c1">// Current number of available tokens</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lastRefillTimestamp</span><span class="o">;</span> <span class="c1">// Timestamp of last token refill</span>

    <span class="c1">// Initialize bucket with capacity and rate, starting with full tokens</span>
    <span class="kd">public</span> <span class="nf">TokenBucket</span><span class="o">(</span><span class="kt">long</span> <span class="n">capacity</span><span class="o">,</span> <span class="kt">double</span> <span class="n">rate</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rate</span> <span class="o">=</span> <span class="n">rate</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tokens</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lastRefillTimestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Check if request is allowed, thread-safe</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">allowRequest</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">refill</span><span class="o">();</span> <span class="c1">// Replenish tokens based on elapsed time</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tokens</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Sufficient tokens available</span>
            <span class="n">tokens</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Consume one token</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// Allow request</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// No tokens, deny request</span>
    <span class="o">}</span>

    <span class="c1">// Replenish tokens based on elapsed time</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">refill</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="kt">double</span> <span class="n">elapsedSeconds</span> <span class="o">=</span> <span class="o">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">lastRefillTimestamp</span><span class="o">)</span> <span class="o">/</span> <span class="mi">1</span><span class="n">e9</span><span class="o">;</span> <span class="c1">// Time elapsed in seconds</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">capacity</span><span class="o">,</span> <span class="n">tokens</span> <span class="o">+</span> <span class="n">elapsedSeconds</span> <span class="o">*</span> <span class="n">rate</span><span class="o">);</span> <span class="c1">// Add tokens, capped at capacity</span>
        <span class="n">lastRefillTimestamp</span> <span class="o">=</span> <span class="n">now</span><span class="o">;</span> <span class="c1">// Update refill timestamp</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Usage Example</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TokenBucket</span> <span class="n">bucket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TokenBucket</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">// Capacity 100, 10 tokens/sec</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">150</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bucket</span><span class="o">.</span><span class="na">allowRequest</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" allowed"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" rejected"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Parameter Tuning</strong>:</p> <ul> <li><strong>Rate</strong>: Set to the average request rate (e.g., 10 requests/sec).</li> <li><strong>Capacity</strong>: Set to the maximum burst size (e.g., 100 requests).</li> </ul> <h3 id="2-leaky-bucket">2. Leaky Bucket</h3> <p><strong>Accessible Explanation</strong>:<br/> The leaky bucket resembles a container with a fixed-size hole at the bottom. Requests flow into the bucket like water, but they can only exit (be processed) at a constant rate through the hole. If requests arrive too quickly, the bucket fills, and new requests are discarded, ensuring a steady processing rate.</p> <p><strong>Principle</strong>: Requests enter the bucket and are processed at a fixed rate. If the bucket is full, new requests are rejected. This is ideal for stable traffic scenarios.</p> <p><strong>Mermaid Diagram</strong>:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/07/2-480.webp 480w,/assets/img/2025/07/2-800.webp 800w,/assets/img/2025/07/2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/07/2.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Advantages</strong>:</p> <ul> <li><strong>Stable Output</strong>: Processes requests at a consistent rate, protecting downstream systems from traffic surges.</li> <li><strong>Memory Efficient</strong>: Requires only a queue to store requests, minimizing memory usage.</li> </ul> <p><strong>Disadvantages</strong>:</p> <ul> <li><strong>No Support for Bursty Traffic</strong>: The fixed outflow rate cannot accommodate sudden traffic spikes, leading to request rejections. For example, during a flash sale, high-concurrency requests may be denied, degrading user experience.</li> <li><strong>Increased Request Latency</strong>: Sustained high request rates cause requests to queue in the bucket, increasing processing delays. For instance, API requests may experience response times escalating from seconds to minutes due to queuing.</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li><strong>E-commerce APIs</strong>: Limiting 50 order requests per second for Shopify.</li> <li><strong>Message Queues</strong>: Ensuring consistent message processing rates.</li> </ul> <p><strong>Java Implementation</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeakyBucket</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">capacity</span><span class="o">;</span> <span class="c1">// Maximum number of requests the bucket can hold</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">rate</span><span class="o">;</span> <span class="c1">// Outflow rate (requests processed per second)</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span> <span class="c1">// Stores request arrival timestamps</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lastLeakTimestamp</span><span class="o">;</span> <span class="c1">// Timestamp of last outflow</span>

    <span class="c1">// Initialize bucket with capacity and outflow rate</span>
    <span class="kd">public</span> <span class="nf">LeakyBucket</span><span class="o">(</span><span class="kt">long</span> <span class="n">capacity</span><span class="o">,</span> <span class="kt">double</span> <span class="n">rate</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rate</span> <span class="o">=</span> <span class="n">rate</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lastLeakTimestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Check if request is allowed, thread-safe</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">allowRequest</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">leak</span><span class="o">();</span> <span class="c1">// Perform outflow to process requests</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Bucket has space</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">());</span> <span class="c1">// Add request</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// Allow request</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Bucket full, deny request</span>
    <span class="o">}</span>

    <span class="c1">// Process outflow based on elapsed time</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">leak</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="kt">double</span> <span class="n">elapsedSeconds</span> <span class="o">=</span> <span class="o">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">lastLeakTimestamp</span><span class="o">)</span> <span class="o">/</span> <span class="mi">1</span><span class="n">e9</span><span class="o">;</span> <span class="c1">// Time elapsed in seconds</span>
        <span class="kt">int</span> <span class="n">leaked</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">elapsedSeconds</span> <span class="o">*</span> <span class="n">rate</span><span class="o">);</span> <span class="c1">// Number of requests that can outflow</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">leaked</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// Remove processed requests</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">leaked</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="n">lastLeakTimestamp</span> <span class="o">=</span> <span class="n">now</span><span class="o">;</span> <span class="c1">// Update outflow timestamp</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Usage Example</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LeakyBucket</span> <span class="n">bucket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LeakyBucket</span><span class="o">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="c1">// Capacity 50, 5 requests/sec</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bucket</span><span class="o">.</span><span class="na">allowRequest</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" allowed"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" rejected"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Parameter Tuning</strong>:</p> <ul> <li><strong>Rate</strong>: Match the downstream processing capability (e.g., 5 requests/sec).</li> <li><strong>Capacity</strong>: Set based on acceptable latency (e.g., 50 requests).</li> </ul> <h3 id="3-fixed-window-counter">3. Fixed Window Counter</h3> <p><strong>Accessible Explanation</strong>:<br/> The fixed window counter is like a venue with a limited number of entry passes per hour. Once the passes are exhausted, new entrants must wait for the next hour. Its simplicity is effective, but pass distribution can cluster at window boundaries, causing short-term overloads.</p> <p><strong>Principle</strong>: Counts requests within a fixed time window, rejecting those exceeding the quota. The counter resets at the end of each window.</p> <p><strong>Mermaid Diagram</strong>:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/07/3-480.webp 480w,/assets/img/2025/07/3-800.webp 800w,/assets/img/2025/07/3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/07/3.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Advantages</strong>:</p> <ul> <li><strong>Simple Implementation</strong>: Requires only counting and comparison, enabling rapid development for basic rate limiting.</li> <li><strong>Memory Efficient</strong>: Stores a single counter, minimizing memory requirements.</li> </ul> <p><strong>Disadvantages</strong>:</p> <ul> <li><strong>Window Boundary Overload</strong>: At window transitions (e.g., 59s to 61s), requests may cluster, doubling the intended rate momentarily. For example, a limit of 100 requests per minute could see 99 requests at 59s and 99 at 61s, resulting in 198 requests in 2 seconds, overwhelming the system.</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li><strong>Login Restrictions</strong>: Limiting 5 login attempts per minute.</li> <li><strong>Simple APIs</strong>: Restricting 1000 calls per hour for small-scale services.</li> </ul> <p><strong>Java Implementation</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FixedWindowCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">windowSize</span><span class="o">;</span> <span class="c1">// Window size in milliseconds</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">;</span> <span class="c1">// Maximum requests allowed in window</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">windowStart</span><span class="o">;</span> <span class="c1">// Start time of current window</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">count</span><span class="o">;</span> <span class="c1">// Current request count in window</span>

    <span class="c1">// Initialize window with size and limit</span>
    <span class="kd">public</span> <span class="nf">FixedWindowCounter</span><span class="o">(</span><span class="kt">long</span> <span class="n">windowSizeSeconds</span><span class="o">,</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">windowSize</span> <span class="o">=</span> <span class="n">windowSizeSeconds</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">windowStart</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Check if request is allowed, thread-safe</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">allowRequest</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">now</span> <span class="o">&gt;</span> <span class="n">windowStart</span> <span class="o">+</span> <span class="n">windowSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Window has expired</span>
            <span class="n">windowStart</span> <span class="o">=</span> <span class="n">now</span><span class="o">;</span> <span class="c1">// Reset window</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Reset counter</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Within limit</span>
            <span class="n">count</span><span class="o">++;</span> <span class="c1">// Increment counter</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// Allow request</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Exceeds limit, deny request</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Usage Example</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FixedWindowCounter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FixedWindowCounter</span><span class="o">(</span><span class="mi">60</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="c1">// 60 seconds, 5 requests</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="na">allowRequest</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" allowed"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" rejected"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Parameter Tuning</strong>:</p> <ul> <li><strong>Window Size</strong>: Smaller windows (e.g., 10 seconds) reduce boundary issues.</li> <li><strong>Limit</strong>: Set based on business requirements (e.g., 5 requests/minute).</li> </ul> <h3 id="4-sliding-window-log">4. Sliding Window Log</h3> <p><strong>Accessible Explanation</strong>:<br/> The sliding window log is like a meticulous registrar, recording the exact timestamp of each request. When a new request arrives, it checks the number of requests within the recent time window, denying those exceeding the limit. Its precision is unparalleled, but it demands significant record-keeping.</p> <p><strong>Principle</strong>: Records timestamps of requests and checks the count within a sliding time window, offering high precision.</p> <p><strong>Mermaid Diagram</strong>:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/07/4-480.webp 480w,/assets/img/2025/07/4-800.webp 800w,/assets/img/2025/07/4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/07/4.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Advantages</strong>:</p> <ul> <li><strong>High Precision</strong>: Tracks exact request times, ideal for strict rate-limiting scenarios like financial transactions.</li> <li><strong>No Boundary Issues</strong>: Smooth sliding window avoids fixed window boundary overloads.</li> </ul> <p><strong>Disadvantages</strong>:</p> <ul> <li><strong>High Memory Usage</strong>: Each request’s timestamp is stored, leading to substantial memory consumption in high-concurrency scenarios. For example, 1000 requests per second in a 1-second window require storing 1000 timestamps.</li> <li><strong>Complex Implementation</strong>: Managing a timestamp queue and removing expired entries increases code complexity and performance overhead. For instance, frequent cleanup in high-traffic scenarios may degrade system performance.</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li><strong>Financial Transactions</strong>: Limiting 1000 trading requests per second in stock exchanges.</li> <li><strong>Ad Bidding</strong>: Restricting 500 bids per second in real-time bidding platforms.</li> <li><strong>Web3</strong>: Controlling blockchain transaction rates.</li> </ul> <p><strong>Java Implementation</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SlidingWindowLog</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">windowSize</span><span class="o">;</span> <span class="c1">// Window size in milliseconds</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">;</span> <span class="c1">// Maximum requests allowed in window</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">requests</span><span class="o">;</span> <span class="c1">// Stores request timestamps</span>

    <span class="c1">// Initialize window with size and limit</span>
    <span class="kd">public</span> <span class="nf">SlidingWindowLog</span><span class="o">(</span><span class="kt">long</span> <span class="n">windowSizeSeconds</span><span class="o">,</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">windowSize</span> <span class="o">=</span> <span class="n">windowSizeSeconds</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">requests</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="c1">// Check if request is allowed, thread-safe</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">allowRequest</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="c1">// Remove timestamps outside the window</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">requests</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">now</span> <span class="o">-</span> <span class="n">requests</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">windowSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">requests</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">requests</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Within limit</span>
            <span class="n">requests</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">now</span><span class="o">);</span> <span class="c1">// Record current request timestamp</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// Allow request</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Exceeds limit, deny request</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Usage Example</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SlidingWindowLog</span> <span class="n">log</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SlidingWindowLog</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">// 1 second, 10 requests</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">log</span><span class="o">.</span><span class="na">allowRequest</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" allowed"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" rejected"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Parameter Tuning</strong>:</p> <ul> <li><strong>Window Size</strong>: Set based on precision needs (e.g., 1 second).</li> <li><strong>Limit</strong>: Set based on peak traffic (e.g., 1000 requests).</li> </ul> <h3 id="5-sliding-window-counter">5. Sliding Window Counter</h3> <p><strong>Accessible Explanation</strong>:<br/> The sliding window counter is like a theme park queue manager tasked with limiting a roller coaster to 10 riders per minute. Instead of recording each rider’s exact arrival time, the manager divides time into 10-second sub-windows (6 sub-windows covering 60 seconds) and tracks the number of riders in each. When a new rider arrives, the manager estimates the total number of riders in the past 60 seconds by weighting each sub-window’s count based on how much of it remains in the time window: older sub-windows contribute less (“discounted”), while newer ones contribute fully. If the estimated total is below 10, the rider is allowed to join the queue, and the current sub-window’s count is updated; otherwise, they are denied. This approach is memory-efficient and smooths traffic peaks but may introduce slight inaccuracies due to estimation.</p> <p><strong>Principle</strong>: Divides the time window (e.g., 60 seconds) into smaller sub-windows (e.g., 10 seconds each) and records request counts per sub-window. For a new request, it calculates the total requests in the sliding window using weighted estimation (based on the sub-window’s remaining time proportion). If the total is below the limit, the request is allowed, and the current sub-window’s count is incremented; otherwise, it is rejected. The weighting mechanism simulates a sliding window, avoiding the boundary issues of fixed windows.</p> <p><strong>Mermaid Diagram</strong>:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/07/5-480.webp 480w,/assets/img/2025/07/5-800.webp 800w,/assets/img/2025/07/5-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/07/5.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Advantages</strong>:</p> <ul> <li> <p><strong>Memory Efficient</strong>: Stores only sub-window counts (e.g., 6 sub-windows), reducing memory usage compared to timestamp storage.</p> </li> <li> <p><strong>Smooths Traffic Peaks</strong>: Weighted estimation mitigates the boundary overload issues of fixed window counters.</p> </li> </ul> <p><strong>Disadvantages</strong>:</p> <ul> <li><strong>Limited Precision</strong>: Weighted estimation may introduce inaccuracies, leading to less strict rate limiting. For example, requests at sub-window boundaries may be partially counted, causing the actual traffic to slightly exceed or fall below the intended limit, impacting high-precision scenarios.</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li> <p><strong>E-commerce Promotions</strong>: Limiting 2000 requests per second during JD 618 sales.</p> </li> <li> <p><strong>Social Media Surges</strong>: Restricting video uploads during TikTok trending events.</p> </li> </ul> <p><strong>Example: Roller Coaster Queue Limiting</strong><br/> Consider the current time as <strong>12:01:01.000</strong> (61 seconds into the event), with a 60-second window (12:00:01.000 to 12:01:01.000), limiting to 10 riders per minute, and sub-windows of 10 seconds (6 sub-windows). A new rider (Rider 10) arrives, and the manager decides whether to allow them to queue.<br/> <strong>Historical Records</strong>:</p> <ul> <li> <p>12:00:10.000-12:00:20.000: 2 riders.</p> </li> <li> <p>12:00:20.000-12:00:30.000: 1 rider.</p> </li> <li> <p>12:00:30.000-12:00:40.000: 2 riders.</p> </li> <li> <p>12:00:40.000-12:00:50.000: 1 rider.</p> </li> <li> <p>12:00:50.000-12:01:00.000: 0 riders.</p> </li> <li> <p>Current Sub-Window (12:01:00.000-12:01:10.000): 1 rider (initial).</p> </li> </ul> <p><strong>Estimation Process</strong>:<br/> The manager estimates the total riders in the past 60 seconds by weighting each sub-window’s count based on its remaining time proportion in the window:</p> <table> <thead> <tr> <th> </th> <th> </th> <th> </th> <th> </th> <th> </th> </tr> </thead> <tbody> <tr> <td>Sub-Window Time</td> <td>Riders</td> <td>Window Proportion (Weight)</td> <td>Weighted Riders (Riders × Weight)</td> <td>Notes</td> </tr> <tr> <td>12:00:10.000-12:00:20.000</td> <td>2</td> <td>10/60 ≈ 0.167</td> <td>2 × 0.167 ≈ 0.33</td> <td>10 seconds remain in window, small weight, 2 riders contribute 0.33.</td> </tr> <tr> <td>12:00:20.000-12:00:30.000</td> <td>1</td> <td>20/60 ≈ 0.333</td> <td>1 × 0.333 ≈ 0.33</td> <td>20 seconds remain, moderate weight, 1 rider contributes 0.33.</td> </tr> <tr> <td>12:00:30.000-12:00:40.000</td> <td>2</td> <td>30/60 = 0.5</td> <td>2 × 0.5 = 1.0</td> <td>30 seconds remain, half weight, 2 riders contribute 1.0.</td> </tr> <tr> <td>12:00:40.000-12:00:50.000</td> <td>1</td> <td>40/60 ≈ 0.667</td> <td>1 × 0.667 ≈ 0.67</td> <td>40 seconds remain, larger weight, 1 rider contributes 0.67.</td> </tr> <tr> <td>12:00:50.000-12:01:00.000</td> <td>0</td> <td>50/60 ≈ 0.833</td> <td>0 × 0.833 = 0</td> <td>50 seconds remain, no riders, contributes 0.</td> </tr> <tr> <td>Current (12:01:00.000-10.000)</td> <td>1</td> <td>60/60 = 1.0</td> <td>1 × 1.0 = 1.0</td> <td>Fully in window, full weight, 1 rider contributes 1.0.</td> </tr> <tr> <td><strong>Total</strong></td> <td> </td> <td> </td> <td><strong>3.33 ≈ 3 riders</strong></td> <td>Estimated 3 riders &lt; 10, allow Rider 10 to queue.</td> </tr> </tbody> </table> <p><strong>Role of Weights</strong>:<br/> The weight (remaining time proportion) simulates a sliding window: older sub-windows (e.g., 10-20 seconds) contribute less (0.167) as they are nearly out of the window, while newer sub-windows (current) contribute fully (1.0). This smooths traffic peaks, avoiding the abrupt resets of fixed window counters (e.g., 10 riders at 59s + 10 at 61s). The estimation may introduce slight inaccuracies (e.g., 3.33 vs. actual 3.5 riders), suitable for scenarios tolerating minor deviations.</p> <p><strong>Java Implementation</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SlidingWindowCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">windowSize</span><span class="o">;</span> <span class="c1">// Window size in milliseconds</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">;</span> <span class="c1">// Maximum requests allowed in window</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">subWindowSize</span><span class="o">;</span> <span class="c1">// Sub-window size in milliseconds</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">windows</span><span class="o">;</span> <span class="c1">// Sub-window counts (timestamp -&gt; count)</span>

    <span class="c1">// Initialize window with size, limit, and sub-window granularity</span>
    <span class="kd">public</span> <span class="nf">SlidingWindowCounter</span><span class="o">(</span><span class="kt">long</span> <span class="n">windowSizeSeconds</span><span class="o">,</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">,</span> <span class="kt">int</span> <span class="n">granularity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">windowSize</span> <span class="o">=</span> <span class="n">windowSizeSeconds</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subWindowSize</span> <span class="o">=</span> <span class="n">windowSize</span> <span class="o">/</span> <span class="n">granularity</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">windows</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="c1">// Check if request is allowed, thread-safe</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">allowRequest</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="c1">// Align current time to sub-window start</span>
        <span class="kt">long</span> <span class="n">gridNumber</span> <span class="o">=</span> <span class="n">now</span> <span class="o">/</span> <span class="n">subWindowSize</span><span class="o">;</span> <span class="c1">// Sub-window index</span>
        <span class="kt">long</span> <span class="n">currentSubWindow</span> <span class="o">=</span> <span class="n">gridNumber</span> <span class="o">*</span> <span class="n">subWindowSize</span><span class="o">;</span> <span class="c1">// Sub-window start time</span>

        <span class="c1">// Remove expired sub-windows (older than window size)</span>
        <span class="n">windows</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">removeIf</span><span class="o">(</span><span class="n">entry</span> <span class="o">-&gt;</span> <span class="n">now</span> <span class="o">-</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">*</span> <span class="n">subWindowSize</span> <span class="o">&gt;</span> <span class="n">windowSize</span><span class="o">);</span>

        <span class="c1">// Calculate total requests in sliding window (weighted estimation)</span>
        <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">windows</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">subWindowStart</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">*</span> <span class="n">subWindowSize</span><span class="o">;</span> <span class="c1">// Sub-window start time</span>
            <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span> <span class="c1">// Sub-window request count</span>
            <span class="c1">// Calculate weight: proportion of sub-window within the window</span>
            <span class="kt">double</span> <span class="n">weight</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="o">(</span><span class="n">windowSize</span> <span class="o">-</span> <span class="o">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">subWindowStart</span><span class="o">))</span> <span class="o">/</span> <span class="n">windowSize</span><span class="o">);</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">weight</span><span class="o">;</span> <span class="c1">// Weighted count</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">total</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Within limit</span>
            <span class="c1">// Increment current sub-window count</span>
            <span class="n">windows</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">currentSubWindow</span><span class="o">,</span> <span class="mi">1L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// Allow request</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Exceeds limit, deny request</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Usage Example</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SlidingWindowCounter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SlidingWindowCounter</span><span class="o">(</span><span class="mi">60</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span> <span class="c1">// 60 seconds, 10 requests, 6 sub-windows</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="na">allowRequest</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" allowed"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Request "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" rejected"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Parameter Tuning</strong>:</p> <ul> <li> <p><strong>Window Size</strong>: Typically 1–60 seconds, 60 seconds in the example.</p> </li> <li> <p><strong>Granularity</strong>: Smaller granularity (e.g., 6 or 10) improves precision, 6 in the example (10 seconds/sub-window).</p> </li> <li> <p><strong>Limit</strong>: Set based on business needs (e.g., 10 requests/minute).</p> </li> </ul> <h2 id="summary">Summary</h2> <ul> <li><strong>Selection Guide</strong>: <ul> <li><strong>Bursty Traffic</strong>: Token Bucket (handles high concurrency), Sliding Window Counter (smooths peaks).</li> <li><strong>Stable Rates</strong>: Leaky Bucket (ensures consistent output).</li> <li><strong>High Precision</strong>: Sliding Window Log (strict limiting).</li> <li><strong>Simple Scenarios</strong>: Fixed Window Counter (quick implementation).</li> </ul> </li> <li><strong>Key Considerations</strong>: <ul> <li>Token Bucket: Balances burst support with tuning challenges.</li> <li>Leaky Bucket: Prioritizes stability but struggles with bursts and latency.</li> <li>Fixed Window Counter: Efficient but prone to boundary issues.</li> <li>Sliding Window Log: Precise yet resource-intensive, ideal for critical applications.</li> <li>Sliding Window Counter: Efficient with moderate precision, suitable for balanced needs.</li> </ul> </li> <li><strong>Practical Recommendations</strong>: <ul> <li>Use Redis for distributed environments (e.g., Token Bucket, Fixed Window).</li> <li>Test under high concurrency to validate rate-limiting effectiveness.</li> <li>Monitor request rates and adjust parameters dynamically.</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="System Design Other"/><summary type="html"><![CDATA[Introduction to Rate Limiting]]></summary></entry><entry><title type="html">3330. Find the Original Typed String I</title><link href="https://zhengstar94.github.io//blog/2025/FindTheOriginalTypedStringI/" rel="alternate" type="text/html" title="3330. Find the Original Typed String I"/><published>2025-07-01T00:00:00+00:00</published><updated>2025-07-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheOriginalTypedStringI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheOriginalTypedStringI/"><![CDATA[<ul> <li>Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and <strong>may</strong> press a key for too long, resulting in a character being typed <strong>multiple</strong> times.</li> <li>Although Alice tried to focus on her typing, she is aware that she may still have done this <strong>at most</strong> <em>once</em>.</li> <li>You are given a string <code class="language-plaintext highlighter-rouge">word</code>, which represents the <strong>final</strong> output displayed on Alice’s screen.</li> <li>Return the total number of <em>possible</em> original strings that Alice <em>might</em> have intended to type.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "abbcccc"

Output: 5

Explanation:

The possible strings are: "abbcccc", "abbccc", "abbcc", "abbc", and "abcccc".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "abcd"

Output: 1

Explanation:

The only possible string is "abcd".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "aaaa"

Output: 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheOriginalTypedStringI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">possibleStringCount</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the count to 1.</span>
        <span class="c1">// This is because the original string itself (with no long press at all) is always a valid possibility.</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Start from the second character and iterate through the string.</span>
        <span class="c1">// We are looking for all pairs of adjacent, identical characters.</span>
        <span class="c1">// Each such pair represents a possible place where a "long press" could have occurred.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current character is the same as the previous one,</span>
            <span class="c1">// it means there is a sequence of repeated characters.</span>
            <span class="c1">// Each such pair gives us one more possible original string,</span>
            <span class="c1">// because we could "remove" one of these repeated characters (simulating that the long press happened here).</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total count.</span>
        <span class="c1">// This includes:</span>
        <span class="c1">//   - The original string itself (no long press)</span>
        <span class="c1">//   - One for each possible pair of adjacent identical characters (where a long press could have happened)</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">possibleStringCount</span><span class="o">(</span><span class="s">"abbcccc"</span><span class="o">));</span> <span class="c1">// Output: 5</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">possibleStringCount</span><span class="o">(</span><span class="s">"abcd"</span><span class="o">));</span>    <span class="c1">// Output: 1</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">possibleStringCount</span><span class="o">(</span><span class="s">"aaaa"</span><span class="o">));</span>    <span class="c1">// Output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and may press a key for too long, resulting in a character being typed multiple times. Although Alice tried to focus on her typing, she is aware that she may still have done this at most once. You are given a string word, which represents the final output displayed on Alice’s screen. Return the total number of possible original strings that Alice might have intended to type.]]></summary></entry><entry><title type="html">594. Longest Harmonious Subsequence</title><link href="https://zhengstar94.github.io//blog/2025/LongestHarmoniousSubsequence/" rel="alternate" type="text/html" title="594. Longest Harmonious Subsequence"/><published>2025-06-30T00:00:00+00:00</published><updated>2025-06-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestHarmoniousSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestHarmoniousSubsequence/"><![CDATA[<ul> <li>We define a harmonious array as an array where the difference between its maximum value and its minimum value is <strong>exactly</strong> <code class="language-plaintext highlighter-rouge">1</code>.</li> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return the length of its longest harmonious subsequence among all its possible subsequences.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,2,2,5,2,3,7]

Output: 5

Explanation:

The longest harmonious subsequence is [3,2,2,2,3].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4]

Output: 2

Explanation:

The longest harmonious subsequences are [1,2], [2,3], and [3,4], all of which have a length of 2.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1]

Output: 0

Explanation:

No harmonic subsequence exists.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestHarmoniousSubsequence</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findLHS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to store the frequency (count) of each number in the array.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Traverse the array and populate the countMap.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each number, increment its count in the map.</span>
            <span class="c1">// If the number is not present, getOrDefault returns 0.</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Variable to keep track of the maximum length found.</span>

        <span class="c1">// Iterate through each unique number (key) in the map.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">key</span> <span class="o">:</span> <span class="n">countMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Check if the map contains the adjacent number (key + 1).</span>
            <span class="c1">// Only pairs of numbers with a difference of exactly 1 can form a harmonious subsequence.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If both key and key+1 exist, calculate the total count of these two numbers.</span>
                <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">+</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update maxLen if this pair forms a longer harmonious subsequence.</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the length of the longest harmonious subsequence found.</span>
        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example from the problem description.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="c1">// Expected output: 5 ([3,2,2,2,3])</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLHS</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Consecutive numbers.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="c1">// Expected output: 2 ([1,2], [2,3], or [3,4])</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLHS</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test case 3: All numbers are the same.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Expected output: 0 (no harmonious subsequence)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLHS</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1. Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.]]></summary></entry><entry><title type="html">2684. Maximum Number of Moves in a Grid</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfMovesInAGrid/" rel="alternate" type="text/html" title="2684. Maximum Number of Moves in a Grid"/><published>2025-06-29T00:00:00+00:00</published><updated>2025-06-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfMovesInAGrid</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfMovesInAGrid/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">grid</code> consisting of <strong>positive</strong> integers.</li> <li>You can start at <strong>any</strong> cell in the first column of the matrix, and traverse the grid in the following way: <ul> <li>From a cell <code class="language-plaintext highlighter-rouge">(row, col)</code>, you can move to any of the cells: <code class="language-plaintext highlighter-rouge">(row - 1, col + 1)</code>, <code class="language-plaintext highlighter-rouge">(row, col + 1)</code> and <code class="language-plaintext highlighter-rouge">(row + 1, col + 1)</code> such that the value of the cell you move to, should be <strong>strictly</strong> bigger than the value of the current cell.</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> number of <strong>moves</strong> that you can perform.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15 ] ]
Output: 3
Explanation: We can start at the cell (0, 0) and make the following moves:
- (0, 0) -&gt; (0, 1).
- (0, 1) -&gt; (1, 2).
- (1, 2) -&gt; (2, 3).
It can be shown that it is the maximum number of moves that can be made.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 3,2,4],[2,1,9],[1,1,7 ] ]
Output: 0
Explanation: Starting from any cell in the first column we cannot perform any moves.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfMovesInAGrid</span> <span class="o">{</span>
   
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxMoves</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the number of rows (m) and columns (n) in the grid</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create a memoization array to store the maximum moves from each cell</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// Initialize the memo array with -1, meaning no cell has been computed yet</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Variable to keep track of the overall maximum moves</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Try starting from every cell in the first column</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update the result with the maximum moves from this starting cell</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">memo</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// Return the maximum number of moves found</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the grid dimensions</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// If we are already at the last column, no more moves can be made</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// If this cell's result has already been computed, return it directly</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">// Initialize the maximum moves from this cell as 0</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Define the three possible row directions: up, straight, down</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">directions</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// Try all three possible moves: right-up, right, right-down</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">directions</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the next row and next column after the move</span>
            <span class="kt">int</span> <span class="n">nextRow</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">dir</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">nextCol</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Check if the next cell is within the grid and its value is strictly greater</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextRow</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nextRow</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">nextRow</span><span class="o">][</span><span class="n">nextCol</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Recursively compute the moves from the next cell and add 1 for this move</span>
                <span class="kt">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">memo</span><span class="o">,</span> <span class="n">nextRow</span><span class="o">,</span> <span class="n">nextCol</span><span class="o">);</span>
                <span class="c1">// Take the maximum among all possible moves from this cell</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">steps</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Store the computed result in the memo array for future reference</span>
        <span class="n">memo</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
        <span class="c1">// Return the maximum moves from this cell</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Output the results for both test cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxMoves</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxMoves</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed m x n matrix grid consisting of positive integers. You can start at any cell in the first column of the matrix, and traverse the grid in the following way: From a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell. Return the maximum number of moves that you can perform.]]></summary></entry><entry><title type="html">1254. Number of Closed Islands</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfClosedIslands/" rel="alternate" type="text/html" title="1254. Number of Closed Islands"/><published>2025-06-29T00:00:00+00:00</published><updated>2025-06-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfClosedIslands</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfClosedIslands/"><![CDATA[<ul> <li>Given a 2D <code class="language-plaintext highlighter-rouge">grid</code> consists of <code class="language-plaintext highlighter-rouge">0s</code> (land) and <code class="language-plaintext highlighter-rouge">1s</code> (water). An <em>island</em> is a maximal 4-directionally connected group of <code class="language-plaintext highlighter-rouge">0s</code> and a <em>closed island</em> is an island <strong>totally</strong> (all left, top, right, bottom) surrounded by <code class="language-plaintext highlighter-rouge">1s.</code></li> <li>Return the number of <em>closed islands</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0 ] ]
Output: 2
Explanation: 
Islands in gray are closed because they are completely surrounded by water (group of 1s).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0 ] ]
Output: 1
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,1,1,1,1,1,1],
               [1,0,0,0,0,0,1],
               [1,0,1,1,1,0,1],
               [1,0,1,0,1,0,1],
               [1,0,1,1,1,0,1],
               [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1 ] ]
Output: 2
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfClosedIslands</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">closedIsland</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the number of rows and columns in the grid</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Step 1: Flood-fill all land cells (0s) that are connected to the grid's boundary.</span>
        <span class="c1">// These cannot be closed islands because they touch the edge.</span>
        <span class="c1">// Flood-fill leftmost and rightmost columns for every row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>         <span class="c1">// Left boundary</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>     <span class="c1">// Right boundary</span>
        <span class="o">}</span>

        <span class="c1">// Flood-fill topmost and bottommost rows for every column</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>         <span class="c1">// Top boundary</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>     <span class="c1">// Bottom boundary</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Traverse the inner grid to count closed islands</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Only check cells that are not on the boundary</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If a land cell (0) is found, it must be a closed island</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Use DFS to flood-fill the entire island, marking it as visited</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
                    <span class="c1">// Increment the closed island count</span>
                    <span class="n">count</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the total number of closed islands found</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If out of bounds or not a land cell, stop recursion</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Mark the current land cell as visited by setting it to 1 (water)</span>
        <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Recursively flood-fill all four directions (down, up, right, left)</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Down</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Up</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Right</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Left</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Two closed islands</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Test case 2: One closed island</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Test case 3: Two closed islands</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// Output the results for each test case</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">closedIsland</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">closedIsland</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">closedIsland</span><span class="o">(</span><span class="n">grid3</span><span class="o">));</span> <span class="c1">// Output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><category term="Medium"/><summary type="html"><![CDATA[Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s. Return the number of closed islands.]]></summary></entry><entry><title type="html">130. Surrounded Regions</title><link href="https://zhengstar94.github.io//blog/2025/SurroundedRegions/" rel="alternate" type="text/html" title="130. Surrounded Regions"/><published>2025-06-29T00:00:00+00:00</published><updated>2025-06-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SurroundedRegions</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SurroundedRegions/"><![CDATA[<ul> <li>You are given an <code class="language-plaintext highlighter-rouge">m x n</code> matrix <code class="language-plaintext highlighter-rouge">board</code> containing <strong>letters</strong> <code class="language-plaintext highlighter-rouge">'X'</code> and <code class="language-plaintext highlighter-rouge">'O'</code>, <strong>capture regions</strong> that are <strong>surrounded</strong>: <ul> <li><strong>Connect</strong>: A cell is connected to adjacent cells horizontally or vertically.</li> <li><strong>Region</strong>: To form a region <strong>connect every</strong> <code class="language-plaintext highlighter-rouge">'O'</code> cell.</li> <li><strong>Surround</strong>: The region is surrounded with <code class="language-plaintext highlighter-rouge">'X'</code> cells if you can <strong>connect the region</strong> with <code class="language-plaintext highlighter-rouge">'X'</code> cells and none of the region cells are on the edge of the <code class="language-plaintext highlighter-rouge">board</code>.</li> </ul> </li> <li>To capture a <strong>surrounded region</strong>, replace all <code class="language-plaintext highlighter-rouge">'O'</code>s with <code class="language-plaintext highlighter-rouge">'X'</code>s <strong>in-place</strong> within the original board. You do not need to return anything.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [ [ "X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X" ] ]

Output: [ [ "X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X" ] ]

Explanation:

In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [ [ "X" ] ]

Output: [ [ "X" ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SurroundedRegions</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the number of rows and columns in the board</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Step 1: Mark all 'O's that are connected to the boundary with a temporary marker '#'</span>
        <span class="c1">// These 'O's cannot be captured because they are not fully surrounded by 'X'</span>

        <span class="c1">// Traverse each row's first and last column (left and right boundaries)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>         <span class="c1">// Left boundary</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>     <span class="c1">// Right boundary</span>
        <span class="o">}</span>

        <span class="c1">// Traverse each column's first and last row (top and bottom boundaries)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>         <span class="c1">// Top boundary</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>     <span class="c1">// Bottom boundary</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Flip all remaining 'O's to 'X' (these are surrounded regions)</span>
        <span class="c1">// Restore all '#' back to 'O' (these were connected to the boundary)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If the cell is still 'O', it means it is surrounded and should be captured</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="o">;</span>
                    <span class="c1">// If the cell is '#', it was connected to the boundary and should be restored</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'O'</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If out of bounds or not an 'O', stop recursion</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'O'</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Mark the current cell as '#' to indicate it is connected to the boundary</span>
        <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'#'</span><span class="o">;</span>
        <span class="c1">// Recursively mark all adjacent 'O's (down, up, right, left)</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Down</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Up</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Right</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// Left</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[][]</span> <span class="n">board1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">},</span>
                <span class="o">{</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'O'</span><span class="o">,</span><span class="sc">'O'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">},</span>
                <span class="o">{</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'O'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">},</span>
                <span class="o">{</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'O'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">,</span><span class="sc">'X'</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="n">solve</span><span class="o">(</span><span class="n">board1</span><span class="o">);</span>
        <span class="n">printBoard</span><span class="o">(</span><span class="n">board1</span><span class="o">);</span> <span class="c1">// OutPut: [ [ "X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X" ] ]</span>

        <span class="kt">char</span><span class="o">[][]</span> <span class="n">board2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="sc">'X'</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="n">solve</span><span class="o">(</span><span class="n">board2</span><span class="o">);</span>
        <span class="n">printBoard</span><span class="o">(</span><span class="n">board2</span><span class="o">);</span> <span class="c1">// OutPut: [ [ "X" ] ]</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printBoard</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><category term="Medium"/><summary type="html"><![CDATA[You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded: Connect: A cell is connected to adjacent cells horizontally or vertically. Region: To form a region connect every 'O' cell. Surround: The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board. To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.]]></summary></entry></feed>