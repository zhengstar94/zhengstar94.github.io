<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-11T03:14:43+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1550. Three Consecutive Odds</title><link href="https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds/" rel="alternate" type="text/html" title="1550. Three Consecutive Odds"/><published>2025-05-11T00:00:00+00:00</published><updated>2025-05-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">arr</code>, return <code class="language-plaintext highlighter-rouge">true</code> if there are three consecutive odd numbers in the array. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeConsecutiveOdds</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">threeConsecutiveOdds</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: If array length is less than 3, it's impossible to have three consecutive elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Counter to track the number of consecutive odd integers encountered</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if the current number is odd (remainder when divided by 2 is 1)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="c1">// Increment the counter for consecutive odd numbers</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="c1">// If we've found three consecutive odd numbers, return true</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we encounter an even number, reset the counter</span>
                <span class="c1">// as it breaks the consecutive sequence of odd numbers</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we've traversed the entire array without finding three consecutive odd numbers, return false</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with no three consecutive odd numbers</span>
        <span class="c1">// Expected output: false</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 2: Array with three consecutive odd numbers (5, 7, 23)</span>
        <span class="c1">// Expected output: true</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">12</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 3: Array with exactly three elements, all odd</span>
        <span class="c1">// Expected output: true</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 4: Array with consecutive odd numbers scattered throughout</span>
        <span class="c1">// Expected output: true (could be because of 7, 3, 1 or 3, 1, 9 or 1, 9, 5)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr4</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 5: Array with only even numbers</span>
        <span class="c1">// Expected output: false</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr5</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.]]></summary></entry><entry><title type="html">2918. Minimum Equal Sum of Two Arrays After Replacing Zeros</title><link href="https://zhengstar94.github.io//blog/2025/MinimumEqualSumOfTwoArraysAfterReplacingZeros/" rel="alternate" type="text/html" title="2918. Minimum Equal Sum of Two Arrays After Replacing Zeros"/><published>2025-05-10T00:00:00+00:00</published><updated>2025-05-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumEqualSumOfTwoArraysAfterReplacingZeros</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumEqualSumOfTwoArraysAfterReplacingZeros/"><![CDATA[<ul> <li>You are given two arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> consisting of positive integers.</li> <li>You have to replace <strong>all</strong> the <code class="language-plaintext highlighter-rouge">0</code>’s in both arrays with <strong>strictly</strong> positive integers such that the sum of elements of both arrays becomes <strong>equal</strong>.</li> <li>Return <em>the <strong>minimum</strong> equal sum you can obtain, or</em> <code class="language-plaintext highlighter-rouge">-1</code> <em>if it is impossible</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [3,2,0,1,0], nums2 = [6,5,0]
Output: 12
Explanation: We can replace 0's in the following way:
- Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4].
- Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1].
Both arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [2,0,2,0], nums2 = [1,4]
Output: -1
Explanation: It is impossible to make the sum of both arrays equal.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengxingxing
 * Date: 2025/05/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumEqualSumOfTwoArraysAfterReplacingZeros</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">minimumEqualSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">zero1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">zero2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Calculate the sum and count the number of zeros in nums1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum1</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zero1</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Calculate the sum and count the number of zeros in nums2</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum2</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zero2</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The minimum possible sum after replacing all zeros with 1</span>
        <span class="kt">long</span> <span class="n">minSum1</span> <span class="o">=</span> <span class="n">sum1</span> <span class="o">+</span> <span class="n">zero1</span><span class="o">;</span> <span class="c1">// Each zero in nums1 is replaced by 1</span>
        <span class="kt">long</span> <span class="n">minSum2</span> <span class="o">=</span> <span class="n">sum2</span> <span class="o">+</span> <span class="n">zero2</span><span class="o">;</span> <span class="c1">// Each zero in nums2 is replaced by 1</span>

        <span class="cm">/**
         * Case 1:
         * If both arrays already have the same sum AND there are no zeros,
         * it means the arrays are naturally equal without needing any replacements.
         * We can directly return the sum as the result.
         *
         * Example:
         * nums1 = {1, 2, 3}
         * nums2 = {3, 2, 1}
         * Both have sum = 6 and no zeros -&gt; return 6.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum1</span> <span class="o">==</span> <span class="n">sum2</span> <span class="o">&amp;&amp;</span> <span class="n">zero1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">zero2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">sum1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Case 2:
         * If the minimum possible sum of nums1 is greater than that of nums2,
         * and nums2 has zeros, we can potentially increase nums2's sum by
         * replacing its zeros with larger numbers to match nums1's sum.
         * We return the minSum1 as the minimum target.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">minSum1</span> <span class="o">&gt;</span> <span class="n">minSum2</span> <span class="o">&amp;&amp;</span> <span class="n">zero2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">minSum1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Case 3:
         * Similarly, if the minimum possible sum of nums2 is greater than that of nums1,
         * and nums1 has zeros, we can potentially increase nums1's sum by
         * replacing its zeros with larger numbers to match nums2's sum.
         * We return the minSum2 as the minimum target.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">minSum2</span> <span class="o">&gt;</span> <span class="n">minSum1</span> <span class="o">&amp;&amp;</span> <span class="n">zero1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">minSum2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Case 4:
         * This is a subtle and important case:
         * If both arrays' minimum possible sums (after replacing all zeros with 1)
         * are already equal, it means they can be balanced by just replacing all
         * zeros with 1 and nothing more needs to be done.
         *
         * Example:
         * nums1 = {0, 2, 3}  -&gt; sum1 = 5, zero1 = 1, minSum1 = 6
         * nums2 = {1, 0, 4}  -&gt; sum2 = 5, zero2 = 1, minSum2 = 6
         * Both minSum1 and minSum2 == 6 -&gt; return 6.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">minSum1</span> <span class="o">==</span> <span class="n">minSum2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">minSum1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * If none of the above cases apply, it's impossible to make the arrays equal,
         * even after replacing zeros.
         */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected: 12</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1Case2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2Case2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1Case2</span><span class="o">,</span> <span class="n">nums2Case2</span><span class="o">));</span> <span class="c1">// Expected: -1</span>

        <span class="c1">// Additional test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1Case3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2Case3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1Case3</span><span class="o">,</span> <span class="n">nums2Case3</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Additional test case 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1Case4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2Case4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1Case4</span><span class="o">,</span> <span class="n">nums2Case4</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given two arrays nums1 and nums2 consisting of positive integers. You have to replace all the 0’s in both arrays with strictly positive integers such that the sum of elements of both arrays becomes equal. Return the minimum equal sum you can obtain, or -1 if it is impossible.]]></summary></entry><entry><title type="html">1920. Build Array from Permutation</title><link href="https://zhengstar94.github.io//blog/2025/BuildArrayFromPermutation/" rel="alternate" type="text/html" title="1920. Build Array from Permutation"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BuildArrayFromPermutation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BuildArrayFromPermutation/"><![CDATA[<ul> <li>Given a <strong>zero-based permutation</strong> <code class="language-plaintext highlighter-rouge">nums</code> (<strong>0-indexed</strong>), build an array <code class="language-plaintext highlighter-rouge">ans</code> of the <strong>same length</strong> where <code class="language-plaintext highlighter-rouge">ans[i] = nums[nums[i]]</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; nums.length</code> and return it.</li> <li>A <strong>zero-based permutation</strong> <code class="language-plaintext highlighter-rouge">nums</code> is an array of <strong>distinct</strong> integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">nums.length - 1</code> (<strong>inclusive</strong>).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]
Explanation: The array ans is built as follows: 
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]
Explanation: The array ans is built as follows:
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BuildArrayFromPermutation</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">buildArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create result array with same length as input array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Iterate through array and build result</span>
        <span class="c1">// For each position i, ans[i] = nums[nums[i]]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output [0,1,2,4,5,3]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">buildArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">result1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Expected output [4,5,0,1,2,3]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">buildArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">result2</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 &lt;= i &lt; nums.length and return it. A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).]]></summary></entry><entry><title type="html">2576. Find the Maximum Number of Marked Indices</title><link href="https://zhengstar94.github.io//blog/2025/FindTheMaximumNumberOfMarkedIndices/" rel="alternate" type="text/html" title="2576. Find the Maximum Number of Marked Indices"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheMaximumNumberOfMarkedIndices</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheMaximumNumberOfMarkedIndices/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times: <ul> <li>Pick two <strong>different unmarked</strong> indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> such that <code class="language-plaintext highlighter-rouge">2 * nums[i] &lt;= nums[j]</code>, then mark <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>.</li> </ul> </li> <li>Return <em>the maximum possible number of marked indices in <code class="language-plaintext highlighter-rouge">nums</code> using the above operation any number of times</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,5,2,4]
Output: 2
Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] &lt;= nums[1]. Then mark index 2 and 1.
It can be shown that there's no other valid operation so the answer is 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [9,2,5,4]
Output: 4
Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] &lt;= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] &lt;= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [7,6,8]
Output: 0
Explanation: There is no valid operation to do, so the answer is 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMaximum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheMaximumNumberOfMarkedIndices</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxNumOfMarkedIndices</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the array to enable our optimal pairing strategy</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// Initialize binary search boundaries</span>
        <span class="c1">// left: current best answer (starts at 0)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// right: theoretical upper bound (n/2 + 1) - we use an open interval approach</span>
        <span class="c1">// The maximum possible number of pairs is n/2 (where n is the array length)</span>
        <span class="c1">// We add 1 to make it an exclusive upper bound for the binary search</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Binary search for the maximum valid k value</span>
        <span class="c1">// We use (left + 1 &lt; right) as our loop condition to avoid infinite loops</span>
        <span class="c1">// This approach will terminate when left and right are adjacent</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle point safely to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if we can form 'mid' pairs that satisfy our condition</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If yes, update our current best answer and try for more pairs</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If no, reduce the upper bound of our search space</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of marked indices</span>
        <span class="c1">// Each valid pair allows us to mark 2 indices, so we multiply by 2</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check all k potential pairs</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For each pair, check if the condition 2*nums[i] &lt;= nums[j] is satisfied</span>
            <span class="c1">// nums[i]: the i-th smallest element</span>
            <span class="c1">// nums[nums.length - k + i]: the i-th element from the k largest elements</span>
            <span class="c1">//</span>
            <span class="c1">// Why nums.length - k + i?</span>
            <span class="c1">// - nums.length - k: This points to the starting position of the k largest elements</span>
            <span class="c1">// - Adding i: As i increases from 0 to k-1, we move through these k largest elements</span>
            <span class="c1">//</span>
            <span class="c1">// For example, with array [2,3,5,7,10,12] and k=3:</span>
            <span class="c1">// i=0: compare nums[0]=2 with nums[6-3+0]=nums[3]=7</span>
            <span class="c1">// i=1: compare nums[1]=3 with nums[6-3+1]=nums[4]=10</span>
            <span class="c1">// i=2: compare nums[2]=5 with nums[6-3+2]=nums[5]=12</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// If any pair doesn't satisfy the condition, we can't form k valid pairs</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// All k pairs satisfy the condition</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">FindTheMaximumNumberOfMarkedIndices</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FindTheMaximumNumberOfMarkedIndices</span><span class="o">();</span>

        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result1</span> <span class="o">==</span> <span class="n">expected1</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected1</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result1</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// After sorting: [2, 3, 4, 5]</span>
        <span class="c1">// We can form 1 pair: (2,5) where 2*2 &lt;= 5, marking 2 indices</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result2</span> <span class="o">==</span> <span class="n">expected2</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected2</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result2</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// After sorting: [2, 4, 5, 9]</span>
        <span class="c1">// We can form 2 pairs: (2,5) and (4,9), marking 4 indices</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result3</span> <span class="o">==</span> <span class="n">expected3</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected3</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result3</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// After sorting: [6, 7, 8]</span>
        <span class="c1">// We can't form any valid pairs because 2*6 &gt; 8, so 0 indices are marked</span>

        <span class="c1">// Test Case 4: Longer array example to illustrate the pairing strategy</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected4</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result4</span> <span class="o">==</span> <span class="n">expected4</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected4</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result4</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// In this case (already sorted): [2, 3, 5, 7, 10, 12]</span>
        <span class="c1">// We can form 3 pairs: (2,7), (3,10), and (5,12), marking 6 indices</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Initially, all of the indices are unmarked. You are allowed to make this operation any number of times: Pick two different unmarked indices i and j such that 2 * nums[i] &lt;= nums[j], then mark i and j. Return the maximum possible number of marked indices in nums using the above operation any number of times.]]></summary></entry><entry><title type="html">Best Practices for Incident Response</title><link href="https://zhengstar94.github.io//blog/2025/BestPracticesForIncidentResponse/" rel="alternate" type="text/html" title="Best Practices for Incident Response"/><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BestPracticesForIncidentResponse</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BestPracticesForIncidentResponse/"><![CDATA[<p>In complex products and systems, failures are inevitable. When incidents occur, we must not only act swiftly to restore business continuity but also continually improve and extract lessons to prevent recurrence. This article summarizes a practical “best response strategy” aimed at providing actionable emergency handling and post-mortem frameworks for development teams.</p> <h2 id="1-golden-rules-of-incident-handling">1. Golden Rules of Incident Handling</h2> <h3 id="11-stopping-the-bleeding-takes-top-priority">1.1 Stopping the Bleeding Takes Top Priority</h3> <p>In emergency response, the primary goal is to restore product functionality as quickly as possible—similar to the “stop the bleeding” principle in first aid. Root cause analysis can wait; the priority is immediate recovery.</p> <h3 id="12-identify-the-triggering-variables">1.2 Identify the Triggering Variables</h3> <p>Response measures must <strong>support phased rollouts</strong> to avoid expanding the scope of the problem. The execution of the plan should be <strong>efficient yet cautious</strong>, ensuring no additional risks are introduced.</p> <ul> <li><strong>Variables are often the trigger point of failures</strong>: These are typically the first suspects and relatively easy to spot.</li> <li><strong>Analyze variables for quick containment</strong>: Focus your investigation on the variables to locate the issue and take immediate action.</li> </ul> <h3 id="13-careful-and-efficient-execution-of-containment-plans">1.3 Careful and Efficient Execution of Containment Plans</h3> <p>While executing containment measures, avoid making the situation worse. Balance speed with thoroughness.</p> <h2 id="2-strengthening-incident-response-capabilities">2. Strengthening Incident Response Capabilities</h2> <h3 id="21-effective-communication">2.1 Effective Communication</h3> <p>During emergency handling, the <strong>product owner should oversee the entire situation</strong>, while team members must quickly synchronize their findings and <strong>divide responsibilities to narrow down the problem scope</strong>.</p> <h3 id="22-sharpen-the-basics">2.2 Sharpen the Basics</h3> <ul> <li>Improve familiarity with business logic</li> <li>Build a toolkit of handy scripts and utilities</li> <li>Establish streamlined troubleshooting processes</li> </ul> <h3 id="23-proactive-measures-in-feature-development">2.3 Proactive Measures in Feature Development</h3> <p>It’s essential to enforce the following during development:</p> <ul> <li><strong>Gray release support</strong></li> <li><strong>Monitoring capability</strong></li> <li><strong>Rollback readiness</strong></li> </ul> <p>Avoid “wishful thinking” and “low-value tasks”; even if it requires extra effort, product quality and safety must not be compromised.</p> <h3 id="24-learn-from-excellent-postmortems">2.4 Learn from Excellent Postmortems</h3> <p>Study <strong>postmortems from leading companies like Cloudflare</strong>, to inspire fresh thinking and continuous improvement.</p> <h3 id="25-mindset-adjustment">2.5 Mindset Adjustment</h3> <p>Incident response <strong>is not an exam</strong>. Teams should maintain a constructive mindset, focusing on problem-solving and learning valuable lessons from each event.</p> <h2 id="3-postmortem-analysis">3. Postmortem Analysis</h2> <h3 id="31-core-objectives">3.1 Core Objectives</h3> <ul> <li>Prevent recurrence of the incident</li> </ul> <h3 id="32-key-considerations">3.2 Key Considerations</h3> <ul> <li>Ensure thorough resolution of the issue</li> <li>Document the incident timeline and root causes</li> <li>Implement targeted improvement actions</li> <li>Establish guidelines and systems to guard against similar problems</li> <li>Maintain a holistic view</li> <li>Ensure high-quality execution of action items</li> <li>Integrate temporary fixes into long-term improvements</li> </ul> <h2 id="4-accountability">4. Accountability</h2> <h3 id="41-attending-the-incident-review-meeting">4.1 Attending the Incident Review Meeting</h3> <p>The purpose of the review is to acknowledge issues and extract lessons—not simply to assign blame. <strong>Taking responsibility is both a duty and a growth opportunity</strong>.</p> <h3 id="42-mindset-adjustment">4.2 Mindset Adjustment</h3> <p>The team should maintain a proactive attitude, learn from mistakes, and avoid repeating them. And if worst comes to worst and the issue proves unsolvable—well, sometimes you have to “grab your bucket and leave” (just kidding!).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/05/FaultResponse-480.webp 480w,/assets/img/2025/05/FaultResponse-800.webp 800w,/assets/img/2025/05/FaultResponse-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/05/FaultResponse.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="Work"/><summary type="html"><![CDATA[In complex products and systems, failures are inevitable. When incidents occur, we must not only act swiftly to restore business continuity but also continually improve and extract lessons to prevent recurrence. This article summarizes a practical “best response strategy” aimed at providing actionable emergency handling and post-mortem frameworks for development teams.]]></summary></entry><entry><title type="html">2226. Maximum Candies Allocated to K Children</title><link href="https://zhengstar94.github.io//blog/2025/MaximumCandiesAllocatedToKChildren/" rel="alternate" type="text/html" title="2226. Maximum Candies Allocated to K Children"/><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumCandiesAllocatedToKChildren</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumCandiesAllocatedToKChildren/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">candies</code>. Each element in the array denotes a pile of candies of size <code class="language-plaintext highlighter-rouge">candies[i]</code>. You can divide each pile into any number of <strong>sub piles</strong>, but you <strong>cannot</strong> merge two piles together.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">k</code>. You should allocate piles of candies to <code class="language-plaintext highlighter-rouge">k</code> children such that each child gets the <strong>same</strong> number of candies. Each child can be allocated candies from <strong>only one</strong> pile of candies and some piles of candies may go unused.</li> <li>Return <em>the <strong>maximum number of candies</strong> each child can get.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candies = [5,8,6], k = 3
Output: 5
Explanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candies = [2,5], k = 11
Output: 0
Explanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogU) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumCandiesAllocatedToKChildren</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumCandies</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candies</span><span class="o">,</span> <span class="kt">long</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize variables to track maximum pile size and total candies</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Maximum pile size</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Total number of candies</span>

        <span class="c1">// Calculate the maximum pile size and sum of all candies</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">:</span> <span class="n">candies</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Set the boundaries for binary search</span>
        <span class="c1">// The minimum candies per child is 0</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// The maximum candies per child can't exceed the maximum pile size</span>
        <span class="c1">// or the average candies per child (sum/k)</span>
        <span class="c1">// We add 1 to make it an exclusive upper bound</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">sum</span> <span class="o">/</span> <span class="n">k</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Binary search to find the maximum number of candies</span>
        <span class="c1">// The search continues until left and right are adjacent</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle point to check</span>
            <span class="c1">// This formula prevents integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If we can distribute 'mid' candies to each child</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">candies</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Try a larger amount</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Try a smaller amount</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the maximum valid amount</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">candies</span><span class="o">,</span> <span class="kt">long</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge case where low is 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Only true if there are no children</span>
        <span class="o">}</span>

        <span class="c1">// Count how many children can receive 'low' candies</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">:</span> <span class="n">candies</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Each pile can serve c/low children</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">/</span> <span class="n">low</span><span class="o">;</span>

            <span class="c1">// Early termination if we've already satisfied all children</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return true if we can serve at least k children</span>
        <span class="k">return</span> <span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candies1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: candies = [5, 8, 6], k = 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maximumCandies</span><span class="o">(</span><span class="n">candies1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candies2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: candies = [2, 5], k = 11"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maximumCandies</span><span class="o">(</span><span class="n">candies2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 0"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together. You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can be allocated candies from only one pile of candies and some piles of candies may go unused. Return the maximum number of candies each child can get.]]></summary></entry><entry><title type="html">1482. Minimum Number of Days to Make m Bouquets</title><link href="https://zhengstar94.github.io//blog/2025/MinimumNumberOfDaysToMakeMBouquets/" rel="alternate" type="text/html" title="1482. Minimum Number of Days to Make m Bouquets"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumNumberOfDaysToMakeMBouquets</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumNumberOfDaysToMakeMBouquets/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">bloomDay</code>, an integer <code class="language-plaintext highlighter-rouge">m</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>You want to make <code class="language-plaintext highlighter-rouge">m</code> bouquets. To make a bouquet, you need to use <code class="language-plaintext highlighter-rouge">k</code> <strong>adjacent flowers</strong> from the garden.</li> <li>The garden consists of <code class="language-plaintext highlighter-rouge">n</code> flowers, the <code class="language-plaintext highlighter-rouge">ith</code> flower will bloom in the <code class="language-plaintext highlighter-rouge">bloomDay[i]</code> and then can be used in <strong>exactly one</strong> bouquet.</li> <li>Return <em>the minimum number of days you need to wait to be able to make</em> <code class="language-plaintext highlighter-rouge">m</code> <em>bouquets from the garden</em>. If it is impossible to make m bouquets return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
Output: 3
Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.
We need 3 bouquets each should contain 1 flower.
After day 1: [x, _, _, _, _]   // we can only make one bouquet.
After day 2: [x, _, _, _, x]   // we can only make two bouquets.
After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
Output: -1
Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
Output: 12
Explanation: We need 2 bouquets each should have 3 flowers.
Here is the garden after the 7 and 12 days:
After day 7: [x, x, x, x, _, x, x]
We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
After day 12: [x, x, x, x, x, x, x]
It is obvious that we can make two bouquets in different ways.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(max-min) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMinimum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumNumberOfDaysToMakeMBouquets</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minDays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">bloomDay</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bloomDay</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Check if there are enough flowers to make m bouquets</span>
        <span class="c1">// Each bouquet needs k flowers, so we need m*k flowers in total</span>
        <span class="c1">// Using long to prevent integer overflow for large m and k values</span>
        <span class="k">if</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="n">m</span> <span class="o">*</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize binary search boundaries</span>
        <span class="c1">// left: earliest possible day (minimum bloom day)</span>
        <span class="c1">// right: latest possible day (maximum bloom day)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="c1">// Find the minimum and maximum bloom days from the array</span>
        <span class="c1">// These values will serve as our binary search range</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">day:</span> <span class="n">bloomDay</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">day</span><span class="o">);</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">day</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Perform binary search to find the minimum number of days</span>
        <span class="c1">// The search space is between the earliest and latest bloom days</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="c1">// Calculate the middle day to test</span>
            <span class="c1">// Using (right-left)/2 to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if we can make m bouquets by waiting 'mid' days</span>
            <span class="c1">// If possible, try to minimize by searching in the lower half</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canMakeBouquets</span><span class="o">(</span><span class="n">bloomDay</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, we need more days, search in the upper half</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// At this point, 'left' contains the minimum number of days needed</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canMakeBouquets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">bloomDay</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">days</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Counter for the number of bouquets we can make</span>
        <span class="kt">int</span> <span class="n">bouquets</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Counter for the current sequence of adjacent bloomed flowers</span>
        <span class="kt">int</span> <span class="n">flowers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each flower in the garden</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bloomDay</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If this flower has bloomed by 'days' day</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bloomDay</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">days</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Increment the count of consecutive bloomed flowers</span>
                <span class="n">flowers</span><span class="o">++;</span>

                <span class="c1">// If we have k adjacent bloomed flowers, we can make a bouquet</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">flowers</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Make a bouquet and reset the flower counter to start a new bouquet</span>
                    <span class="n">bouquets</span><span class="o">++;</span>
                    <span class="n">flowers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If this flower hasn't bloomed, we break the consecutive sequence</span>
                <span class="c1">// Reset the flower counter since we need k adjacent bloomed flowers</span>
                <span class="n">flowers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Early termination: if we've made enough bouquets, return true</span>
            <span class="c1">// This optimization saves computation when we've already found the answer</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bouquets</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Check if we've made at least m bouquets</span>
        <span class="k">return</span> <span class="n">bouquets</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: bloomDay = [1,10,3,10,2], m = 3, k = 1, Expected output: 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bloomDay1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: bloomDay = [1,10,3,10,2], m = 3, k = 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDays</span><span class="o">(</span><span class="n">bloomDay1</span><span class="o">,</span> <span class="n">m1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Example 2: bloomDay = [1,10,3,10,2], m = 3, k = 2, Expected output: -1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bloomDay2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: bloomDay = [1,10,3,10,2], m = 3, k = 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDays</span><span class="o">(</span><span class="n">bloomDay2</span><span class="o">,</span> <span class="n">m2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: -1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Example 3: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3, Expected output: 12</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bloomDay3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDays</span><span class="o">(</span><span class="n">bloomDay3</span><span class="o">,</span> <span class="n">m3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 12"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Example 4: bloomDay = [1000000000,1000000000], m = 1, k = 1, Expected output: 1000000000</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bloomDay4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1000000000</span><span class="o">,</span> <span class="mi">1000000000</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: bloomDay = [1000000000,1000000000], m = 1, k = 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDays</span><span class="o">(</span><span class="n">bloomDay4</span><span class="o">,</span> <span class="n">m4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 1000000000"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Example 5: bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2, Expected output: 9</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bloomDay5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m5</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 5:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDays</span><span class="o">(</span><span class="n">bloomDay5</span><span class="o">,</span> <span class="n">m5</span><span class="o">,</span> <span class="n">k5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 9"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an integer array bloomDay, an integer m and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet. Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.]]></summary></entry><entry><title type="html">1128. Number of Equivalent Domino Pairs</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfEquivalentDominoPairs/" rel="alternate" type="text/html" title="1128. Number of Equivalent Domino Pairs"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfEquivalentDominoPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfEquivalentDominoPairs/"><![CDATA[<ul> <li>Given a list of <code class="language-plaintext highlighter-rouge">dominoes</code>, <code class="language-plaintext highlighter-rouge">dominoes[i] = [a, b]</code> is <strong>equivalent to</strong> <code class="language-plaintext highlighter-rouge">dominoes[j] = [c, d]</code> if and only if either (<code class="language-plaintext highlighter-rouge">a == c</code> and <code class="language-plaintext highlighter-rouge">b == d</code>), or (<code class="language-plaintext highlighter-rouge">a == d</code> and <code class="language-plaintext highlighter-rouge">b == c</code>) - that is, one domino can be rotated to be equal to another domino.</li> <li>Return <em>the number of pairs</em> <code class="language-plaintext highlighter-rouge">(i, j)</code> <em>for which</em> <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; dominoes.length</code><em>, and</em> <code class="language-plaintext highlighter-rouge">dominoes[i]</code> <em>is <strong>equivalent to</strong></em> <code class="language-plaintext highlighter-rouge">dominoes[j]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: dominoes = [ [ 1,2],[2,1],[3,4],[5,6 ] ]
Output: 1
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: dominoes = [ [ 1,2],[1,2],[1,1],[1,2],[2,2 ] ]
Output: 3
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfEquivalentDominoPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numEquivDominoPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store the count of each unique domino type</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Counter for the total number of equivalent pairs</span>
        <span class="kt">int</span> <span class="n">pairs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each domino in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">domino</span> <span class="o">:</span> <span class="n">dominoes</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Create a unique hash value for each domino, ensuring equivalent dominoes have the same hash</span>
            <span class="c1">// We use min*10 + max to ensure [a,b] and [b,a] get the same hash value</span>
            <span class="c1">// This works because in this problem, domino values are between 1-9</span>
            <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">domino</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">domino</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">domino</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">domino</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

            <span class="c1">// Get the current count of dominoes with the same hash value (same type)</span>
            <span class="c1">// If this is the first time we see this type, getOrDefault returns 0</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// The current domino can form a pair with each previously seen domino of the same type</span>
            <span class="c1">// So we add the current count to our running total of pairs</span>
            <span class="n">pairs</span> <span class="o">+=</span> <span class="n">count</span><span class="o">;</span>

            <span class="c1">// Update the count of this domino type in our map</span>
            <span class="c1">// We increment by 1 to account for the current domino</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of equivalent domino pairs found</span>
        <span class="k">return</span> <span class="n">pairs</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Should return 1 pair</span>
        <span class="c1">// [1,2] and [2,1] are equivalent</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">numEquivDominoPairs</span><span class="o">(</span><span class="n">dominoes1</span><span class="o">));</span> <span class="c1">// Should output 1</span>

        <span class="c1">// Test case 2: Should return 3 pairs</span>
        <span class="c1">// The pairs are: ( [ 1,2], [1,2]), ([1,2], [1,2]), ([1,2], [1,2 ] )</span>
        <span class="c1">// Note: These are the pairs at indices (0,1), (0,3), and (1,3)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">numEquivDominoPairs</span><span class="o">(</span><span class="n">dominoes2</span><span class="o">));</span> <span class="c1">// Should output 3</span>

        <span class="c1">// Additional test case: Should return 4 pairs</span>
        <span class="c1">// The pairs are:</span>
        <span class="c1">// ( [ 1,1], [1,1]), ([1,1], [1,1]), ([1,1], [1,1]), ([1,2], [1,2 ] )</span>
        <span class="c1">// These are the pairs at indices (0,2), (0,5), (2,5), and (3,4)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">numEquivDominoPairs</span><span class="o">(</span><span class="n">dominoes3</span><span class="o">));</span> <span class="c1">// Should output 4</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b== d), or (a == d and b== c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j].]]></summary></entry><entry><title type="html">1007. Minimum Domino Rotations For Equal Row</title><link href="https://zhengstar94.github.io//blog/2025/MinimumDominoRotationsForEqualRow/" rel="alternate" type="text/html" title="1007. Minimum Domino Rotations For Equal Row"/><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumDominoRotationsForEqualRow</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumDominoRotationsForEqualRow/"><![CDATA[<ul> <li>In a row of dominoes, <code class="language-plaintext highlighter-rouge">tops[i]</code> and <code class="language-plaintext highlighter-rouge">bottoms[i]</code> represent the top and bottom halves of the <code class="language-plaintext highlighter-rouge">ith</code> domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)</li> <li>We may rotate the <code class="language-plaintext highlighter-rouge">ith</code> domino, so that <code class="language-plaintext highlighter-rouge">tops[i]</code> and <code class="language-plaintext highlighter-rouge">bottoms[i]</code> swap values.</li> <li>Return the minimum number of rotations so that all the values in <code class="language-plaintext highlighter-rouge">tops</code> are the same, or all the values in <code class="language-plaintext highlighter-rouge">bottoms</code> are the same.</li> <li>If it cannot be done, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]
Output: 2
Explanation: 
The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.
If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]
Output: -1
Explanation: 
In this case, it is not possible to rotate the dominoes to make one row of values equal.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumDominoRotationsForEqualRow</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minDominoRotations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tops</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// We only need to check two potential target values: tops[0] and bottoms[0]</span>
        <span class="c1">// This is because if a solution exists, the target value must appear in the first domino</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                <span class="n">minRot</span><span class="o">(</span><span class="n">tops</span><span class="o">,</span> <span class="n">bottoms</span><span class="o">,</span> <span class="n">tops</span><span class="o">[</span><span class="mi">0</span><span class="o">]),</span>     <span class="c1">// Try to make all tops or bottoms equal to tops[0]</span>
                <span class="n">minRot</span><span class="o">(</span><span class="n">tops</span><span class="o">,</span> <span class="n">bottoms</span><span class="o">,</span> <span class="n">bottoms</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>   <span class="c1">// Try to make all tops or bottoms equal to bottoms[0]</span>
        <span class="o">);</span>

        <span class="c1">// If both attempts returned Integer.MAX_VALUE, it means no solution exists</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minRot</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tops</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">toTop</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// Count of rotations needed to make all tops equal to target</span>
        <span class="kt">int</span> <span class="n">toBottom</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Count of rotations needed to make all bottoms equal to target</span>

        <span class="c1">// Iterate through each domino</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tops</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">tops</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>    <span class="c1">// Current top value</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bottoms</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Current bottom value</span>

            <span class="c1">// If neither the top nor bottom is the target value, it's impossible to achieve our goal</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If top is not the target value, we need one rotation to make tops[i] = target</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">toTop</span><span class="o">++;</span>    <span class="c1">// Increment the count for making all tops the target</span>
            <span class="o">}</span>
            <span class="c1">// If bottom is not the target value, we need one rotation to make bottoms[i] = target</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">toBottom</span><span class="o">++;</span> <span class="c1">// Increment the count for making all bottoms the target</span>
            <span class="o">}</span>
            <span class="c1">// If both are the target value, no rotation is needed for this domino</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum of the two approaches:</span>
        <span class="c1">// 1. Make all tops the target value</span>
        <span class="c1">// 2. Make all bottoms the target value</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">toTop</span><span class="o">,</span> <span class="n">toBottom</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tops1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">minDominoRotations</span><span class="o">(</span><span class="n">tops1</span><span class="o">,</span> <span class="n">bottoms1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tops2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: -1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">minDominoRotations</span><span class="o">(</span><span class="n">tops2</span><span class="o">,</span> <span class="n">bottoms2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tops3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: tops = [1,2,1,1,1,2,2,2], bottoms = [2,1,2,2,2,2,2,2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">minDominoRotations</span><span class="o">(</span><span class="n">tops3</span><span class="o">,</span> <span class="n">bottoms3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the ith domino, so that tops[i] and bottoms[i] swap values. Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same. If it cannot be done, return -1.]]></summary></entry><entry><title type="html">2594. Minimum Time to Repair Cars</title><link href="https://zhengstar94.github.io//blog/2025/MinimumTimeToRepairCars/" rel="alternate" type="text/html" title="2594. Minimum Time to Repair Cars"/><published>2025-05-01T00:00:00+00:00</published><updated>2025-05-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumTimeToRepairCars</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumTimeToRepairCars/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">ranks</code> representing the <strong>ranks</strong> of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank <code class="language-plaintext highlighter-rouge">r</code> can repair n cars in <code class="language-plaintext highlighter-rouge">r * n2</code> minutes.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">cars</code> representing the total number of cars waiting in the garage to be repaired.</li> <li>Return <em>the <strong>minimum</strong> time taken to repair all the cars.</em>**</li> <li><strong>Note:</strong> All the mechanics can repair the cars simultaneously.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: ranks = [4,2,3,1], cars = 10
Output: 16
Explanation: 
- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.
- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.
- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.
- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: ranks = [5,1,8], cars = 6
Output: 16
Explanation: 
- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.
- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(R * C²)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMinimum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumTimeToRepairCars</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">repairCars</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ranks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the lower bound of our search range to 1</span>
        <span class="c1">// The minimum possible time cannot be less than 1</span>
        <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Initialize the upper bound of our search range</span>
        <span class="c1">// We calculate an upper bound that is guaranteed to be larger than the answer</span>
        <span class="c1">// Formula: rank * cars^2 represents the time needed if one mechanic repairs all cars</span>
        <span class="c1">// Using ranks[0] gives us a sufficient upper bound, even if it's not the maximum rank</span>
        <span class="c1">// This is a key optimization: we only need a value that's larger than the actual answer</span>
        <span class="kt">long</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">ranks</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="n">cars</span> <span class="o">*</span> <span class="n">cars</span><span class="o">;</span>

        <span class="c1">// Perform binary search to find the minimum possible time</span>
        <span class="c1">// The search continues until left and right pointers converge</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle point, avoiding potential overflow with this formula</span>
            <span class="kt">long</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if all cars can be repaired within 'mid' time</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canRepairAll</span><span class="o">(</span><span class="n">ranks</span><span class="o">,</span> <span class="n">cars</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If possible to repair within 'mid' time, try a smaller time</span>
                <span class="c1">// We don't exclude 'mid' because it might be the answer</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If not possible to repair within 'mid' time, we need more time</span>
                <span class="c1">// Exclude 'mid' as it's definitely not enough time</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found our answer</span>
        <span class="c1">// This is the minimum time needed to repair all cars</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canRepairAll</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ranks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cars</span><span class="o">,</span> <span class="kt">long</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Track the total number of cars that can be repaired within the time limit</span>
        <span class="kt">long</span> <span class="n">totalCars</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each mechanic's rank to calculate their contribution</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">rank</span> <span class="o">:</span> <span class="n">ranks</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each mechanic with efficiency rank 'rank':</span>
            <span class="c1">// The time to repair n cars is: time = rank * n^2</span>
            <span class="c1">// Solving for n: n = sqrt(time/rank)</span>
            <span class="c1">// This gives us the maximum number of cars this mechanic can repair in the given time</span>

            <span class="c1">// Calculate how many cars this mechanic can repair</span>
            <span class="c1">// The cast to long ensures we don't lose precision in the square root calculation</span>
            <span class="kt">long</span> <span class="n">carsPerMechanic</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">time</span> <span class="o">/</span> <span class="n">rank</span><span class="o">);</span>

            <span class="c1">// Add this mechanic's contribution to the total</span>
            <span class="n">totalCars</span> <span class="o">+=</span> <span class="n">carsPerMechanic</span><span class="o">;</span>

            <span class="c1">// Early termination optimization:</span>
            <span class="c1">// If we've already found that enough cars can be repaired, return immediately</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">totalCars</span> <span class="o">&gt;=</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Final check: can all mechanics combined repair enough cars?</span>
        <span class="c1">// This will only be reached if the early termination condition above wasn't triggered</span>
        <span class="k">return</span> <span class="n">totalCars</span> <span class="o">&gt;=</span> <span class="n">cars</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: 4 mechanics with ranks [4,2,3,1], need to repair 10 cars</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ranks1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cars1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">repairCars</span><span class="o">(</span><span class="n">ranks1</span><span class="o">,</span> <span class="n">cars1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected result: 16"</span><span class="o">);</span>

        <span class="c1">// Test case 2: 3 mechanics with ranks [5,1,8], need to repair 6 cars</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ranks2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cars2</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">repairCars</span><span class="o">(</span><span class="n">ranks2</span><span class="o">,</span> <span class="n">cars2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected result: 16"</span><span class="o">);</span>

        <span class="c1">// Explanation for test case 2 - showing the optimal distribution of cars</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2 explanation:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"- The first mechanic (rank 5) repairs 1 car, taking 5 * 1 * 1 = 5 minutes."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"- The second mechanic (rank 1) repairs 4 cars, taking 1 * 4 * 4 = 16 minutes."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"- The third mechanic (rank 8) repairs 1 car, taking 8 * 1 * 1 = 8 minutes."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"16 minutes is the minimum time needed to repair all cars."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes. You are also given an integer cars representing the total number of cars waiting in the garage to be repaired. Return the minimum time taken to repair all the cars.** Note: All the mechanics can repair the cars simultaneously.]]></summary></entry></feed>