<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-31T01:58:03+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2278. Percentage of Letter in String</title><link href="https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString/" rel="alternate" type="text/html" title="2278. Percentage of Letter in String"/><published>2025-03-31T00:00:00+00:00</published><updated>2025-03-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a character <code class="language-plaintext highlighter-rouge">letter</code>, return <em>the <strong>percentage</strong> of characters in</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that equal</em> <code class="language-plaintext highlighter-rouge">letter</code> <em><strong>rounded down</strong> to the nearest whole percent.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "foobar", letter = "o"
Output: 33
Explanation:
The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "jjjj", letter = "k"
Output: 0
Explanation:
The percentage of characters in s that equal the letter 'k' is 0%, so we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PercentageOfLetterInString</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">percentageLetter</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">letter</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize counter to track letter occurrences</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Increment counter when matching letter is found</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">letter</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Calculate and return the percentage rounded down</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">count</span> <span class="o">*</span> <span class="mi">100</span><span class="o">)</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String with multiple occurrences of target letter</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"foobar"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter1</span> <span class="o">=</span> <span class="sc">'o'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">letter1</span><span class="o">));</span> <span class="c1">// Expected output: 33</span>

        <span class="c1">// Test Case 2: String without any occurrence of target letter</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"jjjj"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter2</span> <span class="o">=</span> <span class="sc">'k'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">letter2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 3: Additional test case with target letter 'e'</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"percentage"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter3</span> <span class="o">=</span> <span class="sc">'e'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">letter3</span><span class="o">));</span> <span class="c1">// Expected output: 30</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.]]></summary></entry><entry><title type="html">2109. Adding Spaces to a String</title><link href="https://zhengstar94.github.io//blog/2025/AddingSpacesToAString/" rel="alternate" type="text/html" title="2109. Adding Spaces to a String"/><published>2025-03-30T00:00:00+00:00</published><updated>2025-03-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AddingSpacesToAString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AddingSpacesToAString/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> string <code class="language-plaintext highlighter-rouge">s</code> and a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">spaces</code> that describes the indices in the original string where spaces will be added. Each space should be inserted <strong>before</strong> the character at the given index. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">s = "EnjoyYourCoffee"</code> and <code class="language-plaintext highlighter-rouge">spaces = [5, 9]</code>, we place spaces before <code class="language-plaintext highlighter-rouge">'Y'</code> and <code class="language-plaintext highlighter-rouge">'C'</code>, which are at indices <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">9</code> respectively. Thus, we obtain <code class="language-plaintext highlighter-rouge">"Enjoy **Y**our **C**offee"</code>.</li> </ul> </li> <li>Return <em>the modified string <strong>after</strong> the spaces have been added.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "LeetcodeHelpsMeLearn", spaces = [8,13,15]
Output: "Leetcode Helps Me Learn"
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in "LeetcodeHelpsMeLearn".
We then place spaces before those characters.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "icodeinpython", spaces = [1,5,7,9]
Output: "i code in py thon"
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in "icodeinpython".
We then place spaces before those characters.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "spacing", spaces = [0,1,2,3,4,5,6]
Output: " s p a c i n g"
Explanation:
We are also able to place spaces before the first character of the string.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddingSpacesToAString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">addSpaces</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize StringBuilder with optimal capacity to avoid resizing</span>
        <span class="nc">StringBuilder</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="n">spaces</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

        <span class="c1">// Counter for tracking the current position in spaces array</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if we need to add a space at current position</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">spaces</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">spaces</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">' '</span><span class="o">);</span>
                <span class="n">j</span><span class="o">++;</span> <span class="c1">// Move to next space position</span>
            <span class="o">}</span>
            <span class="c1">// Append the current character from input string</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Adding spaces in a camel case string</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"LeetcodeHelpsMeLearn"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">spaces1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Adding spaces in a lowercase string</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"icodeinpython"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">spaces2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Adding spaces between every character</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"spacing"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">spaces3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index. For example, given s="EnjoyYourCoffee" and spaces=[5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain "Enjoy **Y**our **C**offee". Return the modified string after the spaces have been added.]]></summary></entry><entry><title type="html">763. Partition Labels</title><link href="https://zhengstar94.github.io//blog/2025/PartitionLabels/" rel="alternate" type="text/html" title="763. Partition Labels"/><published>2025-03-30T00:00:00+00:00</published><updated>2025-03-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PartitionLabels</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PartitionLabels/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string <code class="language-plaintext highlighter-rouge">"ababcc"</code> can be partitioned into <code class="language-plaintext highlighter-rouge">["abab", "cc"]</code>, but partitions such as <code class="language-plaintext highlighter-rouge">["aba", "bcc"]</code> or <code class="language-plaintext highlighter-rouge">["ab", "ab", "cc"]</code> are invalid.</li> <li>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Return <em>a list of integers representing the size of these parts</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "eccbbbbdec"
Output: [10]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PartitionLabels</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">partitionLabels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the last position of each character (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">lastPos</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// First pass: Record the last occurrence of each character</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lastPos</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// List to store the sizes of partitions</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Variables to track partition boundaries</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Start index of current partition</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// End index of current partition</span>

        <span class="c1">// Second pass: Determine partition boundaries</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update the end position of current partition</span>
            <span class="c1">// by taking the maximum of current end and last occurrence of current character</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">lastPos</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]);</span>

            <span class="c1">// If we've reached the end of current partition</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Calculate partition size and add to result</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update start position for next partition</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String with multiple partitions</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"ababcbacadefegdehijhklij"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected output: [9,7,8]</span>

        <span class="c1">// Test Case 2: String with single partition</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"eccbbbbdec"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: [10]</span>

        <span class="c1">// Test Case 3: String where each character forms its own partition</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected output: [1,1,1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string "ababcc" can be partitioned into ["abab", "cc"], but partitions such as ["aba", "bcc"] or ["ab", "ab", "cc"] are invalid. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.]]></summary></entry><entry><title type="html">1023. Camelcase Matching</title><link href="https://zhengstar94.github.io//blog/2025/CamelcaseMatching/" rel="alternate" type="text/html" title="1023. Camelcase Matching"/><published>2025-03-28T00:00:00+00:00</published><updated>2025-03-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CamelcaseMatching</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CamelcaseMatching/"><![CDATA[<ul> <li>Given an array of strings <code class="language-plaintext highlighter-rouge">queries</code> and a string <code class="language-plaintext highlighter-rouge">pattern</code>, return a boolean array <code class="language-plaintext highlighter-rouge">answer</code> where <code class="language-plaintext highlighter-rouge">answer[i]</code> is <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">queries[i]</code> matches <code class="language-plaintext highlighter-rouge">pattern</code>, and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li> <li>A query word <code class="language-plaintext highlighter-rouge">queries[i]</code> matches <code class="language-plaintext highlighter-rouge">pattern</code> if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters <strong>at all</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
Output: [true,false,true,true,false]
Explanation: "FooBar" can be generated like this "F" + "oo" + "B" + "ar".
"FootBall" can be generated like this "F" + "oot" + "B" + "all".
"FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
Output: [true,false,true,false,false]
Explanation: "FooBar" can be generated like this "Fo" + "o" + "Ba" + "r".
"FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
Output: [false,true,false,false,false]
Explanation: "FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CamelcaseMatching</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="nf">camelMatch</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">queries</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize result list to store matching results</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Check each query string against the pattern</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">query:</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">isMatch</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="n">pattern</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">query</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize pattern pointer</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in query</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Case 1: Current characters match</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span> <span class="c1">// Move pattern pointer forward</span>
            <span class="o">}</span>
            <span class="c1">// Case 2: Current query character is uppercase but doesn't match</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">(</span><span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Uppercase must match pattern</span>
            <span class="o">}</span>
            <span class="c1">// Case 3: Current query character is lowercase and doesn't match</span>
            <span class="c1">// Simply continue to next character (implicit)</span>
        <span class="o">}</span>

        <span class="c1">// Return true only if we've matched all characters in pattern</span>
        <span class="k">return</span> <span class="n">j</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Pattern "FB"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">queries1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"FooBar"</span><span class="o">,</span><span class="s">"FooBarTest"</span><span class="o">,</span><span class="s">"FootBall"</span><span class="o">,</span><span class="s">"FrameBuffer"</span><span class="o">,</span><span class="s">"ForceFeedBack"</span><span class="o">};</span>
        <span class="nc">String</span> <span class="n">pattern1</span> <span class="o">=</span> <span class="s">"FB"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">camelMatch</span><span class="o">(</span><span class="n">queries1</span><span class="o">,</span> <span class="n">pattern1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test case 2: Pattern "FoBa"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">queries2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"FooBar"</span><span class="o">,</span><span class="s">"FooBarTest"</span><span class="o">,</span><span class="s">"FootBall"</span><span class="o">,</span><span class="s">"FrameBuffer"</span><span class="o">,</span><span class="s">"ForceFeedBack"</span><span class="o">};</span>
        <span class="nc">String</span> <span class="n">pattern2</span> <span class="o">=</span> <span class="s">"FoBa"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">camelMatch</span><span class="o">(</span><span class="n">queries2</span><span class="o">,</span> <span class="n">pattern2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test case 3: Pattern "FoBaT"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">queries3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"FooBar"</span><span class="o">,</span><span class="s">"FooBarTest"</span><span class="o">,</span><span class="s">"FootBall"</span><span class="o">,</span><span class="s">"FrameBuffer"</span><span class="o">,</span><span class="s">"ForceFeedBack"</span><span class="o">};</span>
        <span class="nc">String</span> <span class="n">pattern3</span> <span class="o">=</span> <span class="s">"FoBaT"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">camelMatch</span><span class="o">(</span><span class="n">queries3</span><span class="o">,</span> <span class="n">pattern3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise. A query word queries[i] matches pattern if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters at all.]]></summary></entry><entry><title type="html">2825. Make String a Subsequence Using Cyclic Increments</title><link href="https://zhengstar94.github.io//blog/2025/MakeStringASubsequenceUsingCyclicIncrements/" rel="alternate" type="text/html" title="2825. Make String a Subsequence Using Cyclic Increments"/><published>2025-03-27T00:00:00+00:00</published><updated>2025-03-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MakeStringASubsequenceUsingCyclicIncrements</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MakeStringASubsequenceUsingCyclicIncrements/"><![CDATA[<ul> <li>You are given two <strong>0-indexed</strong> strings <code class="language-plaintext highlighter-rouge">str1</code> and <code class="language-plaintext highlighter-rouge">str2</code>.</li> <li>In an operation, you select a <strong>set</strong> of indices in <code class="language-plaintext highlighter-rouge">str1</code>, and for each index <code class="language-plaintext highlighter-rouge">i</code> in the set, increment <code class="language-plaintext highlighter-rouge">str1[i]</code> to the next character <strong>cyclically</strong>. That is <code class="language-plaintext highlighter-rouge">'a'</code> becomes <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'b'</code> becomes <code class="language-plaintext highlighter-rouge">'c'</code>, and so on, and <code class="language-plaintext highlighter-rouge">'z'</code> becomes <code class="language-plaintext highlighter-rouge">'a'</code>.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to make</em> <code class="language-plaintext highlighter-rouge">str2</code> <em>a subsequence of</em> <code class="language-plaintext highlighter-rouge">str1</code> <em>by performing the operation <strong>at most once</strong></em>, <em>and</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> <li><strong>Note:</strong> A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: str1 = "abc", str2 = "ad"
Output: true
Explanation: Select index 2 in str1.
Increment str1[2] to become 'd'. 
Hence, str1 becomes "abd" and str2 is now a subsequence. Therefore, true is returned.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: str1 = "zc", str2 = "ad"
Output: true
Explanation: Select indices 0 and 1 in str1. 
Increment str1[0] to become 'a'. 
Increment str1[1] to become 'd'. 
Hence, str1 becomes "ad" and str2 is now a subsequence. Therefore, true is returned.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: str1 = "ab", str2 = "d"
Output: false
Explanation: In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once. 
Therefore, false is returned.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MakeStringASubsequenceUsingCyclicIncrements</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canMakeSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">str1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">str2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers: i for str1 and j for str2</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue while we haven't reached the end of either string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Calculate the next character after cyclic increment</span>
            <span class="c1">// For example: 'a' -&gt; 'b', 'b' -&gt; 'c', ..., 'z' -&gt; 'a'</span>
            <span class="c1">// Formula explanation:</span>
            <span class="c1">// 1. str1.charAt(i) - 'a': Convert char to 0-based index (0-25)</span>
            <span class="c1">// 2. + 1: Increment to next character</span>
            <span class="c1">// 3. % 26: Handle cyclic wrap-around ('z' -&gt; 'a')</span>
            <span class="c1">// 4. + 'a': Convert back to character</span>
            <span class="kt">char</span> <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)((</span><span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="mi">26</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">);</span>

            <span class="c1">// If current character in str1 matches str2</span>
            <span class="c1">// OR the next character after increment matches str2</span>
            <span class="c1">// then advance the j pointer</span>
            <span class="k">if</span><span class="o">(</span><span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">||</span> <span class="n">next</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Always advance the i pointer to check next character in str1</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Return true if we matched all characters in str2 (j reached the end)</span>
        <span class="k">return</span> <span class="n">j</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Should return true</span>
        <span class="c1">// We can change 'c' to 'd' to make "abd", which contains "ad"</span>
        <span class="nc">String</span> <span class="n">str1_1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str2_1</span> <span class="o">=</span> <span class="s">"ad"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">canMakeSubsequence</span><span class="o">(</span><span class="n">str1_1</span><span class="o">,</span> <span class="n">str2_1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Should return true</span>
        <span class="c1">// We can change 'z' to 'a' and 'c' to 'd' to make "ad"</span>
        <span class="nc">String</span> <span class="n">str1_2</span> <span class="o">=</span> <span class="s">"zc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str2_2</span> <span class="o">=</span> <span class="s">"ad"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">canMakeSubsequence</span><span class="o">(</span><span class="n">str1_2</span><span class="o">,</span> <span class="n">str2_2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Should return false</span>
        <span class="c1">// Cannot make "d" a subsequence with just one increment operation</span>
        <span class="nc">String</span> <span class="n">str1_3</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str2_3</span> <span class="o">=</span> <span class="s">"d"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">canMakeSubsequence</span><span class="o">(</span><span class="n">str1_3</span><span class="o">,</span> <span class="n">str2_3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two 0-indexed strings str1 and str2. In an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'. Return true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise. Note: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.]]></summary></entry><entry><title type="html">2486. Append Characters to String to Make Subsequence</title><link href="https://zhengstar94.github.io//blog/2025/AppendCharactersToStringToMakeSubsequence/" rel="alternate" type="text/html" title="2486. Append Characters to String to Make Subsequence"/><published>2025-03-26T00:00:00+00:00</published><updated>2025-03-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AppendCharactersToStringToMakeSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AppendCharactersToStringToMakeSubsequence/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> consisting of only lowercase English letters.</li> <li>Return <em>the minimum number of characters that need to be appended to the end of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>so that</em> <code class="language-plaintext highlighter-rouge">t</code> <em>becomes a <strong>subsequence</strong> of</em> <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "coaching", t = "coding"
Output: 4
Explanation: Append the characters "ding" to the end of s so that s = "coachingding".
Now, t is a subsequence of s ("coachingding").
It can be shown that appending any 3 characters to the end of s will never make t a subsequence.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcde", t = "a"
Output: 0
Explanation: t is already a subsequence of s ("abcde").
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "z", t = "abcde"
Output: 5
Explanation: Append the characters "abcde" to the end of s so that s = "zabcde".
Now, t is a subsequence of s ("zabcde").
It can be shown that appending any 4 characters to the end of s will never make t a subsequence.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppendCharactersToStringToMakeSubsequence</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">appendCharacters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers, i for string s and j for string t</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Loop until we reach the end of either string s or string t</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// If the current characters of s and t match</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Move the pointer j to the next character in t</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Always move the pointer i to the next character in s</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// The number of characters that need to be appended is the remaining characters in t</span>
        <span class="c1">// that have not been matched, which is t.length() - j</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"coaching"</span><span class="o">;</span> <span class="c1">// Original string</span>
        <span class="nc">String</span> <span class="n">t1</span> <span class="o">=</span> <span class="s">"coding"</span><span class="o">;</span>   <span class="c1">// Target string</span>
        <span class="c1">// Output the result of the appendCharacters method</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 1 Output: "</span> <span class="o">+</span> <span class="n">appendCharacters</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">t1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span> <span class="c1">// Original string</span>
        <span class="nc">String</span> <span class="n">t2</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>     <span class="c1">// Target string</span>
        <span class="c1">// Output the result of the appendCharacters method</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 2 Output: "</span> <span class="o">+</span> <span class="n">appendCharacters</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">t2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"z"</span><span class="o">;</span>     <span class="c1">// Original string</span>
        <span class="nc">String</span> <span class="n">t3</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span> <span class="c1">// Target string</span>
        <span class="c1">// Output the result of the appendCharacters method</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 3 Output: "</span> <span class="o">+</span> <span class="n">appendCharacters</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">t3</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two strings s and t consisting of only lowercase English letters. Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.]]></summary></entry><entry><title type="html">392. Is Subsequence</title><link href="https://zhengstar94.github.io//blog/2025/IsSubsequence/" rel="alternate" type="text/html" title="392. Is Subsequence"/><published>2025-03-23T00:00:00+00:00</published><updated>2025-03-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/IsSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/IsSubsequence/"><![CDATA[<ul> <li>Given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if</em> <code class="language-plaintext highlighter-rouge">s</code> <em>is a <strong>subsequence</strong> of</em> <code class="language-plaintext highlighter-rouge">t</code><em>, or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> <li>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code class="language-plaintext highlighter-rouge">"ace"</code> is a subsequence of <code class="language-plaintext highlighter-rouge">"abcde"</code> while <code class="language-plaintext highlighter-rouge">"aec"</code> is not).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc", t = "ahbgdc"
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "axc", t = "ahbgdc"
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IsSubsequence</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle null input cases - if either string is null, return false</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Empty source string is always a subsequence</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If source string is longer than target, it can't be a subsequence</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize two pointers: one for source string s and one for target string t</span>
        <span class="kt">int</span> <span class="n">sIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Pointer for string s</span>
        <span class="kt">int</span> <span class="n">tIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Pointer for string t</span>

        <span class="c1">// Traverse both strings using the two pointers</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">sIndex</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">tIndex</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="c1">// If characters match, move source pointer forward</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sIndex</span><span class="o">)</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">tIndex</span><span class="o">)){</span>
                <span class="n">sIndex</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Always move target pointer forward</span>
            <span class="n">tIndex</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// If we've matched all characters in s, sIndex will equal s.length()</span>
        <span class="k">return</span> <span class="n">sIndex</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case with expected output true</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t1</span> <span class="o">=</span> <span class="s">"ahbgdc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">isSubsequence</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">t1</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 2: Normal case with expected output false</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"axc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t2</span> <span class="o">=</span> <span class="s">"ahbgdc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">isSubsequence</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">t2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 3: Empty source string</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t3</span> <span class="o">=</span> <span class="s">"ahbgdc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Empty String Test Result: "</span> <span class="o">+</span> <span class="n">isSubsequence</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">t3</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 4: Empty target string</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">t4</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Empty Target String Test Result: "</span> <span class="o">+</span> <span class="n">isSubsequence</span><span class="o">(</span><span class="n">s4</span><span class="o">,</span> <span class="n">t4</span><span class="o">));</span> <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Easy"/><category term="TwoPointers"/><summary type="html"><![CDATA[Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).]]></summary></entry><entry><title type="html">524. Longest Word in Dictionary through Deleting</title><link href="https://zhengstar94.github.io//blog/2025/LongestWordInDictionaryThroughDeleting/" rel="alternate" type="text/html" title="524. Longest Word in Dictionary through Deleting"/><published>2025-03-23T00:00:00+00:00</published><updated>2025-03-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestWordInDictionaryThroughDeleting</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestWordInDictionaryThroughDeleting/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a string array <code class="language-plaintext highlighter-rouge">dictionary</code>, return <em>the longest string in the dictionary that can be formed by deleting some of the given string characters</em>. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s= "abpoplea", dictionary = ["ale", "apple", "monkey", "plea"] 
Output: "apple"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abpcplea", dictionary = [a,"b","c"］ 
Output: "a"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * x) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestWordInDictionaryThroughDeleting</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">findLongestWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize result string to store the longest valid word found</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

        <span class="c1">// Iterate through each word in the dictionary</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">word:</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if current word is a subsequence of input string</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isSubsequence</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">word</span><span class="o">)){</span>
                <span class="c1">// Update result if current word is longer or</span>
                <span class="c1">// has same length but lexicographically smaller</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)){</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">word</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">source</span><span class="o">,</span> <span class="nc">String</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers for source and target strings</span>
        <span class="kt">int</span> <span class="n">sourceIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Pointer for source string</span>
        <span class="kt">int</span> <span class="n">targetIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Pointer for target string</span>

        <span class="c1">// Traverse both strings simultaneously</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">sourceIndex</span> <span class="o">&lt;</span> <span class="n">source</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">targetIndex</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="c1">// If characters match, move target pointer forward</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">source</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sourceIndex</span><span class="o">)</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">targetIndex</span><span class="o">)){</span>
                <span class="n">targetIndex</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Always move source pointer forward</span>
            <span class="n">sourceIndex</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="c1">// If we've matched all characters in target, targetIndex will equal target.length()</span>
        <span class="k">return</span> <span class="n">targetIndex</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case with expected output "apple"</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abpcplea"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dictionary1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"ale"</span><span class="o">,</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"monkey"</span><span class="o">,</span> <span class="s">"plea"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">findLongestWord</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">dictionary1</span><span class="o">));</span> <span class="c1">// Expected: "apple"</span>

        <span class="c1">// Test Case 2: Case with single character words</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abpcplea"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dictionary2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">findLongestWord</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">dictionary2</span><span class="o">));</span> <span class="c1">// Expected: "a"</span>

        <span class="c1">// Test Case 3: Complex case with longer strings</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aewfafwafjlwajflwajflwafj"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dictionary3</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"ewaf"</span><span class="o">,</span> <span class="s">"awefawfwaf"</span><span class="o">,</span> <span class="s">"awef"</span><span class="o">,</span> <span class="s">"awefe"</span><span class="o">,</span> <span class="s">"ewafeffewafewf"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">findLongestWord</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">dictionary3</span><span class="o">));</span> <span class="c1">// Tests complex scenario</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.]]></summary></entry><entry><title type="html">Interview Question 16.06. Smallest Difference</title><link href="https://zhengstar94.github.io//blog/2025/SmallestDifference/" rel="alternate" type="text/html" title="Interview Question 16.06. Smallest Difference"/><published>2025-03-21T00:00:00+00:00</published><updated>2025-03-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SmallestDifference</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SmallestDifference/"><![CDATA[<ul> <li>Given two arrays of integers a and b, compute the pair of values (one value in each array) with the smallest non-negative difference. Return the difference.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: a = {1, 3, 15, 11, 2}, b = {23, 127, 235, 19, 8} 
Output: 3 Explanation: The pair (11, 8) has the smallest difference of 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn + mlogm) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqTwoPointers</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SmallestDifference</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">smallestDifference</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort both arrays to enable two-pointer approach</span>
        <span class="c1">// Time complexity: O(nlogn + mlogm)</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>

        <span class="c1">// Initialize two pointers, one for each array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for array a</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for array b</span>

        <span class="c1">// Use long to prevent integer overflow when calculating differences</span>
        <span class="kt">long</span> <span class="n">minDiff</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Continue until we reach the end of either array</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate absolute difference between current elements</span>
            <span class="c1">// Cast to long to prevent overflow during subtraction</span>
            <span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">b</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>

            <span class="c1">// Update minimum difference if current difference is smaller</span>
            <span class="n">minDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minDiff</span><span class="o">,</span> <span class="n">diff</span><span class="o">);</span>

            <span class="c1">// Move pointers based on comparison of current elements</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// If current element in a is smaller, move pointer i</span>
                <span class="c1">// to try to get closer to b[j]</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// If current element in b is smaller, move pointer j</span>
                <span class="c1">// to try to get closer to a[i]</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If elements are equal, we found the minimum possible difference (0)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Cast the result back to int as per problem requirement</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">minDiff</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case with positive numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">127</span><span class="o">,</span> <span class="mi">235</span><span class="o">,</span> <span class="mi">19</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">smallestDifference</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">));</span>  <span class="c1">// Expected: 3</span>

        <span class="c1">// Test Case 2: Arrays containing same number</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">smallestDifference</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">));</span>  <span class="c1">// Expected: 0</span>

        <span class="c1">// Test Case 3: Edge case with maximum integer values</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a3</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b3</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">smallestDifference</span><span class="o">(</span><span class="n">a3</span><span class="o">,</span> <span class="n">b3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Edge case with empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a4</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">smallestDifference</span><span class="o">(</span><span class="n">a4</span><span class="o">,</span> <span class="n">b4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqTwoPointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[Given two arrays of integers a and b, compute the pair of values (one value in each array) with the smallest non-negative difference. Return the difference.]]></summary></entry><entry><title type="html">2337. Move Pieces to Obtain a String</title><link href="https://zhengstar94.github.io//blog/2025/MovePiecesToObtainAString/" rel="alternate" type="text/html" title="2337. Move Pieces to Obtain a String"/><published>2025-03-19T00:00:00+00:00</published><updated>2025-03-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MovePiecesToObtainAString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MovePiecesToObtainAString/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">target</code>, both of length <code class="language-plaintext highlighter-rouge">n</code>. Each string consists <strong>only</strong> of the characters <code class="language-plaintext highlighter-rouge">'L'</code>, <code class="language-plaintext highlighter-rouge">'R'</code>, and <code class="language-plaintext highlighter-rouge">'_'</code> where: <ul> <li>The characters <code class="language-plaintext highlighter-rouge">'L'</code> and <code class="language-plaintext highlighter-rouge">'R'</code> represent pieces, where a piece <code class="language-plaintext highlighter-rouge">'L'</code> can move to the <strong>left</strong> only if there is a <strong>blank</strong> space directly to its left, and a piece <code class="language-plaintext highlighter-rouge">'R'</code> can move to the <strong>right</strong> only if there is a <strong>blank</strong> space directly to its right.</li> <li>The character <code class="language-plaintext highlighter-rouge">'_'</code> represents a blank space that can be occupied by <strong>any</strong> of the <code class="language-plaintext highlighter-rouge">'L'</code> or <code class="language-plaintext highlighter-rouge">'R'</code> pieces.</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to obtain the string</em> <code class="language-plaintext highlighter-rouge">target</code> <em>by moving the pieces of the string</em> <code class="language-plaintext highlighter-rouge">start</code> <em><strong>any</strong> number of times</em>. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: start = "_L__R__R_", target = "L______RR"
Output: true
Explanation: We can obtain the string target from start by doing the following moves:
- Move the first piece one step to the left, start becomes equal to "L___R__R_".
- Move the last piece one step to the right, start becomes equal to "L___R___R".
- Move the second piece three steps to the right, start becomes equal to "L______RR".
Since it is possible to get the string target from start, we return true.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: start = "R_L_", target = "__LR"
Output: false
Explanation: The 'R' piece in the string start can move one step to the right to obtain "_RL_".
After that, no pieces can move anymore, so it is impossible to obtain the string target from start.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: start = "_R", target = "R_"
Output: false
Explanation: The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqTwoPointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MovePiecesToObtainAString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canChange</span><span class="o">(</span><span class="nc">String</span> <span class="n">start</span><span class="o">,</span> <span class="nc">String</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// First check: Compare strings after removing all '_' characters</span>
        <span class="c1">// They must be identical to have any chance of transformation</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">start</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"_"</span><span class="o">,</span> <span class="s">""</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"_"</span><span class="o">,</span> <span class="s">""</span><span class="o">)))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Use two pointers to compare non-'_' characters' relative positions</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">start</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Skip '_' characters in start string</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'_'</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Skip '_' characters in target string</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'_'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Check if movement is valid:</span>
            <span class="c1">// 'L' cannot move right (i &lt; j)</span>
            <span class="c1">// 'R' cannot move left (i &gt; j)</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">start</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'L'</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'R'</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">j</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Valid transformation</span>
        <span class="nc">String</span> <span class="n">start1</span> <span class="o">=</span> <span class="s">"_L__R__R_"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">target1</span> <span class="o">=</span> <span class="s">"L______RR"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Output: "</span> <span class="o">+</span> <span class="n">canChange</span><span class="o">(</span><span class="n">start1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test Case 2: Invalid transformation - crossing characters</span>
        <span class="nc">String</span> <span class="n">start2</span> <span class="o">=</span> <span class="s">"R_L_"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">target2</span> <span class="o">=</span> <span class="s">"__LR"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Output: "</span> <span class="o">+</span> <span class="n">canChange</span><span class="o">(</span><span class="n">start2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test Case 3: Invalid transformation - wrong movement</span>
        <span class="nc">String</span> <span class="n">start3</span> <span class="o">=</span> <span class="s">"_R"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">target3</span> <span class="o">=</span> <span class="s">"R_"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Output: "</span> <span class="o">+</span> <span class="n">canChange</span><span class="o">(</span><span class="n">start3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span> <span class="c1">// Expected: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqTwoPointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where: The characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, and a piece 'R' can move to the right only if there is a blank space directly to its right. The character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces. Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.]]></summary></entry></feed>