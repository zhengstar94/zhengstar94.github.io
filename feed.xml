<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-04T01:25:39+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1128. Number of Equivalent Domino Pairs</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfEquivalentDominoPairs/" rel="alternate" type="text/html" title="1128. Number of Equivalent Domino Pairs"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfEquivalentDominoPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfEquivalentDominoPairs/"><![CDATA[<ul> <li>Given a list of <code class="language-plaintext highlighter-rouge">dominoes</code>, <code class="language-plaintext highlighter-rouge">dominoes[i] = [a, b]</code> is <strong>equivalent to</strong> <code class="language-plaintext highlighter-rouge">dominoes[j] = [c, d]</code> if and only if either (<code class="language-plaintext highlighter-rouge">a == c</code> and <code class="language-plaintext highlighter-rouge">b == d</code>), or (<code class="language-plaintext highlighter-rouge">a == d</code> and <code class="language-plaintext highlighter-rouge">b == c</code>) - that is, one domino can be rotated to be equal to another domino.</li> <li>Return <em>the number of pairs</em> <code class="language-plaintext highlighter-rouge">(i, j)</code> <em>for which</em> <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; dominoes.length</code><em>, and</em> <code class="language-plaintext highlighter-rouge">dominoes[i]</code> <em>is <strong>equivalent to</strong></em> <code class="language-plaintext highlighter-rouge">dominoes[j]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: dominoes = [ [ 1,2],[2,1],[3,4],[5,6 ] ]
Output: 1
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: dominoes = [ [ 1,2],[1,2],[1,1],[1,2],[2,2 ] ]
Output: 3
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfEquivalentDominoPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numEquivDominoPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store the count of each unique domino type</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Counter for the total number of equivalent pairs</span>
        <span class="kt">int</span> <span class="n">pairs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each domino in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">domino</span> <span class="o">:</span> <span class="n">dominoes</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Create a unique hash value for each domino, ensuring equivalent dominoes have the same hash</span>
            <span class="c1">// We use min*10 + max to ensure [a,b] and [b,a] get the same hash value</span>
            <span class="c1">// This works because in this problem, domino values are between 1-9</span>
            <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">domino</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">domino</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">domino</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">domino</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

            <span class="c1">// Get the current count of dominoes with the same hash value (same type)</span>
            <span class="c1">// If this is the first time we see this type, getOrDefault returns 0</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// The current domino can form a pair with each previously seen domino of the same type</span>
            <span class="c1">// So we add the current count to our running total of pairs</span>
            <span class="n">pairs</span> <span class="o">+=</span> <span class="n">count</span><span class="o">;</span>

            <span class="c1">// Update the count of this domino type in our map</span>
            <span class="c1">// We increment by 1 to account for the current domino</span>
            <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of equivalent domino pairs found</span>
        <span class="k">return</span> <span class="n">pairs</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Should return 1 pair</span>
        <span class="c1">// [1,2] and [2,1] are equivalent</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">numEquivDominoPairs</span><span class="o">(</span><span class="n">dominoes1</span><span class="o">));</span> <span class="c1">// Should output 1</span>

        <span class="c1">// Test case 2: Should return 3 pairs</span>
        <span class="c1">// The pairs are: ( [ 1,2], [1,2]), ([1,2], [1,2]), ([1,2], [1,2 ] )</span>
        <span class="c1">// Note: These are the pairs at indices (0,1), (0,3), and (1,3)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">numEquivDominoPairs</span><span class="o">(</span><span class="n">dominoes2</span><span class="o">));</span> <span class="c1">// Should output 3</span>

        <span class="c1">// Additional test case: Should return 4 pairs</span>
        <span class="c1">// The pairs are:</span>
        <span class="c1">// ( [ 1,1], [1,1]), ([1,1], [1,1]), ([1,1], [1,1]), ([1,2], [1,2 ] )</span>
        <span class="c1">// These are the pairs at indices (0,2), (0,5), (2,5), and (3,4)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">numEquivDominoPairs</span><span class="o">(</span><span class="n">dominoes3</span><span class="o">));</span> <span class="c1">// Should output 4</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b== d), or (a == d and b== c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j].]]></summary></entry><entry><title type="html">1007. Minimum Domino Rotations For Equal Row</title><link href="https://zhengstar94.github.io//blog/2025/MinimumDominoRotationsForEqualRow/" rel="alternate" type="text/html" title="1007. Minimum Domino Rotations For Equal Row"/><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumDominoRotationsForEqualRow</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumDominoRotationsForEqualRow/"><![CDATA[<ul> <li>In a row of dominoes, <code class="language-plaintext highlighter-rouge">tops[i]</code> and <code class="language-plaintext highlighter-rouge">bottoms[i]</code> represent the top and bottom halves of the <code class="language-plaintext highlighter-rouge">ith</code> domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)</li> <li>We may rotate the <code class="language-plaintext highlighter-rouge">ith</code> domino, so that <code class="language-plaintext highlighter-rouge">tops[i]</code> and <code class="language-plaintext highlighter-rouge">bottoms[i]</code> swap values.</li> <li>Return the minimum number of rotations so that all the values in <code class="language-plaintext highlighter-rouge">tops</code> are the same, or all the values in <code class="language-plaintext highlighter-rouge">bottoms</code> are the same.</li> <li>If it cannot be done, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]
Output: 2
Explanation: 
The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.
If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]
Output: -1
Explanation: 
In this case, it is not possible to rotate the dominoes to make one row of values equal.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumDominoRotationsForEqualRow</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minDominoRotations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tops</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// We only need to check two potential target values: tops[0] and bottoms[0]</span>
        <span class="c1">// This is because if a solution exists, the target value must appear in the first domino</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                <span class="n">minRot</span><span class="o">(</span><span class="n">tops</span><span class="o">,</span> <span class="n">bottoms</span><span class="o">,</span> <span class="n">tops</span><span class="o">[</span><span class="mi">0</span><span class="o">]),</span>     <span class="c1">// Try to make all tops or bottoms equal to tops[0]</span>
                <span class="n">minRot</span><span class="o">(</span><span class="n">tops</span><span class="o">,</span> <span class="n">bottoms</span><span class="o">,</span> <span class="n">bottoms</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>   <span class="c1">// Try to make all tops or bottoms equal to bottoms[0]</span>
        <span class="o">);</span>

        <span class="c1">// If both attempts returned Integer.MAX_VALUE, it means no solution exists</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minRot</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tops</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">toTop</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// Count of rotations needed to make all tops equal to target</span>
        <span class="kt">int</span> <span class="n">toBottom</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Count of rotations needed to make all bottoms equal to target</span>

        <span class="c1">// Iterate through each domino</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tops</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">tops</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>    <span class="c1">// Current top value</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bottoms</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Current bottom value</span>

            <span class="c1">// If neither the top nor bottom is the target value, it's impossible to achieve our goal</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If top is not the target value, we need one rotation to make tops[i] = target</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">toTop</span><span class="o">++;</span>    <span class="c1">// Increment the count for making all tops the target</span>
            <span class="o">}</span>
            <span class="c1">// If bottom is not the target value, we need one rotation to make bottoms[i] = target</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">toBottom</span><span class="o">++;</span> <span class="c1">// Increment the count for making all bottoms the target</span>
            <span class="o">}</span>
            <span class="c1">// If both are the target value, no rotation is needed for this domino</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum of the two approaches:</span>
        <span class="c1">// 1. Make all tops the target value</span>
        <span class="c1">// 2. Make all bottoms the target value</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">toTop</span><span class="o">,</span> <span class="n">toBottom</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tops1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">minDominoRotations</span><span class="o">(</span><span class="n">tops1</span><span class="o">,</span> <span class="n">bottoms1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tops2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: -1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">minDominoRotations</span><span class="o">(</span><span class="n">tops2</span><span class="o">,</span> <span class="n">bottoms2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tops3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">bottoms3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: tops = [1,2,1,1,1,2,2,2], bottoms = [2,1,2,2,2,2,2,2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">minDominoRotations</span><span class="o">(</span><span class="n">tops3</span><span class="o">,</span> <span class="n">bottoms3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the ith domino, so that tops[i] and bottoms[i] swap values. Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same. If it cannot be done, return -1.]]></summary></entry><entry><title type="html">2594. Minimum Time to Repair Cars</title><link href="https://zhengstar94.github.io//blog/2025/MinimumTimeToRepairCars/" rel="alternate" type="text/html" title="2594. Minimum Time to Repair Cars"/><published>2025-05-01T00:00:00+00:00</published><updated>2025-05-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumTimeToRepairCars</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumTimeToRepairCars/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">ranks</code> representing the <strong>ranks</strong> of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank <code class="language-plaintext highlighter-rouge">r</code> can repair n cars in <code class="language-plaintext highlighter-rouge">r * n2</code> minutes.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">cars</code> representing the total number of cars waiting in the garage to be repaired.</li> <li>Return <em>the <strong>minimum</strong> time taken to repair all the cars.</em>**</li> <li><strong>Note:</strong> All the mechanics can repair the cars simultaneously.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: ranks = [4,2,3,1], cars = 10
Output: 16
Explanation: 
- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.
- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.
- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.
- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: ranks = [5,1,8], cars = 6
Output: 16
Explanation: 
- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.
- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(R * C²)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMinimum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumTimeToRepairCars</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">repairCars</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ranks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the lower bound of our search range to 1</span>
        <span class="c1">// The minimum possible time cannot be less than 1</span>
        <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Initialize the upper bound of our search range</span>
        <span class="c1">// We calculate an upper bound that is guaranteed to be larger than the answer</span>
        <span class="c1">// Formula: rank * cars^2 represents the time needed if one mechanic repairs all cars</span>
        <span class="c1">// Using ranks[0] gives us a sufficient upper bound, even if it's not the maximum rank</span>
        <span class="c1">// This is a key optimization: we only need a value that's larger than the actual answer</span>
        <span class="kt">long</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">ranks</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="n">cars</span> <span class="o">*</span> <span class="n">cars</span><span class="o">;</span>

        <span class="c1">// Perform binary search to find the minimum possible time</span>
        <span class="c1">// The search continues until left and right pointers converge</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle point, avoiding potential overflow with this formula</span>
            <span class="kt">long</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if all cars can be repaired within 'mid' time</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canRepairAll</span><span class="o">(</span><span class="n">ranks</span><span class="o">,</span> <span class="n">cars</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If possible to repair within 'mid' time, try a smaller time</span>
                <span class="c1">// We don't exclude 'mid' because it might be the answer</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If not possible to repair within 'mid' time, we need more time</span>
                <span class="c1">// Exclude 'mid' as it's definitely not enough time</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found our answer</span>
        <span class="c1">// This is the minimum time needed to repair all cars</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canRepairAll</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ranks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cars</span><span class="o">,</span> <span class="kt">long</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Track the total number of cars that can be repaired within the time limit</span>
        <span class="kt">long</span> <span class="n">totalCars</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each mechanic's rank to calculate their contribution</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">rank</span> <span class="o">:</span> <span class="n">ranks</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each mechanic with efficiency rank 'rank':</span>
            <span class="c1">// The time to repair n cars is: time = rank * n^2</span>
            <span class="c1">// Solving for n: n = sqrt(time/rank)</span>
            <span class="c1">// This gives us the maximum number of cars this mechanic can repair in the given time</span>

            <span class="c1">// Calculate how many cars this mechanic can repair</span>
            <span class="c1">// The cast to long ensures we don't lose precision in the square root calculation</span>
            <span class="kt">long</span> <span class="n">carsPerMechanic</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">time</span> <span class="o">/</span> <span class="n">rank</span><span class="o">);</span>

            <span class="c1">// Add this mechanic's contribution to the total</span>
            <span class="n">totalCars</span> <span class="o">+=</span> <span class="n">carsPerMechanic</span><span class="o">;</span>

            <span class="c1">// Early termination optimization:</span>
            <span class="c1">// If we've already found that enough cars can be repaired, return immediately</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">totalCars</span> <span class="o">&gt;=</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Final check: can all mechanics combined repair enough cars?</span>
        <span class="c1">// This will only be reached if the early termination condition above wasn't triggered</span>
        <span class="k">return</span> <span class="n">totalCars</span> <span class="o">&gt;=</span> <span class="n">cars</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: 4 mechanics with ranks [4,2,3,1], need to repair 10 cars</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ranks1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cars1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">repairCars</span><span class="o">(</span><span class="n">ranks1</span><span class="o">,</span> <span class="n">cars1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected result: 16"</span><span class="o">);</span>

        <span class="c1">// Test case 2: 3 mechanics with ranks [5,1,8], need to repair 6 cars</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ranks2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cars2</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">repairCars</span><span class="o">(</span><span class="n">ranks2</span><span class="o">,</span> <span class="n">cars2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected result: 16"</span><span class="o">);</span>

        <span class="c1">// Explanation for test case 2 - showing the optimal distribution of cars</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2 explanation:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"- The first mechanic (rank 5) repairs 1 car, taking 5 * 1 * 1 = 5 minutes."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"- The second mechanic (rank 1) repairs 4 cars, taking 1 * 4 * 4 = 16 minutes."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"- The third mechanic (rank 8) repairs 1 car, taking 8 * 1 * 1 = 8 minutes."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"16 minutes is the minimum time needed to repair all cars."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes. You are also given an integer cars representing the total number of cars waiting in the garage to be repaired. Return the minimum time taken to repair all the cars.** Note: All the mechanics can repair the cars simultaneously.]]></summary></entry><entry><title type="html">1295. Find Numbers with Even Number of Digits</title><link href="https://zhengstar94.github.io//blog/2025/FindNumbersWithEvenNumberOfDigits/" rel="alternate" type="text/html" title="1295. Find Numbers with Even Number of Digits"/><published>2025-04-30T00:00:00+00:00</published><updated>2025-04-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindNumbersWithEvenNumberOfDigits</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindNumbersWithEvenNumberOfDigits/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code> of integers, return how many of them contain an <strong>even number</strong> of digits.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindNumbersWithEvenNumberOfDigits</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Counter to keep track of numbers with even digits</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in array</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Convert number to string and check if length is even</span>
            <span class="c1">// If even, increment counter</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">num</span><span class="o">).</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1 demonstration</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span><span class="mi">345</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7896</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">findNumbers</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 2 demonstration</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">555</span><span class="o">,</span><span class="mi">901</span><span class="o">,</span><span class="mi">482</span><span class="o">,</span><span class="mi">1771</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">findNumbers</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array nums of integers, return how many of them contain an even number of digits.]]></summary></entry><entry><title type="html">1011. Capacity To Ship Packages Within D Days</title><link href="https://zhengstar94.github.io//blog/2025/CapacityToShipPackagesWithinDDays/" rel="alternate" type="text/html" title="1011. Capacity To Ship Packages Within D Days"/><published>2025-04-29T00:00:00+00:00</published><updated>2025-04-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CapacityToShipPackagesWithinDDays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CapacityToShipPackagesWithinDDays/"><![CDATA[<ul> <li>A conveyor belt has packages that must be shipped from one port to another within <code class="language-plaintext highlighter-rouge">days</code> days.</li> <li>The <code class="language-plaintext highlighter-rouge">ith</code> package on the conveyor belt has a weight of <code class="language-plaintext highlighter-rouge">weights[i]</code>. Each day, we load the ship with packages on the conveyor belt (in the order given by <code class="language-plaintext highlighter-rouge">weights</code>). We may not load more weight than the maximum weight capacity of the ship.</li> <li>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within <code class="language-plaintext highlighter-rouge">days</code> days.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: weights = [3,2,2,4,1,4], days = 3
Output: 6
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: weights = [1,2,3,1,1], days = 4
Output: 3
Explanation:
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(sum-max)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMinimum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CapacityToShipPackagesWithinDDays</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">shipWithinDays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">weights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">days</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize binary search boundaries</span>
        <span class="c1">// left = maximum single package weight (minimum possible capacity)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">weights</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
        <span class="c1">// right = sum of all weights (maximum possible capacity)</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">weights</span><span class="o">).</span><span class="na">sum</span><span class="o">();</span>

        <span class="c1">// Binary search to find minimum capacity</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="c1">// Calculate middle point avoiding overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If current capacity is feasible, try lower capacity</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canShipWithinDays</span><span class="o">(</span><span class="n">weights</span><span class="o">,</span> <span class="n">days</span><span class="o">,</span> <span class="n">mid</span><span class="o">)){</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current capacity is not enough, need higher capacity</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the minimum feasible capacity</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canShipWithinDays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">weights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">days</span><span class="o">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Start with day 1</span>
        <span class="kt">int</span> <span class="n">currentDays</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Track current day's load</span>
        <span class="kt">int</span> <span class="n">currentLoad</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Process each package</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">weight:</span> <span class="n">weights</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If adding current package exceeds capacity</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">currentLoad</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">){</span>
                <span class="c1">// Move to next day</span>
                <span class="n">currentDays</span><span class="o">++;</span>
                <span class="c1">// Start new day with current package</span>
                <span class="n">currentLoad</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>

                <span class="c1">// If exceeded allowed days, return false</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">currentDays</span> <span class="o">&gt;</span> <span class="n">days</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// Add package to current day's load</span>
                <span class="n">currentLoad</span> <span class="o">+=</span> <span class="n">weight</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return true if all packages processed within allowed days</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple packages with sequential weights</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">weights1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">days1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span>
                <span class="n">shipWithinDays</span><span class="o">(</span><span class="n">weights1</span><span class="o">,</span> <span class="n">days1</span><span class="o">));</span>  <span class="c1">// Expected output: 15</span>

        <span class="c1">// Test Case 2: Mixed weights with shorter duration</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">weights2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">days2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span>
                <span class="n">shipWithinDays</span><span class="o">(</span><span class="n">weights2</span><span class="o">,</span> <span class="n">days2</span><span class="o">));</span>  <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test Case 3: Small weights with more days</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">weights3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">days3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span>
                <span class="n">shipWithinDays</span><span class="o">(</span><span class="n">weights3</span><span class="o">,</span> <span class="n">days3</span><span class="o">));</span>  <span class="c1">// Expected output: 3</span>

        <span class="c1">// Detailed explanation of Test Case 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nShipping plan for Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"With capacity 15:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Day 1: 1,2,3,4,5 (total=15)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Day 2: 6,7 (total=13)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Day 3: 8 (total=8)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Day 4: 9 (total=9)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Day 5: 10 (total=10)"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[A conveyor belt has packages that must be shipped from one port to another within days days. The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.]]></summary></entry><entry><title type="html">2187. Minimum Time to Complete Trips</title><link href="https://zhengstar94.github.io//blog/2025/MinimumTimeToCompleteTrips/" rel="alternate" type="text/html" title="2187. Minimum Time to Complete Trips"/><published>2025-04-29T00:00:00+00:00</published><updated>2025-04-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumTimeToCompleteTrips</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumTimeToCompleteTrips/"><![CDATA[<ul> <li>You are given an array <code class="language-plaintext highlighter-rouge">time</code> where <code class="language-plaintext highlighter-rouge">time[i]</code> denotes the time taken by the <code class="language-plaintext highlighter-rouge">ith</code> bus to complete <strong>one trip</strong>.</li> <li>Each bus can make multiple trips <strong>successively</strong>; that is, the next trip can start <strong>immediately after</strong> completing the current trip. Also, each bus operates <strong>independently</strong>; that is, the trips of one bus do not influence the trips of any other bus.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">totalTrips</code>, which denotes the number of trips all buses should make <strong>in total</strong>. Return <em>the <strong>minimum time</strong> required for all buses to complete <strong>at least</strong></em> <code class="language-plaintext highlighter-rouge">totalTrips</code> <em>trips</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [1,2,3], totalTrips = 5
Output: 3
Explanation:
- At time t = 1, the number of trips completed by each bus are [1,0,0]. 
  The total number of trips completed is 1 + 0 + 0 = 1.
- At time t = 2, the number of trips completed by each bus are [2,1,0]. 
  The total number of trips completed is 2 + 1 + 0 = 3.
- At time t = 3, the number of trips completed by each bus are [3,1,1]. 
  The total number of trips completed is 3 + 1 + 1 = 5.
So the minimum time needed for all buses to complete at least 5 trips is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [2], totalTrips = 1
Output: 2
Explanation:
There is only one bus, and it will complete its first trip at t = 2.
So the minimum time needed to complete 1 trip is 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(min(time) * totalTrips)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMinimum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumTimeToCompleteTrips</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">minimumTime</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">,</span> <span class="kt">int</span> <span class="n">totalTrips</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize left pointer to minimum possible time</span>
        <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Initialize right pointer to maximum possible time</span>
        <span class="c1">// right = minimum time among all buses * total trips required</span>
        <span class="kt">long</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">time</span><span class="o">).</span><span class="na">min</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">()</span> <span class="o">*</span> <span class="n">totalTrips</span><span class="o">;</span>

        <span class="c1">// Binary search to find the minimum time</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="c1">// Calculate mid point to avoid overflow</span>
            <span class="kt">long</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
            <span class="c1">// If we can complete required trips in mid time, try to minimize the time</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canComplete</span><span class="o">(</span><span class="n">time</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">totalTrips</span><span class="o">)){</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we cannot complete in mid time, we need more time</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum time found</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canComplete</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">,</span> <span class="kt">long</span> <span class="n">givenTime</span><span class="o">,</span> <span class="kt">int</span> <span class="n">totalTrips</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Count total trips possible in given time</span>
        <span class="kt">long</span> <span class="n">trip</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Calculate trips for each bus</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">t:</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Add number of trips this bus can complete</span>
            <span class="n">trip</span> <span class="o">+=</span> <span class="n">givenTime</span> <span class="o">/</span> <span class="n">t</span><span class="o">;</span>
            <span class="c1">// Early return if we already reached required trips</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">trip</span> <span class="o">&gt;=</span> <span class="n">totalTrips</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return false if total trips possible is less than required</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple buses with different times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">time1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">totalTrips1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minimumTime</span><span class="o">(</span><span class="n">time1</span><span class="o">,</span> <span class="n">totalTrips1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 2: Single bus case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">time2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">totalTrips2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minimumTime</span><span class="o">(</span><span class="n">time2</span><span class="o">,</span> <span class="n">totalTrips2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip. Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus. You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.]]></summary></entry><entry><title type="html">475. Heaters</title><link href="https://zhengstar94.github.io//blog/2025/Heaters/" rel="alternate" type="text/html" title="475. Heaters"/><published>2025-04-29T00:00:00+00:00</published><updated>2025-04-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/Heaters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/Heaters/"><![CDATA[<ul> <li>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.</li> <li>Every house can be warmed, as long as the house is within the heater’s warm radius range.</li> <li>Given the positions of <code class="language-plaintext highlighter-rouge">houses</code> and <code class="language-plaintext highlighter-rouge">heaters</code> on a horizontal line, return <em>the minimum radius standard of heaters so that those heaters could cover all houses.</em>**</li> <li><strong>Notice</strong> that all the <code class="language-plaintext highlighter-rouge">heaters</code> follow your radius standard, and the warm radius will the same.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: houses = [1,2,3], heaters = [2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: houses = [1,2,3,4], heaters = [1,4]
Output: 1
Explanation: The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: houses = [1,5], heaters = [2]
Output: 3
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogm) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMinimum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Heaters</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findRadius</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">houses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">heaters</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort heaters array to enable binary search</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">heaters</span><span class="o">);</span>

        <span class="c1">// Initialize the maximum radius needed</span>
        <span class="kt">int</span> <span class="n">maxRadius</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each house to find its minimum heating radius</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">house:</span> <span class="n">houses</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Use binary search to find the insertion point for current house</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">heaters</span><span class="o">,</span> <span class="n">house</span><span class="o">);</span>

            <span class="c1">// If house position has a heater, no need to calculate distance</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Convert negative insertion point to actual index</span>
            <span class="c1">// If binary search returns -x, the actual insertion point is (x-1)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="o">-(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Calculate distances to nearest heaters:</span>
            <span class="c1">// dist1: distance to heater on the left (if exists)</span>
            <span class="c1">// If no heater on left (index-1 &lt; 0), set to MAX_VALUE</span>
            <span class="kt">int</span> <span class="n">dist1</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">house</span> <span class="o">-</span> <span class="n">heaters</span><span class="o">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

            <span class="c1">// dist2: distance to heater on the right (if exists)</span>
            <span class="c1">// If no heater on right (index &gt;= length), set to MAX_VALUE</span>
            <span class="kt">int</span> <span class="n">dist2</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">heaters</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">heaters</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">-</span> <span class="n">house</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

            <span class="c1">// Update maximum radius needed:</span>
            <span class="c1">// Take minimum of dist1 and dist2 (nearest heater)</span>
            <span class="c1">// Take maximum with previous maxRadius (need to cover all houses)</span>
            <span class="n">maxRadius</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxRadius</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dist1</span><span class="o">,</span> <span class="n">dist2</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxRadius</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Houses at positions 1,2,3 with heater at position 2</span>
        <span class="c1">// Expected result: 1 (radius of 1 can cover all houses)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">houses1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">heaters1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">findRadius</span><span class="o">(</span><span class="n">houses1</span><span class="o">,</span> <span class="n">heaters1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Houses at positions 1,2,3,4 with heaters at positions 1,4</span>
        <span class="c1">// Expected result: 1 (heater at 1 covers houses 1,2; heater at 4 covers houses 3,4)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">houses2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">heaters2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">findRadius</span><span class="o">(</span><span class="n">houses2</span><span class="o">,</span> <span class="n">heaters2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Houses at positions 1,5 with heater at position 2</span>
        <span class="c1">// Expected result: 3 (need radius of 3 to cover both houses from position 2)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">houses3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">heaters3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">findRadius</span><span class="o">(</span><span class="n">houses3</span><span class="o">,</span> <span class="n">heaters3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses. Every house can be warmed, as long as the house is within the heater’s warm radius range. Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.** Notice that all the heaters follow your radius standard, and the warm radius will the same.]]></summary></entry><entry><title type="html">1283. Find the Smallest Divisor Given a Threshold</title><link href="https://zhengstar94.github.io//blog/2025/FindTheSmallestDivisorGivenAThreshold/" rel="alternate" type="text/html" title="1283. Find the Smallest Divisor Given a Threshold"/><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheSmallestDivisorGivenAThreshold</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheSmallestDivisorGivenAThreshold/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">threshold</code>, we will choose a positive integer <code class="language-plaintext highlighter-rouge">divisor</code>, divide all the array by it, and sum the division’s result. Find the <strong>smallest</strong> <code class="language-plaintext highlighter-rouge">divisor</code> such that the result mentioned above is less than or equal to <code class="language-plaintext highlighter-rouge">threshold</code>.</li> <li>Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: <code class="language-plaintext highlighter-rouge">7/3 = 3</code> and <code class="language-plaintext highlighter-rouge">10/2 = 5</code>).</li> <li>The test cases are generated so that there will be an answer.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,5,9], threshold = 6
Output: 5
Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [44,22,33,11,1], threshold = 5
Output: 44
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(N * log(M)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMinimum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheSmallestDivisorGivenAThreshold</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">smallestDivisor</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Find maximum number in array to set binary search upper bound</span>
        <span class="kt">int</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxNum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxNum</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Perform binary search to find smallest valid divisor</span>
        <span class="c1">// Left boundary: 1 (minimum possible divisor)</span>
        <span class="c1">// Right boundary: maxNum (maximum needed divisor)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">maxNum</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point avoiding overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If current divisor produces sum &lt;= threshold,</span>
            <span class="c1">// try to find smaller divisor in left half</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">calculateSum</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If sum &gt; threshold, need larger divisor</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculateSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">divisor</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate ceiling division using integer arithmetic</span>
            <span class="c1">// Formula: ceil(num/divisor) = (num + divisor - 1) / divisor</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="n">divisor</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">divisor</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic example with small numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">smallestDivisor</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">6</span><span class="o">));</span>  <span class="c1">// Expected: 5</span>

        <span class="c1">// Test Case 2: Example with prime numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">11</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">smallestDivisor</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">11</span><span class="o">));</span>  <span class="c1">// Expected: 3</span>

        <span class="c1">// Test Case 3: Single element array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">19</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">smallestDivisor</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division’s result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). The test cases are generated so that there will be an answer.]]></summary></entry><entry><title type="html">911. Online Election</title><link href="https://zhengstar94.github.io//blog/2025/TopVotedCandidate/" rel="alternate" type="text/html" title="911. Online Election"/><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TopVotedCandidate</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TopVotedCandidate/"><![CDATA[<ul> <li>You are given two integer arrays <code class="language-plaintext highlighter-rouge">persons</code> and <code class="language-plaintext highlighter-rouge">times</code>. In an election, the <code class="language-plaintext highlighter-rouge">ith</code> vote was cast for <code class="language-plaintext highlighter-rouge">persons[i]</code> at time <code class="language-plaintext highlighter-rouge">times[i]</code>.</li> <li>For each query at a time <code class="language-plaintext highlighter-rouge">t</code>, find the person that was leading the election at time <code class="language-plaintext highlighter-rouge">t</code>. Votes cast at time <code class="language-plaintext highlighter-rouge">t</code> will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.</li> <li>Implement the <code class="language-plaintext highlighter-rouge">TopVotedCandidate</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">TopVotedCandidate(int[] persons, int[] times)</code> Initializes the object with the <code class="language-plaintext highlighter-rouge">persons</code> and <code class="language-plaintext highlighter-rouge">times</code> arrays.</li> <li><code class="language-plaintext highlighter-rouge">int q(int t)</code> Returns the number of the person that was leading the election at time <code class="language-plaintext highlighter-rouge">t</code> according to the mentioned rules.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["TopVotedCandidate", "q", "q", "q", "q", "q", "q"]
[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]
Output
[null, 0, 1, 1, 0, 0, 1]

Explanation
TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);
topVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.
topVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.
topVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)
topVotedCandidate.q(15); // return 0
topVotedCandidate.q(24); // return 0
topVotedCandidate.q(8); // return 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(N) build, O(logN) query time | O(N) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TopVotedCandidate</span> <span class="o">{</span>
    <span class="c1">// Stores the leading candidate at each time point</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tops</span><span class="o">;</span>
    <span class="c1">// Maps each candidate to their current vote count</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">voteCounts</span><span class="o">;</span>
    <span class="c1">// Array of timestamps when votes were cast</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">times</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">TopVotedCandidate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">persons</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">times</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">tops</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="n">voteCounts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="c1">// Initialize with -1 as baseline for comparison</span>
        <span class="n">voteCounts</span><span class="o">.</span><span class="na">put</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// Current leading candidate</span>

        <span class="c1">// Process each vote</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">persons</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">persons</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">// Update vote count for current candidate</span>
            <span class="n">voteCounts</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">voteCounts</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">// Update leader if current candidate has equal or more votes</span>
            <span class="c1">// This handles tie-breaking by favoring the most recent vote</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">voteCounts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">voteCounts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">top</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tops</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">times</span> <span class="o">=</span> <span class="n">times</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">q</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Binary search to find largest time point &lt;= t</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">times</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">tops</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case initialization</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">persons</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">times</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">25</span><span class="o">,</span> <span class="mi">30</span><span class="o">};</span>

        <span class="nc">TopVotedCandidate</span> <span class="n">tvc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TopVotedCandidate</span><span class="o">(</span><span class="n">persons</span><span class="o">,</span> <span class="n">times</span><span class="o">);</span>

        <span class="c1">// Test cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tvc</span><span class="o">.</span><span class="na">q</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>   <span class="c1">// Expected output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tvc</span><span class="o">.</span><span class="na">q</span><span class="o">(</span><span class="mi">12</span><span class="o">));</span>  <span class="c1">// Expected output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tvc</span><span class="o">.</span><span class="na">q</span><span class="o">(</span><span class="mi">25</span><span class="o">));</span>  <span class="c1">// Expected output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tvc</span><span class="o">.</span><span class="na">q</span><span class="o">(</span><span class="mi">15</span><span class="o">));</span>  <span class="c1">// Expected output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tvc</span><span class="o">.</span><span class="na">q</span><span class="o">(</span><span class="mi">24</span><span class="o">));</span>  <span class="c1">// Expected output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tvc</span><span class="o">.</span><span class="na">q</span><span class="o">(</span><span class="mi">8</span><span class="o">));</span>   <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i]. For each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins. Implement the TopVotedCandidate class: TopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays. int q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.]]></summary></entry><entry><title type="html">3392. Count Subarrays of Length Three With a Condition</title><link href="https://zhengstar94.github.io//blog/2025/CountSubarraysOfLengthThreeWithACondition/" rel="alternate" type="text/html" title="3392. Count Subarrays of Length Three With a Condition"/><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubarraysOfLengthThreeWithACondition</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubarraysOfLengthThreeWithACondition/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return the number of subarrays of length 3 such that the sum of the first and third numbers equals <em>exactly</em> half of the second number.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,1,4,1]

Output: 1

Explanation:

Only the subarray [1,4,1] contains exactly 3 elements where the sum of the first and third numbers equals half the middle number.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]

Output: 0

Explanation:

[1,1,1] is the only subarray of length 3. However, its first and third numbers do not add to half the middle number.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubarraysOfLengthThreeWithACondition</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countSubArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Return 0 if array length is less than 3 as we need at least 3 elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Use sliding window of size 3 to check each subarray</span>
        <span class="c1">// Loop runs from first element to last possible position for a size-3 window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if sum of first and third number equals half of middle number</span>
            <span class="c1">// nums[i]: first number</span>
            <span class="c1">// nums[i + 1]: middle number</span>
            <span class="c1">// nums[i + 2]: third number</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with valid subarray</span>
        <span class="c1">// Expected output: 1 (subarray [1,4,1] satisfies the condition)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Array with no valid subarray</span>
        <span class="c1">// Expected output: 0 (no subarray satisfies the condition)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Empty array</span>
        <span class="c1">// Expected output: 0 (array length less than 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Array with length less than 3</span>
        <span class="c1">// Expected output: 0 (array length less than 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">countSubArrays</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array nums, return the number of subarrays of length 3 such that the sum of the first and third numbers equals exactly half of the second number.]]></summary></entry></feed>