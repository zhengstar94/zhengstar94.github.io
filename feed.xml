<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-10T12:32:31+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">739.Daily Temperatures</title><link href="https://zhengstar94.github.io//blog/2024/DailyTemperatures/" rel="alternate" type="text/html" title="739.Daily Temperatures"/><published>2024-10-10T00:00:00+00:00</published><updated>2024-10-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DailyTemperatures</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DailyTemperatures/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">temperatures</code> represents the daily temperatures, return <em>an array</em> <code class="language-plaintext highlighter-rouge">answer</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">answer[i]</code> <em>is the number of days you have to wait after the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>day to get a warmer temperature</em>. If there is no future day for which this is possible, keep <code class="language-plaintext highlighter-rouge">answer[i] == 0</code> instead.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: temperatures = [ 73,74,75,71,69,72,76,73]
Output: [ 1,1,4,2,1,1,0,0]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: temperatures = [ 30,40,50,60]
Output: [ 1,1,1,0]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: temperatures = [30,60,90]
Output: [1,1,0]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DailyTemperatures</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dailyTemperatures</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">temperatures</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">temperatures</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Initialize the result array with zeros</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// Use a stack to keep track of indices of temperatures</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each temperature</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// While the stack is not empty and the current temperature is warmer</span>
            <span class="c1">// than the temperature at the top of the stack</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">temperatures</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">temperatures</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()])</span> <span class="o">{</span>
                <span class="c1">// Pop the index of the cooler day</span>
                <span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="c1">// Calculate the number of days to wait for a warmer temperature</span>
                <span class="c1">// i - prevIndex represents the number of days between the current day</span>
                <span class="c1">// and the day at prevIndex</span>
                <span class="c1">// This is the key operation: it calculates how many days you need to wait</span>
                <span class="c1">// from the day at prevIndex to get to a warmer day (the current day i)</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">prevIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">prevIndex</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Push the current day's index onto the stack</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test case</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">temperatures</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">73</span><span class="o">,</span> <span class="mi">74</span><span class="o">,</span> <span class="mi">75</span><span class="o">,</span> <span class="mi">71</span><span class="o">,</span> <span class="mi">69</span><span class="o">,</span> <span class="mi">72</span><span class="o">,</span> <span class="mi">76</span><span class="o">,</span> <span class="mi">73</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">dailyTemperatures</span><span class="o">(</span><span class="n">temperatures</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input temperatures: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">temperatures</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Days to wait for warmer temperature: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
        <span class="c1">// Expected output: [ 1, 1, 4, 2, 1, 1, 0, 0]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.]]></summary></entry><entry><title type="html">Floyd’s Algorithm for Finding Duplicate Number</title><link href="https://zhengstar94.github.io//blog/2024/FloydAlgorithmForFindingDuplicateNumber/" rel="alternate" type="text/html" title="Floyd’s Algorithm for Finding Duplicate Number"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/FloydAlgorithmForFindingDuplicateNumber</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/FloydAlgorithmForFindingDuplicateNumber/"><![CDATA[<h2 id="1-introduction">1. Introduction</h2> <p>Floyd’s Cycle-Finding Algorithm, also known as the “Tortoise and Hare” algorithm, is a pointer algorithm that uses only two pointers, moving through the sequence at different speeds. This algorithm is particularly useful for detecting cycles in sequences and has an interesting application in solving the “Find the Duplicate Number” problem.</p> <h2 id="2-problem-statement">2. Problem Statement</h2> <p>Given an array <code class="language-plaintext highlighter-rouge">nums</code> containing <code class="language-plaintext highlighter-rouge">n + 1</code> integers where each integer is in the range <code class="language-plaintext highlighter-rouge">[1, n]</code> inclusive, prove that at least one duplicate number must exist. Assume that there is only one duplicate number, but it may be repeated more than once.</p> <p>The task is to find the duplicate number without modifying the array <code class="language-plaintext highlighter-rouge">nums</code> and using only constant extra space.</p> <h2 id="3-algorithm-description">3. Algorithm Description</h2> <p>Floyd’s algorithm can be adapted to solve this problem by treating the array as a linked list where <code class="language-plaintext highlighter-rouge">nums[i]</code> is treated as a pointer to index <code class="language-plaintext highlighter-rouge">nums[i]</code>.</p> <p>The algorithm consists of two phases:</p> <h3 id="phase-1-detecting-the-intersection-point-of-two-runners">Phase 1: Detecting the intersection point of two runners</h3> <ol> <li>Initialize two pointers, <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code>, to the first element of the array.</li> <li>Move <code class="language-plaintext highlighter-rouge">tortoise</code> one step at a time: <code class="language-plaintext highlighter-rouge">tortoise = nums[tortoise]</code></li> <li>Move <code class="language-plaintext highlighter-rouge">hare</code> two steps at a time: <code class="language-plaintext highlighter-rouge">hare = nums[nums[hare]]</code></li> <li>Repeat steps 2 and 3 until <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code> meet at the same element.</li> </ol> <h3 id="phase-2-finding-the-entrance-to-the-cycle-the-duplicate-number">Phase 2: Finding the entrance to the cycle (the duplicate number)</h3> <ol> <li>Reset the <code class="language-plaintext highlighter-rouge">tortoise</code> to the first element of the array.</li> <li>Move both <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code> one step at a time.</li> <li>The point at which they meet is the entrance to the cycle, which is the duplicate number.</li> </ol> <h2 id="4-implementation">4. Implementation</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Phase 1: Detecting the cycle</span>
    <span class="kt">int</span> <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// Initialize the slow pointer (tortoise)</span>
    <span class="kt">int</span> <span class="n">hare</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>      <span class="c1">// Initialize the fast pointer (hare)</span>

    <span class="k">do</span> <span class="o">{</span>
      <span class="c1">// Move the tortoise one step forward</span>
      <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">tortoise</span><span class="o">];</span>

      <span class="c1">// Move the hare two steps forward</span>
      <span class="n">hare</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">hare</span><span class="o">]];</span>

      <span class="c1">// Continue until the tortoise and hare meet</span>
      <span class="c1">// This meeting point is guaranteed to be inside the cycle</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">tortoise</span> <span class="o">!=</span> <span class="n">hare</span><span class="o">);</span>

    <span class="c1">// Phase 2: Finding the entrance to the cycle (the duplicate number)</span>
    <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// Reset the tortoise to the start of the array</span>

    <span class="c1">// Move both pointers at the same speed until they meet again</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">tortoise</span> <span class="o">!=</span> <span class="n">hare</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Move both pointers one step at a time</span>
      <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">tortoise</span><span class="o">];</span>
      <span class="n">hare</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">hare</span><span class="o">];</span>

      <span class="c1">// The point where they meet is the entrance to the cycle,</span>
      <span class="c1">// which is the duplicate number</span>
    <span class="o">}</span>

    <span class="c1">// Both pointers now point to the duplicate number</span>
    <span class="k">return</span> <span class="n">hare</span><span class="o">;</span>  <span class="c1">// We could return tortoise as well, they're the same at this point</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="5-proof-of-correctness">5. Proof of Correctness</h2> <p>The correctness of this algorithm relies on the following properties:</p> <ol> <li>If there is a cycle, the <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code> will eventually meet.</li> <li>The meeting point is not necessarily the duplicate number, but it is guaranteed to be part of the cycle.</li> <li>The distance from the start of the array to the entrance of the cycle (duplicate number) is equal to the distance from the meeting point to the entrance of the cycle.</li> </ol> <h2 id="6-complexity-analysis">6. Complexity Analysis</h2> <ul> <li>Time Complexity: O(n), where n is the length of the array. The worst case occurs when the duplicate element is at the end of the array.</li> <li>Space Complexity: O(1), as only two pointers are used regardless of the input size.</li> </ul> <h2 id="7-advantages-and-disadvantages">7. Advantages and Disadvantages</h2> <h3 id="advantages">Advantages:</h3> <ul> <li>Meets the problem constraints of O(1) space complexity.</li> <li>Does not modify the original array.</li> <li>Has optimal time complexity of O(n).</li> </ul> <h3 id="disadvantages">Disadvantages:</h3> <ul> <li>Not intuitive and can be difficult to understand at first glance.</li> <li>Doesn’t provide information about all duplicates if multiple exist.</li> </ul> <h2 id="8-conclusion">8. Conclusion</h2> <p>Floyd’s Cycle-Finding Algorithm provides an elegant and efficient solution to the “Find the Duplicate Number” problem. While it may not be the most intuitive approach, it showcases how algorithmic thinking can lead to optimal solutions that satisfy strict constraints. Understanding this algorithm and its application can provide valuable insights into problem-solving techniques in computer science.</p> <h2 id="example-of-leetode">Example of Leetode</h2> <ol> <li>LeetCode 142 - Linked List Cycle II</li> </ol> <p>Problem: Given a linked list, return the node where the cycle begins. If there is no cycle, return <code class="language-plaintext highlighter-rouge">null</code>.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">detectCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="c1">// Phase 1: Detect the intersection point</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>            <span class="c1">// Move slow pointer one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>       <span class="c1">// Move fast pointer two steps</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>     <span class="c1">// They meet at the cycle</span>
        <span class="o">}</span>

        <span class="c1">// If fast reaches null, there is no cycle</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

        <span class="c1">// Phase 2: Find the entrance to the cycle</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>  <span class="c1">// This is the entrance to the cycle</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>LeetCode 202 - Happy Number</li> </ol> <p>Problem: Write an algorithm to determine if a number <code class="language-plaintext highlighter-rouge">n</code> is a “happy number.” A happy number is one where you repeatedly replace the number by the sum of the squares of its digits until it either equals <code class="language-plaintext highlighter-rouge">1</code> (which means it’s happy) or loops endlessly in a cycle.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHappy</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">getNext</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

        <span class="c1">// Phase 1: Detect cycle</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">getNext</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>             <span class="c1">// Slow pointer moves one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">getNext</span><span class="o">(</span><span class="n">getNext</span><span class="o">(</span><span class="n">fast</span><span class="o">));</span>    <span class="c1">// Fast pointer moves two steps</span>
        <span class="o">}</span>

        <span class="c1">// If fast reaches 1, it's a happy number</span>
        <span class="k">return</span> <span class="n">fast</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getNext</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">totalSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
            <span class="n">totalSum</span> <span class="o">+=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">totalSum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>LeetCode 41 - First Missing Positive</li> </ol> <p>Problem: Given an unsorted integer array, find the smallest missing positive integer. Although this problem doesn’t directly use Floyd’s algorithm, you can solve it by rearranging the array to simulate the cyclic behavior.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstMissingPositive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Place each number at its correct index (e.g., 1 goes to index 0, 2 goes to index 1)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Swap nums[i] with nums[nums[i] - 1]</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Find the first missing positive number</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// If all numbers are in the correct place, return n+1</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>Cycle Detection in Function Iteration</li> </ol> <p>In function iteration, we want to detect if a function eventually enters a cycle. You can apply Floyd’s algorithm here as well. Below is an example:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">detectCycleInFunction</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>

        <span class="c1">// Phase 1: Detect cycle</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>           <span class="c1">// Slow pointer moves one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">fast</span><span class="o">));</span>        <span class="c1">// Fast pointer moves two steps</span>
        <span class="o">}</span>

        <span class="c1">// Phase 2: Find the entrance of the cycle</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">fast</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>  <span class="c1">// Return the entrance of the cycle</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example of a function f</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>  <span class="c1">// For instance, square the number and add 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>Cycle Detection in Finite State Machines</li> </ol> <p>You can also use Floyd’s algorithm to detect cycles in state transitions of a finite state machine (FSM).</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">detectCycleInFSM</span><span class="o">(</span><span class="kt">int</span> <span class="n">state</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">transitions</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">state</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">transitions</span><span class="o">[</span><span class="n">state</span><span class="o">][</span><span class="mi">0</span><span class="o">]][</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Phase 1: Detect cycle</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">slow</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>               <span class="c1">// Slow pointer moves one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">transitions</span><span class="o">[</span><span class="n">fast</span><span class="o">][</span><span class="mi">0</span><span class="o">]][</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// Fast pointer moves two steps</span>
        <span class="o">}</span>

        <span class="c1">// Phase 2: Find the entrance of the cycle</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">slow</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">fast</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>  <span class="c1">// Return the state where the cycle starts</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[1. Introduction]]></summary></entry><entry><title type="html">22.Generate Parenthesesn</title><link href="https://zhengstar94.github.io//blog/2024/GenerateParentheses/" rel="alternate" type="text/html" title="22.Generate Parenthesesn"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/GenerateParentheses</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/GenerateParentheses/"><![CDATA[<ul> <li>Given <code class="language-plaintext highlighter-rouge">n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: ["()"]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(4<span class="p">^</span>n / √n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/08
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenerateParentheses</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">backtrac</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Recursive backtracking method to generate parentheses combinations
     * @param result The list to store all valid combinations
     * @param current The current combination being built
     * @param open The count of open parentheses in the current combination
     * @param close The count of close parentheses in the current combination
     * @param max The maximum number of pairs allowed (n)
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrac</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">current</span><span class="o">,</span> <span class="kt">int</span> <span class="n">open</span><span class="o">,</span> <span class="kt">int</span> <span class="n">close</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: If the current combination has the correct length, add it to the result</span>
        <span class="k">if</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">max</span> <span class="o">*</span> <span class="mi">2</span><span class="o">){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Add an open parenthesis if we haven't used all n open parentheses yet</span>
        <span class="k">if</span><span class="o">(</span><span class="n">open</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">){</span>
            <span class="n">current</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"("</span><span class="o">);</span>
            <span class="n">backtrac</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">current</span><span class="o">,</span> <span class="n">open</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">close</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
            <span class="n">current</span><span class="o">.</span><span class="na">setLength</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">// Backtrack: remove the last added parenthesis</span>
        <span class="o">}</span>

        <span class="c1">// Add a close parenthesis if it's valid (close count &lt; open count)</span>
        <span class="k">if</span><span class="o">(</span><span class="n">close</span> <span class="o">&lt;</span> <span class="n">open</span><span class="o">){</span>
            <span class="n">current</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">")"</span><span class="o">);</span>
            <span class="n">backtrac</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">current</span><span class="o">,</span> <span class="n">open</span><span class="o">,</span> <span class="n">close</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
            <span class="n">current</span><span class="o">.</span><span class="na">setLength</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">// Backtrack: remove the last added parenthesis</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to run tests
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test different values of n</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Test method to generate and print results for a given n
     * @param n The number of pairs of parentheses to generate
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">generateParenthesis</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"n = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of combinations: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.]]></summary></entry><entry><title type="html">150.Evaluate Reverse Polish Notation</title><link href="https://zhengstar94.github.io//blog/2024/EvaluateReversePolishNotation/" rel="alternate" type="text/html" title="150.Evaluate Reverse Polish Notation"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/EvaluateReversePolishNotation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/EvaluateReversePolishNotation/"><![CDATA[<ul> <li>You are given an array of strings <code class="language-plaintext highlighter-rouge">tokens</code> that represents an arithmetic expression in a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</li> <li>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</li> <li><strong>Note</strong> that: <ul> <li>The valid operators are <code class="language-plaintext highlighter-rouge">'+'</code>, <code class="language-plaintext highlighter-rouge">'-'</code>, <code class="language-plaintext highlighter-rouge">'*'</code>, and <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Each operand may be an integer or another expression.</li> <li>The division between two integers always <strong>truncates toward zero</strong>.</li> <li>There will not be any division by zero.</li> <li>The input represents a valid arithmetic expression in a reverse polish notation.</li> <li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EvaluateReversePolishNotation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">evalRPN</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">tokens</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a stack to store operands</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each token in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">token</span> <span class="o">:</span> <span class="n">tokens</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"+"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Addition: pop two numbers, add them, and push the result</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"*"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Multiplication: pop two numbers, multiply them, and push the result</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">*</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"-"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Subtraction: pop two numbers (order matters), subtract, and push the result</span>
                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"/"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Division: pop two numbers (order matters), divide, and push the result</span>
                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If the token is a number, parse it to integer and push onto the stack</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">token</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The final result is the only item left on the stack</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic addition and multiplication</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"2"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"*"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens1</span><span class="o">));</span> <span class="c1">// Expected output: 9</span>

        <span class="c1">// Test case 2: Division and addition</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens2</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"4"</span><span class="o">,</span><span class="s">"13"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"/"</span><span class="o">,</span><span class="s">"+"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens2</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 3: Complex expression with multiple operations</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens3</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"10"</span><span class="o">,</span><span class="s">"6"</span><span class="o">,</span><span class="s">"9"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"-11"</span><span class="o">,</span><span class="s">"*"</span><span class="o">,</span><span class="s">"/"</span><span class="o">,</span><span class="s">"*"</span><span class="o">,</span><span class="s">"17"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"+"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens3</span><span class="o">));</span> <span class="c1">// Expected output: 22</span>

        <span class="c1">// Test case 4: Expression with negative numbers</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens4</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"4"</span><span class="o">,</span><span class="s">"-2"</span><span class="o">,</span><span class="s">"/"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"-"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens4</span><span class="o">));</span> <span class="c1">// Expected output: -4</span>

        <span class="c1">// Test case 5: Expression with a single number</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens5</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"18"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens5</span><span class="o">));</span> <span class="c1">// Expected output: 18</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.]]></summary></entry><entry><title type="html">42.Trapping Rain Water</title><link href="https://zhengstar94.github.io//blog/2024/TrappingRainWater/" rel="alternate" type="text/html" title="42.Trapping Rain Water"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/TrappingRainWater</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/TrappingRainWater/"><![CDATA[<ul> <li>Given <code class="language-plaintext highlighter-rouge">n</code> non-negative integers representing an elevation map where the width of each bar is <code class="language-plaintext highlighter-rouge">1</code>, compute how much water it can trap after raining.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: height = [4,2,0,3,2,5]
Output: 9
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrappingRainWater</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">trap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers: left starts from the beginning, right from the end</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Keep track of the maximum height encountered from left and right</span>
        <span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Variable to store the total amount of water trapped</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue until the two pointers meet</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Compare the heights at the left and right pointers</span>
            <span class="c1">// This comparison is crucial as it determines which side to process</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Process the left side when its height is smaller</span>

                <span class="c1">// If current height is greater or equal to leftMax,</span>
                <span class="c1">// update leftMax as no water can be trapped here</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">leftMax</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">leftMax</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Water can be trapped at this position</span>
                    <span class="c1">// The amount is the difference between leftMax and current height</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">leftMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="c1">// Move the left pointer to the right</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Process the right side when its height is smaller or equal</span>

                <span class="c1">// If current height is greater or equal to rightMax,</span>
                <span class="c1">// update rightMax as no water can be trapped here</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">rightMax</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">rightMax</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Water can be trapped at this position</span>
                    <span class="c1">// The amount is the difference between rightMax and current height</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">rightMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="c1">// Move the right pointer to the left</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total amount of water trapped</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: Standard case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height1</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height1</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 2: No water can be trapped</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height2</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 3: Single peak</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height3</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height3</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 4: Multiple peaks</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height4</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height4</span><span class="o">));</span> <span class="c1">// Expected output: 7</span>

        <span class="c1">// Test case 5: Empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height5</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height5</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.]]></summary></entry><entry><title type="html">1143.Longest Common Subsequence</title><link href="https://zhengstar94.github.io//blog/2024/LongestCommonSubsequence/" rel="alternate" type="text/html" title="1143.Longest Common Subsequence"/><published>2024-10-05T00:00:00+00:00</published><updated>2024-10-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestCommonSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestCommonSubsequence/"><![CDATA[<ul> <li> <p>Given two strings <code class="language-plaintext highlighter-rouge">text1</code> and <code class="language-plaintext highlighter-rouge">text2</code>, return <em>the length of their longest <strong>common subsequence</strong>.</em> If there is no <strong>common subsequence</strong>, return <code class="language-plaintext highlighter-rouge">0</code>.</p> </li> <li> <p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p> <ul> <li>For example, <code class="language-plaintext highlighter-rouge">"ace"</code> is a subsequence of <code class="language-plaintext highlighter-rouge">"abcde"</code>.</li> </ul> <p>A <strong>common subsequence</strong> of two strings is a subsequence that is common to both strings.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestCommonSubsequence</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestCommonSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">text1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">text2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the lengths of the input strings</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">text1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">text2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Create a 2D array to store the lengths of LCS</span>
        <span class="c1">// The size is (m+1) x (n+1) to handle empty string cases</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Iterate through both strings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If the characters at the current positions match</span>
                <span class="k">if</span><span class="o">(</span><span class="n">text1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">text2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)){</span>
                    <span class="c1">// Increment the LCS length from the previous state</span>
                    <span class="c1">// dp[i-1][j-1] represents the LCS length without these characters</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// If characters don't match, take the maximum of:</span>
                    <span class="c1">// 1. LCS without the current character of text1 (dp[i-1][j])</span>
                    <span class="c1">// 2. LCS without the current character of text2 (dp[i][j-1])</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The bottom-right cell contains the length of the LCS of the entire strings</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test Case 1: Different strings with a common subsequence</span>
        <span class="nc">String</span> <span class="n">text1</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">text2</span> <span class="o">=</span> <span class="s">"ace"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">longestCommonSubsequence</span><span class="o">(</span><span class="n">text1</span><span class="o">,</span> <span class="n">text2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Identical strings</span>
        <span class="n">text1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">text2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">longestCommonSubsequence</span><span class="o">(</span><span class="n">text1</span><span class="o">,</span> <span class="n">text2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Completely different strings</span>
        <span class="n">text1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">text2</span> <span class="o">=</span> <span class="s">"def"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">longestCommonSubsequence</span><span class="o">(</span><span class="n">text1</span><span class="o">,</span> <span class="n">text2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 0"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.]]></summary></entry><entry><title type="html">62.Unique Paths</title><link href="https://zhengstar94.github.io//blog/2024/UniquePaths/" rel="alternate" type="text/html" title="62.Unique Paths"/><published>2024-10-01T00:00:00+00:00</published><updated>2024-10-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/UniquePaths</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/UniquePaths/"><![CDATA[<ul> <li> <p>There is a robot on an <code class="language-plaintext highlighter-rouge">m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code class="language-plaintext highlighter-rouge">grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code class="language-plaintext highlighter-rouge">grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p> <p>Given the two integers <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p> <p>The test cases are generated so that the answer will be less than or equal to <code class="language-plaintext highlighter-rouge">2 * 10^9</code>.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 7
Output: 28
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Down
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3
Output: 6
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * Solution for LeetCode 62: Unique Paths
 * @author zhengstars
 * @date 2024/10/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UniquePaths</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the number of unique paths from top-left to bottom-right corner of a m x n grid.
     *
     * @param m Number of rows in the grid
     * @param n Number of columns in the grid
     * @return The total number of unique paths
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a 1D array to store the number of paths for each column</span>
        <span class="c1">// The size is n because we only need to keep track of one row at a time</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Fill the array with 1s initially</span>
        <span class="c1">// This represents the first row where there's only one way to reach each cell</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Iterate through each row (starting from the second row)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For each column (starting from the second column)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Update the number of paths to the current cell</span>
                <span class="c1">// It's the sum of paths from the cell above (current dp[j])</span>
                <span class="c1">// and the cell to the left (dp[j-1])</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The last element of dp array contains the total number of unique paths</span>
        <span class="c1">// to reach the bottom-right corner</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method for testing the uniquePaths function
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">UniquePaths</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UniquePaths</span><span class="o">();</span>

        <span class="c1">// Test case 1: 3x7 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x7 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">));</span> <span class="c1">// Expected output: 28</span>

        <span class="c1">// Test case 2: 3x2 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x2 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 3: 7x3 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"7x3 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected output: 28</span>

        <span class="c1">// Test case 4: 3x3 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x3 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 5: 1x1 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1x1 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 6: 10x10 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"10x10 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span> <span class="c1">// Expected output: 48620</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.]]></summary></entry><entry><title type="html">300.Longest Increasing Subsequence</title><link href="https://zhengstar94.github.io//blog/2024/LongestIncreasingSubsequence/" rel="alternate" type="text/html" title="300.Longest Increasing Subsequence"/><published>2024-09-29T00:00:00+00:00</published><updated>2024-09-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestIncreasingSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestIncreasingSubsequence/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a dictionary of strings <code class="language-plaintext highlighter-rouge">wordDict</code>, return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">s</code> can be segmented into a space-separated sequence of one or more dictionary words.</li> <li><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</li> </ul> <p><strong>Example 1</strong></p> <ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the length of the longest <strong>strictly increasing</strong></em> <strong><em>subsequence</em></strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0,3,2,3]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [7,7,7,7,7,7,7]
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestIncreasingSubsequence</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if the input array is null or empty, return 0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// dp array to store the smallest tail of all increasing subsequences</span>
        <span class="c1">// of lengths i+1 in dp[i]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// len keeps track of the current length of the longest increasing subsequence</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Use binary search to find the position where num should be placed in dp</span>
            <span class="c1">// This is more efficient than linear search, reducing time complexity to O(log n)</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>

            <span class="c1">// If the element is not found, binarySearch returns (-(insertion point) - 1)</span>
            <span class="c1">// We need to convert this to the actual insertion point</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">i</span> <span class="o">=</span> <span class="o">-(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Place the current number in its correct position in dp</span>
            <span class="c1">// This either replaces a larger element or extends the sequence</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>

            <span class="c1">// If i equals len, it means we've found a new largest element</span>
            <span class="c1">// This extends our longest increasing subsequence, so we increment len</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">len</span><span class="o">){</span>
                <span class="n">len</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Note: If i &lt; len, we're just replacing an existing element</span>
            <span class="c1">// This doesn't increase the length, but might help form a longer sequence later</span>
        <span class="o">}</span>

        <span class="c1">// The final value of len is the length of the longest increasing subsequence</span>
        <span class="k">return</span> <span class="n">len</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">101</span><span class="o">,</span><span class="mi">18</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Length of Longest Increasing Subsequence: "</span> <span class="o">+</span> <span class="n">lengthOfLIS</span><span class="o">(</span><span class="n">nums</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.]]></summary></entry><entry><title type="html">139.Word Break</title><link href="https://zhengstar94.github.io//blog/2024/WordBreak/" rel="alternate" type="text/html" title="139.Word Break"/><published>2024-09-26T00:00:00+00:00</published><updated>2024-09-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/WordBreak</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/WordBreak/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a dictionary of strings <code class="language-plaintext highlighter-rouge">wordDict</code>, return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">s</code> can be segmented into a space-separated sequence of one or more dictionary words.</li> <li><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n + m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordBreak</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">wordBreak</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert wordDict to a HashSet for O(1) lookup time</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">wordDict</span><span class="o">);</span>

        <span class="c1">// Create a boolean array to store the results of subproblems</span>
        <span class="c1">// dp[i] will be true if the substring s[0,i) can be segmented into words from the dictionary</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Base case: empty string is always valid</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="c1">// Iterate through all possible end positions of substrings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Try all possible starting positions for the last word</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If the substring s[0,j) can be segmented (dp[j] is true)</span>
                <span class="c1">// and the substring s[j,i) is in the dictionary</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">wordSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                    <span class="c1">// Then the substring s[0,i) can be segmented</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="c1">// No need to check further for this i</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return whether the entire string can be segmented</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"leetcode"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"leet"</span><span class="o">,</span> <span class="s">"code"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">wordDict1</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"applepenapple"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pen"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">wordDict2</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"catsandog"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict3</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"cats"</span><span class="o">,</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"sand"</span><span class="o">,</span> <span class="s">"and"</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">wordDict3</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test case 4 (Empty string)</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict4</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s4</span><span class="o">,</span> <span class="n">wordDict4</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 5 (Single character)</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict5</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s5</span><span class="o">,</span> <span class="n">wordDict5</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 6 (No valid segmentation)</span>
        <span class="nc">String</span> <span class="n">s6</span> <span class="o">=</span> <span class="s">"aaaaaaa"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict6</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"aaaa"</span><span class="o">,</span> <span class="s">"aaaa"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 6: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s6</span><span class="o">,</span> <span class="n">wordDict6</span><span class="o">));</span> <span class="c1">// Expected: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.]]></summary></entry><entry><title type="html">152.Maximum Product Subarray</title><link href="https://zhengstar94.github.io//blog/2024/MaximumProductSubarray/" rel="alternate" type="text/html" title="152.Maximum Product Subarray"/><published>2024-09-25T00:00:00+00:00</published><updated>2024-09-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumProductSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumProductSubarray/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, find a subarray that has the largest product, and return <em>the product</em>.</li> <li>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumProductSubarray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if the array is null or empty, return 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize max as the first element of the array</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// imax/imin stores the max/min product of subarray that ends with the current number</span>
        <span class="kt">int</span> <span class="n">imax</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">imin</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If we encounter a negative number, swap imax and imin</span>
            <span class="c1">// This is because a negative number will make the bigger number smaller and the smaller number bigger</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">imax</span><span class="o">;</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="n">imin</span><span class="o">;</span>
                <span class="n">imin</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Update imax: compare current number with product of current number and previous imax</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">imax</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// Update imin: compare current number with product of current number and previous imin</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">imin</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Update max if we have found a larger product</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">imax</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: Normal case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 2: All positive numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 24</span>

        <span class="c1">// Test case 3: All negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 4: Mixed positive and negative with zero</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 5: Single element array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: -5</span>

        <span class="c1">// Test case 6: Empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums6</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 6 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums6</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer.]]></summary></entry></feed>