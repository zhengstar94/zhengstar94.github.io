<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-07T06:46:19+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">Group cycle</title><link href="https://zhengstar94.github.io//blog/2025/GroupCycle/" rel="alternate" type="text/html" title="Group cycle"/><published>2025-04-07T00:00:00+00:00</published><updated>2025-04-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/GroupCycle</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/GroupCycle/"><![CDATA[<h2 id="group-cycle">Group cycle</h2> <h3 id="core-concept">Core Concept</h3> <p>Group cycle is a powerful algorithmic technique specifically designed for handling problems that require dividing arrays or sequences into several groups and applying the same logical processing to each group. This pattern is particularly effective when dealing with data that has segmented characteristics, significantly simplifying code structure and improving readability.</p> <p>When we face problems that require dividing continuous elements into different groups according to specific conditions, the group cycle pattern provides a clear solution. Unlike traditional single-layer loops, group cycle uses a double-layer loop structure, with outer and inner loops each having their own responsibilities:</p> <ol> <li><strong>Outer Loop</strong>: Responsible for two key tasks <ul> <li>Inter-group preparation: Recording the starting position of each group</li> <li>Post-group statistics: Updating global results after processing a group (e.g., maximum values, counts, etc.)</li> </ul> </li> <li><strong>Inner Loop</strong>: Focuses on single group processing <ul> <li>Determining the current group’s boundary: Finding where the group ends</li> <li>Applying intra-group processing logic: Executing required operations on the elements of the current group</li> </ul> </li> </ol> <p>The key advantage of this structure lies in its clear logic and well-defined boundaries, especially that it doesn’t require special processing for the last group of data, which is often a common source of errors in coding.</p> <h3 id="example-problem">Example Problem</h3> <h4 id="problem-description">Problem Description</h4> <p>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">threshold</code>, we need to find the longest subarray that satisfies the following conditions:</p> <ol> <li>The first element of the subarray must be even</li> <li>The parity of adjacent elements in the subarray must alternate (one odd, one even)</li> <li>All elements in the subarray must not exceed the threshold We need to return the length of the longest subarray that satisfies these conditions.</li> </ol> <p><strong>Example:</strong></p> <ul> <li><strong>Input:</strong> nums = [3,2,5,4], threshold = 5</li> <li><strong>Output:</strong> 3</li> <li><strong>Explanation:</strong> The longest subarray that satisfies the conditions is [2,5,4], with a length of 3.</li> </ul> <h4 id="algorithm-implementation">Algorithm Implementation</h4> <p>Using group cycle to solve this problem, we implement the following:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestAlternatingSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">i</span><span class="o">++;</span> <span class="c1">// Skip elements that don't meet the initial conditions</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// Record the starting position of this group</span>
        <span class="n">i</span><span class="o">++;</span> <span class="c1">// Starting position already meets requirements, start judging from next position</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="c1">// From start to i-1 is a subarray that meets the requirements (and cannot be extended further)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="execution-step-analysis">Execution Step Analysis</h4> <p>Using the example input nums = [3,2,5,4], threshold = 5, the execution process is as follows:</p> <ol> <li><strong>Initialization</strong>: n = 4, ans = 0, i = 0</li> <li><strong>First Outer Loop</strong>: <ul> <li>nums[0] = 3, is odd, doesn’t meet initial condition (must be even)</li> <li>i++ → i = 1, continue to next iteration</li> </ul> </li> <li><strong>Second Outer Loop</strong>: <ul> <li>nums[1] = 2, is even and ≤ threshold, meets initial condition</li> <li>Record start = 1</li> <li>i++ → i = 2, enter inner loop</li> <li>Inner loop: <ul> <li>Check nums[2] = 5: ≤ threshold and has different parity from nums[1] (5 is odd, 2 is even)</li> <li>Meets condition, i++ → i = 3</li> <li>Check nums[3] = 4: ≤ threshold and has different parity from nums[2] (4 is even, 5 is odd)</li> <li>Meets condition, i++ → i = 4</li> <li>i = 4 is beyond array range, inner loop ends</li> </ul> </li> <li>Calculate subarray length: i - start = 4 - 1 = 3</li> <li>Update ans = max(0, 3) = 3</li> </ul> </li> <li><strong>Loop End</strong>: i = 4 ≥ n = 4, outer loop ends</li> <li><strong>Return Result</strong>: ans = 3</li> </ol> <h3 id="complexity-analysis">Complexity Analysis</h3> <ol> <li><strong>Time Complexity: O(n)</strong> <ul> <li>Although the code has nested loops, each element is visited at most once</li> <li>The outer loop variable i doesn’t simply increment, but jumps based on inner loop results</li> <li>All elements are processed only once in total, so the time complexity is O(n)</li> </ul> </li> <li><strong>Space Complexity: O(1)</strong> <ul> <li>Only uses a few variables (ans, i, start) to track state</li> <li>No additional data structures related to input size are used</li> </ul> </li> </ol> <h3 id="key-advantages">Key Advantages</h3> <ol> <li><strong>Clear Logic</strong> <ul> <li>Outer loop is responsible for finding suitable subarray starting points</li> <li>Inner loop is responsible for extending the subarray until it can’t be extended further</li> <li>Maximum length is updated immediately after group processing is complete</li> </ul> </li> <li><strong>Concise Code</strong> <ul> <li>No need for additional markers or complex condition judgments</li> <li>Naturally handles subarray boundaries through the concept of groups</li> </ul> </li> <li><strong>Avoids Common Errors</strong> <ul> <li>No need to specially process the last group of elements</li> <li>Boundary conditions are built into the loop structure</li> </ul> </li> <li><strong>Completed in One Pass</strong> <ul> <li>A single scan can find the answer, no need for repeated processing</li> <li>Ensures algorithm efficiency</li> </ul> </li> </ol> <h3 id="universal-pattern-of-group-cycle">Universal Pattern of Group Cycle</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">groupCycle</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        
        <span class="c1">// Inner loop: determine how far the current group can extend</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="cm">/* condition for continuing current group */</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        
        <span class="c1">// Elements from index 'start' to 'i - 1' form one group</span>
        <span class="c1">// You can process the group here, for example:</span>
        <span class="c1">// int groupLength = i - start;</span>
        
        <span class="c1">// No need to do i++ here — the index has already been advanced inside the inner loop</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>The beauty of this pattern lies in the fact that the outer loop doesn’t simply increment the index step by step—instead, it jumps forward based on the result of the inner loop. This ensures that each element is processed exactly once, while maintaining both clarity and efficiency in the code.</p> <h3 id="best-practices">Best Practices</h3> <ol> <li><strong>Clearly Define Group Boundary Conditions</strong> <ul> <li>Clearly specify under what circumstances a new group starts</li> <li>Clearly specify under what circumstances the current group ends</li> </ul> </li> <li><strong>Skip Elements That Don’t Meet Conditions Early</strong> <ul> <li>Check and skip elements that can’t be group starting points in the outer loop</li> <li>Reduce unnecessary calculations and checks</li> </ul> </li> <li><strong>Correctly Increment Loop Variables</strong> <ul> <li>Distinguish between direct incrementation (i++) and condition-based incrementation</li> <li>Increment loop variables at appropriate times to avoid missing or duplicate processing</li> </ul> </li> <li><strong>Correctly Calculate Group Length</strong> <ul> <li>Group length is the end position minus the start position</li> <li>Update the answer immediately after group processing is complete</li> </ul> </li> <li><strong>Reasonably Use the Continue Statement</strong> <ul> <li>Use continue to skip conditions that don’t meet requirements</li> <li>Maintain the clarity of loop logic</li> </ul> </li> </ol> <h3 id="application-scenarios">Application Scenarios</h3> <p>The group cycle technique is applicable to various algorithmic problems, especially those involving data with segmented characteristics:</p> <ol> <li><strong>Processing Consecutive Identical Elements</strong> <ul> <li>Calculate the longest sequence of consecutive identical characters</li> <li>Compress consecutive repeated elements (e.g., AAABBC → 3A2B1C)</li> </ul> </li> <li><strong>Peak-Valley Analysis</strong> <ul> <li>Find peaks and valleys in arrays</li> <li>Analyze trend changes in time series data such as stock prices</li> </ul> </li> <li><strong>Interval Property Problems</strong> <ul> <li>Find the longest/shortest intervals that satisfy specific conditions</li> <li>Process sequences with alternating characteristics (such as odd-even alternating, up-down alternating)</li> </ul> </li> <li><strong>Pattern Recognition</strong> <ul> <li>Identify specific patterns or regularities in sequences</li> <li>Find substrings that satisfy specific rules in strings</li> </ul> </li> <li><strong>Sequence Segmentation Processing</strong> <ul> <li>Divide sequences into multiple segments with similar properties</li> <li>Apply different processing logic to different segments</li> </ul> </li> </ol> <h3 id="key-considerations">Key Considerations</h3> <p>When applying the group cycle technique, consider the following key factors:</p> <ol> <li><strong>Group Definition</strong> <ul> <li>Clearly define group start conditions: What kind of elements can serve as starting points for groups?</li> <li>Clearly define group end conditions: Under what circumstances does the current group end?</li> <li>These definitions directly determine the conditions and structure of the loop</li> </ul> </li> <li><strong>Handling Boundary Cases</strong> <ul> <li>Empty array processing: The algorithm needs to correctly handle cases where the input is empty</li> <li>Single element processing: Determine whether a valid group can be formed when the array has only one element</li> <li>No satisfying groups exist: Ensure the algorithm returns an appropriate default value (such as 0)</li> </ul> </li> <li><strong>Index Management</strong> <ul> <li>Index updates for inner and outer loops need to be correct, avoiding skipping elements or processing duplicates</li> <li>Pay special attention to index handling after the group’s starting position is confirmed</li> </ul> </li> <li><strong>Condition Optimization</strong> <ul> <li>The order of condition judgments may affect performance, especially the application of short-circuit logic</li> <li>In the inner loop, check conditions that are easier to fail first to end unnecessary calculations early</li> </ul> </li> <li><strong>Scalability</strong> <ul> <li>Consider whether the algorithm is easy to extend to similar problems or more complex variants</li> <li>Analysis of the universality and specificity of grouping conditions</li> </ul> </li> </ol> <h3 id="summary">Summary</h3> <p>Group cycle is an efficient algorithmic technique for handling sequence segmentation problems. Its core idea is to divide sequences into multiple continuous groups through clearly defined inter-group and intra-group logic, and apply unified processing to each group. The main features of this technique include:</p> <ol> <li><strong>Clear Structure</strong>: The outer loop is responsible for inter-group management and result updates, while the inner loop focuses on single group processing and boundary determination, with clear responsibilities.</li> <li><strong>High Efficiency</strong>: Despite using nested loops, each element is processed at most once, ensuring linear time complexity.</li> <li><strong>Concise Boundary Handling</strong>: Naturally handles boundary conditions through the loop structure, avoiding common boundary errors.</li> <li><strong>Wide Application Range</strong>: From simple processing of consecutive identical elements to complex pattern recognition, group cycle provides elegant solutions.</li> </ol>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[Group cycle]]></summary></entry><entry><title type="html">2760. Longest Even Odd Subarray With Threshold</title><link href="https://zhengstar94.github.io//blog/2025/LongestEvenOddSubarrayWithThreshold/" rel="alternate" type="text/html" title="2760. Longest Even Odd Subarray With Threshold"/><published>2025-04-07T00:00:00+00:00</published><updated>2025-04-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestEvenOddSubarrayWithThreshold</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestEvenOddSubarrayWithThreshold/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">threshold</code>.</li> <li>Find the length of the <strong>longest subarray</strong> of <code class="language-plaintext highlighter-rouge">nums</code> starting at index <code class="language-plaintext highlighter-rouge">l</code> and ending at index <code class="language-plaintext highlighter-rouge">r</code> <code class="language-plaintext highlighter-rouge">(0 &lt;= l &lt;= r &lt; nums.length)</code> that satisfies the following conditions: <ul> <li><code class="language-plaintext highlighter-rouge">nums[l] % 2 == 0</code></li> <li>For all indices <code class="language-plaintext highlighter-rouge">i</code> in the range <code class="language-plaintext highlighter-rouge">[l, r - 1]</code>, <code class="language-plaintext highlighter-rouge">nums[i] % 2 != nums[i + 1] % 2</code></li> <li>For all indices <code class="language-plaintext highlighter-rouge">i</code> in the range <code class="language-plaintext highlighter-rouge">[l, r]</code>, <code class="language-plaintext highlighter-rouge">nums[i] &lt;= threshold</code></li> </ul> </li> <li>Return *an integer denoting the length of the longest such subarray.**</li> <li><strong>*Note:</strong> A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,5,4], threshold = 5
Output: 3
Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 3 =&gt; [2,5,4]. This subarray satisfies the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2], threshold = 2
Output: 1
Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 1 =&gt; [2]. 
It satisfies all the conditions and we can show that 1 is the maximum possible achievable length.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,4,5], threshold = 4
Output: 3
Explanation: In this example, we can select the subarray that starts at l = 0 and ends at r = 2 =&gt; [2,3,4]. 
It satisfies all the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.GroupedLoop</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestEvenOddSubarrayWithThreshold</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestAlternatingSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>    <span class="c1">// Length of input array</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>            <span class="c1">// Variable to store the maximum length found</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>              <span class="c1">// Loop counter/pointer</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Skip numbers that are either above threshold or not even</span>
            <span class="c1">// as they cannot be the start of a valid subarray</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Found a valid starting position (even number within threshold)</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>      <span class="c1">// Mark the start of current valid subarray</span>
            <span class="n">i</span><span class="o">++;</span>                <span class="c1">// Move to next position as start is already validated</span>

            <span class="c1">// Extend the subarray as long as conditions are met:</span>
            <span class="c1">// 1. Within array bounds</span>
            <span class="c1">// 2. Current element &lt;= threshold</span>
            <span class="c1">// 3. Current element has different parity than previous element</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="o">&amp;&amp;</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update the maximum length if current subarray is longer</span>
            <span class="c1">// i-start gives the length of current valid subarray</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: [3,2,5,4], threshold=5</span>
        <span class="c1">// Expected output: 3, because subarray [2,5,4] satisfies:</span>
        <span class="c1">// - Starts with even number 2</span>
        <span class="c1">// - 2 and 5 have different parity, 5 and 4 have different parity</span>
        <span class="c1">// - All numbers &lt;= 5</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">longestAlternatingSubarray</span><span class="o">(</span><span class="n">test1</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// Output: 3</span>

        <span class="c1">// Test Case 2: [1,2], threshold=2</span>
        <span class="c1">// Expected output: 1, because only [2] satisfies conditions</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">longestAlternatingSubarray</span><span class="o">(</span><span class="n">test2</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>  <span class="c1">// Output: 1</span>

        <span class="c1">// Test Case 3: [2,3,4,5], threshold=4</span>
        <span class="c1">// Expected output: 3, because subarray [2,3,4] satisfies:</span>
        <span class="c1">// - Starts with even number 2</span>
        <span class="c1">// - 2 and 3 have different parity, 3 and 4 have different parity</span>
        <span class="c1">// - All numbers &lt;= 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">longestAlternatingSubarray</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span>  <span class="c1">// Output: 3</span>

        <span class="c1">// Additional Test Cases</span>
        <span class="c1">// Test empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Empty Array Test Result: "</span> <span class="o">+</span> <span class="n">longestAlternatingSubarray</span><span class="o">(</span><span class="n">test4</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// Output: 0</span>

        <span class="c1">// Test single even element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Single Even Element Test Result: "</span> <span class="o">+</span> <span class="n">longestAlternatingSubarray</span><span class="o">(</span><span class="n">test5</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// Output: 1</span>

        <span class="c1">// Test array with no valid elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test6</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"No Valid Elements Test Result: "</span> <span class="o">+</span> <span class="n">longestAlternatingSubarray</span><span class="o">(</span><span class="n">test6</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>  <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode GroupedLoop"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums and an integer threshold. Find the length of the longest subarray of nums starting at index l and ending at index r (0 &lt;= l &lt;= r &lt; nums.length) that satisfies the following conditions: nums[l] % 2== 0 For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2 For all indices i in the range [l, r], nums[i] &lt;= threshold Return *an integer denoting the length of the longest such subarray.** *Note: A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry><entry><title type="html">2444. Count Subarrays With Fixed Bounds</title><link href="https://zhengstar94.github.io//blog/2025/CountSubarraysWithFixedBounds/" rel="alternate" type="text/html" title="2444. Count Subarrays With Fixed Bounds"/><published>2025-04-06T00:00:00+00:00</published><updated>2025-04-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubarraysWithFixedBounds</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubarraysWithFixedBounds/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and two integers <code class="language-plaintext highlighter-rouge">minK</code> and <code class="language-plaintext highlighter-rouge">maxK</code>.</li> <li>A <strong>fixed-bound subarray</strong> of <code class="language-plaintext highlighter-rouge">nums</code> is a subarray that satisfies the following conditions: <ul> <li>Return <em>the <strong>number</strong> of fixed-bound subarrays</em>.</li> <li>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</li> </ul> </li> <li>Return <em>the <strong>number</strong> of fixed-bound subarrays</em>.</li> <li>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
Output: 2
Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1], minK = 1, maxK = 1
Output: 10
Explanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.ThreePointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubarraysWithFixedBounds</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">minK</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxK</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Store the final count of valid subarrays</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// lastOutOfBound: Index of the last element that was out of bounds [minK, maxK]</span>
        <span class="c1">// Initially -1 indicating no out-of-bounds element found yet</span>
        <span class="kt">int</span> <span class="n">lastOutOfBound</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// lastMin: Index of the last occurrence of minK</span>
        <span class="c1">// lastMax: Index of the last occurrence of maxK</span>
        <span class="c1">// Initially -1 indicating no valid minK or maxK found yet</span>
        <span class="kt">int</span> <span class="n">lastMin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">lastMax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if current element is within bounds [minK, maxK]</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">minK</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">maxK</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update lastMin if we find minK</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">minK</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">lastMin</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Update lastMax if we find maxK</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">maxK</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">lastMax</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// If we have found both minK and maxK</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">lastMin</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">lastMax</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Calculate new valid subarrays:</span>
                    <span class="c1">// Take the minimum of lastMin and lastMax (earliest position we must include)</span>
                    <span class="c1">// Subtract lastOutOfBound (position we can't include)</span>
                    <span class="c1">// Use Math.max to ensure we don't add negative values</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">lastMin</span><span class="o">,</span> <span class="n">lastMax</span><span class="o">)</span> <span class="o">-</span> <span class="n">lastOutOfBound</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current element is out of bounds:</span>
                <span class="c1">// 1. Update lastOutOfBound to current position</span>
                <span class="c1">// 2. Reset lastMin and lastMax as we need to find new occurrences</span>
                <span class="n">lastOutOfBound</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">lastMin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="n">lastMax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with multiple valid subarrays</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">minK1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxK1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">minK1</span><span class="o">,</span> <span class="n">maxK1</span><span class="o">));</span> <span class="c1">// Expected: 2</span>
        <span class="c1">// Valid subarrays: [1,3,5], [1,3,5,2]</span>

        <span class="c1">// Test Case 2: Array with all elements equal</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">minK2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxK2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">minK2</span><span class="o">,</span> <span class="n">maxK2</span><span class="o">));</span> <span class="c1">// Expected: 10</span>
        <span class="c1">// All possible subarrays are valid</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode ThreePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given an integer array nums and two integers minK and maxK. A fixed-bound subarray of nums is a subarray that satisfies the following conditions: Return the number of fixed-bound subarrays. A subarray is a contiguous part of an array. Return the number of fixed-bound subarrays. A subarray is a contiguous part of an array.]]></summary></entry><entry><title type="html">795. Number of Subarrays with Bounded Maximum</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfSubarraysWithBoundedMaximum/" rel="alternate" type="text/html" title="795. Number of Subarrays with Bounded Maximum"/><published>2025-04-06T00:00:00+00:00</published><updated>2025-04-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfSubarraysWithBoundedMaximum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfSubarraysWithBoundedMaximum/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and two integers <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>, return <em>the number of contiguous non-empty <strong>subarrays</strong> such that the value of the maximum array element in that subarray is in the range</em> <code class="language-plaintext highlighter-rouge">[left, right]</code>.</li> <li>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,4,3], left = 2, right = 3
Output: 3
Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,9,2,5,6], left = 2, right = 8
Output: 7
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.ThreePointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfSubarraysWithBoundedMaximum</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numSubarrayBoundedMax</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// stores final count of valid subarrays</span>
        <span class="kt">int</span> <span class="n">lastInvalidPos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// position of last element &gt; right</span>
        <span class="kt">int</span> <span class="n">lastValid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// position of last element &gt;= left</span>

        <span class="c1">// Iterate through array once</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If current element exceeds right boundary</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">){</span>
                <span class="n">lastInvalidPos</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If current element is within or above left boundary</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">){</span>
                <span class="n">lastValid</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Add count of valid subarrays ending at current position</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">lastValid</span> <span class="o">-</span> <span class="n">lastInvalidPos</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">left1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span>
                <span class="n">numSubarrayBoundedMax</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">left1</span><span class="o">,</span> <span class="n">right1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">left2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right2</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span>
                <span class="n">numSubarrayBoundedMax</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">left2</span><span class="o">,</span> <span class="n">right2</span><span class="o">));</span> <span class="c1">// Expected output: 7</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode ThreePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right]. The test cases are generated so that the answer will fit in a 32-bit integer.]]></summary></entry><entry><title type="html">(Review)2563. Count the Number of Fair Pairs</title><link href="https://zhengstar94.github.io//blog/2025/CountTheNumberOfFairPairs/" rel="alternate" type="text/html" title="(Review)2563. Count the Number of Fair Pairs"/><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountTheNumberOfFairPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountTheNumberOfFairPairs/"><![CDATA[<ul> <li>Given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code> and two integers <code class="language-plaintext highlighter-rouge">lower</code> and <code class="language-plaintext highlighter-rouge">upper</code>, return <em>the number of fair pairs</em>.</li> <li>A pair <code class="language-plaintext highlighter-rouge">(i, j)</code> is <strong>fair</strong> if: <ul> <li><code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; n</code>, and</li> <li><code class="language-plaintext highlighter-rouge">lower &lt;= nums[i] + nums[j] &lt;= upper</code></li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
Output: 6
Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,7,9,2,5], lower = 11, upper = 11
Output: 1
Explanation: There is a single fair pair: (2,3).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.ThreePointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountTheNumberOfFairPairs</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countFairPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort array to handle pairs in order</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Initialize pointers to end of array</span>
        <span class="c1">// left: tracks the leftmost position where nums[j] + nums[i] &gt;= lower</span>
        <span class="c1">// right: tracks the leftmost position where nums[j] + nums[i] &gt; upper</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// For each number as the second element of the pair</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Move right pointer left while sum is too large</span>
            <span class="c1">// Find rightmost position where nums[right-1] + nums[i] &lt;= upper</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Move left pointer left while sum is large enough</span>
            <span class="c1">// Find rightmost position where nums[left-1] + nums[i] &gt;= lower</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">lower</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Calculate valid pairs for current nums[i]:
             *
             * Math.min(right, i) - Math.min(left, i) counts pairs where:
             * 1. The first number (nums[j]) must be to the left of nums[i] (j &lt; i)
             * 2. The sum must be &lt;= upper (controlled by right pointer)
             * 3. The sum must be &gt;= lower (controlled by left pointer)
             *
             * Example: for i = 2 (nums[2] = 5):
             * - If right = 3 and left = 0:
             * - Math.min(3, 2) = 2 (can only use positions up to i)
             * - Math.min(0, 2) = 0 (start from position 0)
             * - 2 - 0 = 2 pairs possible (using positions 0 and 1)
             *
             * We use Math.min because:
             * - We can't use positions beyond i (need j &lt; i)
             * - right gives upper bound of valid positions
             * - left gives lower bound of valid positions
             * - The difference gives count of valid positions
             */</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Multiple fair pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">countFairPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">lower1</span><span class="o">,</span> <span class="n">upper1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2: Single fair pair</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">lower2</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">upper2</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [1,7,9,2,5], lower = 11, upper = 11"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">countFairPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">lower2</span><span class="o">,</span> <span class="n">upper2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode ThreePointers"/><category term="Medium"/><category term="TwoPointers"/><category term="Review"/><summary type="html"><![CDATA[Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs. A pair (i, j) is fair if: 0 &lt;= i &lt; j &lt; n, and lower &lt;= nums[i] + nums[j] &lt;= upper]]></summary></entry><entry><title type="html">1123. Lowest Common Ancestor of Deepest Leaves</title><link href="https://zhengstar94.github.io//blog/2025/LowestCommonAncestorOfDeepestLeaves/" rel="alternate" type="text/html" title="1123. Lowest Common Ancestor of Deepest Leaves"/><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LowestCommonAncestorOfDeepestLeaves</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LowestCommonAncestorOfDeepestLeaves/"><![CDATA[<ul> <li>Given the <code class="language-plaintext highlighter-rouge">root</code> of a binary tree, return <em>the lowest common ancestor of its deepest leaves</em>.</li> <li>Recall that: <ul> <li>The node of a binary tree is a leaf if and only if it has no children</li> <li>The depth of the root of the tree is <code class="language-plaintext highlighter-rouge">0</code>. if the depth of a node is <code class="language-plaintext highlighter-rouge">d</code>, the depth of each of its children is <code class="language-plaintext highlighter-rouge">d + 1</code>.</li> <li>The lowest common ancestor of a set <code class="language-plaintext highlighter-rouge">S</code> of nodes, is the node <code class="language-plaintext highlighter-rouge">A</code> with the largest depth such that every node in <code class="language-plaintext highlighter-rouge">S</code> is in the subtree with root <code class="language-plaintext highlighter-rouge">A</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest leaf-nodes of the tree.
Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree, and it's the lca of itself.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest leaf node in the tree is 2, the lca of one node is itself.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LowestCommonAncestorOfDeepestLeaves</span> <span class="o">{</span>
    <span class="c1">// Store the result node (lowest common ancestor)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="n">ans</span><span class="o">;</span>
    <span class="c1">// Track the maximum depth in the entire tree</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">maxDepth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="nf">lcaDeepestLeaves</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Reset static variables for multiple test cases</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">maxDepth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Start DFS from root with initial depth 0</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: reached null node</span>
        <span class="c1">// Update maxDepth and return current depth</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxDepth</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDepth</span><span class="o">,</span> <span class="n">depth</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">depth</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Recursively process left and right subtrees</span>
        <span class="kt">int</span> <span class="n">leftMaxDepth</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rightMaxDepth</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// If both subtrees reach the same maximum depth</span>
        <span class="c1">// and this depth equals the tree's maximum depth,</span>
        <span class="c1">// current node is a candidate for LCA</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leftMaxDepth</span> <span class="o">==</span> <span class="n">rightMaxDepth</span> <span class="o">&amp;&amp;</span> <span class="n">leftMaxDepth</span> <span class="o">==</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Return the maximum depth reached in this subtree</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftMaxDepth</span><span class="o">,</span> <span class="n">rightMaxDepth</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Balanced tree</span>
        <span class="c1">//       1</span>
        <span class="c1">//      / \</span>
        <span class="c1">//     2   3</span>
        <span class="c1">//    /     \</span>
        <span class="c1">//   4       5</span>
        <span class="nc">TreeNode</span> <span class="n">test1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>

        <span class="nc">TreeNode</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">lcaDeepestLeaves</span><span class="o">(</span><span class="n">test1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 - Expected: 1, Actual: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Unbalanced tree</span>
        <span class="c1">//       1</span>
        <span class="c1">//      / \</span>
        <span class="c1">//     2   3</span>
        <span class="c1">//    / \</span>
        <span class="c1">//   4   5</span>
        <span class="c1">//  /   /</span>
        <span class="c1">// 6   7</span>
        <span class="nc">TreeNode</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>

        <span class="nc">TreeNode</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">lcaDeepestLeaves</span><span class="o">(</span><span class="n">test2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 - Expected: 2, Actual: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="c1">// Test Case 3: Single node tree</span>
        <span class="nc">TreeNode</span> <span class="n">test3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">lcaDeepestLeaves</span><span class="o">(</span><span class="n">test3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 - Expected: 1, Actual: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><category term="Medium"/><summary type="html"><![CDATA[Given the root of a binary tree, return the lowest common ancestor of its deepest leaves. Recall that: The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1. The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.]]></summary></entry><entry><title type="html">2367. Number of Arithmetic Triplets</title><link href="https://zhengstar94.github.io//blog/2025/NumberOfArithmeticTriplets/" rel="alternate" type="text/html" title="2367. Number of Arithmetic Triplets"/><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/NumberOfArithmeticTriplets</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/NumberOfArithmeticTriplets/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong>, <strong>strictly increasing</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> and a positive integer <code class="language-plaintext highlighter-rouge">diff</code>. A triplet <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is an <strong>arithmetic triplet</strong> if the following conditions are met: <ul> <li><code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code>,</li> <li><code class="language-plaintext highlighter-rouge">nums[j] - nums[i] == diff</code>, and</li> <li><code class="language-plaintext highlighter-rouge">nums[k] - nums[j] == diff</code>.</li> </ul> </li> <li>Return <em>the number of unique <strong>arithmetic triplets</strong>.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,4,6,7,10], diff = 3
Output: 2
Explanation:
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,5,6,7,8,9], diff = 2
Output: 2
Explanation:
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.ThreePointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfArithmeticTriplets</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">arithmeticTriplets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Counter for arithmetic triplets</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Pointer i for the first number in the triplet</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Pointer j for the second number in the triplet</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through the array, treating each element as the third number (x)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Move pointer j until we find a potential second number</span>
            <span class="c1">// We want: nums[j] + diff &gt;= x</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">){</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If nums[j] + diff &gt; x, no valid triplet possible with current x</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Move pointer i until we find a potential first number</span>
            <span class="c1">// We want: nums[i] + 2*diff &gt;= x</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If we found a perfect match where nums[i] + 2*diff = x,</span>
            <span class="c1">// we've found an arithmetic triplet</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">x</span><span class="o">){</span>
                <span class="n">ans</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple arithmetic triplets</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">diff1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [0,1,4,6,7,10], diff = 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">arithmeticTriplets</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">diff1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Consecutive arithmetic triplets</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">diff2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums = [4,5,6,7,8,9], diff = 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Output: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Output: "</span> <span class="o">+</span> <span class="n">arithmeticTriplets</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">diff2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode ThreePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met: i &lt; j &lt; k, nums[j] - nums[i] == diff, and nums[k] - nums[j] == diff. Return the number of unique arithmetic triplets.]]></summary></entry><entry><title type="html">2874. Maximum Value of an Ordered Triplet II</title><link href="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII/" rel="alternate" type="text/html" title="2874. Maximum Value of an Ordered Triplet II"/><published>2025-04-03T00:00:00+00:00</published><updated>2025-04-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <strong><em>the maximum value over all triplets of indices</em></strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code><em>.</em> If all such triplets have a negative value, return <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>The <strong>value of a triplet of indices</strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is equal to <code class="language-plaintext highlighter-rouge">(nums[i] - nums[j]) * nums[k]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumValueOfAnOrderedTripletII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumTripletValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                <span class="c1">// Stores maximum triplet value</span>
        <span class="kt">int</span> <span class="n">maxDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>            <span class="c1">// Tracks maximum difference between any two previous elements</span>
        <span class="kt">int</span> <span class="n">preMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>             <span class="c1">// Keeps track of maximum element seen so far</span>

        <span class="c1">// Iterate through each element in array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Update maximum triplet value using current element as nums[k]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">maxDiff</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span>

            <span class="c1">// Update maximum difference considering current element as nums[j]</span>
            <span class="n">maxDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDiff</span><span class="o">,</span> <span class="n">preMax</span> <span class="o">-</span> <span class="n">x</span><span class="o">);</span>

            <span class="c1">// Update maximum value seen so far (potential nums[i])</span>
            <span class="n">preMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">preMax</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases array with example inputs</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span>    <span class="c1">// Expected output: 77  ( ( 12-1)*7)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">19</span><span class="o">},</span>   <span class="c1">// Expected output: 133 ( ( 10-3)*19)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>            <span class="c1">// Expected output: 0   (no valid positive value possible)</span>
        <span class="o">};</span>

        <span class="c1">// Run all test cases and print results</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maximumTripletValue</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i &lt; j &lt; k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].]]></summary></entry><entry><title type="html">2873. Maximum Value of an Ordered Triplet I</title><link href="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI/" rel="alternate" type="text/html" title="2873. Maximum Value of an Ordered Triplet I"/><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <strong><em>the maximum value over all triplets of indices</em></strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code>. If all such triplets have a negative value, return <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>The <strong>value of a triplet of indices</strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is equal to <code class="language-plaintext highlighter-rouge">(nums[i] - nums[j ] ) * nums[k]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2 ] ) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2 ] ) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1 ] ) * nums[2] = -3. Hence, the answer would be 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumValueOfAnOrderedTripletI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumTripletValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the answer to store the maximum triplet value</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the maximum difference (nums[i] - nums[j]) encountered so far</span>
        <span class="kt">int</span> <span class="n">maxDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the maximum value encountered so far (potential nums[i])</span>
        <span class="kt">int</span> <span class="n">preMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate potential answer using current number as nums[k]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">maxDiff</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span>
            <span class="c1">// Update maxDiff: current number could be nums[j]</span>
            <span class="n">maxDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDiff</span><span class="o">,</span> <span class="n">preMax</span> <span class="o">-</span> <span class="n">x</span><span class="o">);</span>
            <span class="c1">// Update preMax: current number could be nums[i]</span>
            <span class="n">preMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">preMax</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases array with example inputs</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span>    <span class="c1">// Expected output: 77  ( ( 12-1)*7)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">19</span><span class="o">},</span>   <span class="c1">// Expected output: 133 ( ( 10-3)*19)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>            <span class="c1">// Expected output: 0   (no valid positive value possible)</span>
        <span class="o">};</span>

        <span class="c1">// Run all test cases and print results</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maximumTripletValue</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i &lt; j &lt; k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j ] ) * nums[k].]]></summary></entry><entry><title type="html">2140. Solving Questions With Brainpower</title><link href="https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower/" rel="alternate" type="text/html" title="2140. Solving Questions With Brainpower"/><published>2025-04-01T00:00:00+00:00</published><updated>2025-04-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">questions</code> where <code class="language-plaintext highlighter-rouge">questions[i] = [pointsi, brainpoweri]</code>.</li> <li>The array describes the questions of an exam, where you have to process the questions <strong>in order</strong> (i.e., starting from question <code class="language-plaintext highlighter-rouge">0</code>) and make a decision whether to <strong>solve</strong> or <strong>skip</strong> each question. Solving question <code class="language-plaintext highlighter-rouge">i</code> will <strong>earn</strong> you <code class="language-plaintext highlighter-rouge">pointsi</code> points but you will be <strong>unable</strong> to solve each of the next <code class="language-plaintext highlighter-rouge">brainpoweri</code> questions. If you skip question <code class="language-plaintext highlighter-rouge">i</code>, you get to make the decision on the next question. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">questions = [ [ 3, 2], [4, 3], [4, 4], [2, 5 ] ]</code>: <ul> <li>If question <code class="language-plaintext highlighter-rouge">0</code> is solved, you will earn <code class="language-plaintext highlighter-rouge">3</code> points but you will be unable to solve questions <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">2</code>.</li> <li>If instead, question <code class="language-plaintext highlighter-rouge">0</code> is skipped and question <code class="language-plaintext highlighter-rouge">1</code> is solved, you will earn <code class="language-plaintext highlighter-rouge">4</code> points but you will be unable to solve questions <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code>.</li> </ul> </li> </ul> </li> <li>Return <em>the <strong>maximum</strong> points you can earn for the exam</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: questions = [ [ 3,2],[4,3],[4,4],[2,5 ] ]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: questions = [ [ 1,1],[2,2],[3,3],[4,4],[5,5 ] ]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengxingxing
 * Date: 2025/04/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SolvingQuestionsWithBrainpower</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">mostPoints</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">questions</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Total number of questions.</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">questions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// dp[i] stores the maximum points obtainable from question i to the end.</span>
        <span class="c1">// dp[n] is the base case (0 points) for when we are beyond the last question.</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Iterate from the last question backwards.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="c1">// Retrieve the points for the current question.</span>
            <span class="kt">int</span> <span class="n">points</span> <span class="o">=</span> <span class="n">questions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="c1">// Retrieve the brainpower value (number of questions to skip after solving this question).</span>
            <span class="kt">int</span> <span class="n">jump</span> <span class="o">=</span> <span class="n">questions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Determine the next question index after solving the current one.</span>
            <span class="c1">// Ensure that nextPosition does not exceed the array bounds.</span>
            <span class="kt">int</span> <span class="n">nextPosition</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">jump</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Two options at this question:</span>
            <span class="c1">// Option 1: Solve this question → points + dp[nextPosition]</span>
            <span class="c1">// Option 2: Skip this question → dp[i + 1]</span>
            <span class="c1">// Choose the maximum of the two.</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">points</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">nextPosition</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// dp[0] holds the maximum points obtainable starting from the first question.</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1:</span>
        <span class="c1">// Explanation: Optimal strategy is to solve question 0 (3 points) and question 3 (2 points),</span>
        <span class="c1">// resulting in a total of 5 points.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">questions1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">mostPoints</span><span class="o">(</span><span class="n">questions1</span><span class="o">));</span>  <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 2:</span>
        <span class="c1">// Explanation: Optimal strategy is to skip question 0, solve question 1 (2 points)</span>
        <span class="c1">// and question 4 (5 points), resulting in a total of 7 points.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">questions2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">mostPoints</span><span class="o">(</span><span class="n">questions2</span><span class="o">));</span>  <span class="c1">// Expected output: 7</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri]. The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question. For example, given questions=[ [ 3, 2], [4, 3], [4, 4], [2, 5 ] ]: If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2. If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3. Return the maximum points you can earn for the exam.]]></summary></entry></feed>