<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-16T05:31:39+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1299. Replace Elements with Greatest Element on Right Side</title><link href="https://zhengstar94.github.io//blog/2025/ReplaceElementsWithGreatestElementOnRightSide/" rel="alternate" type="text/html" title="1299. Replace Elements with Greatest Element on Right Side"/><published>2025-02-16T00:00:00+00:00</published><updated>2025-02-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ReplaceElementsWithGreatestElementOnRightSide</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ReplaceElementsWithGreatestElementOnRightSide/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">arr</code>, replace every element in that array with the greatest element among the elements to its right, and replace the last element with <code class="language-plaintext highlighter-rouge">-1</code>.</li> <li>After doing so, return the array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [17,18,5,4,6,1]
Output: [18,6,6,6,1,-1]
Explanation: 
- index 0 --&gt; the greatest element to the right of index 0 is index 1 (18).
- index 1 --&gt; the greatest element to the right of index 1 is index 4 (6).
- index 2 --&gt; the greatest element to the right of index 2 is index 4 (6).
- index 3 --&gt; the greatest element to the right of index 3 is index 4 (6).
- index 4 --&gt; the greatest element to the right of index 4 is index 5 (1).
- index 5 --&gt; there are no elements to the right of index 5, so we put -1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [400]
Output: [-1]
Explanation: There are no elements to the right of index 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReplaceElementsWithGreatestElementOnRightSide</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">replaceElements</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>  <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>        <span class="c1">// Initialize max as -1 (will be the value for the last element)</span>

        <span class="c1">// Traverse array from right to left</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>    <span class="c1">// Store current element temporarily</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>         <span class="c1">// Replace current element with maximum value seen so far</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>  <span class="c1">// Update maximum value</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with multiple elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">17</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">replaceElements</span><span class="o">(</span><span class="n">arr1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span> <span class="c1">// Expected output: [18, 6, 6, 6, 1, -1]</span>

        <span class="c1">// Test Case 2: Array with single element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">400</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">replaceElements</span><span class="o">(</span><span class="n">arr2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span> <span class="c1">// Expected output: [-1]</span>

        <span class="c1">// Test Case 3: Array with decreasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">replaceElements</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result</span><span class="o">));</span> <span class="c1">// Expected output: [4, 3, 2, 1, -1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array.]]></summary></entry><entry><title type="html">1706. Where Will the Ball Fall</title><link href="https://zhengstar94.github.io//blog/2025/WhereWillTheBallFall/" rel="alternate" type="text/html" title="1706. Where Will the Ball Fall"/><published>2025-02-15T00:00:00+00:00</published><updated>2025-02-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/WhereWillTheBallFall</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/WhereWillTheBallFall/"><![CDATA[<ul> <li>You have a 2-D <code class="language-plaintext highlighter-rouge">grid</code> of size <code class="language-plaintext highlighter-rouge">m x n</code> representing a box, and you have <code class="language-plaintext highlighter-rouge">n</code> balls. The box is open on the top and bottom sides.</li> <li>Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left. <ul> <li>A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as <code class="language-plaintext highlighter-rouge">1</code>.</li> <li>A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> </li> <li>We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a “V” shaped pattern between two boards or if a board redirects the ball into either wall of the box.</li> <li>Return <em>an array</em> <code class="language-plaintext highlighter-rouge">answer</code> <em>of size</em> <code class="language-plaintext highlighter-rouge">n</code> <em>where</em> <code class="language-plaintext highlighter-rouge">answer[i]</code> <em>is the column that the ball falls out of at the bottom after dropping the ball from the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>column at the top, or <code class="language-plaintext highlighter-rouge">-1</code> *if the ball gets stuck in the box*.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1] ]
Output: [1,-1,-1,-1,-1]
Explanation: This example is shown in the photo.
Ball b0 is dropped at column 0 and falls out of the box at column 1.
Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.
Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.
Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.
Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [-1] ]
Output: [-1]
Explanation: The ball gets stuck against the left wall.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1 ] ]
Output: [0,1,2,3,4,-1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WhereWillTheBallFall</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findBall</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the width of the grid (number of columns)</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Initialize result array to store the exit positions for each ball</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Simulate dropping a ball from each column</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Track current column position of the ball</span>
            <span class="c1">// Initially, ball starts from column j</span>
            <span class="kt">int</span> <span class="n">curCol</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>

            <span class="c1">// Iterate through each row of the grid</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">row:</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Get the direction of the current board</span>
                <span class="c1">// d = 1: board directs ball to right</span>
                <span class="c1">// d = -1: board directs ball to left</span>
                <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">row</span><span class="o">[</span><span class="n">curCol</span><span class="o">];</span>

                <span class="c1">// Move ball to next position based on board direction</span>
                <span class="n">curCol</span> <span class="o">+=</span> <span class="n">d</span><span class="o">;</span>

                <span class="c1">// Check if ball gets stuck:</span>
                <span class="c1">// 1. curCol &lt; 0: ball hits left boundary</span>
                <span class="c1">// 2. curCol == n: ball hits right boundary</span>
                <span class="c1">// 3. row[curCol] != d: forms V-shape with adjacent board</span>
                <span class="c1">//    Example: Current board goes right (1) but next position board goes left (-1)</span>
                <span class="c1">//    or current board goes left (-1) but next position board goes right (1)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">curCol</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">curCol</span> <span class="o">==</span> <span class="n">n</span> <span class="o">||</span> <span class="n">row</span><span class="o">[</span><span class="n">curCol</span><span class="o">]</span> <span class="o">!=</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Ball is stuck, mark position as -1</span>
                    <span class="n">curCol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="c1">// Stop simulating this ball's path</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Store final position for ball dropped from column j</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">curCol</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Complex path with multiple directions</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findBall</span><span class="o">(</span><span class="n">grid1</span><span class="o">)));</span>

        <span class="c1">// Test Case 2: Simplest case with single cell</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findBall</span><span class="o">(</span><span class="n">grid2</span><span class="o">)));</span>

        <span class="c1">// Test Case 3: Alternating rows of same direction</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findBall</span><span class="o">(</span><span class="n">grid3</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides. Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left. A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1. A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1. We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a “V” shaped pattern between two boards or if a board redirects the ball into either wall of the box. Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 *if the ball gets stuck in the box*.]]></summary></entry><entry><title type="html">1352. Product of the Last K Numbers</title><link href="https://zhengstar94.github.io//blog/2025/ProductOfNumbers/" rel="alternate" type="text/html" title="1352. Product of the Last K Numbers"/><published>2025-02-14T00:00:00+00:00</published><updated>2025-02-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ProductOfNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ProductOfNumbers/"><![CDATA[<ul> <li>Design an algorithm that accepts a stream of integers and retrieves (vt. 重新得到；恢复；检索 vi. 找回猎物) the product of the last <code class="language-plaintext highlighter-rouge">k</code> integers of the stream.</li> <li>Implement the <code class="language-plaintext highlighter-rouge">ProductOfNumbers</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">ProductOfNumbers()</code> Initializes the object with an empty stream.</li> <li><code class="language-plaintext highlighter-rouge">void add(int num)</code> Appends the integer <code class="language-plaintext highlighter-rouge">num</code> to the stream.</li> <li><code class="language-plaintext highlighter-rouge">int getProduct(int k)</code> Returns the product of the last <code class="language-plaintext highlighter-rouge">k</code> numbers in the current list. You can assume that always the current list has at least <code class="language-plaintext highlighter-rouge">k</code> numbers.</li> </ul> </li> <li>The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

Output
[null,null,null,null,null,null,20,40,0,null,32]

Explanation
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengxingxing
 * Date: 2025/02/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductOfNumbers</span> <span class="o">{</span>
    <span class="c1">// Use ArrayList to store the prefix product of the numbers in the stream.</span>
    <span class="c1">// prefixProduct[i] represents the product of all numbers from the start of the list to index i.</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">prefixProduct</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">ProductOfNumbers</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">prefixProduct</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">prefixProduct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// Add 1 as the initial base of the prefix product list.</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the number is 0, reset the prefix product list.</span>
            <span class="c1">// This resets the product calculation due to the zero.</span>
            <span class="n">prefixProduct</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="n">prefixProduct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// Start fresh with 1 again as the base.</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// If the number is not zero, calculate the new prefix product </span>
            <span class="c1">// by multiplying the last prefix product with the new number.</span>
            <span class="n">prefixProduct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">prefixProduct</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prefixProduct</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getProduct</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prefixProduct</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="c1">// If `k` is greater than or equal to the size of the prefix list,</span>
        <span class="c1">// it means the range includes a zero, so the product is 0.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Return the product of the last `k` numbers using:</span>
        <span class="c1">// prefixProduct[n-1] (total product up to the last number)</span>
        <span class="c1">// divided by prefixProduct[n-k-1] (product up to the last `n-k` numbers).</span>
        <span class="k">return</span> <span class="n">prefixProduct</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">prefixProduct</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ProductOfNumbers</span> <span class="n">productOfNumbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ProductOfNumbers</span><span class="o">();</span>

        <span class="c1">// Test case 1</span>
        <span class="n">productOfNumbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span> <span class="c1">// Stream: [3]</span>
        <span class="n">productOfNumbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// Stream: [3,0] - reset due to zero</span>
        <span class="n">productOfNumbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// Stream: [2] - starting fresh</span>
        <span class="n">productOfNumbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span> <span class="c1">// Stream: [2,5]</span>
        <span class="n">productOfNumbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> <span class="c1">// Stream: [2,5,4]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">productOfNumbers</span><span class="o">.</span><span class="na">getProduct</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected output: 20 (5 * 4)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">productOfNumbers</span><span class="o">.</span><span class="na">getProduct</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected output: 40 (2 * 5 * 4)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">productOfNumbers</span><span class="o">.</span><span class="na">getProduct</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span> <span class="c1">// Expected output: 0 (due to zero in the range)</span>
        <span class="n">productOfNumbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span> <span class="c1">// Stream: [2,5,4,8]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">productOfNumbers</span><span class="o">.</span><span class="na">getProduct</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected output: 32 (4 * 8)</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">ProductOfNumbers</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ProductOfNumbers</span><span class="o">();</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// Stream: [2]</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span> <span class="c1">// Stream: [2,3]</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> <span class="c1">// Stream: [2,3,4]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test2</span><span class="o">.</span><span class="na">getProduct</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected output: 12 (3 * 4)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test2</span><span class="o">.</span><span class="na">getProduct</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected output: 24 (2 * 3 * 4)</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[Design an algorithm that accepts a stream of integers and retrieves (vt. 重新得到；恢复；检索 vi. 找回猎物) the product of the last k integers of the stream. Implement the ProductOfNumbers class: ProductOfNumbers() Initializes the object with an empty stream. void add(int num) Appends the integer num to the stream. int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers. The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.]]></summary></entry><entry><title type="html">930. Binary Subarrays With Sum</title><link href="https://zhengstar94.github.io//blog/2025/BinarySubarraysWithSum/" rel="alternate" type="text/html" title="930. Binary Subarrays With Sum"/><published>2025-02-13T00:00:00+00:00</published><updated>2025-02-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BinarySubarraysWithSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BinarySubarraysWithSum/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">goal</code>, return <em>the number of non-empty <strong>subarrays</strong> with a sum</em> <code class="language-plaintext highlighter-rouge">goal</code>.</li> <li>A <strong>subarray</strong> is a contiguous part of the array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,0,0,0,0], goal = 0
Output: 15
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountExact</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinarySubarraysWithSum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numSubarraysWithSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">goal</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Result counter to store the number of valid subarrays</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// sum1: tracks sum for window1 (sum &gt;= goal)</span>
        <span class="c1">// sum2: tracks sum for window2 (sum &gt;= goal + 1)</span>
        <span class="kt">int</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Using three pointers:</span>
        <span class="c1">// l1: left boundary for sum &gt;= goal</span>
        <span class="c1">// l2: left boundary for sum &gt;= goal + 1</span>
        <span class="c1">// r: right boundary for both windows</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Expand both windows by adding the current element</span>
            <span class="n">sum1</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
            <span class="n">sum2</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>

            <span class="c1">// First window: contract from left while sum1 &gt;= goal</span>
            <span class="c1">// This window finds all subarrays with sum &gt;= goal</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">sum1</span> <span class="o">&gt;=</span> <span class="n">goal</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sum1</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l1</span><span class="o">];</span>
                <span class="n">l1</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Second window: contract from left while sum2 &gt;= goal + 1</span>
            <span class="c1">// This window finds all subarrays with sum &gt;= goal + 1</span>
            <span class="c1">// The purpose is to exclude subarrays with sum greater than goal</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">l2</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">sum2</span> <span class="o">&gt;=</span> <span class="n">goal</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sum2</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l2</span><span class="o">];</span>
                <span class="n">l2</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// The difference (l1 - l2) gives us the count of subarrays</span>
            <span class="c1">// with sum exactly equal to goal ending at current right pointer 'r'</span>
            <span class="c1">// Because:</span>
            <span class="c1">// l1 represents: how many positions we can place left boundary to get sum &gt;= goal</span>
            <span class="c1">// l2 represents: how many positions we can place left boundary to get sum &gt;= goal+1</span>
            <span class="c1">// Their difference is exactly the count of subarrays with sum == goal</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Regular case with mixed 0s and 1s</span>
        <span class="c1">// Expected subarrays with sum=2: [1,0,1], [1,0,1], [0,1,0,1], [1,0,1]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">goal1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numSubarraysWithSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">goal1</span><span class="o">));</span> <span class="c1">// Output: 4</span>

        <span class="c1">// Test Case 2: Array with all zeros</span>
        <span class="c1">// Every subarray has sum=0, total number of subarrays = n*(n+1)/2 where n=5</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">goal2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numSubarraysWithSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">goal2</span><span class="o">));</span> <span class="c1">// Output: 15</span>

        <span class="c1">// Test Case 3: Array with all ones</span>
        <span class="c1">// Subarrays with sum=3: [1,1,1], [1,1,1], [1,1,1]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">goal3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numSubarraysWithSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">goal3</span><span class="o">));</span> <span class="c1">// Output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountExact"/><category term="Medium"/><category term="SlideWindow"/><summary type="html"><![CDATA[Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal. A subarray is a contiguous part of the array.]]></summary></entry><entry><title type="html">1248. Count Number of Nice Subarrays</title><link href="https://zhengstar94.github.io//blog/2025/CountNumberOfNiceSubarrays/" rel="alternate" type="text/html" title="1248. Count Number of Nice Subarrays"/><published>2025-02-13T00:00:00+00:00</published><updated>2025-02-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountNumberOfNiceSubarrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountNumberOfNiceSubarrays/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>. A continuous subarray is called <strong>nice</strong> if there are <code class="language-plaintext highlighter-rouge">k</code> odd numbers on it.</li> <li>Return <em>the number of <strong>nice</strong> sub-arrays</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There are no odd numbers in the array.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountExact</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountNumberOfNiceSubarrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">count1</span><span class="o">++;</span>
                <span class="n">count2</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">count1</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l1</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">count1</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="n">l1</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">l2</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">count2</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l2</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">count2</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="n">l2</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="n">res</span> <span class="o">+=</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 测试用例1：常规情况</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"测试用例1结果: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// 输出: 2</span>

        <span class="c1">// 测试用例2：没有奇数的情况</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"测试用例2结果: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// 输出: 0</span>

        <span class="c1">// 测试用例3：较长数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"测试用例3结果: "</span> <span class="o">+</span> <span class="n">numberOfSubarrays</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// 输出: 16</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountExact"/><category term="Medium"/><category term="SlideWindow"/><summary type="html"><![CDATA[Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays.]]></summary></entry><entry><title type="html">1742. Maximum Number of Balls in a Box</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfBallsInABox/" rel="alternate" type="text/html" title="1742. Maximum Number of Balls in a Box"/><published>2025-02-13T00:00:00+00:00</published><updated>2025-02-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfBallsInABox</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfBallsInABox/"><![CDATA[<ul> <li>You are working in a ball factory where you have <code class="language-plaintext highlighter-rouge">n</code> balls numbered from <code class="language-plaintext highlighter-rouge">lowLimit</code> up to <code class="language-plaintext highlighter-rouge">highLimit</code> <strong>inclusive</strong> (i.e., <code class="language-plaintext highlighter-rouge">n == highLimit - lowLimit + 1</code>), and an infinite number of boxes numbered from <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">infinity</code>.</li> <li>Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball’s number. For example, the ball number <code class="language-plaintext highlighter-rouge">321</code> will be put in the box number <code class="language-plaintext highlighter-rouge">3 + 2 + 1 = 6</code> and the ball number <code class="language-plaintext highlighter-rouge">10</code> will be put in the box number <code class="language-plaintext highlighter-rouge">1 + 0 = 1</code>.</li> <li>Given two integers <code class="language-plaintext highlighter-rouge">lowLimit</code> and <code class="language-plaintext highlighter-rouge">highLimit</code>, return <em>the number of balls in the box with the most balls.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: lowLimit = 1, highLimit = 10
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...
Box 1 has the most number of balls with 2 balls.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: lowLimit = 5, highLimit = 15
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...
Boxes 5 and 6 have the most number of balls with 2 balls in each.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: lowLimit = 19, highLimit = 28
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...
Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...
Box 10 has the most number of balls with 2 balls.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * logm) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfBallsInABox</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countBalls</span><span class="o">(</span><span class="kt">int</span> <span class="n">lowLimit</span><span class="o">,</span> <span class="kt">int</span> <span class="n">highLimit</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the count of balls in each box</span>
        <span class="c1">// Size is 46 because max sum of digits for 100000 is 9*5=45</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">boxes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">46</span><span class="o">];</span>

        <span class="c1">// Iterate through each ball number</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lowLimit</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">highLimit</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Increment the count in the box corresponding to the digit sum</span>
            <span class="n">boxes</span><span class="o">[</span><span class="n">getDigitSum</span><span class="o">(</span><span class="n">i</span><span class="o">)]++;</span>
        <span class="o">}</span>

        <span class="c1">// Find the maximum number of balls in any box</span>
        <span class="kt">int</span> <span class="n">maxBalls</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="n">boxes</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxBalls</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxBalls</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxBalls</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getDigitSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Extract each digit and add to sum</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>    <span class="c1">// Get the last digit</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>          <span class="c1">// Remove the last digit</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">countBalls</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>  <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">countBalls</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">15</span><span class="o">));</span>  <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">countBalls</span><span class="o">(</span><span class="mi">19</span><span class="o">,</span> <span class="mi">28</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n== highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity. Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball’s number. For example, the ball number 321 will be put in the box number 3 + 2 + 1=6 and the ball number 10 will be put in the box number 1 + 0=1. Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls.]]></summary></entry><entry><title type="html">LCP 68. Beautiful Bouquet</title><link href="https://zhengstar94.github.io//blog/2025/BeautifulBouquet/" rel="alternate" type="text/html" title="LCP 68. Beautiful Bouquet"/><published>2025-02-12T00:00:00+00:00</published><updated>2025-02-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BeautifulBouquet</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BeautifulBouquet/"><![CDATA[<ul> <li> <p>At the LeetCode Carnival’s flower shop, flowers are arranged in a row from left to right, recorded in an integer array <code class="language-plaintext highlighter-rouge">flowers</code> where each number represents the variety ID of the flower at that position. You can select a continuous segment of flowers to make a floral arrangement, and no flowers can be discarded. In your chosen arrangement, if the quantity of each flower variety does not exceed <code class="language-plaintext highlighter-rouge">cnt</code> flowers, then we consider this floral arrangement to be “aesthetically pleasing.”</p> <blockquote> <p>For example: In <code class="language-plaintext highlighter-rouge">[5,5,5,6,6]</code>, there are <code class="language-plaintext highlighter-rouge">3</code> flowers of variety <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">2</code> flowers of variety <code class="language-plaintext highlighter-rouge">6</code>. The quantity of <strong>each variety</strong> does not exceed <code class="language-plaintext highlighter-rouge">3</code>.</p> </blockquote> </li> <li> <p>Return the total number of possible continuous segments that can be selected from this row of flowers where the resulting floral arrangement would be “aesthetically pleasing.”</p> </li> <li> <p>Note:</p> <ul> <li>The answer should be calculated modulo <code class="language-plaintext highlighter-rouge">1e9 + 7 (1000000007)</code>. For example, if the initial result is <code class="language-plaintext highlighter-rouge">1000000008</code>, return <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let me translate this example with its explanation:
Input: flowers = [1,2,3,2], cnt = 1
Output: 8
Explanation: For arrangements where each flower variety cannot exceed 1 flower, there are 8 aesthetically pleasing arrangements:
Length-1 segments: [1], [2], [3], [2] all meet the condition, giving 4 possible segments
Length-2 segments: [1,2], [2,3], [3,2] all meet the condition, giving 3 possible segments
Length-3 segments: [1,2,3] meets the condition, giving 1 possible segment
Segments [2,3,2] and [1,2,3,2] both contain 2 flowers of variety 2, so they don't meet the condition.
Total count is 4+3+1 = 8
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: flowers = [5,3,3,3], cnt = 2
Output: 8
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountShortest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeautifulBouquet</span> <span class="o">{</span>
    <span class="c1">// Constant for modulo operation to prevent integer overflow</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1000000007</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">beautifulBouquet</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">flowers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the count of each flower type</span>
        <span class="c1">// Size is 100001 because flower types range from 1 to 100000</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100001</span><span class="o">];</span>

        <span class="c1">// Use long to prevent overflow during calculations</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">flowers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Increment count of current flower type at right pointer</span>
            <span class="n">count</span><span class="o">[</span><span class="n">flowers</span><span class="o">[</span><span class="n">right</span><span class="o">]]++;</span>

            <span class="c1">// Shrink window from left while current flower type exceeds cnt</span>
            <span class="c1">// This ensures window always contains valid counts</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">flowers</span><span class="o">[</span><span class="n">right</span><span class="o">]]</span> <span class="o">&gt;</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">[</span><span class="n">flowers</span><span class="o">[</span><span class="n">left</span><span class="o">]]--;</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate number of valid subarrays ending at current right pointer</span>
            <span class="c1">// For current window [left, right]:</span>
            <span class="c1">// - We can form subarrays: [right], [right-1,right], [right-2,right],...,[left,right]</span>
            <span class="c1">// - Total count of such subarrays is (right - left + 1)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with repeated flower</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">flowers1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cnt1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">beautifulBouquet</span><span class="o">(</span><span class="n">flowers1</span><span class="o">,</span> <span class="n">cnt1</span><span class="o">));</span>
        <span class="c1">// Expected output: 8</span>

        <span class="c1">// Test Case 2: Case with multiple repeated flowers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">flowers2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cnt2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">beautifulBouquet</span><span class="o">(</span><span class="n">flowers2</span><span class="o">,</span> <span class="n">cnt2</span><span class="o">));</span>
        <span class="c1">// Expected output: 8</span>

        <span class="c1">// Test Case 3: Edge case with all same flowers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">flowers3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cnt3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">beautifulBouquet</span><span class="o">(</span><span class="n">flowers3</span><span class="o">,</span> <span class="n">cnt3</span><span class="o">));</span>
        <span class="c1">// Testing case with all identical elements</span>

        <span class="c1">// Test Case 4: Edge case with single element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">flowers4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">cnt4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">beautifulBouquet</span><span class="o">(</span><span class="n">flowers4</span><span class="o">,</span> <span class="n">cnt4</span><span class="o">));</span>
        <span class="c1">// Testing single element case</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountShortest"/><category term="Medium"/><category term="SlideWindow"/><summary type="html"><![CDATA[At the LeetCode Carnival’s flower shop, flowers are arranged in a row from left to right, recorded in an integer array flowers where each number represents the variety ID of the flower at that position. You can select a continuous segment of flowers to make a floral arrangement, and no flowers can be discarded. In your chosen arrangement, if the quantity of each flower variety does not exceed cnt flowers, then we consider this floral arrangement to be “aesthetically pleasing.”]]></summary></entry><entry><title type="html">1910. Remove All Occurrences of a Substring</title><link href="https://zhengstar94.github.io//blog/2025/RemoveAllOccurrencesOfASubstring/" rel="alternate" type="text/html" title="1910. Remove All Occurrences of a Substring"/><published>2025-02-10T00:00:00+00:00</published><updated>2025-02-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RemoveAllOccurrencesOfASubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RemoveAllOccurrencesOfASubstring/"><![CDATA[<ul> <li>Given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">part</code>, perform the following operation on <code class="language-plaintext highlighter-rouge">s</code> until <strong>all</strong> occurrences of the substring <code class="language-plaintext highlighter-rouge">part</code> are removed: <ul> <li>Find the <strong>leftmost</strong> occurrence of the substring <code class="language-plaintext highlighter-rouge">part</code> and <strong>remove</strong> it from <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">s</code> <em>after removing all occurrences of</em> <code class="language-plaintext highlighter-rouge">part</code>.</li> <li>A <strong>substring</strong> is a contiguous sequence of characters in a string.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "daabcbaabcbc", part = "abc"
Output: "dab"
Explanation: The following operations are done:
- s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
- s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
- s = "dababc", remove "abc" starting at index 3, so s = "dab".
Now s has no occurrences of "abc".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "axxxxyyyyb", part = "xy"
Output: "ab"
Explanation: The following operations are done:
- s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
- s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
- s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
- s = "axyb", remove "xy" starting at index 1 so s = "ab".
Now s has no occurrences of "xy".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveAllOccurrencesOfASubstring</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">removeOccurrences</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">part</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert input string to StringBuilder for efficient modification</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="c1">// Store the length of the substring to be removed</span>
        <span class="kt">int</span> <span class="n">partLen</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Variable to store the index of found substring</span>
        <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
        <span class="c1">// Continue loop until no more occurrences of 'part' are found</span>
        <span class="c1">// indexOf() returns -1 when the substring is not found</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">index</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">part</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Remove the substring from StringBuilder</span>
            <span class="c1">// delete() removes characters from index to (index + partLen - 1)</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">partLen</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder back to String and return</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple overlapping removals</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"daabcbaabcbc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">part1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">", part = "</span> <span class="o">+</span> <span class="n">part1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeOccurrences</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">part1</span><span class="o">));</span> <span class="c1">// Expected: "dab"</span>

        <span class="c1">// Test Case 2: Multiple consecutive removals</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"axxxxyyyyb"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">part2</span> <span class="o">=</span> <span class="s">"xy"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="s">", part = "</span> <span class="o">+</span> <span class="n">part2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeOccurrences</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">part2</span><span class="o">));</span> <span class="c1">// Expected: "ab"</span>

        <span class="c1">// Test Case 3: Single removal at the end</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"welcome"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">part3</span> <span class="o">=</span> <span class="s">"come"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = "</span> <span class="o">+</span> <span class="n">s3</span> <span class="o">+</span> <span class="s">", part = "</span> <span class="o">+</span> <span class="n">part3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeOccurrences</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">part3</span><span class="o">));</span> <span class="c1">// Expected: "wel"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Medium"/><summary type="html"><![CDATA[Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed: Find the leftmost occurrence of the substring part and remove it from s. Return s after removing all occurrences of part. A substring is a contiguous sequence of characters in a string.]]></summary></entry><entry><title type="html">2364. Count Number of Bad Pairs</title><link href="https://zhengstar94.github.io//blog/2025/CountNumberOfBadPairs/" rel="alternate" type="text/html" title="2364. Count Number of Bad Pairs"/><published>2025-02-09T00:00:00+00:00</published><updated>2025-02-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountNumberOfBadPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountNumberOfBadPairs/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>. A pair of indices <code class="language-plaintext highlighter-rouge">(i, j)</code> is a <strong>bad pair</strong> if <code class="language-plaintext highlighter-rouge">i &lt; j</code> and <code class="language-plaintext highlighter-rouge">j - i != nums[j] - nums[i]</code>.</li> <li>Return <em>the total number of <strong>bad pairs</strong> in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,1,3,3]
Output: 5
Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.
The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.
The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.
The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.
The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.
There are a total of 5 bad pairs, so we return 5.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,4,5]
Output: 0
Explanation: There are no bad pairs.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/09
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountNumberOfBadPairs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countBadPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a HashMap to store the frequency of nums[i] - i values.</span>
        <span class="c1">// This helps us efficiently count how many times a specific "difference" has occurred.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Variable to count the number of good pairs, initialized to 0.</span>
        <span class="c1">// A good pair satisfies the condition nums[j] - j == nums[i] - i.</span>
        <span class="kt">long</span> <span class="n">goodPairs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array, calculating the current difference and updating goodPairs.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate the difference (nums[i] - i), which is used to identify good pairs.</span>
            <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Add the number of previous occurrences of the current difference to goodPairs.</span>
            <span class="c1">// This indicates how many indices before i have the same difference, forming good pairs with the current index.</span>
            <span class="n">goodPairs</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">diff</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Update the frequency of the current difference in the map.</span>
            <span class="c1">// This prepares for future iterations to count good pairs for subsequent elements.</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">diff</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">diff</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Calculate the total number of possible pairs in the array.</span>
        <span class="c1">// Using the formula for combinations: n * (n - 1) / 2 (where n = nums.length).</span>
        <span class="kt">long</span> <span class="n">totalPairs</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// The number of bad pairs is equal to the total pairs minus the number of good pairs.</span>
        <span class="k">return</span> <span class="n">totalPairs</span> <span class="o">-</span> <span class="n">goodPairs</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Example array with some bad pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countBadPairs</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 2: Example array with no bad pairs (fully good pairs)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countBadPairs</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 3: A large array with perfectly ordered elements (no bad pairs)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100000</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums3</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">nums3</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Each element is its index + 1</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countBadPairs</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 4: Array where all elements are identical</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">countBadPairs</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i &lt; j and j - i != nums[j] - nums[i]. Return the total number of bad pairs in nums.]]></summary></entry><entry><title type="html">2302. Count Subarrays With Score Less Than K</title><link href="https://zhengstar94.github.io//blog/2025/DynamicSlidingWindowCountShortest/" rel="alternate" type="text/html" title="2302. Count Subarrays With Score Less Than K"/><published>2025-02-09T00:00:00+00:00</published><updated>2025-02-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DynamicSlidingWindowCountShortest</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DynamicSlidingWindowCountShortest/"><![CDATA[<ul> <li>The <strong>score</strong> of an array is defined as the <strong>product</strong> of its sum and its length. <ul> <li>For example, the score of <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, 5]</code> is <code class="language-plaintext highlighter-rouge">(1 + 2 + 3 + 4 + 5) * 5 = 75</code>.</li> </ul> </li> <li>Given a positive integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the <strong>number of non-empty subarrays</strong> of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>whose score is <strong>strictly less</strong> than</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>A <strong>subarray</strong> is a contiguous sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,1,4,3,5], k = 10
Output: 6
Explanation:
The 6 subarrays having scores less than 10 are:
- [2] with score 2 * 1 = 2.
- [1] with score 1 * 1 = 1.
- [4] with score 4 * 1 = 4.
- [3] with score 3 * 1 = 3. 
- [5] with score 5 * 1 = 5.
- [2,1] with score (2 + 1) * 2 = 6.
Note that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1], k = 5
Output: 5
Explanation:
Every subarray except  [1,1,1] has a score less than 5.
[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.
Thus, there are 5 subarrays having scores less than 5.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountShortest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/09
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubarraysWithScoreLessThanK</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">long</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize result counter for valid subarrays</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Track running sum of current window</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to window sum</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="c1">// Shrink window while score is &gt;= k</span>
            <span class="c1">// Window score = sum * window_length</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">sum</span> <span class="o">*</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Remove leftmost element from sum</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Add count of valid subarrays ending at current right pointer</span>
            <span class="c1">// All subarrays from left to right are valid</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with mixed numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">long</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: 6</span>

        <span class="c1">// Test Case 2: Array with identical elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">long</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: 5</span>

        <span class="c1">// Test Case 3: Large array performance test</span>
        <span class="c1">// Creates array of size 100000 filled with 1's</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100000</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums3</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">nums3</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">long</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Performance test</span>

        <span class="c1">// Test Case 4: Single element array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">};</span>
        <span class="kt">long</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">15</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 5: No valid subarrays</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">};</span>
        <span class="kt">long</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">k5</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountShortest"/><category term="Hard"/><category term="SlideWindow"/><summary type="html"><![CDATA[The score of an array is defined as the product of its sum and its length. For example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5=75. Given a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k. A subarray is a contiguous sequence of elements within an array.]]></summary></entry></feed>