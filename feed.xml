<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-21T03:53:41+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">378. Kth Smallest Element in a Sorted Matrix</title><link href="https://zhengstar94.github.io//blog/2025/KthSmallestElementInASortedMatrix/" rel="alternate" type="text/html" title="378. Kth Smallest Element in a Sorted Matrix"/><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/KthSmallestElementInASortedMatrix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/KthSmallestElementInASortedMatrix/"><![CDATA[<ul> <li>Given an <code class="language-plaintext highlighter-rouge">n x n</code> <code class="language-plaintext highlighter-rouge">matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code class="language-plaintext highlighter-rouge">kth</code> <em>smallest element in the matrix</em>.</li> <li>Note that it is the <code class="language-plaintext highlighter-rouge">kth</code> smallest element <strong>in the sorted order</strong>, not the <code class="language-plaintext highlighter-rouge">kth</code> <strong>distinct</strong> element.</li> <li>You must find a solution with a memory complexity better than <code class="language-plaintext highlighter-rouge">O(n^2)</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [ [ 1,5,9],[10,11,13],[12,13,15 ] ], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: matrix = [ [ -5 ] ], k = 1
Output: -5
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n × log(max-min)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.KthElement</span><span class="o">;</span>

<span class="cm">/**
 * author: zhengxingxing
 * date: 2025/05/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KthSmallestElementInASortedMatrix</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>         <span class="c1">// The smallest possible value in the matrix</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// The largest possible value in the matrix</span>

        <span class="c1">// Binary search on value range</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>  <span class="c1">// Prevents potential overflow</span>

            <span class="c1">// Count how many elements in the matrix are ≤ mid</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">countLessOrEqual</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If there are fewer than k elements ≤ mid, then the target must be in the right half</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, mid is large enough (maybe too large), move left</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the smallest number such that at least k elements are ≤ it</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Counts the number of elements in the matrix that are less than or equal to the given target.
     *
     * We take advantage of the sorted property:
     * - Start from the bottom-left corner.
     * - If the current number is ≤ target, then all numbers above it in that column are also ≤ target.
     * - If it's &gt; target, move upward to smaller numbers.
     *
     * Example: For matrix[i][j]
     * - If matrix[i][j] ≤ target → count += i + 1, move right
     * - Else → move up
     *
     * Time Complexity: O(n), where n is number of rows/columns
     *
     * @param matrix the input sorted matrix
     * @param target the value to compare against
     * @return count of elements ≤ target
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countLessOrEqual</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Start from the bottom-left corner</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Traverse while staying within matrix boundaries</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Since matrix[row][col] ≤ target, all elements above in this column (from row 0 to current row)</span>
                <span class="c1">// are also ≤ target due to sorted column. So we can add (row + 1) elements in one go.</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Move to next column (right)</span>
                <span class="n">col</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current element is &gt; target, move up to smaller elements</span>
                <span class="n">row</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Test cases to validate the solution.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">15</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: matrix = [ [ 1,5,9],[10,11,13],[12,13,15 ] ], k = 8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">kthSmallest</span><span class="o">(</span><span class="n">matrix1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 13\n"</span><span class="o">);</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: matrix = [ [ -5 ] ], k = 1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">kthSmallest</span><span class="o">(</span><span class="n">matrix2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: -5"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.KthElement"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n^2).]]></summary></entry><entry><title type="html">668. Kth Smallest Number in Multiplication Table</title><link href="https://zhengstar94.github.io//blog/2025/KthSmallestNumberInMultiplicationTable/" rel="alternate" type="text/html" title="668. Kth Smallest Number in Multiplication Table"/><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/KthSmallestNumberInMultiplicationTable</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/KthSmallestNumberInMultiplicationTable/"><![CDATA[<ul> <li>Nearly everyone has used the <a href="https://en.wikipedia.org/wiki/Multiplication_table">Multiplication Table</a>. The multiplication table of size <code class="language-plaintext highlighter-rouge">m x n</code> is an integer matrix <code class="language-plaintext highlighter-rouge">mat</code> where <code class="language-plaintext highlighter-rouge">mat[i][j] == i * j</code> (<strong>1-indexed</strong>).</li> <li>Given three integers <code class="language-plaintext highlighter-rouge">m</code>, <code class="language-plaintext highlighter-rouge">n</code>, and <code class="language-plaintext highlighter-rouge">k</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">kth</code> <em>smallest element in the</em> <code class="language-plaintext highlighter-rouge">m x n</code> <em>multiplication table</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3, k = 5
Output: 3
Explanation: The 5th smallest number is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 2, n = 3, k = 6
Output: 6
Explanation: The 6th smallest number is 6.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(mlog(mn)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.KthElement</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KthSmallestNumberInMultiplicationTable</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findKthNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the binary search boundaries:</span>
        <span class="c1">// - left: smallest possible value in the table (always 1)</span>
        <span class="c1">// - right: largest possible value in the table (m*n)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Binary search loop</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle value to test</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Count elements less than or equal to x in the multiplication table</span>
            <span class="c1">// First, handle complete rows (rows where all elements are &lt;= x)</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>  <span class="c1">// (x/n) complete rows, each contributing n elements</span>

            <span class="c1">// Then, handle partial rows (rows where only some elements are &lt;= x)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// In row i, elements less than or equal to x are: i, 2i, 3i, ..., up to x/i multiples</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Adjust search boundaries</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If we have at least k elements &lt;= x, the kth smallest could be x or smaller</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we have fewer than k elements &lt;= x, the kth smallest must be larger than x</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// When left == right, we've found the kth smallest number</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method with test cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: m=3, n=3, k=5 (Expected output: 3)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: m=3, n=3, k=5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKthNumber</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: m=2, n=3, k=6 (Expected output: 6)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: m=2, n=3, k=6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKthNumber</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: m=5, n=6, k=10 (Expected output: 5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: m=5, n=6, k=10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">findKthNumber</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.KthElement"/><category term="Hard"/><category term="BinarySearch"/><summary type="html"><![CDATA[Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed). Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.]]></summary></entry><entry><title type="html">3355. Zero Array Transformation I</title><link href="https://zhengstar94.github.io//blog/2025/ZeroArrayTransformationI/" rel="alternate" type="text/html" title="3355. Zero Array Transformation I"/><published>2025-05-20T00:00:00+00:00</published><updated>2025-05-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ZeroArrayTransformationI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ZeroArrayTransformationI/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code> and a 2D array <code class="language-plaintext highlighter-rouge">queries</code>, where <code class="language-plaintext highlighter-rouge">queries[i] = [li, ri]</code>.</li> <li>For each <code class="language-plaintext highlighter-rouge">queries[i]</code>: <ul> <li>Select a subset of indices within the range <code class="language-plaintext highlighter-rouge">[li, ri]</code> in <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Decrement the values at the selected indices by 1.</li> </ul> </li> <li>A <strong>Zero Array</strong> is an array where all elements are equal to 0.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if it is <em>possible</em> to transform <code class="language-plaintext highlighter-rouge">nums</code> into a <strong>Zero Array</strong> after processing all the queries sequentially, otherwise return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,0,1], queries = [ [0,2] ]

Output: true

Explanation:

For i = 0:
Select the subset of indices as [0, 2] and decrement the values at these indices by 1.
The array will become [0, 0, 0], which is a Zero Array.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,3,2,1], queries = [ [1,3],[0,2] ]

Output: false

Explanation:

For i = 0:
Select the subset of indices as [1, 2, 3] and decrement the values at these indices by 1.
The array will become [4, 2, 1, 0].
For i = 1:
Select the subset of indices as [0, 1, 2] and decrement the values at these indices by 1.
The array will become [3, 1, 0, 0], which is not a Zero Array.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + q) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ZeroArrayTransformationI</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isZeroArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// Difference array to simulate range updates efficiently</span>

        <span class="c1">// Apply each query as a range update: increment elements in the range [l, r] by 1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">q</span> <span class="o">:</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">diff</span><span class="o">[</span><span class="n">l</span><span class="o">]++;</span>         <span class="c1">// Start increment at index l</span>
            <span class="n">diff</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]--;</span>     <span class="c1">// Cancel the increment after index r</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">sumD</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Accumulator for the effective increments at each position</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sumD</span> <span class="o">+=</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// sumD represents how many times nums[i] is incremented</span>

            <span class="c1">// Since each increment operation is effectively a -1 to nums[i],</span>
            <span class="c1">// sumD also represents how much we are allowed to reduce nums[i] by.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">sumD</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If nums[i] is still greater than the total reduction allowed,</span>
                <span class="c1">// it is impossible to reduce it to 0.</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we never encountered a value that can't be zeroed out, return true</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">boolean</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">isZeroArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">queries1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">boolean</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">isZeroArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">queries2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Additional test case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">boolean</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">isZeroArray</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">queries3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums of length n and a 2D array queries, where queries[i] = [li, ri]. For each queries[i]: Select a subset of indices within the range [li, ri] in nums. Decrement the values at the selected indices by 1. A Zero Array is an array where all elements are equal to 0. Return true if it is possible to transform nums into a Zero Array after processing all the queries sequentially, otherwise return false.]]></summary></entry><entry><title type="html">3024. Type of Triangle</title><link href="https://zhengstar94.github.io//blog/2025/TypeOfTriangle/" rel="alternate" type="text/html" title="3024. Type of Triangle"/><published>2025-05-19T00:00:00+00:00</published><updated>2025-05-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TypeOfTriangle</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TypeOfTriangle/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">3</code> which can form the sides of a triangle. <ul> <li>A triangle is called <strong>equilateral</strong> if it has all sides of equal length.</li> <li>A triangle is called <strong>isosceles</strong> if it has exactly two sides of equal length.</li> <li>A triangle is called <strong>scalene</strong> if all its sides are of different lengths.</li> </ul> </li> <li>Return <em>a string representing</em> <em>the type of triangle that can be formed</em> <em>or</em> <code class="language-plaintext highlighter-rouge">"none"</code> <em>if it <strong>cannot</strong> form a triangle.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,3]
Output: "equilateral"
Explanation: Since all the sides are of equal length, therefore, it will form an equilateral triangle.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,4,5]
Output: "scalene"
Explanation: 
nums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.
nums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.
nums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3. 
Since the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.
As all the sides are of different lengths, it will form a scalene triangle.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TypeOfTriangle</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">triangleType</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check if the sides can form a valid triangle</span>
        <span class="c1">// Triangle inequality theorem: The sum of the lengths of any two sides must be greater than the length of the remaining side</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">||</span>
                <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span>
                <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"none"</span><span class="o">;</span>  <span class="c1">// Cannot form a valid triangle</span>
        <span class="o">}</span>

        <span class="c1">// Determine the type of triangle based on the equality of sides</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"equilateral"</span><span class="o">;</span>  <span class="c1">// All three sides are equal -&gt; Equilateral triangle</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"isosceles"</span><span class="o">;</span>    <span class="c1">// Exactly two sides are equal -&gt; Isosceles triangle</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"scalene"</span><span class="o">;</span>      <span class="c1">// All three sides have different lengths -&gt; Scalene triangle</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Equilateral triangle (all sides equal)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: [3,3,3] -&gt; "</span> <span class="o">+</span> <span class="n">triangleType</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Scalene triangle (all sides different)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: [3,4,5] -&gt; "</span> <span class="o">+</span> <span class="n">triangleType</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Isosceles triangle (exactly two sides equal)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: [3,3,2] -&gt; "</span> <span class="o">+</span> <span class="n">triangleType</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Not a valid triangle (fails triangle inequality theorem)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: [1,1,3] -&gt; "</span> <span class="o">+</span> <span class="n">triangleType</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle. A triangle is called equilateral if it has all sides of equal length. A triangle is called isosceles if it has exactly two sides of equal length. A triangle is called scalene if all its sides are of different lengths. Return a string representing the type of triangle that can be formed or "none" if it cannot form a triangle.]]></summary></entry><entry><title type="html">3281. Maximize Score of Numbers in Ranges</title><link href="https://zhengstar94.github.io//blog/2025/MaximizeScoreOfNumbersInRanges/" rel="alternate" type="text/html" title="3281. Maximize Score of Numbers in Ranges"/><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximizeScoreOfNumbersInRanges</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximizeScoreOfNumbersInRanges/"><![CDATA[<ul> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">start</code> and an integer <code class="language-plaintext highlighter-rouge">d</code>, representing <code class="language-plaintext highlighter-rouge">n</code> intervals <code class="language-plaintext highlighter-rouge">[start[i], start[i] + d]</code>.</li> <li>You are asked to choose <code class="language-plaintext highlighter-rouge">n</code> integers where the <code class="language-plaintext highlighter-rouge">ith</code> integer must belong to the <code class="language-plaintext highlighter-rouge">ith</code> interval. The <strong>score</strong> of the chosen integers is defined as the <strong>minimum</strong> absolute difference between any two integers that have been chosen.</li> <li>Return the <strong>maximum</strong> <em>possible score</em> of the chosen integers.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: start = [6,0,3], d = 2

Output: 4

Explanation:

The maximum possible score can be obtained by choosing integers: 8, 0, and 4. The score of these chosen integers is min(|8 - 0|, |8 - 4|, |0 - 4|) which equals 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: start = [2,6,13,13], d = 5

Output: 5

Explanation:

The maximum possible score can be obtained by choosing integers: 2, 7, 13, and 18. The score of these chosen integers is min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|) which equals 5.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)+nlog(A)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MaximizeMinimum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximizeScoreOfNumbersInRanges</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxPossibleScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the start array to ensure order for greedy assignment</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="cm">/*
         * Calculate the upper bound for binary search 'right':
         * Explanation:
         * - The maximum possible difference between any two assigned numbers
         *   can be no more than the total length of the entire range divided evenly.
         * - The total range length is from the smallest start to the largest possible end:
         *   (start[n-1] + d) - start[0].
         * - Divide by (n-1) because there are (n-1) gaps between n numbers.
         * - Adding 1 ensures the upper bound is strictly greater,
         *   so the binary search range is safe.
         */</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="n">start</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Binary search loop to find the maximum minimum difference</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// mid = (left + right) / 2 without overflow</span>

            <span class="cm">/*
             * Check if it is possible to assign numbers with at least 'mid' difference
             * between adjacent assigned values while keeping each within allowed intervals.
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>   <span class="c1">// If feasible, try a larger minimum difference</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>  <span class="c1">// Otherwise, try smaller differences</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 'left' holds the largest minimum difference found</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">,</span> <span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">prevPlacedValue</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>  <span class="c1">// Initialize to very small to place first number freely</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">baseValue</span> <span class="o">:</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the assigned value for current interval:</span>
            <span class="c1">// It must be at least 'score' away from the previously assigned value,</span>
            <span class="c1">// and also no less than the interval's start value.</span>
            <span class="n">prevPlacedValue</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">prevPlacedValue</span> <span class="o">+</span> <span class="n">score</span><span class="o">,</span> <span class="n">baseValue</span><span class="o">);</span>

            <span class="c1">// If assigned value goes beyond the interval's max allowed value, fail</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prevPlacedValue</span> <span class="o">&gt;</span> <span class="n">baseValue</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// All intervals assigned successfully with at least 'score' difference</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1:</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">start1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">maxPossibleScore</span><span class="o">(</span><span class="n">start1</span><span class="o">,</span> <span class="n">d1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 1 output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span> <span class="c1">// Expected 4</span>

        <span class="c1">// Example 2:</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">start2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">maxPossibleScore</span><span class="o">(</span><span class="n">start2</span><span class="o">,</span> <span class="n">d2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 2 output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span> <span class="c1">// Expected 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MaximizeMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an array of integers start and an integer d, representing n intervals [start[i], start[i] + d]. You are asked to choose n integers where the ith integer must belong to the ith interval. The score of the chosen integers is defined as the minimum absolute difference between any two integers that have been chosen. Return the maximum possible score of the chosen integers.]]></summary></entry><entry><title type="html">2517. Maximum Tastiness of Candy Basket</title><link href="https://zhengstar94.github.io//blog/2025/MaximumTastinessOfCandyBasket/" rel="alternate" type="text/html" title="2517. Maximum Tastiness of Candy Basket"/><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumTastinessOfCandyBasket</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumTastinessOfCandyBasket/"><![CDATA[<ul> <li>You are given an array of positive integers <code class="language-plaintext highlighter-rouge">price</code> where <code class="language-plaintext highlighter-rouge">price[i]</code> denotes the price of the <code class="language-plaintext highlighter-rouge">ith</code> candy and a positive integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>The store sells baskets of <code class="language-plaintext highlighter-rouge">k</code> <strong>distinct</strong> candies. The <strong>tastiness</strong> of a candy basket is the smallest absolute difference of the <strong>prices</strong> of any two candies in the basket.</li> <li>Return <em>the <strong>maximum</strong> tastiness of a candy basket.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: price = [13,5,1,8,21,2], k = 3
Output: 8
Explanation: Choose the candies with the prices [13,5,21].
The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.
It can be proven that 8 is the maximum tastiness that can be achieved.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: price = [1,3,1], k = 2
Output: 2
Explanation: Choose the candies with the prices [1,3].
The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.
It can be proven that 2 is the maximum tastiness that can be achieved.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: price = [7,7,7,7], k = 2
Output: 0
Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)+nlog(U)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MaximizeMinimum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumTastinessOfCandyBasket</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumTastiness</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the prices to enable binary search and greedy checking</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>

        <span class="c1">// Initialize binary search boundaries:</span>
        <span class="c1">// left = 0 means minimum possible difference</span>
        <span class="c1">// right = max possible difference between prices divided by (k-1), plus 1 for upper bound</span>
        <span class="c1">// Explanation:</span>
        <span class="c1">// - The maximum minimum difference can't be larger than the total price range divided by (k-1)</span>
        <span class="c1">// - We add 1 to make sure right is an exclusive upper bound for binary search</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="n">price</span><span class="o">[</span><span class="n">price</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">price</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Binary search for the maximum minimum difference (tastiness)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if it's possible to select k candies such that</span>
            <span class="c1">// the minimum difference between any two selected candies &gt;= mid</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">price</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If possible, we try to find a larger minimum difference</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If not possible, we reduce the minimum difference</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 'left' now holds the largest minimum difference that can be achieved</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>          <span class="c1">// Already selected the first candy (smallest price)</span>
        <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">price</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// The price of the last selected candy</span>

        <span class="c1">// Iterate through prices to greedily select candies</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">price</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current candy's price is at least d away from previously selected candy</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">price</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prev</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>        <span class="c1">// Select this candy</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">price</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Update last selected candy price</span>

                <span class="c1">// If we have selected enough candies, return true immediately</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Not possible to select k candies with minimum difference d</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">price1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">13</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 1 maximum tastiness: "</span> <span class="o">+</span> <span class="n">maximumTastiness</span><span class="o">(</span><span class="n">price1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>  <span class="c1">// Expected output: 8</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">price2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 2 maximum tastiness: "</span> <span class="o">+</span> <span class="n">maximumTastiness</span><span class="o">(</span><span class="n">price2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>  <span class="c1">// Expected output: 2</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">price3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 3 maximum tastiness: "</span> <span class="o">+</span> <span class="n">maximumTastiness</span><span class="o">(</span><span class="n">price3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>  <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MaximizeMinimum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k. The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket. Return the maximum tastiness of a candy basket.]]></summary></entry><entry><title type="html">2513. Minimize the Maximum of Two Arrays</title><link href="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumOfTwoArrays/" rel="alternate" type="text/html" title="2513. Minimize the Maximum of Two Arrays"/><published>2025-05-17T00:00:00+00:00</published><updated>2025-05-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumOfTwoArrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumOfTwoArrays/"><![CDATA[<ul> <li>We have two arrays <code class="language-plaintext highlighter-rouge">arr1</code> and <code class="language-plaintext highlighter-rouge">arr2</code> which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions: <ul> <li><code class="language-plaintext highlighter-rouge">arr1</code> contains <code class="language-plaintext highlighter-rouge">uniqueCnt1</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code class="language-plaintext highlighter-rouge">divisor1</code>.</li> <li><code class="language-plaintext highlighter-rouge">arr2</code> contains <code class="language-plaintext highlighter-rouge">uniqueCnt2</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code class="language-plaintext highlighter-rouge">divisor2</code>.</li> <li><strong>No</strong> integer is present in both <code class="language-plaintext highlighter-rouge">arr1</code> and <code class="language-plaintext highlighter-rouge">arr2</code>.</li> </ul> </li> <li>Given <code class="language-plaintext highlighter-rouge">divisor1</code>, <code class="language-plaintext highlighter-rouge">divisor2</code>, <code class="language-plaintext highlighter-rouge">uniqueCnt1</code>, and <code class="language-plaintext highlighter-rouge">uniqueCnt2</code>, return <em>the <strong>minimum possible maximum</strong> integer that can be present in either array</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
Output: 4
Explanation: 
We can distribute the first 4 natural numbers into arr1 and arr2.
arr1 = [1] and arr2 = [2,3,4].
We can see that both arrays satisfy all the conditions.
Since the maximum value is 4, we return it.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
Output: 3
Explanation: 
Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
Since the maximum value is 3, we return it.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
Output: 15
Explanation: 
Here, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].
It can be shown that it is not possible to obtain a lower maximum satisfying all conditions. 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(divisor1+divisor2)+log(uniqueCnt1+uniqueCnt2)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizeTheMaximumOfTwoArrays</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizeSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">divisor1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">divisor2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate the Least Common Multiple (LCM) of divisor1 and divisor2,</span>
        <span class="c1">// used for applying the inclusion-exclusion principle later.</span>
        <span class="kt">long</span> <span class="n">lcm</span> <span class="o">=</span> <span class="n">lcm</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">);</span>

        <span class="c1">// Initialize binary search boundaries:</span>
        <span class="c1">// left starts at 1 (smallest positive integer),</span>
        <span class="c1">// right is a safe upper bound (twice the total count of unique elements needed).</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>

        <span class="c1">// Perform binary search to find the minimal maximum integer x</span>
        <span class="c1">// such that it's possible to form arr1 and arr2 under constraints.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">// Use the check function to verify if mid can satisfy the constraints.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">,</span> <span class="n">lcm</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If possible, try smaller values to minimize the maximum integer.</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, increase the lower bound to look for a larger feasible value.</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// At the end of binary search, left == right and represents the minimal maximum integer.</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">uniqueCnt2</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lcm</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*
         * Calculate how many integers arr1 still needs to pick after excluding
         * numbers that arr2 will take (numbers divisible by d2, except those divisible by lcm).
         * uniqueCnt1 - (x / d2) + (x / lcm) calculates the "remaining needed" count for arr1.
         *
         * Math.max(..., 0) ensures we don't get negative values when arr2 doesn't take enough to affect arr1.
         */</span>
        <span class="kt">long</span> <span class="n">left1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">uniqueCnt1</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d2</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lcm</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>

        <span class="cm">/*
         * Similarly, calculate how many integers arr2 still needs to pick after excluding
         * numbers that arr1 will take (numbers divisible by d1, except those divisible by lcm).
         */</span>
        <span class="kt">long</span> <span class="n">left2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">uniqueCnt2</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d1</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lcm</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>

        <span class="cm">/*
         * Calculate how many numbers in [1, x] are not divisible by either d1 or d2.
         * This uses the inclusion-exclusion principle:
         * - total numbers in [1,x]: x
         * - subtract numbers divisible by d1: x/d1
         * - subtract numbers divisible by d2: x/d2
         * - add back numbers divisible by both (lcm): x/lcm
         *
         * This 'common' count represents the pool of numbers that neither arr1 nor arr2
         * is restricted from using, and hence can be distributed between them.
         */</span>
        <span class="kt">long</span> <span class="n">common</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">d2</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lcm</span><span class="o">);</span>

        <span class="cm">/*
         * Return true if the common pool has enough numbers to satisfy the leftover
         * needs of both arrays without conflicts.
         */</span>
        <span class="k">return</span> <span class="n">common</span> <span class="o">&gt;=</span> <span class="n">left1</span> <span class="o">+</span> <span class="n">left2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Calculate the Greatest Common Divisor (GCD) of two numbers using the Euclidean algorithm.
     *
     * @param a First number.
     * @param b Second number.
     * @return The GCD of a and b.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">gcd</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If b is zero, gcd is a; otherwise, recurse with (b, a % b).</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Calculate the Least Common Multiple (LCM) of two numbers.
     * Formula: lcm(a, b) = (a * b) / gcd(a, b)
     *
     * @param a First number.
     * @param b Second number.
     * @return The LCM of a and b.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">lcm</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span> <span class="n">divisor1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">divisor2</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span> <span class="n">uniqueCnt1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">uniqueCnt2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: divisor1 = "</span> <span class="o">+</span> <span class="n">divisor1</span> <span class="o">+</span> <span class="s">", divisor2 = "</span> <span class="o">+</span> <span class="n">divisor2</span> <span class="o">+</span>
                <span class="s">", uniqueCnt1 = "</span> <span class="o">+</span> <span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="s">", uniqueCnt2 = "</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minimizeSet</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 4"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 2</span>
        <span class="n">divisor1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="n">divisor2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="n">uniqueCnt1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">uniqueCnt2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: divisor1 = "</span> <span class="o">+</span> <span class="n">divisor1</span> <span class="o">+</span> <span class="s">", divisor2 = "</span> <span class="o">+</span> <span class="n">divisor2</span> <span class="o">+</span>
                <span class="s">", uniqueCnt1 = "</span> <span class="o">+</span> <span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="s">", uniqueCnt2 = "</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minimizeSet</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test case 3</span>
        <span class="n">divisor1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">divisor2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="n">uniqueCnt1</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="n">uniqueCnt2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: divisor1 = "</span> <span class="o">+</span> <span class="n">divisor1</span> <span class="o">+</span> <span class="s">", divisor2 = "</span> <span class="o">+</span> <span class="n">divisor2</span> <span class="o">+</span>
                <span class="s">", uniqueCnt1 = "</span> <span class="o">+</span> <span class="n">uniqueCnt1</span> <span class="o">+</span> <span class="s">", uniqueCnt2 = "</span> <span class="o">+</span> <span class="n">uniqueCnt2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minimizeSet</span><span class="o">(</span><span class="n">divisor1</span><span class="o">,</span> <span class="n">divisor2</span><span class="o">,</span> <span class="n">uniqueCnt1</span><span class="o">,</span> <span class="n">uniqueCnt2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 15"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions: arr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1. arr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2. No integer is present in both arr1 and arr2. Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.]]></summary></entry><entry><title type="html">LCP 12. Zhang’s Problem Solving Plan</title><link href="https://zhengstar94.github.io//blog/2025/ZhangsProblemSolvingPlan/" rel="alternate" type="text/html" title="LCP 12. Zhang’s Problem Solving Plan"/><published>2025-05-17T00:00:00+00:00</published><updated>2025-05-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ZhangsProblemSolvingPlan</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ZhangsProblemSolvingPlan/"><![CDATA[<ul> <li>To improve his coding skills, Zhang has prepared a LeetCode problem-solving plan. He selected <code class="language-plaintext highlighter-rouge">n</code> problems from the LeetCode problem database, numbered from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>, and plans to solve all problems <strong>in order of their problem numbers</strong> within <code class="language-plaintext highlighter-rouge">m</code> days (note that Zhang cannot spend multiple days on the same problem).</li> <li>In Zhang’s plan, he needs <code class="language-plaintext highlighter-rouge">time[i]</code> units of time to complete problem number <code class="language-plaintext highlighter-rouge">i</code>. Additionally, Zhang can use an external help feature by asking his good friend Yang for the solution to a problem, which saves him the time needed for that problem. To prevent “Zhang’s problem-solving plan” from becoming “Yang’s problem-solving plan,” Zhang can use this help feature at most once per day.</li> <li>We define <code class="language-plaintext highlighter-rouge">T</code> as the maximum time spent solving problems in a single day among the <code class="language-plaintext highlighter-rouge">m</code> days (problems completed by Yang do not count toward the total solving time). Please help Zhang find the minimum possible value of <code class="language-plaintext highlighter-rouge">T</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [1,2,3,3], m = 2
Output: 3
Explanation: On the first day, Zhang completes the first three problems, with Yang's help for the third problem. On the second day, he completes the fourth problem and also asks Yang for help. This way, the maximum time spent on any day is 3, and this value is minimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [999,999,999], m = 4
Output: 0
Explanation: During the first three days, Zhang asks Yang for help once each day, allowing him to complete all problems within three days without spending any time himself.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(sum(time))) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ZhangsProblemSolvingPlan</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minTime</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if input is null, empty, or days &lt;= 0, no time needed</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">time</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">time</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If days &gt;= number of problems, Zhang can do one problem per day,</span>
        <span class="c1">// use help for each to reduce time to zero</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize binary search boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">right</span> <span class="o">+=</span> <span class="n">t</span><span class="o">;</span> <span class="c1">// maximum possible time is sum of all problem times (no help used)</span>
        <span class="o">}</span>

        <span class="c1">// Binary search to find the minimal max time per day</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if Zhang can finish all problems within m days</span>
            <span class="c1">// without exceeding mid as max daily solving time (after help)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canFinish</span><span class="o">(</span><span class="n">time</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span> <span class="c1">// try smaller max time</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// need to allow more time</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">left</span><span class="o">;</span> <span class="c1">// minimum max time found</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxTime</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">days</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// currently used days</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// sum of problem times for the current day</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// maximum problem time for the current day (help will be used here)</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="o">;</span>                <span class="c1">// accumulate time for current day</span>
            <span class="n">maxVal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxVal</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>  <span class="c1">// track longest problem time in the day</span>

            <span class="c1">// Check if current day's time minus longest problem time exceeds maxTime</span>
            <span class="c1">// This simulates using help on the longest problem to reduce daily load</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">maxVal</span> <span class="o">&gt;</span> <span class="n">maxTime</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">days</span><span class="o">++;</span>        <span class="c1">// need an additional day</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>       <span class="c1">// reset sum to current problem time for new day</span>
                <span class="n">maxVal</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>    <span class="c1">// reset maxVal for new day</span>

                <span class="c1">// If number of days exceeds allowed m, return false immediately</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">days</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If all problems fit in m days under maxTime constraint, return true</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Example input 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">time1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1, expected: 3, actual: "</span> <span class="o">+</span> <span class="n">minTime</span><span class="o">(</span><span class="n">time1</span><span class="o">,</span> <span class="n">m1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Example input 2, days more than problems</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">time2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">999</span><span class="o">,</span> <span class="mi">999</span><span class="o">,</span> <span class="mi">999</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2, expected: 0, actual: "</span> <span class="o">+</span> <span class="n">minTime</span><span class="o">(</span><span class="n">time2</span><span class="o">,</span> <span class="n">m2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[To improve his coding skills, Zhang has prepared a LeetCode problem-solving plan. He selected n problems from the LeetCode problem database, numbered from 0 to n-1, and plans to solve all problems in order of their problem numbers within m days (note that Zhang cannot spend multiple days on the same problem). In Zhang’s plan, he needs time[i] units of time to complete problem number i. Additionally, Zhang can use an external help feature by asking his good friend Yang for the solution to a problem, which saves him the time needed for that problem. To prevent “Zhang’s problem-solving plan” from becoming “Yang’s problem-solving plan,” Zhang can use this help feature at most once per day. We define T as the maximum time spent solving problems in a single day among the m days (problems completed by Yang do not count toward the total solving time). Please help Zhang find the minimum possible value of T.]]></summary></entry><entry><title type="html">2616. Minimize the Maximum Difference of Pairs</title><link href="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs/" rel="alternate" type="text/html" title="2616. Minimize the Maximum Difference of Pairs"/><published>2025-05-16T00:00:00+00:00</published><updated>2025-05-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">p</code>. Find <code class="language-plaintext highlighter-rouge">p</code> pairs of indices of <code class="language-plaintext highlighter-rouge">nums</code> such that the <strong>maximum</strong> difference amongst all the pairs is <strong>minimized</strong>. Also, ensure no index appears more than once amongst the <code class="language-plaintext highlighter-rouge">p</code> pairs.</li> <li>Note that for a pair of elements at the index <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>, the difference of this pair is <code class="language-plaintext highlighter-rouge">|nums[i] - nums[j]|</code>, where <code class="language-plaintext highlighter-rouge">|x|</code> represents the <strong>absolute</strong> <strong>value</strong> of <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>Return <em>the <strong>minimum</strong> <strong>maximum</strong> difference among all</em> <code class="language-plaintext highlighter-rouge">p</code> <em>pairs.</em> We define the maximum of an empty set to be zero.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,1,2,7,1,3], p = 2
Output: 1
Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,1,2], p = 1
Output: 0
Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n*log(n)+n*log(U)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizeTheMaximumDifferenceOfPairs</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizeMax</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If no pairs are needed, return 0 immediately.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort the array so we can easily find close numbers (small differences).</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Initialize binary search boundaries.</span>
        <span class="c1">// left is the smallest possible difference (0),</span>
        <span class="c1">// right is the largest possible difference (max - min).</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Perform binary search to find the minimal threshold</span>
        <span class="c1">// such that we can form at least p valid pairs.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If it's possible to form p pairs with max difference ≤ mid,</span>
            <span class="c1">// try smaller values (search left half).</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canFormPairs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">p</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, try larger threshold (search right half).</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After convergence, left is the smallest valid threshold.</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canFormPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If adjacent elements form a valid pair under the threshold</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">++;</span>  <span class="c1">// Count the valid pair</span>
                <span class="n">i</span><span class="o">++;</span>    <span class="c1">// Skip the next element, as it's already paired</span>
            <span class="o">}</span>
            <span class="c1">// If not valid, move to the next element to try a new pair</span>
        <span class="o">}</span>
        <span class="c1">// Return true if we've formed at least p pairs</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">p1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">p2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Additional test case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">p3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs. Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x. Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.]]></summary></entry><entry><title type="html">2900. Longest Unequal Adjacent Groups Subsequence I</title><link href="https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI/" rel="alternate" type="text/html" title="2900. Longest Unequal Adjacent Groups Subsequence I"/><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI/"><![CDATA[<ul> <li>You are given a string array <code class="language-plaintext highlighter-rouge">words</code> and a <strong>binary</strong> array <code class="language-plaintext highlighter-rouge">groups</code> both of length <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">words[i]</code> is associated with <code class="language-plaintext highlighter-rouge">groups[i]</code>.</li> <li>Your task is to select the <strong>longest alternating</strong> subsequence from <code class="language-plaintext highlighter-rouge">words</code>. A subsequence of <code class="language-plaintext highlighter-rouge">words</code> is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array <code class="language-plaintext highlighter-rouge">groups</code> differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the <code class="language-plaintext highlighter-rouge">groups</code> array.</li> <li>Formally, you need to find the longest subsequence of an array of indices <code class="language-plaintext highlighter-rouge">[0, 1, ..., n - 1]</code> denoted as <code class="language-plaintext highlighter-rouge">[i0, i1, ..., ik-1]</code>, such that <code class="language-plaintext highlighter-rouge">groups[ij] != groups[ij+1]</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= j &lt; k - 1</code> and then find the words corresponding to these indices.</li> <li>Return <em>the selected subsequence. If there are multiple answers, return <strong>any</strong> of them.</em>**</li> <li><strong>Note:</strong> The elements in <code class="language-plaintext highlighter-rouge">words</code> are distinct.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["e","a","b"], groups = [0,0,1]

Output: ["e","b"]

Explanation: A subsequence that can be selected is ["e","b"] because groups[0] != groups[2]. Another subsequence that can be selected is ["a","b"] because groups[1] != groups[2]. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["a","b","c","d"], groups = [1,0,1,1]

Output: ["a","b","c"]

Explanation: A subsequence that can be selected is ["a","b","c"] because groups[0] != groups[1] and groups[1] != groups[2]. Another subsequence that can be selected is ["a","b","d"] because groups[0] != groups[1] and groups[1] != groups[3]. It can be shown that the length of the longest subsequence of indices that satisfies the condition is 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(max(nums) - min(nums))) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestUnequalAdjacentGroupsSubsequenceI</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getLongestSubsequence</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">groups</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the result list to store our subsequence</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Add the first element to the result</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// Remember the group value of the last added element</span>
        <span class="kt">int</span> <span class="n">lastGroup</span> <span class="o">=</span> <span class="n">groups</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the remaining elements</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current element's group is different from the last added element's group</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">lastGroup</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add the current element to our result</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

                <span class="c1">// Update the last group value</span>
                <span class="n">lastGroup</span> <span class="o">=</span> <span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the longest subsequence</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words1</span><span class="o">,</span> <span class="n">groups1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words1</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [a, b, c] or [a, b, d]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"e"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words2</span><span class="o">,</span> <span class="n">groups2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words2</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [e, b] or [a, b]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Additional Test Case 3</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"red"</span><span class="o">,</span> <span class="s">"green"</span><span class="o">,</span> <span class="s">"blue"</span><span class="o">,</span> <span class="s">"yellow"</span><span class="o">,</span> <span class="s">"purple"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words3</span><span class="o">,</span> <span class="n">groups3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words3</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [red, green, blue, purple]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a string array words and a binary array groups both of length n, where words[i] is associated with groups[i]. Your task is to select the longest alternating subsequence from words. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array groups differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the groups array. Formally, you need to find the longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each 0 &lt;= j &lt; k - 1 and then find the words corresponding to these indices. Return the selected subsequence. If there are multiple answers, return any of them.** Note: The elements in words are distinct.]]></summary></entry></feed>