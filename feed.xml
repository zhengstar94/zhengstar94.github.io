<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-07T03:58:02+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">59. Spiral Matrix II</title><link href="https://zhengstar94.github.io//blog/2025/SpiralMatrixII/" rel="alternate" type="text/html" title="59. Spiral Matrix II"/><published>2025-02-07T00:00:00+00:00</published><updated>2025-02-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SpiralMatrixII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SpiralMatrixII/"><![CDATA[<ul> <li>Given a positive integer <code class="language-plaintext highlighter-rouge">n</code>, generate an <code class="language-plaintext highlighter-rouge">n x n</code> <code class="language-plaintext highlighter-rouge">matrix</code> filled with elements from <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">n2</code> in spiral order.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 3
Output: [ [1,2,3],[8,9,4],[7,6,5 ] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: [ [1] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n²) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpiralMatrixII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">generateMatrix</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the result matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Define four pointers to track the boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// leftmost column not yet filled</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// rightmost column not yet filled</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// topmost row not yet filled</span>
        <span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span><span class="c1">// bottommost row not yet filled</span>

        <span class="c1">// Start with 1 and go up to n^2</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Continue until all numbers from 1 to n^2 are placed</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Fill top row from left to right</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">top</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">top</span><span class="o">++;</span> <span class="c1">// Move top boundary down</span>

            <span class="c1">// Fill rightmost column from top to bottom</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">right</span><span class="o">--;</span> <span class="c1">// Move right boundary left</span>

            <span class="c1">// Fill bottom row from right to left</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">bottom</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">bottom</span><span class="o">--;</span> <span class="c1">// Move bottom boundary up</span>

            <span class="c1">// Fill leftmost column from bottom to top</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bottom</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">top</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">left</span><span class="o">++;</span> <span class="c1">// Move left boundary right</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">matrix</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: 3x3 matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">generateMatrix</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test Case 2: 1x1 matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">generateMatrix</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.]]></summary></entry><entry><title type="html">713. Subarray Product Less Than K</title><link href="https://zhengstar94.github.io//blog/2025/SubarrayProductLessThanK/" rel="alternate" type="text/html" title="713. Subarray Product Less Than K"/><published>2025-02-07T00:00:00+00:00</published><updated>2025-02-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SubarrayProductLessThanK</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SubarrayProductLessThanK/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3], k = 0
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountShortest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SubarrayProductLessThanK</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numSubarrayProductLessThanK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if k &lt;= 1, no subarray can have product less than k</span>
        <span class="c1">// since all numbers in the array are positive</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables for sliding window</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Counter for valid subarrays</span>
        <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>    <span class="c1">// Current product of elements in window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// Left pointer of sliding window</span>

        <span class="c1">// Iterate through array with right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Include current element in product</span>
            <span class="n">product</span> <span class="o">*=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="c1">// Shrink window from left while product is &gt;= k</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">product</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Remove leftmost element from product</span>
                <span class="n">product</span> <span class="o">/=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="c1">// Move left pointer</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Add count of valid subarrays ending at current right pointer</span>
            <span class="c1">// For window of size n, number of subarrays = n</span>
            <span class="c1">// Window size = right - left + 1</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case with mixed numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numSubarrayProductLessThanK</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="c1">// Expected output: 8</span>
        <span class="c1">// Valid subarrays: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]</span>

        <span class="c1">// Test Case 2: Edge case with k = 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numSubarrayProductLessThanK</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="c1">// Expected output: 0</span>
        <span class="c1">// No valid subarrays as all products are positive</span>

        <span class="c1">// Test Case 3: Special case with all ones</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numSubarrayProductLessThanK</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
        <span class="c1">// Expected output: 6</span>
        <span class="c1">// All possible subarrays are valid as their products are 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountShortest"/><category term="Medium"/><category term="SlideWindow"/><summary type="html"><![CDATA[Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.]]></summary></entry><entry><title type="html">(Review)2537. Count the Number of Good Subarrays</title><link href="https://zhengstar94.github.io//blog/2025/CountTheNumberOfGoodSubarrays/" rel="alternate" type="text/html" title="(Review)2537. Count the Number of Good Subarrays"/><published>2025-02-06T00:00:00+00:00</published><updated>2025-02-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountTheNumberOfGoodSubarrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountTheNumberOfGoodSubarrays/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the number of <strong>good</strong> subarrays of</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>A subarray <code class="language-plaintext highlighter-rouge">arr</code> is <strong>good</strong> if there are <strong>at least</strong> <code class="language-plaintext highlighter-rouge">k</code> pairs of indices <code class="language-plaintext highlighter-rouge">(i, j)</code> such that <code class="language-plaintext highlighter-rouge">i &lt; j</code> and <code class="language-plaintext highlighter-rouge">arr[i] == arr[j]</code>.</li> <li>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,1,1], k = 10
Output: 1
Explanation: The only good subarray is the array nums itself.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,1,4,3,2,2,4], k = 2
Output: 4
Explanation: There are 4 different good subarrays:
- [3,1,4,3,2,2] that has 2 pairs.
- [3,1,4,3,2,2,4] that has 3 pairs.
- [1,4,3,2,2,4] that has 2 pairs.
- [4,3,2,2,4] that has 2 pairs.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountTheNumberOfGoodSubarrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countGood</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store the frequency of each number in the current window</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Store the total count of good subarrays</span>
        <span class="kt">long</span> <span class="n">currentPairs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Track the number of pairs in current window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Left pointer of sliding window</span>

        <span class="c1">// Iterate through array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// When adding a new element at right, it forms pairs with all its previous occurrences</span>
            <span class="c1">// For example: if we have [1,1] and add another 1, it forms 2 new pairs</span>
            <span class="n">currentPairs</span> <span class="o">+=</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="mi">0</span><span class="o">);</span>
            <span class="n">count</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>

            <span class="cm">/**
             * Key Part 1: Window Shrinking Condition
             * while (left &lt;= right &amp;&amp; currentPairs - count.get(nums[left]) + 1 &gt;= k)
             *
             * This condition checks if we can shrink the window from the left while still maintaining k pairs:
             * - left &lt;= right: ensures left pointer doesn't exceed right pointer
             * - currentPairs - count.get(nums[left]) + 1 &gt;= k: 
             *   - currentPairs: current total pairs in window
             *   - count.get(nums[left]): number of occurrences of leftmost element
             *   - +1: adjustment factor for remaining pairs after removal
             *   If this condition is true, we can safely remove the leftmost element
             *   and still have enough pairs to meet the requirement
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">currentPairs</span> <span class="o">-</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Remove the leftmost element and update pairs count</span>
                <span class="n">currentPairs</span> <span class="o">-=</span> <span class="n">count</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Key Part 2: Counting Valid Subarrays
             * if (currentPairs &gt;= k)
             * result += left + 1
             *
             * When we find a window with enough pairs (currentPairs &gt;= k):
             * - left + 1 represents the number of valid subarrays ending at 'right'
             * - For example, if left=2 and right=4, we add 3 because:
             *   We can start the subarray from index 0,1,or 2 (total of 3 possibilities)
             *   all ending at index 4, and each of these subarrays is valid
             * - This counts all possible valid subarrays that end at the current right pointer
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">currentPairs</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with all same elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countGood</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 2: Array with different elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countGood</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test Case 3: Small array with same elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countGood</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><category term="Review"/><category term="SlideWindow"/><summary type="html"><![CDATA[Given an integer array nums and an integer k, return the number of good subarrays of nums. A subarray arr is good if there are at least k pairs of indices (i, j) such that i &lt; j and arr[i] == arr[j]. A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry><entry><title type="html">1790. Check if One String Swap Can Make Strings Equal</title><link href="https://zhengstar94.github.io//blog/2025/CheckIfOneStringSwapCanMakeStringsEqual/" rel="alternate" type="text/html" title="1790. Check if One String Swap Can Make Strings Equal"/><published>2025-02-05T00:00:00+00:00</published><updated>2025-02-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CheckIfOneStringSwapCanMakeStringsEqual</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CheckIfOneStringSwapCanMakeStringsEqual/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code> of equal length. A <strong>string swap</strong> is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to make both strings equal by performing <strong>at most one string swap</strong> on <strong>exactly one</strong> of the strings.</em> Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "bank", s2 = "kanb"
Output: true
Explanation: For example, swap the first character with the last character of s2 to make "bank".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "attack", s2 = "defend"
Output: false
Explanation: It is impossible to make them equal with one string swap.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "kelb", s2 = "kelb"
Output: true
Explanation: The two strings are already equal, so no string swap operation is required.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckIfOneStringSwapCanMakeStringsEqual</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">areAlmostEqual</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the lengths of the two strings are not equal, return false</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Variables to store indices of different characters</span>
        <span class="c1">// i1 will store the index of the first differing character</span>
        <span class="c1">// i2 will store the index of the second differing character</span>
        <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each character of both strings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If characters at the current index are the same, continue to the next index</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If we already found two differences and another one is found,</span>
            <span class="c1">// then we need more than one swap, hence return false</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If this is the first differing character, store its index</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// This is the second differing character, store its index</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no differing characters were found, it means both strings are already equal</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If we found only one differing character, return false</span>
        <span class="c1">// Because a single swap can only fix two differing characters</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Finally, check if swapping the characters at these two indices</span>
        <span class="c1">// would make the two strings equal</span>
        <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i1</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i2</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"bank"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"kanb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 2</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"attack"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"defend"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test case 3</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"kelb"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"kelb"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 4 (where there's a possible swap)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"badc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test case 5 (where too many differences)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"xyz"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: "</span> <span class="o">+</span> <span class="n">areAlmostEqual</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.]]></summary></entry><entry><title type="html">2799. Count Complete Subarrays in an Array</title><link href="https://zhengstar94.github.io//blog/2025/CountCompleteSubarraysInAnArray/" rel="alternate" type="text/html" title="2799. Count Complete Subarrays in an Array"/><published>2025-02-05T00:00:00+00:00</published><updated>2025-02-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountCompleteSubarraysInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountCompleteSubarraysInAnArray/"><![CDATA[<ul> <li>You are given an array <code class="language-plaintext highlighter-rouge">nums</code> consisting of <strong>positive</strong> integers.</li> <li>We call a subarray of an array <strong>complete</strong> if the following condition is satisfied: <ul> <li>The number of <strong>distinct</strong> elements in the subarray is equal to the number of distinct elements in the whole array.</li> </ul> </li> <li>Return <em>the number of <strong>complete</strong> subarrays</em>.</li> <li>A <strong>subarray</strong> is a contiguous non-empty part of an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,1,2,2]
Output: 4
Explanation: The complete subarrays are the following: [1,3,1,2], [1,3,1,2,2], [3,1,2] and [3,1,2,2].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,5,5,5]
Output: 10
Explanation: The array consists only of the integer 5, so any subarray is complete. The number of subarrays that we can choose is 10.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountCompleteSubarraysInAnArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countCompleteSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Count distinct elements in the entire array using HashSet</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">total</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">total</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Store the total number of distinct elements</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">total</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

        <span class="c1">// Initialize variables for sliding window</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>          <span class="c1">// Counter for valid complete subarrays</span>
        <span class="kt">int</span> <span class="n">distinct</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// Count of distinct elements in current window</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>  <span class="c1">// Frequency map for elements in window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>         <span class="c1">// Left pointer of sliding window</span>

        <span class="c1">// Iterate through array with right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to frequency map</span>
            <span class="c1">// If element exists, increment its count, if not, set count to 1</span>
            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// If this is the first occurrence of the element in window</span>
            <span class="c1">// increment distinct counter</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">distinct</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If window contains same number of distinct elements as whole array</span>
            <span class="c1">// start shrinking window from left</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">distinct</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Decrease frequency of leftmost element</span>
                <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

                <span class="c1">// If element frequency becomes 0, it's no longer in window</span>
                <span class="c1">// so decrease distinct counter</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">distinct</span><span class="o">--;</span>
                <span class="o">}</span>

                <span class="c1">// Move left pointer forward</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Add number of valid subarrays ending at current right pointer</span>
            <span class="c1">// left represents how many starting positions can form valid subarrays</span>
            <span class="c1">// with current right position as ending point</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Array with repeated elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">countCompleteSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Array with all same elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">countCompleteSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><category term="SlideWindow"/><summary type="html"><![CDATA[You are given an array nums consisting of positive integers. We call a subarray of an array complete if the following condition is satisfied: The number of distinct elements in the subarray is equal to the number of distinct elements in the whole array. Return the number of complete subarrays. A subarray is a contiguous non-empty part of an array.]]></summary></entry><entry><title type="html">3325. Count Substrings With K-Frequency Characters I</title><link href="https://zhengstar94.github.io//blog/2025/CountSubstringsWithKFrequencyCharactersI/" rel="alternate" type="text/html" title="3325. Count Substrings With K-Frequency Characters I"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubstringsWithKFrequencyCharactersI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubstringsWithKFrequencyCharactersI/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return the total number of substrings of <code class="language-plaintext highlighter-rouge">s</code> where <strong>at least one</strong> character appears <strong>at least</strong> <code class="language-plaintext highlighter-rouge">k</code> times.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abacb", k = 2

Output: 4

Explanation:

The valid substrings are:

"aba" (character 'a' appears 2 times).
"abac" (character 'a' appears 2 times).
"abacb" (character 'a' appears 2 times).
"bacb" (character 'b' appears 2 times).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcde", k = 1

Output: 15

Explanation:

All substrings are valid because every character appears at least once.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubstringsWithKFrequencyCharactersI</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store frequency of each character (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">charFreq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Right pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the final result</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Expand window by moving right pointer</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Increment frequency of current character at right pointer</span>
            <span class="c1">// charFreq[0] represents 'a', charFreq[1] represents 'b', and so on</span>
            <span class="n">charFreq</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>

            <span class="c1">// When frequency of current character equals k,</span>
            <span class="c1">// contract window from left until its frequency becomes less than k</span>
            <span class="c1">// This is because we want to count substrings where character appears exactly k times</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">charFreq</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Decrement frequency of character at left pointer</span>
                <span class="c1">// as we're removing it from our window</span>
                <span class="n">charFreq</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
                <span class="c1">// Move left pointer ahead to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Add left pointer value to result</span>
            <span class="c1">// This counts all valid substrings ending at right pointer</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">left</span><span class="o">;</span>
            <span class="c1">// Move right pointer ahead to expand window</span>
            <span class="n">right</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abacb"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected output: 15</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aaa"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">numberOfSubstrings</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><category term="SlideWindow"/><summary type="html"><![CDATA[Given a string s and an integer k, return the total number of substrings of s where at least one character appears at least k times.]]></summary></entry><entry><title type="html">1800. Maximum Ascending Subarray Sum</title><link href="https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum/" rel="alternate" type="text/html" title="1800. Maximum Ascending Subarray Sum"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumAscendingSubarraySum/"><![CDATA[<ul> <li>Given an array of positive integers <code class="language-plaintext highlighter-rouge">nums</code>, return the <em>maximum possible sum of an <strong>ascending</strong> subarray in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>A subarray is defined as a contiguous sequence of numbers in an array.</li> <li>A subarray <code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> is <strong>ascending</strong> if for all <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">l &lt;= i &lt; r</code>, <code class="language-plaintext highlighter-rouge">numsi &lt; numsi+1</code>. Note that a subarray of size <code class="language-plaintext highlighter-rouge">1</code> is <strong>ascending</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumAscendingSubarraySum</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxAscendingSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or empty array</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables:</span>
        <span class="c1">// maxSum: keeps track of the maximum sum found so far</span>
        <span class="c1">// currentSum: keeps track of the current ascending sequence sum</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the array starting from second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If current element is greater than previous element</span>
            <span class="c1">// Continue building the ascending sequence</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If sequence breaks, start a new sequence from current element</span>
                <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// Update maxSum if currentSum is greater</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">currentSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with mixed ascending and non-ascending sequences</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">50</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 65</span>

        <span class="c1">// Test Case 2: Completely ascending array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">40</span><span class="o">,</span><span class="mi">50</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 150</span>

        <span class="c1">// Test Case 3: Array with multiple small ascending sequences</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">12</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 33</span>

        <span class="c1">// Test Case 4: Array with single element</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxAscendingSum</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums. A subarray is defined as a contiguous sequence of numbers in an array. A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l &lt;= i &lt; r, numsi &lt; numsi+1. Note that a subarray of size 1 is ascending.]]></summary></entry><entry><title type="html">922. Sort Array By Parity II</title><link href="https://zhengstar94.github.io//blog/2025/SortArrayByParityII/" rel="alternate" type="text/html" title="922. Sort Array By Parity II"/><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SortArrayByParityII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SortArrayByParityII/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>, half of the integers in <code class="language-plaintext highlighter-rouge">nums</code> are <strong>odd</strong>, and the other half are <strong>even</strong>.</li> <li>Sort the array so that whenever <code class="language-plaintext highlighter-rouge">nums[i]</code> is odd, <code class="language-plaintext highlighter-rouge">i</code> is <strong>odd</strong>, and whenever <code class="language-plaintext highlighter-rouge">nums[i]</code> is even, <code class="language-plaintext highlighter-rouge">i</code> is <strong>even</strong>.</li> <li>Return <em>any answer array that satisfies this condition</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3]
Output: [2,3]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SortArrayByParityII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParityII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize pointer for even indices starting from 0</span>
        <span class="kt">int</span> <span class="n">evenIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Initialize pointer for odd indices starting from 1</span>
        <span class="kt">int</span> <span class="n">oddIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Get the length of input array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create a new array to store the result</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Iterate through each number in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If number is even, place it at even index</span>
                <span class="n">result</span><span class="o">[</span><span class="n">evenIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="c1">// Move even index pointer by 2 positions</span>
                <span class="n">evenIndex</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If number is odd, place it at odd index</span>
                <span class="n">result</span><span class="o">[</span><span class="n">oddIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="c1">// Move odd index pointer by 2 positions</span>
                <span class="n">oddIndex</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the sorted array</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with multiple elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">sortArrayByParityII</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Array with minimum elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">sortArrayByParityII</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even. Return any answer array that satisfies this condition.]]></summary></entry><entry><title type="html">2962. Count Subarrays Where Max Element Appears at Least K Times</title><link href="https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes/" rel="alternate" type="text/html" title="2962. Count Subarrays Where Max Element Appears at Least K Times"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountSubarraysWhereMaxElementAppearsAtLeastKTimes/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and a <strong>positive</strong> integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Return <em>the number of subarrays where the <strong>maximum</strong> element of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>appears <strong>at least</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>times in that subarray.</em></li> <li>A <strong>subarray</strong> is a contiguous sequence of elements within (prep. 在…之内 adv. 在内部) an array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,2,3,3], k = 2
Output: 6
Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,2,1], k = 3
Output: 0
Explanation: No subarray contains the element 4 at least 3 times.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowCountLongest</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountSubarraysWhereMaxElementAppearsAtLeastKTimes</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countSubarrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1. Find the maximum value in the array</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 2. Process using sliding window technique</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Store the final count of valid subarrays</span>
        <span class="kt">int</span> <span class="n">cntMx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Count of maximum value occurrences in current window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Left pointer of the sliding window</span>

        <span class="c1">// Iterate through array using right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If current element is the maximum value, increment the counter</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cntMx</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Key Part 1: Window Adjustment
             * When we find exactly k occurrences of maximum value in the window:
             * 1. We need to shrink the window from left until cntMx &lt; k
             * 2. This helps us find the leftmost valid position for the current right pointer
             *
             * For example, in [1,3,2,3,3] with k=2:
             * When right=3 (fourth position), window contains [1,3,2,3]
             * We move left pointer until we have less than k max values
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">cntMx</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If we remove a maximum value from the left, decrease the counter</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">++]</span> <span class="o">==</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">cntMx</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="cm">/**
             * Key Part 2: Counting Valid Subarrays
             * After the while loop:
             * - 'left' represents the position where window becomes invalid
             * - All positions before 'left' can be valid starting points
             *
             * For example, when right=3 in [1,3,2,3]:
             * If left=2, we can start subarrays from:
             * - position 0: [1,3,2,3]
             * - position 1: [3,2,3]
             * So we add 'left' (2) to answer
             *
             * This is why ans += left works:
             * - It counts all possible valid starting positions
             * - Each starting position forms exactly one valid subarray with current right pointer
             */</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with maximum value appearing multiple times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
        <span class="c1">// Valid subarrays are: [1,3,2,3], [3,2,3], [1,3,2,3,3], [3,2,3,3], [2,3,3], [3,3]</span>

        <span class="c1">// Test Case 2: Array where maximum value appears less than k times</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countSubarrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected: 0</span>
        <span class="c1">// No valid subarrays as maximum value (4) appears less than 3 times</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowCountLongest"/><category term="Medium"/><category term="SlideWindow"/><summary type="html"><![CDATA[You are given an integer array nums and a positive integer k. Return the number of subarrays where the maximum element of nums appears at least k times in that subarray. A subarray is a contiguous sequence of elements within (prep. 在…之内 adv. 在内部) an array.]]></summary></entry><entry><title type="html">3105. Longest Strictly Increasing or Strictly Decreasing Subarray</title><link href="https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray/" rel="alternate" type="text/html" title="3105. Longest Strictly Increasing or Strictly Decreasing Subarray"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestStrictlyIncreasingOrStrictlyDecreasingSubarray/"><![CDATA[<ul> <li>You are given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>. Return <em>the length of the <strong>longest</strong> subarray of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>which is either <strong>strictly increasing</strong> or <strong>strictly decreasing</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,3,3,2]

Output: 2

Explanation:

The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].

The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].

Hence, we return 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,3,3,3]

Output: 1

Explanation:

The strictly increasing subarrays of nums are [3], [3], [3], and [3].

The strictly decreasing subarrays of nums are [3], [3], [3], and [3].

Hence, we return 1.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1]

Output: 3

Explanation:

The strictly increasing subarrays of nums are [3], [2], and [1].

The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].

Hence, we return 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/02/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestStrictlyIncreasingOrStrictlyDecreasingSubarray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestMonotonicSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Return 0 for null or empty array</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Return 1 for single element array</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables:</span>
        <span class="c1">// inc: length of current increasing sequence</span>
        <span class="c1">// dec: length of current decreasing sequence</span>
        <span class="c1">// maxLen: maximum length found so far</span>
        <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through the array starting from second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>  <span class="c1">// If current element is greater than previous</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Extend increasing sequence</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset decreasing sequence</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>  <span class="c1">// If current element is less than previous</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="n">dec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Extend decreasing sequence</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset increasing sequence</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>  <span class="c1">// If current element equals previous</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>        <span class="c1">// Reset both sequences</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum length found</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">inc</span><span class="o">,</span> <span class="n">dec</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>  <span class="c1">// Return the final result</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the implementation with various test cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 2: Equal elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 3: Strictly decreasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 4: Strictly increasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 5: Strictly decreasing sequence</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">longestMonotonicSubarray</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.]]></summary></entry></feed>