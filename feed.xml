<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-28T07:50:34+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2658. Maximum Number of Fish in a Grid</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfFishInAGrid/" rel="alternate" type="text/html" title="2658. Maximum Number of Fish in a Grid"/><published>2025-01-28T00:00:00+00:00</published><updated>2025-01-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfFishInAGrid</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfFishInAGrid/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D matrix <code class="language-plaintext highlighter-rouge">grid</code> of size <code class="language-plaintext highlighter-rouge">m x n</code>, where <code class="language-plaintext highlighter-rouge">(r, c)</code> represents: <ul> <li>A <strong>land</strong> cell if <code class="language-plaintext highlighter-rouge">grid[r][c] = 0</code>, or</li> <li>A <strong>water</strong> cell containing <code class="language-plaintext highlighter-rouge">grid[r][c]</code> fish, if <code class="language-plaintext highlighter-rouge">grid[r][c] &gt; 0</code>.</li> </ul> </li> <li>A fisher can start at any <strong>water</strong> cell <code class="language-plaintext highlighter-rouge">(r, c)</code> and can do the following operations any number of times: <ul> <li>Catch all the fish at cell <code class="language-plaintext highlighter-rouge">(r, c)</code>, or</li> <li>Move to any adjacent <strong>water</strong> cell.</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or</em> <code class="language-plaintext highlighter-rouge">0</code> if no water cell exists.</li> <li>An <strong>adjacent</strong> cell of the cell <code class="language-plaintext highlighter-rouge">(r, c)</code>, is one of the cells <code class="language-plaintext highlighter-rouge">(r, c + 1)</code>, <code class="language-plaintext highlighter-rouge">(r, c - 1)</code>, <code class="language-plaintext highlighter-rouge">(r + 1, c)</code> or <code class="language-plaintext highlighter-rouge">(r - 1, c)</code> if it exists.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0 ] ]
Output: 7
Explanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1 ] ]
Output: 1
Explanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DFS</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfFishInAGrid</span> <span class="o">{</span>

    <span class="c1">// Define four directional movements: up, down, left, right</span>
    <span class="c1">// Used for exploring adjacent cells in the grid</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">DIRECTIONS</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxFish</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check for null or empty grid</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Get grid dimensions</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxFish</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each cell in the grid</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If current cell is a water cell (contains fish)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="c1">// Start DFS from this cell and update maximum fish count</span>
                    <span class="n">maxFish</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxFish</span><span class="o">,</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxFish</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check boundaries and if cell is already visited (0)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span>
                <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">||</span>
                <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Store current cell's fish count</span>
        <span class="kt">int</span> <span class="n">currentFish</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
        <span class="c1">// Mark cell as visited by setting to 0</span>
        <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Initialize total fish count with current cell's fish</span>
        <span class="kt">int</span> <span class="n">totalFish</span> <span class="o">=</span> <span class="n">currentFish</span><span class="o">;</span>
        <span class="c1">// Explore all four directions</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">dir:</span> <span class="no">DIRECTIONS</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">newRow</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">newCol</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="c1">// Add fish count from adjacent water cells</span>
            <span class="n">totalFish</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">newRow</span><span class="o">,</span> <span class="n">newCol</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">totalFish</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal grid with multiple water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Expected output: 7</span>

        <span class="c1">// Test Case 2: Grid with isolated water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 3: Empty grid</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid3</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 4: Grid with only land cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid4</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DFS"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents: A land cell if grid[r][c] = 0, or A water cell containing grid[r][c] fish, if grid[r][c] &gt; 0. A fisher can start at any water cell (r, c) and can do the following operations any number of times: Catch all the fish at cell (r, c), or Move to any adjacent water cell. Return the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists. An adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.]]></summary></entry><entry><title type="html">119. Pascal’s Triangle II</title><link href="https://zhengstar94.github.io//blog/2025/PascalsTriangleII/" rel="alternate" type="text/html" title="119. Pascal’s Triangle II"/><published>2025-01-28T00:00:00+00:00</published><updated>2025-01-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PascalsTriangleII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PascalsTriangleII/"><![CDATA[<ul> <li>Given an integer <code class="language-plaintext highlighter-rouge">rowIndex</code>, return the <code class="language-plaintext highlighter-rouge">rowIndexth</code> (<strong>0-indexed</strong>) row of the <strong>Pascal’s triangle</strong>.</li> <li>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rowIndex = 3
Output: [1,3,3,1]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rowIndex = 0
Output: [1]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rowIndex = 1
Output: [1,1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(rowIndex) time | O(rowIndex) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PascalsTriangleII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">getRow</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a list to store the final result.</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Create an array to store the current row values.</span>
        <span class="c1">// The size of the array is rowIndex + 1 because the row is 0-indexed.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rowIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// The first element of every row in Pascal's Triangle is always 1.</span>
        <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Loop to calculate each element in the row.</span>
        <span class="c1">// Start from the second element (i=1) because the first element is already set to 1.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rowIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Get the previous element in the row.</span>
            <span class="c1">// This is equivalent to C(n, k-1) in the combination formula.</span>
            <span class="kt">long</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">row</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Calculate the current element using the combination formula:</span>
            <span class="c1">// C(n, k) = C(n, k-1) * (n - k + 1) / k</span>
            <span class="c1">// Here:</span>
            <span class="c1">// - n is the rowIndex.</span>
            <span class="c1">// - k is the current position in the row (i).</span>
            <span class="c1">// - (rowIndex - i + 1) is the numerator part of the formula.</span>
            <span class="c1">// - i is the denominator part of the formula.</span>
            <span class="kt">long</span> <span class="n">current</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">*</span> <span class="o">(</span><span class="n">rowIndex</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Store the calculated value in the current position of the row.</span>
            <span class="n">row</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">current</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Convert the array to a list for the final result.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the generated row.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: rowIndex = 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 3: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>  <span class="c1">// Expected output: [1, 3, 3, 1]</span>

        <span class="c1">// Test case 2: rowIndex = 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 0: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>  <span class="c1">// Expected output: [1]</span>

        <span class="c1">// Test case 3: rowIndex = 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 1: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>  <span class="c1">// Expected output: [1, 1]</span>

        <span class="c1">// Additional test case: rowIndex = 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 4: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>  <span class="c1">// Expected output: [1, 4, 6, 4, 1]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:]]></summary></entry><entry><title type="html">1462. Course Schedule IV</title><link href="https://zhengstar94.github.io//blog/2025/CourseScheduleIV/" rel="alternate" type="text/html" title="1462. Course Schedule IV"/><published>2025-01-27T00:00:00+00:00</published><updated>2025-01-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CourseScheduleIV</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CourseScheduleIV/"><![CDATA[<ul> <li>There are a total of <code class="language-plaintext highlighter-rouge">numCourses</code> courses you have to take, labeled from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">numCourses - 1</code>. You are given an array <code class="language-plaintext highlighter-rouge">prerequisites</code> where <code class="language-plaintext highlighter-rouge">prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code class="language-plaintext highlighter-rouge">ai</code> first if you want to take course <code class="language-plaintext highlighter-rouge">bi</code>. <ul> <li>For example, the pair <code class="language-plaintext highlighter-rouge">[0, 1]</code> indicates that you have to take course <code class="language-plaintext highlighter-rouge">0</code> before you can take course <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> </li> <li>Prerequisites can also be <strong>indirect</strong>. If course <code class="language-plaintext highlighter-rouge">a</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">b</code>, and course <code class="language-plaintext highlighter-rouge">b</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">c</code>, then course <code class="language-plaintext highlighter-rouge">a</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">c</code>.</li> <li>You are also given an array <code class="language-plaintext highlighter-rouge">queries</code> where <code class="language-plaintext highlighter-rouge">queries[j] = [uj, vj]</code>. For the <code class="language-plaintext highlighter-rouge">jth</code> query, you should answer whether course <code class="language-plaintext highlighter-rouge">uj</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">vj</code> or not.</li> <li>Return <em>a boolean array</em> <code class="language-plaintext highlighter-rouge">answer</code><em>, where</em> <code class="language-plaintext highlighter-rouge">answer[j]</code> <em>is the answer to the</em> <code class="language-plaintext highlighter-rouge">jth</code> <em>query.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 2, prerequisites = [ [ 1,0 ] ], queries = [ [ 0,1],[1,0 ] ]
Output: [false,true]
Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 2, prerequisites = [], queries = [ [ 1,0],[0,1 ] ]
Output: [false,false]
Explanation: There are no prerequisites, and each course is independent.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 3, prerequisites = [ [ 1,2],[1,0],[2,0 ] ], queries = [ [ 1,0],[1,2 ] ]
Output: [true,true]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n³) time | O(n²) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CourseScheduleIV</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="nf">checkIfPrerequisite</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create adjacency matrix to represent course dependencies</span>
        <span class="c1">// connected[i][j] = true means course i is a prerequisite of course j</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">connected</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">][</span><span class="n">numCourses</span><span class="o">];</span>

        <span class="c1">// Initialize direct prerequisites relationships</span>
        <span class="c1">// For each pair [a,b], mark that course 'a' is a direct prerequisite of course 'b'</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prereq</span> <span class="o">:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">connected</span><span class="o">[</span><span class="n">prereq</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">prereq</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Floyd-Warshall Algorithm Implementation</span>
        <span class="c1">// This algorithm finds all possible paths between any two courses (direct and indirect prerequisites)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>           <span class="c1">// k represents the intermediate course being considered</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>       <span class="c1">// i represents the starting course</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>   <span class="c1">// j represents the target course</span>
                    <span class="c1">// For each trio of courses (i,j,k), check if:</span>
                    <span class="c1">// 1. Either there's already a path from i to j (connected[i][j])</span>
                    <span class="c1">// 2. OR there's a path from i to k AND from k to j</span>
                    <span class="c1">// If either condition is true, then course i is a prerequisite of course j</span>
                    <span class="n">connected</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">connected</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span>
                            <span class="o">(</span><span class="n">connected</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">connected</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Process each query to build the result list</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">query</span> <span class="o">:</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each query [u,v], check if course u is a prerequisite of course v</span>
            <span class="c1">// by looking up the value in our processed adjacency matrix</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">connected</span><span class="o">[</span><span class="n">query</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">query</span><span class="o">[</span><span class="mi">1</span><span class="o">]]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="c1">// Course structure: 1 -&gt; 0 (Course 1 is a prerequisite of Course 0)</span>
        <span class="kt">int</span> <span class="n">numCourses1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span>
                <span class="n">checkIfPrerequisite</span><span class="o">(</span><span class="n">numCourses1</span><span class="o">,</span> <span class="n">prerequisites1</span><span class="o">,</span> <span class="n">queries1</span><span class="o">));</span>
        <span class="c1">// Expected Output: [false,true]</span>

        <span class="c1">// Test Case 2</span>
        <span class="c1">// Course structure: 1 -&gt; 2 -&gt; 0 and 1 -&gt; 0 (direct)</span>
        <span class="kt">int</span> <span class="n">numCourses2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span>
                <span class="n">checkIfPrerequisite</span><span class="o">(</span><span class="n">numCourses2</span><span class="o">,</span> <span class="n">prerequisites2</span><span class="o">,</span> <span class="n">queries2</span><span class="o">));</span>
        <span class="c1">// Expected Output: [true,true]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><summary type="html"><![CDATA[There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi. For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1. Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c. You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not. Return a boolean array answer, where answer[j] is the answer to the jth query.]]></summary></entry><entry><title type="html">45. Jump Game II</title><link href="https://zhengstar94.github.io//blog/2025/JumpGameII/" rel="alternate" type="text/html" title="45. Jump Game II"/><published>2025-01-27T00:00:00+00:00</published><updated>2025-01-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/JumpGameII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/JumpGameII/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array of integers <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code>. You are initially positioned at <code class="language-plaintext highlighter-rouge">nums[0]</code>.</li> <li>Each element <code class="language-plaintext highlighter-rouge">nums[i]</code> represents the maximum length of a forward jump from index <code class="language-plaintext highlighter-rouge">i</code>. In other words, if you are at <code class="language-plaintext highlighter-rouge">nums[i]</code>, you can jump to any <code class="language-plaintext highlighter-rouge">nums[i + j]</code> where: <ul> <li><code class="language-plaintext highlighter-rouge">0 &lt;= j &lt;= nums[i]</code> and</li> <li><code class="language-plaintext highlighter-rouge">i + j &lt; n</code></li> </ul> </li> <li>Return <em>the minimum number of jumps to reach</em> <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>. The test cases are generated such that you can reach <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,0,1,4]
Output: 2
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JumpGameII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">jump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Counter for the minimum number of jumps needed</span>
        <span class="kt">int</span> <span class="n">jumps</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// The farthest position that can be reached in the current jump</span>
        <span class="kt">int</span> <span class="n">curEnd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// The farthest position that can be reached considering all positions up to current position</span>
        <span class="kt">int</span> <span class="n">curFarthest</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array (except the last element as we don't need to jump from there)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update the farthest position that can be reached from current position</span>
            <span class="n">curFarthest</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">curFarthest</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// If we've reached the end of current jump range</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">curEnd</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// We must take a jump</span>
                <span class="n">jumps</span><span class="o">++;</span>
                <span class="c1">// Update the end range for the next jump</span>
                <span class="n">curEnd</span> <span class="o">=</span> <span class="n">curFarthest</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">jumps</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with multiple possible paths</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">jump</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 2: Another case with same minimum jumps but different path</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">jump</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 3: Case where each step can only jump one position</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">jump</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: 0 &lt;= j &lt;= nums[i] and i + j &lt; n Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].]]></summary></entry><entry><title type="html">40. Combination Sum II</title><link href="https://zhengstar94.github.io//blog/2025/CombinationSumII/" rel="alternate" type="text/html" title="40. Combination Sum II"/><published>2025-01-26T00:00:00+00:00</published><updated>2025-01-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CombinationSumII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CombinationSumII/"><![CDATA[<ul> <li>Given a collection of candidate numbers (<code class="language-plaintext highlighter-rouge">candidates</code>) and a target number (<code class="language-plaintext highlighter-rouge">target</code>), find all unique combinations in <code class="language-plaintext highlighter-rouge">candidates</code> where the candidate numbers sum to <code class="language-plaintext highlighter-rouge">target</code>.</li> <li>Each number in <code class="language-plaintext highlighter-rouge">candidates</code> may only be used <strong>once</strong> in the combination.</li> <li><strong>Note:</strong> The solution set must not contain duplicate combinations.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(2<span class="p">^</span>n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinationSumII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Sort array first to handle duplicates and enable pruning</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">candidates</span><span class="o">);</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">results</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span> <span class="n">candidates</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">results</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span><span class="o">,</span>
                                  <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">remain</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: if remaining sum is 0, we found a valid combination</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Add a deep copy of current combination to results</span>
            <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">temp</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Try each candidate number starting from 'start' index</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Pruning: if current number is greater than remaining sum,</span>
            <span class="c1">// all subsequent numbers will also be too large (array is sorted)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">remain</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Skip duplicates in the same level of recursion tree</span>
            <span class="c1">// This prevents generating duplicate combinations</span>
            <span class="c1">// Only skip if it's not the first element in current recursion level</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Include current number in combination</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Recursive call:</span>
            <span class="c1">// - Subtract current number from remaining sum</span>
            <span class="c1">// - Start from next index (i+1) as each number can only be used once</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">results</span><span class="o">,</span> <span class="n">temp</span><span class="o">,</span> <span class="n">candidates</span><span class="o">,</span> <span class="n">remain</span> <span class="o">-</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Backtrack: remove current number to try next possibility</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output: [[1,1,6], [1,2,5], [1,7], [2,6]]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">combinationSum2</span><span class="o">(</span><span class="n">candidates1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Expected output: [[1,2,2], [5]]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">combinationSum2</span><span class="o">(</span><span class="n">candidates2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><category term="Medium"/><summary type="html"><![CDATA[Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.]]></summary></entry><entry><title type="html">2781. Length of the Longest Valid Substring</title><link href="https://zhengstar94.github.io//blog/2025/LengthOfTheLongestValidSubstring/" rel="alternate" type="text/html" title="2781. Length of the Longest Valid Substring"/><published>2025-01-26T00:00:00+00:00</published><updated>2025-01-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LengthOfTheLongestValidSubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LengthOfTheLongestValidSubstring/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">word</code> and an array of strings <code class="language-plaintext highlighter-rouge">forbidden</code>.</li> <li>A string is called <strong>valid</strong> if none of its substrings are present in <code class="language-plaintext highlighter-rouge">forbidden</code>.</li> <li>Return <em>the length of the <strong>longest valid substring</strong> of the string</em> <code class="language-plaintext highlighter-rouge">word</code>.</li> <li>A <strong>substring</strong> is a contiguous sequence of characters in a string, possibly empty.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "cbaaaabc", forbidden = ["aaa","cb"]
Output: 4
Explanation: There are 11 valid substrings in word: "c", "b", "a", "ba", "aa", "bc", "baa", "aab", "ab", "abc" and "aabc". The length of the longest valid substring is 4. 
It can be shown that all other substrings contain either "aaa" or "cb" as a substring. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "leetcode", forbidden = ["de","le","e"]
Output: 4
Explanation: There are 11 valid substrings in word: "l", "t", "c", "o", "d", "tc", "co", "od", "tco", "cod", and "tcod". The length of the longest valid substring is 4.
It can be shown that all other substrings contain either "de", "le", or "e" as a substring. 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(L * nM<span class="p">^</span>2) time | O(L) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LengthOfTheLongestValidSubstring</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestValidSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">forbidden</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert forbidden list to HashSet for O(1) lookup time</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">forbiddenSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
        <span class="n">forbiddenSet</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">forbidden</span><span class="o">);</span>

        <span class="c1">// Initialize variables</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="c1">// Store the maximum length of valid substring</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// Left pointer of the sliding window</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// Length of input string</span>

        <span class="c1">// Outer loop: moves the right pointer of the sliding window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Inner loop: checks substrings within the current window [left, right]</span>
            <span class="c1">// This is a small sliding window check from right to left</span>
            <span class="c1">// Conditions:</span>
            <span class="c1">// 1. i &gt;= left: ensures we don't check beyond the left boundary</span>
            <span class="c1">// 2. i &gt; right - 10: optimizes by only checking up to 10 characters</span>
            <span class="c1">// (since forbidden strings are at most 10 characters long)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="c1">// Check if current substring [i, right] is in forbidden set</span>
                <span class="c1">// substring(i, right + 1) extracts the substring from index i to right (inclusive)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">forbiddenSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">{</span>
                    <span class="c1">// If found forbidden substring:</span>
                    <span class="c1">// 1. Update left pointer to skip the forbidden part</span>
                    <span class="c1">// 2. Move left pointer to i + 1 to ensure window starts after forbidden substring</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="c1">// Break inner loop as we've found a forbidden substring</span>
                    <span class="c1">// No need to check shorter substrings as window has been adjusted</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// After checking/adjusting window, update maximum length</span>
            <span class="c1">// right - left + 1 gives current window size</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic test with multiple forbidden strings</span>
        <span class="nc">String</span> <span class="n">word1</span> <span class="o">=</span> <span class="s">"cbaaaabc"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">forbidden1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"aaa"</span><span class="o">,</span> <span class="s">"cb"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">longestValidSubstring</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">forbidden1</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test case 2: Test with overlapping forbidden strings</span>
        <span class="nc">String</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"leetcode"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">forbidden2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"de"</span><span class="o">,</span> <span class="s">"le"</span><span class="o">,</span> <span class="s">"e"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">longestValidSubstring</span><span class="o">(</span><span class="n">word2</span><span class="o">,</span> <span class="n">forbidden2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Hard"/><summary type="html"><![CDATA[You are given a string word and an array of strings forbidden. A string is called valid if none of its substrings are present in forbidden. Return the length of the longest valid substring of the string word. A substring is a contiguous sequence of characters in a string, possibly empty.]]></summary></entry><entry><title type="html">2412. Minimum Money Required Before Transactions</title><link href="https://zhengstar94.github.io//blog/2025/MinimumMoneyRequiredBeforeTransactions/" rel="alternate" type="text/html" title="2412. Minimum Money Required Before Transactions"/><published>2025-01-25T00:00:00+00:00</published><updated>2025-01-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumMoneyRequiredBeforeTransactions</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumMoneyRequiredBeforeTransactions/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">transactions</code>, where <code class="language-plaintext highlighter-rouge">transactions[i] = [costi, cashbacki]</code>.</li> <li>The array describes transactions, where each transaction must be completed exactly once in <strong>some order</strong>. At any given moment, you have a certain amount of <code class="language-plaintext highlighter-rouge">money</code>. In order to complete transaction <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">money &gt;= costi</code> must hold true. After performing a transaction, <code class="language-plaintext highlighter-rouge">money</code> becomes <code class="language-plaintext highlighter-rouge">money - costi + cashbacki</code>.</li> <li>Return <em>the minimum amount of</em> <code class="language-plaintext highlighter-rouge">money</code> <em>required before any transaction so that all of the transactions can be completed <strong>regardless of the order</strong> of the transactions.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: transactions = [ [ 2,1],[5,0],[4,2 ] ]
Output: 10
Explanation:
Starting with money = 10, the transactions can be performed in any order.
It can be shown that starting with money &lt; 10 will fail to complete all transactions in some order.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: transactions = [ [ 3,0],[0,3 ] ]
Output: 3
Explanation:
- If transactions are in the order [ [ 3,0],[0,3 ] ], the minimum money required to complete the transactions is 3.
- If transactions are in the order [ [ 0,3],[3,0 ] ], the minimum money required to complete the transactions is 0.
Thus, starting with money = 3, the transactions can be performed in any order.

</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumMoneyRequiredBeforeTransactions</span> <span class="o">{</span>

    <span class="cm">/**
     * Calculate the minimum initial money required to complete all transactions
     *
     * @param transactions 2D array where each inner array contains [cost, cashback]
     * @return long value representing the minimum initial money needed
     *
     * Algorithm explanation:
     * 1. totalLose: Accumulates the total money lost from all losing transactions
     * 2. mx: Tracks the maximum of minimum starting money needed for any single transaction
     * 3. Final result = totalLose + mx
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">minimumMoney</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">transactions</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Track the total money lost from all losing transactions</span>
        <span class="kt">long</span> <span class="n">totalLose</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Track the maximum of minimum starting money needed for any transaction</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each transaction</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">transaction</span> <span class="o">:</span> <span class="n">transactions</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate and accumulate losses</span>
            <span class="c1">// If cost &gt; cashback, add the difference to totalLose</span>
            <span class="c1">// If cost &lt;= cashback, add 0 (no loss)</span>
            <span class="n">totalLose</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">transaction</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">transaction</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="mi">0</span><span class="o">);</span>

            <span class="c1">// Calculate minimum starting money needed for this transaction</span>
            <span class="c1">// Why min?: Because we need at least the smaller of (cost, cashback)</span>
            <span class="c1">// to start this transaction at any point</span>
            <span class="kt">int</span> <span class="n">minStart</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">transaction</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">transaction</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

            <span class="c1">// Update mx if current transaction needs more starting money</span>
            <span class="c1">// This ensures we have enough money to start the most demanding transaction</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">minStart</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return total losses plus maximum starting money needed</span>
        <span class="c1">// This sum ensures we can complete all transactions in any order</span>
        <span class="k">return</span> <span class="n">totalLose</span> <span class="o">+</span> <span class="n">mx</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Mixed transactions with losses</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== Example 1 ==="</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">transactions1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">long</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">minimumMoney</span><span class="o">(</span><span class="n">transactions1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum initial money needed for Example 1: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Transactions with extreme cashback differences</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n\n=== Example 2 ==="</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">transactions2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">long</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">minimumMoney</span><span class="o">(</span><span class="n">transactions2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum initial money needed for Example 2: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test Case 3: More complex transactions with varying profits/losses</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n\n=== Example 3 ==="</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">transactions3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">10</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">},</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">long</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">minimumMoney</span><span class="o">(</span><span class="n">transactions3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum initial money needed for Example 3: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Hard"/><summary type="html"><![CDATA[You are given a 0-indexed 2D integer array transactions, where transactions[i] = [costi, cashbacki]. The array describes transactions, where each transaction must be completed exactly once in some order. At any given moment, you have a certain amount of money. In order to complete transaction i, money &gt;= costi must hold true. After performing a transaction, money becomes money - costi + cashbacki. Return the minimum amount of money required before any transaction so that all of the transactions can be completed regardless of the order of the transactions.]]></summary></entry><entry><title type="html">2009. Minimum Number of Operations to Make Array Continuous</title><link href="https://zhengstar94.github.io//blog/2025/MinimumNumberOfOperationsToMakeArrayContinuous/" rel="alternate" type="text/html" title="2009. Minimum Number of Operations to Make Array Continuous"/><published>2025-01-25T00:00:00+00:00</published><updated>2025-01-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumNumberOfOperationsToMakeArrayContinuous</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumNumberOfOperationsToMakeArrayContinuous/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. In one operation, you can replace <strong>any</strong> element in <code class="language-plaintext highlighter-rouge">nums</code> with <strong>any</strong> integer.</li> <li><code class="language-plaintext highlighter-rouge">nums</code> is considered <strong>continuous</strong> if both of the following conditions are fulfilled: <ul> <li>All elements in <code class="language-plaintext highlighter-rouge">nums</code> are <strong>unique</strong>.</li> <li>The difference between the <strong>maximum</strong> element and the <strong>minimum</strong> element in <code class="language-plaintext highlighter-rouge">nums</code> equals <code class="language-plaintext highlighter-rouge">nums.length - 1</code>.</li> </ul> </li> <li>For example, <code class="language-plaintext highlighter-rouge">nums = [4, 2, 5, 3]</code> is <strong>continuous</strong>, but <code class="language-plaintext highlighter-rouge">nums = [1, 2, 3, 5, 6]</code> is <strong>not continuous</strong>.</li> <li>Return <em>the <strong>minimum</strong> number of operations to make</em> <code class="language-plaintext highlighter-rouge">nums</code> <strong>*continuous*</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,5,3]
Output: 0
Explanation: nums is already continuous.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,5,6]
Output: 1
Explanation: One possible solution is to change the last element to 4.
The resulting array is [1,2,3,5,4], which is continuous.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,10,100,1000]
Output: 3
Explanation: One possible solution is to:
- Change the second element to 2.
- Change the third element to 3.
- Change the fourth element to 4.
The resulting array is [1,2,3,4], which is continuous.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumNumberOfOperationsToMakeArrayContinuous</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Step 1: Sort and remove duplicates</span>
        <span class="c1">// - Sort the array first to handle duplicates and make it easier to find continuous ranges</span>
        <span class="c1">// - This also helps in implementing the sliding window approach</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">unique</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Only keep unique elements by moving them to the front of the array</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">unique</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Use sliding window to find minimum replacements needed</span>
        <span class="c1">// Initialize minOperations with n (worst case: need to replace all elements)</span>
        <span class="kt">int</span> <span class="n">minOperations</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each possible starting point</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">unique</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Find the first number that's out of range for current window</span>
            <span class="c1">// For a continuous array of length n starting at nums[i],</span>
            <span class="c1">// all elements must be in range [nums[i], nums[i] + n - 1]</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">unique</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Calculate number of elements in current window</span>
            <span class="c1">// j - i represents the count of numbers that can be used in the continuous array</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Calculate minimum operations needed for this window</span>
            <span class="c1">// Total length (n) minus the count of usable numbers equals</span>
            <span class="c1">// the number of elements that need to be replaced</span>
            <span class="n">minOperations</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minOperations</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">count</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">minOperations</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Already continuous array</span>
        <span class="c1">// Expected output: 0 (no operations needed as [2,3,4,5] is already continuous)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Array with one gap</span>
        <span class="c1">// Expected output: 1 (replace either 5 with 4 or 6 with 4)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Array with large gaps</span>
        <span class="c1">// Expected output: 3 (need to replace 3 elements to make it continuous)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">100</span><span class="o">,</span><span class="mi">1000</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Hard"/><summary type="html"><![CDATA[You are given an integer array nums. In one operation, you can replace any element in nums with any integer. nums is considered continuous if both of the following conditions are fulfilled: All elements in nums are unique. The difference between the maximum element and the minimum element in nums equals nums.length - 1. For example, nums=[4, 2, 5, 3] is continuous, but nums=[1, 2, 3, 5, 6] is not continuous. Return the minimum number of operations to make nums *continuous*.]]></summary></entry><entry><title type="html">802. Find Eventual Safe States</title><link href="https://zhengstar94.github.io//blog/2025/FindEventualSafeStates/" rel="alternate" type="text/html" title="802. Find Eventual Safe States"/><published>2025-01-24T00:00:00+00:00</published><updated>2025-01-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindEventualSafeStates</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindEventualSafeStates/"><![CDATA[<ul> <li>There is a directed graph of <code class="language-plaintext highlighter-rouge">n</code> nodes with each node labeled from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n - 1</code>. The graph is represented by a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">graph</code> where <code class="language-plaintext highlighter-rouge">graph[i]</code> is an integer array of nodes adjacent to node <code class="language-plaintext highlighter-rouge">i</code>, meaning there is an edge from node <code class="language-plaintext highlighter-rouge">i</code> to each node in <code class="language-plaintext highlighter-rouge">graph[i]</code>.</li> <li>A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong> (or another safe node).</li> <li>Return <em>an array containing all the <strong>safe nodes</strong> of the graph</em>. The answer should be sorted in <strong>ascending</strong> order.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: graph = [ [ 1,2],[2,3],[5],[0],[5],[],[ ] ]
Output: [2,4,5,6]
Explanation: The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: graph = [ [ 1,2,3,4],[1,2],[3,4],[0,4],[ ] ]
Output: [4]
Explanation:
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(V + E) time | O(V) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DFS</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindEventualSafeStates</span> <span class="o">{</span>

    <span class="cm">/**
     * Array to keep track of node states:
     * 0 = unvisited
     * 1 = currently being visited (in the current DFS path)
     * 2 = confirmed safe node
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">eventualSafeNodes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each node in the graph to check if it's safe</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">graph</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Case 1: If we encounter a node that's currently being visited,</span>
        <span class="c1">// we've found a cycle, and all nodes in this cycle are unsafe</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Case 2: If we encounter a node that's already been confirmed safe,</span>
        <span class="c1">// we can return true without further exploration</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Mark the current node as being visited (in the current DFS path)</span>
        <span class="c1">// This helps in cycle detection</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Explore all neighboring nodes</span>
        <span class="c1">// If any path from the current node leads to an unsafe node,</span>
        <span class="c1">// the current node is also unsafe</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">next</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">node</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">next</span><span class="o">,</span> <span class="n">graph</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>  <span class="c1">// Found an unsafe path</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we reach here, all paths from this node are safe</span>
        <span class="c1">// Mark the node as a confirmed safe node</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  <span class="c1">// Node is safe</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Graph with multiple safe nodes</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">5</span><span class="o">},{</span><span class="mi">0</span><span class="o">},{</span><span class="mi">5</span><span class="o">},{},{</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">eventualSafeNodes</span><span class="o">(</span><span class="n">graph1</span><span class="o">));</span> <span class="c1">// Expected output: [2,4,5,6]</span>

        <span class="c1">// Test Case 2: Graph with only one safe node</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">eventualSafeNodes</span><span class="o">(</span><span class="n">graph2</span><span class="o">));</span> <span class="c1">// Expected output: [4]</span>

        <span class="c1">// Test Case 3: Graph where all nodes are safe</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">},{</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">3</span><span class="o">},{</span><span class="mi">4</span><span class="o">},{</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">eventualSafeNodes</span><span class="o">(</span><span class="n">graph3</span><span class="o">));</span> <span class="c1">// Expected output: [0,1,2,3,4]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DFS"/><category term="Medium"/><summary type="html"><![CDATA[There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i]. A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.]]></summary></entry><entry><title type="html">2555. Maximize Win From Two Segments</title><link href="https://zhengstar94.github.io//blog/2025/MaximizeWinFromTwoSegments/" rel="alternate" type="text/html" title="2555. Maximize Win From Two Segments"/><published>2025-01-24T00:00:00+00:00</published><updated>2025-01-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximizeWinFromTwoSegments</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximizeWinFromTwoSegments/"><![CDATA[<ul> <li>There are some prizes on the <strong>X-axis</strong>. You are given an integer array <code class="language-plaintext highlighter-rouge">prizePositions</code> that is <strong>sorted in non-decreasing order</strong>, where <code class="language-plaintext highlighter-rouge">prizePositions[i]</code> is the position of the <code class="language-plaintext highlighter-rouge">ith</code> prize. There could be different prizes at the same position on the line. You are also given an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>You are allowed to select two segments with integer endpoints. The length of each segment must be <code class="language-plaintext highlighter-rouge">k</code>. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect. <ul> <li>For example if <code class="language-plaintext highlighter-rouge">k = 2</code>, you can choose segments <code class="language-plaintext highlighter-rouge">[1, 3]</code> and <code class="language-plaintext highlighter-rouge">[2, 4]</code>, and you will win any prize i that satisfies <code class="language-plaintext highlighter-rouge">1 &lt;= prizePositions[i] &lt;= 3</code> or <code class="language-plaintext highlighter-rouge">2 &lt;= prizePositions[i] &lt;= 4</code>.</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> number of prizes you can win if you choose the two segments optimally</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prizePositions = [1,1,2,2,3,3,5], k = 2
Output: 7
Explanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: prizePositions = [1,2,3,4], k = 0
Output: 2
Explanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximizeWinFromTwoSegments</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximizeWin</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prizePositions</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prizePositions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// dp[i] represents the maximum number of prizes that can be collected</span>
        <span class="c1">// from the first `i` positions (0 to i-1) using one segment.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="c1">// ans stores the final result, which is the maximum number of prizes</span>
        <span class="c1">// that can be collected using two segments.</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// j is the left pointer of the sliding window, representing the start</span>
        <span class="c1">// of the current segment.</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Traverse the array with the right pointer `i`.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Move the left pointer `j` to ensure the length of the current segment</span>
            <span class="c1">// [j, i] does not exceed `k`. If the length exceeds `k`, move `j` to the right.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">prizePositions</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prizePositions</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Update dp[i + 1], which represents the maximum number of prizes</span>
            <span class="c1">// that can be collected from the first `i + 1` positions (0 to i).</span>
            <span class="c1">// There are two choices:</span>
            <span class="c1">// 1. Do not select the current segment, and use the previous result dp[i].</span>
            <span class="c1">// 2. Select the current segment [j, i], which contains `i - j + 1` prizes.</span>
            <span class="c1">// We take the maximum of these two choices.</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">// Update the final result `ans`. The total number of prizes is the sum of:</span>
            <span class="c1">// 1. The number of prizes in the current segment [j, i], which is `i - j + 1`.</span>
            <span class="c1">// 2. The maximum number of prizes that can be collected before position `j`,</span>
            <span class="c1">//    which is dp[j].</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// Return the final result.</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">prizePositions1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximizeWin</span><span class="o">(</span><span class="n">prizePositions1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Output: 7</span>

        <span class="c1">// Example 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">prizePositions2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maximizeWin</span><span class="o">(</span><span class="n">prizePositions2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k. You are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect. For example if k=2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 &lt;= prizePositions[i] &lt;= 3 or 2 &lt;= prizePositions[i] &lt;= 4. Return the maximum number of prizes you can win if you choose the two segments optimally.]]></summary></entry></feed>