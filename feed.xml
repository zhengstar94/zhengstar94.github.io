<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-01T04:48:47+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">81. Search in Rotated Sorted Array II</title><link href="https://zhengstar94.github.io//blog/2025/SearchInRotatedSortedArrayII/" rel="alternate" type="text/html" title="81. Search in Rotated Sorted Array II"/><published>2025-02-01T00:00:00+00:00</published><updated>2025-02-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SearchInRotatedSortedArrayII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SearchInRotatedSortedArrayII/"><![CDATA[<ul> <li>There is an integer array <code class="language-plaintext highlighter-rouge">nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong> values).</li> <li>Before being passed to your function, <code class="language-plaintext highlighter-rouge">nums</code> is <strong>rotated</strong> at an unknown pivot index <code class="language-plaintext highlighter-rouge">k</code> (<code class="language-plaintext highlighter-rouge">0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code class="language-plaintext highlighter-rouge">[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code class="language-plaintext highlighter-rouge">[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code class="language-plaintext highlighter-rouge">5</code> and become <code class="language-plaintext highlighter-rouge">[4,5,6,6,7,0,1,2,4,4]</code>.</li> <li>Given the array <code class="language-plaintext highlighter-rouge">nums</code> <strong>after</strong> the rotation and an integer <code class="language-plaintext highlighter-rouge">target</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if</em> <code class="language-plaintext highlighter-rouge">target</code> <em>is in</em> <code class="language-plaintext highlighter-rouge">nums</code><em>, or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>if it is not in</em> <code class="language-plaintext highlighter-rouge">nums</code><em>.</em></li> <li>You must decrease the overall operation steps as much as possible.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n))time∣O(1)space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2025/02/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SearchInRotatedSortedArrayII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: empty array or null input</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize pointers for binary search</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point avoiding potential integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If target is found at mid, return true</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Handle the case where left element equals middle element</span>
            <span class="c1">// This is the key difference from the original rotated sorted array problem</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Skip one duplicate element and continue</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the left half is sorted</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Check if target lies in the left sorted half</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                    <span class="c1">// Target is in the left half, search there</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Target is in the right half</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Right half must be sorted</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Check if target lies in the right sorted half</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
                    <span class="c1">// Target is in the right half, search there</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Target is in the left half</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Target was not found in the array</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Here we test our solution with five common cases.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// We expect: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// We expect: false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// We expect: true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// We expect: false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="mi">2</span><span class="o">));</span>     <span class="c1">// We expect: true</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Binary Search"/><category term="Medium"/><summary type="html"><![CDATA[There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums. You must decrease the overall operation steps as much as possible.]]></summary></entry><entry><title type="html">209. Minimum Size Subarray Sum</title><link href="https://zhengstar94.github.io//blog/2025/MinimumSizeSubarraySum/" rel="alternate" type="text/html" title="209. Minimum Size Subarray Sum"/><published>2025-01-31T00:00:00+00:00</published><updated>2025-01-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumSizeSubarraySum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumSizeSubarraySum/"><![CDATA[<ul> <li>Given an array of positive integers <code class="language-plaintext highlighter-rouge">nums</code> and a positive integer <code class="language-plaintext highlighter-rouge">target</code>, return <em>the <strong>minimal length</strong> of a</em> <em>subarray</em> <em>whose sum is greater than or equal to</em> <code class="language-plaintext highlighter-rouge">target</code>. If there is no such subarray, return <code class="language-plaintext highlighter-rouge">0</code> instead.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: target = 4, nums = [1,4,4]
Output: 1
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowMin</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumSizeSubarraySum</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// sum of subarray</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// start position of sliding window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">end</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>
            <span class="c1">// try to shrink the window when sum is greater than or equal to target</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
                <span class="n">start</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minSubArrayLen</span><span class="o">(</span><span class="n">target1</span><span class="o">,</span> <span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minSubArrayLen</span><span class="o">(</span><span class="n">target2</span><span class="o">,</span> <span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minSubArrayLen</span><span class="o">(</span><span class="n">target3</span><span class="o">,</span> <span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowMin"/><category term="Medium"/><summary type="html"><![CDATA[Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.]]></summary></entry><entry><title type="html">541. Reverse String II</title><link href="https://zhengstar94.github.io//blog/2025/ReverseStringII/" rel="alternate" type="text/html" title="541. Reverse String II"/><published>2025-01-31T00:00:00+00:00</published><updated>2025-01-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ReverseStringII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ReverseStringII/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, reverse the first <code class="language-plaintext highlighter-rouge">k</code> characters for every <code class="language-plaintext highlighter-rouge">2k</code> characters counting from the start of the string.</li> <li>If there are fewer than <code class="language-plaintext highlighter-rouge">k</code> characters left, reverse all of them. If there are less than <code class="language-plaintext highlighter-rouge">2k</code> but greater than or equal to <code class="language-plaintext highlighter-rouge">k</code> characters, then reverse the first <code class="language-plaintext highlighter-rouge">k</code> characters and leave the other as original.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcdefg", k = 2
Output: "bacdfeg"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", k = 2
Output: "bacd"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReverseStringII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">reverseStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the actual length that needs to be reversed each time</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="c1">// Use Math.min to handle boundary cases when remaining chars less than k</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Two pointers approach to reverse characters</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
                <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Regular case</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcdefg"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">reverseStr</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected output: "bacdfeg"</span>

        <span class="c1">// Test case 2: String length equals 2k</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">reverseStr</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected output: "bacd"</span>

        <span class="c1">// Test case 3: Edge case - single character</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">reverseStr</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected output: "a"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.]]></summary></entry><entry><title type="html">(Review)2904. Shortest and Lexicographically Smallest Beautiful String</title><link href="https://zhengstar94.github.io//blog/2025/ShortestAndLexicographicallySmallestBeautifulString/" rel="alternate" type="text/html" title="(Review)2904. Shortest and Lexicographically Smallest Beautiful String"/><published>2025-01-31T00:00:00+00:00</published><updated>2025-01-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ShortestAndLexicographicallySmallestBeautifulString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ShortestAndLexicographicallySmallestBeautifulString/"><![CDATA[<ul> <li>You are given a binary string <code class="language-plaintext highlighter-rouge">s</code> and a positive integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>A substring of <code class="language-plaintext highlighter-rouge">s</code> is <strong>beautiful</strong> if the number of <code class="language-plaintext highlighter-rouge">1</code>’s in it is exactly <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Let <code class="language-plaintext highlighter-rouge">len</code> be the length of the <strong>shortest</strong> beautiful substring.</li> <li>Return <em>the lexicographically <strong>smallest</strong> beautiful substring of string</em> <code class="language-plaintext highlighter-rouge">s</code> <em>with length equal to</em> <code class="language-plaintext highlighter-rouge">len</code>. If <code class="language-plaintext highlighter-rouge">s</code> doesn’t contain a beautiful substring, return <em>an <strong>empty</strong> string</em>.</li> <li>A string <code class="language-plaintext highlighter-rouge">a</code> is lexicographically <strong>larger</strong> than a string <code class="language-plaintext highlighter-rouge">b</code> (of the same length) if in the first position where <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> differ, <code class="language-plaintext highlighter-rouge">a</code> has a character strictly larger than the corresponding character in <code class="language-plaintext highlighter-rouge">b</code>. <ul> <li>For example, <code class="language-plaintext highlighter-rouge">"abcd"</code> is lexicographically larger than <code class="language-plaintext highlighter-rouge">"abcc"</code> because the first position they differ is at the fourth character, and <code class="language-plaintext highlighter-rouge">d</code> is greater than <code class="language-plaintext highlighter-rouge">c</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "100011001", k = 3
Output: "11001"
Explanation: There are 7 beautiful substrings in this example:
1. The substring "100011001".
2. The substring "100011001".
3. The substring "100011001".
4. The substring "100011001".
5. The substring "100011001".
6. The substring "100011001".
7. The substring "100011001".
The length of the shortest beautiful substring is 5.
The lexicographically smallest beautiful substring with length 5 is the substring "11001".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1011", k = 2
Output: "11"
Explanation: There are 3 beautiful substrings in this example:
1. The substring "1011".
2. The substring "1011".
3. The substring "1011".
The length of the shortest beautiful substring is 2.
The lexicographically smallest beautiful substring with length 2 is the substring "11".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "000", k = 1
Output: ""
Explanation: There are no beautiful substrings in this example.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindowMin</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestAndLexicographicallySmallestBeautifulString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">shortestBeautifulSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">bestLeft</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// Store the starting position of the best substring found</span>
        <span class="kt">int</span> <span class="n">minLength</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Initialize with length greater than possible</span>
        <span class="kt">int</span> <span class="n">ones</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Counter for number of '1's in current window</span>

        <span class="c1">// Iterate through string using sliding window technique</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Count '1's as we expand the window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'1'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ones</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Process window when we have exactly k ones</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">ones</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/* First condition: Check if current window length is smaller than minLength
                 * If true, we've found a shorter valid substring
                 * Update both bestLeft and minLength to track this new shortest substring
                 * Example: if current window "11001" (length 5) is shorter than previous "100011" (length 6)
                 */</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">minLength</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">bestLeft</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                    <span class="n">minLength</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="cm">/* Second condition: If current window length equals minLength
                 * We need to check if current substring is lexicographically smaller
                 * bestLeft == -1: handles the first valid substring case
                 * compareTo &lt; 0: true if current substring is lexicographically smaller
                 * Example: "01111" is lexicographically smaller than "10001" (both length 5)
                 */</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">minLength</span> <span class="o">&amp;&amp;</span>
                        <span class="o">(</span><span class="n">bestLeft</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">left</span> <span class="o">+</span> <span class="n">minLength</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">bestLeft</span><span class="o">,</span> <span class="n">bestLeft</span> <span class="o">+</span> <span class="n">minLength</span><span class="o">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">bestLeft</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Shrink window from left and update ones count</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">++)</span> <span class="o">==</span> <span class="sc">'1'</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ones</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return empty string if no valid substring found, otherwise return the best substring</span>
        <span class="k">return</span> <span class="n">bestLeft</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">bestLeft</span><span class="o">,</span> <span class="n">bestLeft</span> <span class="o">+</span> <span class="n">minLength</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Should find shortest substring with exactly 3 ones</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"100011001"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">shortestBeautifulSubstring</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: "11001"</span>

        <span class="c1">// Test case 2: Should find shortest substring with exactly 2 ones</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"1011"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">shortestBeautifulSubstring</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: "11"</span>

        <span class="c1">// Test case 3: Should return empty string as no substring has exactly 1 one</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"000"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">shortestBeautifulSubstring</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected: ""</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindowMin"/><category term="Medium"/><category term="Review"/><summary type="html"><![CDATA[You are given a binary string s and a positive integer k. A substring of s is beautiful if the number of 1’s in it is exactly k. Let len be the length of the shortest beautiful substring. Return the lexicographically smallest beautiful substring of string s with length equal to len. If s doesn’t contain a beautiful substring, return an empty string. A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. For example, "abcd" is lexicographically larger than "abcc" because the first position they differ is at the fourth character, and d is greater than c.]]></summary></entry><entry><title type="html">350. Intersection of Two Arrays II</title><link href="https://zhengstar94.github.io//blog/2025/IntersectionOfTwoArraysII/" rel="alternate" type="text/html" title="350. Intersection of Two Arrays II"/><published>2025-01-30T00:00:00+00:00</published><updated>2025-01-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/IntersectionOfTwoArraysII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/IntersectionOfTwoArraysII/"><![CDATA[<ul> <li>Given two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(min(n, m)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntersectionOfTwoArraysII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If nums1 is longer than nums2, swap them to ensure nums1 is the shorter array</span>
        <span class="c1">// This optimization helps reduce space complexity by using the shorter array to create HashMap</span>
        <span class="c1">// For example:</span>
        <span class="c1">// nums1 = [1,2], length = 2</span>
        <span class="c1">// nums2 = [1,2,3,4,5,...,1000000], length = 1000000</span>
        <span class="c1">// After swap, HashMap only needs to store 2 elements instead of 1000000</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">return</span> <span class="nf">intersect</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">nums1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Use HashMap to store the frequency of each number in nums1</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// First loop: Iterate through nums1 and count frequency of each number</span>
        <span class="c1">// Time complexity: O(n) where n is length of nums1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Store intersection results in a dynamic ArrayList</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intersection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Second loop: Iterate through nums2 to find intersections</span>
        <span class="c1">// For each number in nums2, check if it exists in HashMap and has remaining count</span>
        <span class="c1">// Time complexity: O(m) where m is length of nums2</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">intersection</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">// Decrease count as we've used this number</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert ArrayList to fixed-size array for return</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">intersection</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="c1">// Third loop: Convert dynamic ArrayList to static array</span>
        <span class="c1">// Time complexity: O(k) where k is size of intersection</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intersection</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic test with repeated elements</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">intersect</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">)));</span>

        <span class="c1">// Test case 2: Test with different array sizes and multiple occurrences</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">intersect</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">nums4</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.]]></summary></entry><entry><title type="html">219. Contains Duplicate II</title><link href="https://zhengstar94.github.io//blog/2025/ContainsDuplicateII/" rel="alternate" type="text/html" title="219. Contains Duplicate II"/><published>2025-01-29T00:00:00+00:00</published><updated>2025-01-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ContainsDuplicateII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ContainsDuplicateII/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if there are two <strong>distinct indices</strong></em> <code class="language-plaintext highlighter-rouge">i</code> <em>and</em> <code class="language-plaintext highlighter-rouge">j</code> <em>in the array such that</em> <code class="language-plaintext highlighter-rouge">nums[i] == nums[j]</code> <em>and</em> <code class="language-plaintext highlighter-rouge">abs(i - j) &lt;= k</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1], k = 3
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,0,1,1], k = 1
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContainsDuplicateII</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Using HashSet as a sliding window to store elements</span>
    <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// Iterate through the array</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="c1">// If window size exceeds k, remove the leftmost element</span>
      <span class="c1">// This maintains the window size of k elements</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>
      <span class="o">}</span>

      <span class="c1">// Try to add current element to set</span>
      <span class="c1">// If addition fails, it means element already exists in window</span>
      <span class="c1">// Therefore, we found duplicates within distance k</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// No duplicates found within distance k</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Test Case 1: Should return true</span>
    <span class="c1">// Contains duplicate 1's with distance 3</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
    <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>

    <span class="c1">// Test Case 2: Should return true</span>
    <span class="c1">// Contains duplicate 1's with distance 1</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
    <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>

    <span class="c1">// Test Case 3: Should return false</span>
    <span class="c1">// No duplicates within distance 2</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
    <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">containsNearbyDuplicate</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.]]></summary></entry><entry><title type="html">2658. Maximum Number of Fish in a Grid</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfFishInAGrid/" rel="alternate" type="text/html" title="2658. Maximum Number of Fish in a Grid"/><published>2025-01-28T00:00:00+00:00</published><updated>2025-01-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfFishInAGrid</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfFishInAGrid/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D matrix <code class="language-plaintext highlighter-rouge">grid</code> of size <code class="language-plaintext highlighter-rouge">m x n</code>, where <code class="language-plaintext highlighter-rouge">(r, c)</code> represents: <ul> <li>A <strong>land</strong> cell if <code class="language-plaintext highlighter-rouge">grid[r][c] = 0</code>, or</li> <li>A <strong>water</strong> cell containing <code class="language-plaintext highlighter-rouge">grid[r][c]</code> fish, if <code class="language-plaintext highlighter-rouge">grid[r][c] &gt; 0</code>.</li> </ul> </li> <li>A fisher can start at any <strong>water</strong> cell <code class="language-plaintext highlighter-rouge">(r, c)</code> and can do the following operations any number of times: <ul> <li>Catch all the fish at cell <code class="language-plaintext highlighter-rouge">(r, c)</code>, or</li> <li>Move to any adjacent <strong>water</strong> cell.</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or</em> <code class="language-plaintext highlighter-rouge">0</code> if no water cell exists.</li> <li>An <strong>adjacent</strong> cell of the cell <code class="language-plaintext highlighter-rouge">(r, c)</code>, is one of the cells <code class="language-plaintext highlighter-rouge">(r, c + 1)</code>, <code class="language-plaintext highlighter-rouge">(r, c - 1)</code>, <code class="language-plaintext highlighter-rouge">(r + 1, c)</code> or <code class="language-plaintext highlighter-rouge">(r - 1, c)</code> if it exists.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0 ] ]
Output: 7
Explanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1 ] ]
Output: 1
Explanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DFS</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfFishInAGrid</span> <span class="o">{</span>

    <span class="c1">// Define four directional movements: up, down, left, right</span>
    <span class="c1">// Used for exploring adjacent cells in the grid</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">DIRECTIONS</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxFish</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check for null or empty grid</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Get grid dimensions</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxFish</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each cell in the grid</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If current cell is a water cell (contains fish)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="c1">// Start DFS from this cell and update maximum fish count</span>
                    <span class="n">maxFish</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxFish</span><span class="o">,</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxFish</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check boundaries and if cell is already visited (0)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span>
                <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">||</span>
                <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Store current cell's fish count</span>
        <span class="kt">int</span> <span class="n">currentFish</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
        <span class="c1">// Mark cell as visited by setting to 0</span>
        <span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Initialize total fish count with current cell's fish</span>
        <span class="kt">int</span> <span class="n">totalFish</span> <span class="o">=</span> <span class="n">currentFish</span><span class="o">;</span>
        <span class="c1">// Explore all four directions</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">dir:</span> <span class="no">DIRECTIONS</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">newRow</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">newCol</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="c1">// Add fish count from adjacent water cells</span>
            <span class="n">totalFish</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">newRow</span><span class="o">,</span> <span class="n">newCol</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">totalFish</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal grid with multiple water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Expected output: 7</span>

        <span class="c1">// Test Case 2: Grid with isolated water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test Case 3: Empty grid</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid3</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 4: Grid with only land cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid4</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">findMaxFish</span><span class="o">(</span><span class="n">grid4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DFS"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents: A land cell if grid[r][c] = 0, or A water cell containing grid[r][c] fish, if grid[r][c] &gt; 0. A fisher can start at any water cell (r, c) and can do the following operations any number of times: Catch all the fish at cell (r, c), or Move to any adjacent water cell. Return the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists. An adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.]]></summary></entry><entry><title type="html">119. Pascal’s Triangle II</title><link href="https://zhengstar94.github.io//blog/2025/PascalsTriangleII/" rel="alternate" type="text/html" title="119. Pascal’s Triangle II"/><published>2025-01-28T00:00:00+00:00</published><updated>2025-01-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PascalsTriangleII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PascalsTriangleII/"><![CDATA[<ul> <li>Given an integer <code class="language-plaintext highlighter-rouge">rowIndex</code>, return the <code class="language-plaintext highlighter-rouge">rowIndexth</code> (<strong>0-indexed</strong>) row of the <strong>Pascal’s triangle</strong>.</li> <li>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rowIndex = 3
Output: [1,3,3,1]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rowIndex = 0
Output: [1]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: rowIndex = 1
Output: [1,1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(rowIndex) time | O(rowIndex) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PascalsTriangleII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">getRow</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a list to store the final result.</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Create an array to store the current row values.</span>
        <span class="c1">// The size of the array is rowIndex + 1 because the row is 0-indexed.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rowIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// The first element of every row in Pascal's Triangle is always 1.</span>
        <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Loop to calculate each element in the row.</span>
        <span class="c1">// Start from the second element (i=1) because the first element is already set to 1.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rowIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Get the previous element in the row.</span>
            <span class="c1">// This is equivalent to C(n, k-1) in the combination formula.</span>
            <span class="kt">long</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">row</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Calculate the current element using the combination formula:</span>
            <span class="c1">// C(n, k) = C(n, k-1) * (n - k + 1) / k</span>
            <span class="c1">// Here:</span>
            <span class="c1">// - n is the rowIndex.</span>
            <span class="c1">// - k is the current position in the row (i).</span>
            <span class="c1">// - (rowIndex - i + 1) is the numerator part of the formula.</span>
            <span class="c1">// - i is the denominator part of the formula.</span>
            <span class="kt">long</span> <span class="n">current</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">*</span> <span class="o">(</span><span class="n">rowIndex</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Store the calculated value in the current position of the row.</span>
            <span class="n">row</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">current</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Convert the array to a list for the final result.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the generated row.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: rowIndex = 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 3: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>  <span class="c1">// Expected output: [1, 3, 3, 1]</span>

        <span class="c1">// Test case 2: rowIndex = 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 0: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>  <span class="c1">// Expected output: [1]</span>

        <span class="c1">// Test case 3: rowIndex = 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 1: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>  <span class="c1">// Expected output: [1, 1]</span>

        <span class="c1">// Additional test case: rowIndex = 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"rowIndex = 4: "</span> <span class="o">+</span> <span class="n">getRow</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>  <span class="c1">// Expected output: [1, 4, 6, 4, 1]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:]]></summary></entry><entry><title type="html">1462. Course Schedule IV</title><link href="https://zhengstar94.github.io//blog/2025/CourseScheduleIV/" rel="alternate" type="text/html" title="1462. Course Schedule IV"/><published>2025-01-27T00:00:00+00:00</published><updated>2025-01-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CourseScheduleIV</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CourseScheduleIV/"><![CDATA[<ul> <li>There are a total of <code class="language-plaintext highlighter-rouge">numCourses</code> courses you have to take, labeled from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">numCourses - 1</code>. You are given an array <code class="language-plaintext highlighter-rouge">prerequisites</code> where <code class="language-plaintext highlighter-rouge">prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code class="language-plaintext highlighter-rouge">ai</code> first if you want to take course <code class="language-plaintext highlighter-rouge">bi</code>. <ul> <li>For example, the pair <code class="language-plaintext highlighter-rouge">[0, 1]</code> indicates that you have to take course <code class="language-plaintext highlighter-rouge">0</code> before you can take course <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> </li> <li>Prerequisites can also be <strong>indirect</strong>. If course <code class="language-plaintext highlighter-rouge">a</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">b</code>, and course <code class="language-plaintext highlighter-rouge">b</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">c</code>, then course <code class="language-plaintext highlighter-rouge">a</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">c</code>.</li> <li>You are also given an array <code class="language-plaintext highlighter-rouge">queries</code> where <code class="language-plaintext highlighter-rouge">queries[j] = [uj, vj]</code>. For the <code class="language-plaintext highlighter-rouge">jth</code> query, you should answer whether course <code class="language-plaintext highlighter-rouge">uj</code> is a prerequisite of course <code class="language-plaintext highlighter-rouge">vj</code> or not.</li> <li>Return <em>a boolean array</em> <code class="language-plaintext highlighter-rouge">answer</code><em>, where</em> <code class="language-plaintext highlighter-rouge">answer[j]</code> <em>is the answer to the</em> <code class="language-plaintext highlighter-rouge">jth</code> <em>query.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 2, prerequisites = [ [ 1,0 ] ], queries = [ [ 0,1],[1,0 ] ]
Output: [false,true]
Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 2, prerequisites = [], queries = [ [ 1,0],[0,1 ] ]
Output: [false,false]
Explanation: There are no prerequisites, and each course is independent.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 3, prerequisites = [ [ 1,2],[1,0],[2,0 ] ], queries = [ [ 1,0],[1,2 ] ]
Output: [true,true]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n³) time | O(n²) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CourseScheduleIV</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="nf">checkIfPrerequisite</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create adjacency matrix to represent course dependencies</span>
        <span class="c1">// connected[i][j] = true means course i is a prerequisite of course j</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">connected</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">][</span><span class="n">numCourses</span><span class="o">];</span>

        <span class="c1">// Initialize direct prerequisites relationships</span>
        <span class="c1">// For each pair [a,b], mark that course 'a' is a direct prerequisite of course 'b'</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prereq</span> <span class="o">:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">connected</span><span class="o">[</span><span class="n">prereq</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">prereq</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Floyd-Warshall Algorithm Implementation</span>
        <span class="c1">// This algorithm finds all possible paths between any two courses (direct and indirect prerequisites)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>           <span class="c1">// k represents the intermediate course being considered</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>       <span class="c1">// i represents the starting course</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>   <span class="c1">// j represents the target course</span>
                    <span class="c1">// For each trio of courses (i,j,k), check if:</span>
                    <span class="c1">// 1. Either there's already a path from i to j (connected[i][j])</span>
                    <span class="c1">// 2. OR there's a path from i to k AND from k to j</span>
                    <span class="c1">// If either condition is true, then course i is a prerequisite of course j</span>
                    <span class="n">connected</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">connected</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span>
                            <span class="o">(</span><span class="n">connected</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">connected</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Process each query to build the result list</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">query</span> <span class="o">:</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each query [u,v], check if course u is a prerequisite of course v</span>
            <span class="c1">// by looking up the value in our processed adjacency matrix</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">connected</span><span class="o">[</span><span class="n">query</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">query</span><span class="o">[</span><span class="mi">1</span><span class="o">]]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="c1">// Course structure: 1 -&gt; 0 (Course 1 is a prerequisite of Course 0)</span>
        <span class="kt">int</span> <span class="n">numCourses1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span>
                <span class="n">checkIfPrerequisite</span><span class="o">(</span><span class="n">numCourses1</span><span class="o">,</span> <span class="n">prerequisites1</span><span class="o">,</span> <span class="n">queries1</span><span class="o">));</span>
        <span class="c1">// Expected Output: [false,true]</span>

        <span class="c1">// Test Case 2</span>
        <span class="c1">// Course structure: 1 -&gt; 2 -&gt; 0 and 1 -&gt; 0 (direct)</span>
        <span class="kt">int</span> <span class="n">numCourses2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">queries2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span>
                <span class="n">checkIfPrerequisite</span><span class="o">(</span><span class="n">numCourses2</span><span class="o">,</span> <span class="n">prerequisites2</span><span class="o">,</span> <span class="n">queries2</span><span class="o">));</span>
        <span class="c1">// Expected Output: [true,true]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><summary type="html"><![CDATA[There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi. For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1. Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c. You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not. Return a boolean array answer, where answer[j] is the answer to the jth query.]]></summary></entry><entry><title type="html">45. Jump Game II</title><link href="https://zhengstar94.github.io//blog/2025/JumpGameII/" rel="alternate" type="text/html" title="45. Jump Game II"/><published>2025-01-27T00:00:00+00:00</published><updated>2025-01-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/JumpGameII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/JumpGameII/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> array of integers <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code>. You are initially positioned at <code class="language-plaintext highlighter-rouge">nums[0]</code>.</li> <li>Each element <code class="language-plaintext highlighter-rouge">nums[i]</code> represents the maximum length of a forward jump from index <code class="language-plaintext highlighter-rouge">i</code>. In other words, if you are at <code class="language-plaintext highlighter-rouge">nums[i]</code>, you can jump to any <code class="language-plaintext highlighter-rouge">nums[i + j]</code> where: <ul> <li><code class="language-plaintext highlighter-rouge">0 &lt;= j &lt;= nums[i]</code> and</li> <li><code class="language-plaintext highlighter-rouge">i + j &lt; n</code></li> </ul> </li> <li>Return <em>the minimum number of jumps to reach</em> <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>. The test cases are generated such that you can reach <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,0,1,4]
Output: 2
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JumpGameII</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">jump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Counter for the minimum number of jumps needed</span>
        <span class="kt">int</span> <span class="n">jumps</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// The farthest position that can be reached in the current jump</span>
        <span class="kt">int</span> <span class="n">curEnd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// The farthest position that can be reached considering all positions up to current position</span>
        <span class="kt">int</span> <span class="n">curFarthest</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array (except the last element as we don't need to jump from there)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update the farthest position that can be reached from current position</span>
            <span class="n">curFarthest</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">curFarthest</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// If we've reached the end of current jump range</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">curEnd</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// We must take a jump</span>
                <span class="n">jumps</span><span class="o">++;</span>
                <span class="c1">// Update the end range for the next jump</span>
                <span class="n">curEnd</span> <span class="o">=</span> <span class="n">curFarthest</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">jumps</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with multiple possible paths</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">jump</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 2: Another case with same minimum jumps but different path</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">jump</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test Case 3: Case where each step can only jump one position</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">jump</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: 0 &lt;= j &lt;= nums[i] and i + j &lt; n Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].]]></summary></entry></feed>