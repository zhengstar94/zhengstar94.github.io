<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-02T06:12:25+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">729. My Calendar I</title><link href="https://zhengstar94.github.io//blog/2025/MyCalendar/" rel="alternate" type="text/html" title="729. My Calendar I"/><published>2025-01-02T00:00:00+00:00</published><updated>2025-01-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MyCalendar</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MyCalendar/"><![CDATA[<ul> <li>You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a <strong>double booking</strong>.</li> <li>A <strong>double booking</strong> happens when two events have some non-empty intersection (i.e., some moment is common to both events.).</li> <li>The event can be represented as a pair of integers <code class="language-plaintext highlighter-rouge">startTime</code> and <code class="language-plaintext highlighter-rouge">endTime</code> that represents a booking on the half-open interval <code class="language-plaintext highlighter-rouge">[startTime, endTime)</code>, the range of real numbers <code class="language-plaintext highlighter-rouge">x</code> such that <code class="language-plaintext highlighter-rouge">startTime &lt;= x &lt; endTime</code>.</li> <li>Implement the <code class="language-plaintext highlighter-rouge">MyCalendar</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">MyCalendar()</code> Initializes the calendar object.</li> <li><code class="language-plaintext highlighter-rouge">boolean book(int startTime, int endTime)</code> Returns <code class="language-plaintext highlighter-rouge">true</code> if the event can be added to the calendar successfully without causing a <strong>double booking</strong>. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code> and do not add the event to the calendar.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["MyCalendar", "book", "book", "book"]
[ [], [10, 20], [15, 25], [20, 30 ] ]
Output
[null, true, false, true]

Explanation
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.TreeMap</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/02
 */</span>
<span class="kd">class</span> <span class="nc">MyCalendar</span> <span class="o">{</span>
    <span class="c1">// Use TreeMap to store bookings, key is start time, value is end time</span>
    <span class="kd">private</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">calendar</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyCalendar</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">calendar</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">startTime</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endTime</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the largest start time less than or equal to startTime</span>
        <span class="nc">Integer</span> <span class="n">prevStart</span> <span class="o">=</span> <span class="n">calendar</span><span class="o">.</span><span class="na">floorKey</span><span class="o">(</span><span class="n">startTime</span><span class="o">);</span>
        <span class="c1">// Get the smallest start time greater than startTime</span>
        <span class="nc">Integer</span> <span class="n">nextStart</span> <span class="o">=</span> <span class="n">calendar</span><span class="o">.</span><span class="na">ceilingKey</span><span class="o">(</span><span class="n">startTime</span><span class="o">);</span>

        <span class="c1">// Check if there's any conflict with the previous booking</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prevStart</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">calendar</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prevStart</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Check if there's any conflict with the next booking</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nextStart</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">endTime</span> <span class="o">&gt;</span> <span class="n">nextStart</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// No conflict found, add the new booking</span>
        <span class="n">calendar</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">startTime</span><span class="o">,</span> <span class="n">endTime</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases in main method</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyCalendar</span> <span class="n">myCalendar</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyCalendar</span><span class="o">();</span>

        <span class="c1">// Test case 1: Basic booking scenarios</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">myCalendar</span><span class="o">.</span><span class="na">book</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span> <span class="o">);</span> <span class="c1">// Should return true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myCalendar</span><span class="o">.</span><span class="na">book</span><span class="o">(</span><span class="mi">15</span><span class="o">,</span> <span class="mi">25</span><span class="o">));</span> <span class="c1">// Should return false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myCalendar</span><span class="o">.</span><span class="na">book</span><span class="o">(</span><span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">));</span> <span class="c1">// Should return true</span>

        <span class="c1">// Test case 2: Edge cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2:"</span><span class="o">);</span>
        <span class="nc">MyCalendar</span> <span class="n">myCalendar2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyCalendar</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">myCalendar2</span><span class="o">.</span><span class="na">book</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">);</span>   <span class="c1">// Should return true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">myCalendar2</span><span class="o">.</span><span class="na">book</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">);</span>   <span class="c1">// Should return true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">myCalendar2</span><span class="o">.</span><span class="na">book</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">);</span>   <span class="c1">// Should return false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><category term="Medium"/><summary type="html"><![CDATA[You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking. A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.). The event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime &lt;= x &lt; endTime. Implement the MyCalendar class: MyCalendar() Initializes the calendar object. boolean book(int startTime, int endTime) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.]]></summary></entry><entry><title type="html">3280. Convert Date to Binary</title><link href="https://zhengstar94.github.io//blog/2025/ConvertDateToBinary/" rel="alternate" type="text/html" title="3280. Convert Date to Binary"/><published>2025-01-01T00:00:00+00:00</published><updated>2025-01-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ConvertDateToBinary</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ConvertDateToBinary/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">date</code> representing a Gregorian calendar date in the <code class="language-plaintext highlighter-rouge">yyyy-mm-dd</code> format.</li> <li><code class="language-plaintext highlighter-rouge">date</code> can be written in its binary representation obtained by converting year, month, and day to their binary representations without any leading zeroes and writing them down in <code class="language-plaintext highlighter-rouge">year-month-day</code> format.</li> <li>Return the <strong>binary</strong> representation of <code class="language-plaintext highlighter-rouge">date</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: date = "2080-02-29"

Output: "100000100000-10-11101"

Explanation:

100000100000, 10, and 11101 are the binary representations of 2080, 02, and 29 respectively.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: date = "1900-01-01"

Output: "11101101100-1-1"

Explanation:

11101101100, 1, and 1 are the binary representations of 1900, 1, and 1 respectively.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConvertDateToBinary</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">convertToBinary</span><span class="o">(</span><span class="nc">String</span> <span class="n">date</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Split the date string</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"-"</span><span class="o">);</span>

        <span class="c1">// Convert year, month, and day to integers</span>
        <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>

        <span class="c1">// Convert to binary and remove leading zeros</span>
        <span class="nc">String</span> <span class="n">binaryYear</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">year</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">binaryMonth</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">month</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">binaryDay</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">day</span><span class="o">);</span>

        <span class="c1">// Concatenate the result in the required format</span>
        <span class="k">return</span> <span class="n">binaryYear</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">binaryMonth</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">binaryDay</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">date1</span> <span class="o">=</span> <span class="s">"2080-02-29"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">date1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">convertToBinary</span><span class="o">(</span><span class="n">date1</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">date2</span> <span class="o">=</span> <span class="s">"1900-01-01"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">date2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">convertToBinary</span><span class="o">(</span><span class="n">date2</span><span class="o">));</span>

        <span class="c1">// Additional test case</span>
        <span class="nc">String</span> <span class="n">date3</span> <span class="o">=</span> <span class="s">"2024-03-20"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">date3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">convertToBinary</span><span class="o">(</span><span class="n">date3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are given a string date representing a Gregorian calendar date in the yyyy-mm-dd format. date can be written in its binary representation obtained by converting year, month, and day to their binary representations without any leading zeroes and writing them down in year-month-day format. Return the binary representation of date.]]></summary></entry><entry><title type="html">1422. Maximum Score After Splitting a String</title><link href="https://zhengstar94.github.io//blog/2025/MaximumScoreAfterSplittingaString/" rel="alternate" type="text/html" title="1422. Maximum Score After Splitting a String"/><published>2025-01-01T00:00:00+00:00</published><updated>2025-01-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumScoreAfterSplittingaString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumScoreAfterSplittingaString/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> of zeros and ones, <em>return the maximum score after splitting the string into two <strong>non-empty</strong> substrings</em> (i.e. <strong>left</strong> substring and <strong>right</strong> substring).</li> <li>The score after splitting a string is the number of <strong>zeros</strong> in the <strong>left</strong> substring plus the number of <strong>ones</strong> in the <strong>right</strong> substring.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "011101"
Output: 5 
Explanation: 
All possible ways of splitting s into two non-empty substrings are:
left = "0" and right = "11101", score = 1 + 4 = 5 
left = "01" and right = "1101", score = 1 + 3 = 4 
left = "011" and right = "101", score = 1 + 2 = 3 
left = "0111" and right = "01", score = 1 + 1 = 2 
left = "01110" and right = "1", score = 2 + 1 = 3
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "00111"
Output: 5
Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "1111"
Output: 3
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumScoreAfterSplittingaString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxScore</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="c1">// Count initial number of ones (initial right substring score)</span>
        <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">){</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Find maximum score by trying each split position</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">// Adjust score based on current character</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">score</span><span class="o">);</span>      <span class="c1">// Update maximum score if current is higher</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Mixed zeros and ones</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"011101"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Zeros followed by ones</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"00111"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2: "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 5"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>

        <span class="c1">// Test case 3: All ones</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"1111"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3: "</span> <span class="o">+</span> <span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Easy"/><summary type="html"><![CDATA[Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring). The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.]]></summary></entry><entry><title type="html">2653. Sliding Subarray Beauty</title><link href="https://zhengstar94.github.io//blog/2025/SlidingSubarrayBeauty/" rel="alternate" type="text/html" title="2653. Sliding Subarray Beauty"/><published>2025-01-01T00:00:00+00:00</published><updated>2025-01-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SlidingSubarrayBeauty</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SlidingSubarrayBeauty/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> containing <code class="language-plaintext highlighter-rouge">n</code> integers, find the <strong>beauty</strong> of each subarray of size <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>The <strong>beauty</strong> of a subarray is the <code class="language-plaintext highlighter-rouge">xth</code> <strong>smallest integer</strong> in the subarray if it is <strong>negative</strong>, or <code class="language-plaintext highlighter-rouge">0</code> if there are fewer than <code class="language-plaintext highlighter-rouge">x</code> negative integers.</li> <li>Return <em>an integer array containing</em> <code class="language-plaintext highlighter-rouge">n - k + 1</code> <em>integers, which denote the</em> <strong>beauty</strong> <em>of the subarrays <strong>in order</strong> from the first index in the array.</em> <ul> <li>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,-1,-3,-2,3], k = 3, x = 2
Output: [-1,-2,-2]
Explanation: There are 3 subarrays with size k = 3. 
The first subarray is [1, -1, -3] and the 2nd smallest negative integer is -1. 
The second subarray is [-1, -3, -2] and the 2nd smallest negative integer is -2. 
The third subarray is [-3, -2, 3] and the 2nd smallest negative integer is -2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,-2,-3,-4,-5], k = 2, x = 2
Output: [-1,-2,-3,-4]
Explanation: There are 4 subarrays with size k = 2.
For [-1, -2], the 2nd smallest negative integer is -1.
For [-2, -3], the 2nd smallest negative integer is -2.
For [-3, -4], the 2nd smallest negative integer is -3.
For [-4, -5], the 2nd smallest negative integer is -4. 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-3,1,2,-3,0,-3], k = 2, x = 1
Output: [-3,0,-3,-3,-3]
Explanation: There are 5 subarrays with size k = 2.
For [-3, 1], the 1st smallest negative integer is -3.
For [1, 2], there is no negative integer so the beauty is 0.
For [2, -3], the 1st smallest negative integer is -3.
For [-3, 0], the 1st smallest negative integer is -3.
For [0, -3], the 1st smallest negative integer is -3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SlidingSubarrayBeauty</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getSubarrayBeauty</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Use a counting array to track the frequency of negative numbers</span>
        <span class="c1">// Since array elements are limited to [-50, 50], we only need to count negatives</span>
        <span class="c1">// Index i in count array represents number -i</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">51</span><span class="o">];</span> <span class="c1">// indices 0-50 represent numbers -50 to 0</span>

        <span class="c1">// Initialize the first window by counting negative numbers</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">[-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]++;</span> <span class="c1">// Convert negative number to positive index</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Process the first window result</span>
        <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">findXthNegative</span><span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>

        <span class="c1">// Slide the window and process subsequent windows</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Remove the leftmost number from the window</span>
            <span class="c1">// If it's negative, decrease its count</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">[-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">]]--;</span>
            <span class="o">}</span>

            <span class="c1">// Add the rightmost number to the window</span>
            <span class="c1">// If it's negative, increase its count</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">[-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]++;</span>
            <span class="o">}</span>

            <span class="c1">// Find the xth smallest negative number in current window</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">findXthNegative</span><span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 在计数数组中找到第x小的负数
     * @param count 计数数组
     * @param x 要找的第x小的位置
     * @return 第x小的负数，如果负数个数少于x则返回0
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findXthNegative</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">count</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Iterate from -50 to -1 (represented as indices 50 to 1)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="c1">// Add up counts until we reach or exceed x</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// When sum &gt;= x, we've found the xth smallest negative number</span>
                <span class="c1">// Return the negative of current index</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return 0 if there are fewer than x negative numbers</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Mixed positive and negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">getSubarrayBeauty</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">,</span> <span class="n">x1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Test case 1 result: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test case 2: All negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">2</span><span class="o">,-</span><span class="mi">3</span><span class="o">,-</span><span class="mi">4</span><span class="o">,-</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">getSubarrayBeauty</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">,</span> <span class="n">x2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Test case 2 result: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test case 3: All positive numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">getSubarrayBeauty</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">,</span> <span class="n">x3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Test case 3 result: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">result3</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Helper method: Print array in formatted way</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given an integer array nums containing n integers, find the beauty of each subarray of size k. The beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers. Return an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array. A subarray is a contiguous non-empty sequence of elements within an array.]]></summary></entry><entry><title type="html">2134. Minimum Swaps to Group All 1’s Together II</title><link href="https://zhengstar94.github.io//blog/2024/MinimumSwapsToGroupAll1sTogetherII/" rel="alternate" type="text/html" title="2134. Minimum Swaps to Group All 1’s Together II"/><published>2024-12-31T00:00:00+00:00</published><updated>2024-12-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MinimumSwapsToGroupAll1sTogetherII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MinimumSwapsToGroupAll1sTogetherII/"><![CDATA[<ul> <li>A <strong>swap</strong> is defined as taking two <strong>distinct</strong> positions in an array and swapping the values in them.</li> <li>A <strong>circular</strong> array is defined as an array where we consider the <strong>first</strong> element and the <strong>last</strong> element to be <strong>adjacent</strong>.</li> <li>Given a <strong>binary</strong> <strong>circular</strong> array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the minimum number of swaps required to group all</em> <code class="language-plaintext highlighter-rouge">1</code><em>’s present in the array together at <strong>any location</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0,1,1,0,0]
Output: 1
Explanation: Here are a few of the ways to group all the 1's together:
[0,0,1,1,1,0,0] using 1 swap.
[0,1,1,1,0,0,0] using 1 swap.
[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).
There is no way to group all 1's together with 0 swaps.
Thus, the minimum number of swaps required is 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,1,1,0,0,1,1,0]
Output: 2
Explanation: Here are a few of the ways to group all the 1's together:
[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).
[1,1,1,1,1,0,0,0,0] using 2 swaps.
There is no way to group all 1's together with 0 or 1 swaps.
Thus, the minimum number of swaps required is 2.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,0,0,1]
Output: 0
Explanation: All the 1's are already grouped together due to the circular property of the array.
Thus, the minimum number of swaps required is 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumSwapsToGroupAll1sTogetherII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minSwaps</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if array is null or length less than 2, no swaps needed</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 1: Count the number of 1's in the array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">onesCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">onesCount</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If there are 0 or 1 ones, no swaps needed</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">onesCount</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Create double-length array to handle circular nature</span>
        <span class="c1">// Example: [1,0,1] -&gt; [1,0,1,1,0,1]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">doubleNums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// Copy first half to second half</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Initialize the first window</span>
        <span class="c1">// Count zeros in the first window of size onesCount</span>
        <span class="kt">int</span> <span class="n">windowZeros</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Tracks number of zeros in current window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">onesCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">windowZeros</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Initialize minZeros with first window's zero count</span>
        <span class="kt">int</span> <span class="n">minZeros</span> <span class="o">=</span> <span class="n">windowZeros</span><span class="o">;</span>

        <span class="c1">// Step 4: Slide the window and find minimum zeros</span>
        <span class="c1">// Example: For array [1,0,1,0,1] with onesCount = 3</span>
        <span class="c1">// Windows: [1,0,1], [0,1,0], [1,0,1], [0,1,1], etc.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">onesCount</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">onesCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Remove leftmost element from window</span>
            <span class="c1">// If it's 0, decrease window's zero count</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">onesCount</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">windowZeros</span><span class="o">--;</span>
            <span class="o">}</span>

            <span class="c1">// Add rightmost element to window</span>
            <span class="c1">// If it's 0, increase window's zero count</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">doubleNums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">windowZeros</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="cm">/* Update minimum zeros if current window has fewer zeros
             * Why this represents minimum swaps:
             * 1. Each window of size onesCount represents a potential position for grouped 1's
             * 2. Number of zeros in window = number of swaps needed for that position
             * Example: Window [1,0,1] has 1 zero
             * - Need 1 swap to make it [1,1,1]
             * Window [0,1,0] has 2 zeros
             * - Need 2 swaps to make it [1,1,1]
             * Therefore, minimum zeros across all windows = minimum swaps needed
             */</span>
            <span class="n">minZeros</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minZeros</span><span class="o">,</span> <span class="n">windowZeros</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum number of zeros found in any window</span>
        <span class="c1">// This equals the minimum number of swaps needed</span>
        <span class="k">return</span> <span class="n">minZeros</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: [1,0,1,0,1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: All ones</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: [1,1,1]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: All zeros</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: [0,0,0]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Multiple swaps needed</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: [1,0,1,0,1,0]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Edge case - empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test5</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: []"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">minSwaps</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[A swap is defined as taking two distinct positions in an array and swapping the values in them. A circular array is defined as an array where we consider the first element and the last element to be adjacent. Given a binary circular array nums, return the minimum number of swaps required to group all 1’s present in the array together at any location.]]></summary></entry><entry><title type="html">1367. Linked List in Binary Tree</title><link href="https://zhengstar94.github.io//blog/2024/LinkedListInBinaryTree/" rel="alternate" type="text/html" title="1367. Linked List in Binary Tree"/><published>2024-12-30T00:00:00+00:00</published><updated>2024-12-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LinkedListInBinaryTree</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LinkedListInBinaryTree/"><![CDATA[<ul> <li>Given a binary tree <code class="language-plaintext highlighter-rouge">root</code> and a linked list with <code class="language-plaintext highlighter-rouge">head</code> as the first node.</li> <li>Return True if all the elements in the linked list starting from the <code class="language-plaintext highlighter-rouge">head</code> correspond to some <em>downward path</em> connected in the binary tree otherwise return False.</li> <li>In this context downward path means a path that starts at some node and goes downwards.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: false
Explanation: There is no path in the binary tree that contains all the elements of the linked list from head.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(N × min(L, H)) time | O(H) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="cm">/**
* @author zhengxingxing
* @date 2024/12/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedListInBinaryTree</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSubPath</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Empty list is always a valid path</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Empty tree can't contain any path</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// First, try to match the entire linked list starting from current tree node</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">root</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * If current node doesn't lead to a match, try finding a match in left or right subtrees.
         * This is different from the DFS below because:
         * 1. It looks for a completely new starting point for the entire linked list
         * 2. It resets back to the head of the linked list for each new tree node
         * 3. It explores every possible starting point in the tree
         * Example: If we're looking for [4,2,8] and current node is 1, we check if either
         * the left or right subtree contains the entire sequence [4,2,8] starting from any node
         */</span>
        <span class="k">return</span> <span class="nf">isSubPath</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">||</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Matched entire linked list</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Reached end of tree path without full match</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Current nodes must match to continue</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Continue matching the rest of the linked list with either left or right child.
         * This is different from the isSubPath recursion above because:
         * 1. It continues an existing match (uses head.next instead of head)
         * 2. Only looks for the next value in the current path
         * 3. Doesn't try to restart the sequence from the beginning
         * Example: If we matched first node 4, we only look for the next value 2
         * in the immediate children of current node
         */</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">||</span> <span class="n">dfs</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test Case 1: Example from the problem statement</span>
        <span class="nc">TreeNode</span> <span class="n">root1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">head1</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Expected: true"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head1</span><span class="o">,</span> <span class="n">root1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Simple tree with matching path</span>
        <span class="nc">TreeNode</span> <span class="n">root2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root2</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root2</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">root2</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">head2</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Expected: true"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head2</span><span class="o">,</span> <span class="n">root2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: No matching path</span>
        <span class="nc">TreeNode</span> <span class="n">root3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root3</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">root3</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">head3</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Expected: false"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">isSubPath</span><span class="o">(</span><span class="n">head3</span><span class="o">,</span> <span class="n">root3</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ListNode</span> <span class="nf">createLinkedList</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">values</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">ListNode</span><span class="o">()</span> <span class="o">{}</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="o">}</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><category term="Medium"/><summary type="html"><![CDATA[Given a binary tree root and a linked list with head as the first node. Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False. In this context downward path means a path that starts at some node and goes downwards.]]></summary></entry><entry><title type="html">1297. Maximum Number of Occurrences of a Substring</title><link href="https://zhengstar94.github.io//blog/2024/MaximumNumberOfOccurrencesOfASubstring/" rel="alternate" type="text/html" title="1297. Maximum Number of Occurrences of a Substring"/><published>2024-12-30T00:00:00+00:00</published><updated>2024-12-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumNumberOfOccurrencesOfASubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumNumberOfOccurrencesOfASubstring/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return the maximum number of occurrences of <strong>any</strong> substring under the following rules: <ul> <li>The number of unique characters in the substring must be less than or equal to <code class="language-plaintext highlighter-rouge">maxLetters</code>.</li> <li>The substring size must be between <code class="language-plaintext highlighter-rouge">minSize</code> and <code class="language-plaintext highlighter-rouge">maxSize</code> inclusive.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
Output: 2
Explanation: Substring "aab" has 2 occurrences in the original string.
It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
Output: 2
Explanation: Substring "aaa" occur 2 times in the string. It can overlap.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * minSize) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfOccurrencesOfASubstring</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxFreq</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxLetters</span><span class="o">,</span> <span class="kt">int</span> <span class="n">minSize</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the string is null or its length is less than the minimum size, return 0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">minSize</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// A map to store the frequency of each valid substring</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// An array to track the count of characters in the current sliding window</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">charCount</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>

        <span class="c1">// The number of unique characters in the current window</span>
        <span class="kt">int</span> <span class="n">uniqueChars</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Step 1: Initialize the first window by processing the first (minSize-1) characters</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">minSize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Get the character at the current index</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="c1">// Increment the count for this character and check if it is a new unique character</span>
            <span class="k">if</span><span class="o">(</span><span class="n">charCount</span><span class="o">[</span><span class="n">c</span><span class="o">]++</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">uniqueChars</span><span class="o">++;</span>  <span class="c1">// If it's the first occurrence of this character, increment uniqueChars</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Start sliding the window across the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">minSize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="c1">// Add the current character to the sliding window</span>
            <span class="kt">char</span> <span class="n">addChar</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">charCount</span><span class="o">[</span><span class="n">addChar</span><span class="o">]++</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">uniqueChars</span><span class="o">++;</span>  <span class="c1">// If this character is new to the window, increment uniqueChars</span>
            <span class="o">}</span>

            <span class="c1">// If the number of unique characters in the window is within the allowed limit</span>
            <span class="k">if</span><span class="o">(</span><span class="n">uniqueChars</span> <span class="o">&lt;=</span> <span class="n">maxLetters</span><span class="o">){</span>
                <span class="c1">// Extract the current substring (from index i-minSize+1 to i+1) and add it to the map</span>
                <span class="nc">String</span> <span class="n">subStr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">minSize</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update the frequency of this substring in the map</span>
                <span class="n">count</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">subStr</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Step 3: Remove the character that is sliding out of the window from the left</span>
            <span class="kt">char</span> <span class="n">removeChar</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">minSize</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">// Decrement the count of the character and check if it’s now no longer in the window</span>
            <span class="k">if</span> <span class="o">(--</span><span class="n">charCount</span><span class="o">[</span><span class="n">removeChar</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">uniqueChars</span><span class="o">--;</span>  <span class="c1">// If the character's count reaches 0, decrement uniqueChars</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 4: Return the highest frequency of any valid substring, or 0 if no valid substrings were found</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example input string and parameters</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"aababcaab"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLetters</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// Maximum allowed distinct characters in each substring</span>
        <span class="kt">int</span> <span class="n">minSize</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>    <span class="c1">// Minimum length of substrings to consider</span>
        <span class="kt">int</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>    <span class="c1">// Maximum length of substrings (not used in this solution)</span>

        <span class="c1">// Print the input parameters</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input String: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"maxLetters: "</span> <span class="o">+</span> <span class="n">maxLetters</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"minSize: "</span> <span class="o">+</span> <span class="n">minSize</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"maxSize: "</span> <span class="o">+</span> <span class="n">maxSize</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nProcessing...\n"</span><span class="o">);</span>

        <span class="c1">// Call the method and print the result</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maxFreq</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">maxLetters</span><span class="o">,</span> <span class="n">minSize</span><span class="o">,</span> <span class="n">maxSize</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nFinal Result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, return the maximum number of occurrences of any substring under the following rules: The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive.]]></summary></entry><entry><title type="html">1652. Defuse the Bomb</title><link href="https://zhengstar94.github.io//blog/2024/DefuseTheBomb/" rel="alternate" type="text/html" title="1652. Defuse the Bomb"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DefuseTheBomb</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DefuseTheBomb/"><![CDATA[<ul> <li>You have a bomb to defuse, and your time is running out! Your informer will provide you with a <strong>circular</strong> array <code class="language-plaintext highlighter-rouge">code</code> of length of <code class="language-plaintext highlighter-rouge">n</code> and a key <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>To decrypt the code, you must replace every number. All the numbers are replaced <strong>simultaneously</strong>. <ul> <li>If <code class="language-plaintext highlighter-rouge">k &gt; 0</code>, replace the <code class="language-plaintext highlighter-rouge">ith</code> number with the sum of the <strong>next</strong> <code class="language-plaintext highlighter-rouge">k</code> numbers.</li> <li>If <code class="language-plaintext highlighter-rouge">k &lt; 0</code>, replace the <code class="language-plaintext highlighter-rouge">ith</code> number with the sum of the <strong>previous</strong> <code class="language-plaintext highlighter-rouge">k</code> numbers.</li> <li>If <code class="language-plaintext highlighter-rouge">k == 0</code>, replace the <code class="language-plaintext highlighter-rouge">ith</code> number with <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> </li> <li>As <code class="language-plaintext highlighter-rouge">code</code> is circular, the next element of <code class="language-plaintext highlighter-rouge">code[n-1]</code> is <code class="language-plaintext highlighter-rouge">code[0]</code>, and the previous element of <code class="language-plaintext highlighter-rouge">code[0]</code> is <code class="language-plaintext highlighter-rouge">code[n-1]</code>.</li> <li>Given the <strong>circular</strong> array <code class="language-plaintext highlighter-rouge">code</code> and an integer key <code class="language-plaintext highlighter-rouge">k</code>, return <em>the decrypted code to defuse the bomb</em>!</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: code = [5,7,1,4], k = 3
Output: [12,10,16,13]
Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: code = [1,2,3,4], k = 0
Output: [0,0,0,0]
Explanation: When k is zero, the numbers are replaced by 0. 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: code = [2,4,9,3], k = -2
Output: [12,5,6,13]
Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefuseTheBomb</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">code</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>  <span class="c1">// Store the result array</span>

        <span class="c1">// Initialize the right boundary 'r'</span>
        <span class="c1">// If k &gt; 0: r = k + 1 (points to the position after the first window)</span>
        <span class="c1">// If k &lt; 0: r = n (points to the end of array)</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// Take absolute value of k to handle both positive and negative cases uniformly</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>

        <span class="c1">// Initialize sum for first position</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// First loop: Calculate sum for the initial window</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For k &gt; 0: directly sum the next k numbers</span>
            <span class="c1">// For k &lt; 0: using modulo to wrap around and sum the previous k numbers</span>
            <span class="c1">// Example for k = 3: sums code[1] + code[2] + code[3]</span>
            <span class="c1">// Example for k = -3: sums code[3] + code[4] + code[5] (using i % n)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">code</span><span class="o">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Second loop: Slide the window to calculate sums for all positions</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Store current window sum in result array</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>

            <span class="c1">// Slide window by:</span>
            <span class="c1">// 1. Adding new element (code[r % n])</span>
            <span class="c1">// 2. Removing leftmost element (code[(r - k) % n])</span>
            <span class="c1">// Example: if current sum is [1,4,1], next sum will be [4,1,5]</span>
            <span class="c1">// by adding code[4]=5 and removing code[1]=1</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">code</span><span class="o">[</span><span class="n">r</span> <span class="o">%</span> <span class="n">n</span><span class="o">]</span> <span class="o">-</span> <span class="n">code</span><span class="o">[(</span><span class="n">r</span> <span class="o">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">%</span> <span class="n">n</span><span class="o">];</span>
            <span class="n">r</span><span class="o">++;</span>  <span class="c1">// Move window right by one position</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution with example cases
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: k &gt; 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">code1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">code1</span><span class="o">,</span> <span class="n">k1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 (k &gt; 0):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: code = [5,7,1,4], k = 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Output: ["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">result1</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">","</span> <span class="o">:</span> <span class="s">""</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>  <span class="c1">// Expected: [12,10,16,13]</span>

        <span class="c1">// Test Case 2: k = 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">code2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">code2</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2 (k = 0):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: code = [1,2,3,4], k = 0"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Output: ["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">result2</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">","</span> <span class="o">:</span> <span class="s">""</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>  <span class="c1">// Expected: [0,0,0,0]</span>

        <span class="c1">// Test Case 3: k &lt; 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">code3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">code3</span><span class="o">,</span> <span class="n">k3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3 (k &lt; 0):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: code = [2,4,9,3], k = -2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Output: ["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result3</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result3</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">result3</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">","</span> <span class="o">:</span> <span class="s">""</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>  <span class="c1">// Expected: [12,5,6,13]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k. To decrypt the code, you must replace every number. All the numbers are replaced simultaneously. If k &gt; 0, replace the ith number with the sum of the next k numbers. If k &lt; 0, replace the ith number with the sum of the previous k numbers. If k== 0, replace the ith number with 0. As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1]. Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!]]></summary></entry><entry><title type="html">1366. Rank Teams by Votes</title><link href="https://zhengstar94.github.io//blog/2024/RankTeamsByVotes/" rel="alternate" type="text/html" title="1366. Rank Teams by Votes"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RankTeamsByVotes</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RankTeamsByVotes/"><![CDATA[<ul> <li>In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition.</li> <li>The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.</li> <li>You are given an array of strings <code class="language-plaintext highlighter-rouge">votes</code> which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.</li> <li>Return <em>a string of all teams <strong>sorted</strong> by the ranking system</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: votes = ["ABC","ACB","ABC","ACB","ACB"]
Output: "ACB"
Explanation: 
Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team.
Team B was ranked second by 2 voters and ranked third by 3 voters.
Team C was ranked second by 3 voters and ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team, and team B is the third.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: votes = ["WXYZ","XYZW"]
Output: "XWYZ"
Explanation:
X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: votes = ["ZMNAGUEDSJYLBOPHRQICWFXTVK"]
Output: "ZMNAGUEDSJYLBOPHRQICWFXTVK"
Explanation: Only one voter, so their votes are used for the ranking.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(N * K + M * log M) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RankTeamsByVotes</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">rankTeams</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">votes</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: empty input or null</span>
        <span class="k">if</span><span class="o">(</span><span class="n">votes</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">votes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If there's only one vote, return it directly</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">votes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">votes</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Create a 2D array to store vote counts</span>
        <span class="c1">// First dimension [26]: represents teams (A-Z)</span>
        <span class="c1">// Second dimension [26]: represents positions (0 to 25)</span>
        <span class="c1">// count[team][position] stores how many votes a team got for that position</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">][</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Array to track which teams participated in voting</span>
        <span class="c1">// teams[i] will be true if team (A+i) received any votes</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">teams</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">teamCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/* First Important Section: Vote Counting Loop
         * Outer loop: Iterates through each vote (ballot)
         * Inner loop: Processes each position in the current vote
         *
         * For example, if vote is "ABC":
         * - First iteration (i=0): Increment count for A in position 0
         * - Second iteration (i=1): Increment count for B in position 1
         * - Third iteration (i=2): Increment count for C in position 2
         *
         * Also marks teams as participating when they first appear
         */</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">vote</span> <span class="o">:</span> <span class="n">votes</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vote</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">team</span> <span class="o">=</span> <span class="n">vote</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>  <span class="c1">// Convert character to 0-25 index</span>
                <span class="n">count</span><span class="o">[</span><span class="n">team</span><span class="o">][</span><span class="n">i</span><span class="o">]++;</span>                 <span class="c1">// Increment vote count for team at position i</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">teams</span><span class="o">[</span><span class="n">team</span><span class="o">])</span> <span class="o">{</span>               <span class="c1">// If this is first time seeing this team</span>
                    <span class="n">teams</span><span class="o">[</span><span class="n">team</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>           <span class="c1">// Mark team as participating</span>
                    <span class="n">teamCount</span><span class="o">++;</span>                  <span class="c1">// Increment total number of teams</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Create array to store participating teams as characters</span>
        <span class="nc">Character</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Character</span><span class="o">[</span><span class="n">teamCount</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">teams</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="sc">'A'</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/* Second Important Section: Custom Sorting Logic
         * This comparator implements the ranking rules:
         * 1. Primary Rule: Teams are ranked by votes at each position, starting from position 0
         * 2. Secondary Rule: If teams tie in all positions, sort alphabetically
         *
         * For example, comparing teams A and B:
         * - First checks votes in position 0
         * - If tied, checks position 1
         * - If tied, checks position 2
         * - If tied in all positions, compares team names (A vs B)
         *
         * The subtraction (count[teamB][i] - count[teamA][i]) ensures:
         * - Positive result: teamB ranks higher (has more votes)
         * - Negative result: teamA ranks higher
         * - Zero: tied at this position, continue checking
         */</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">teamA</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">teamB</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>

            <span class="c1">// Compare votes at each position</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">teamA</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">count</span><span class="o">[</span><span class="n">teamB</span><span class="o">][</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">count</span><span class="o">[</span><span class="n">teamB</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">count</span><span class="o">[</span><span class="n">teamA</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// Higher votes first</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// If all positions are tied, sort alphabetically</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="c1">// Convert result array to string</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Multiple votes with clear preference</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">votes1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"ABC"</span><span class="o">,</span><span class="s">"ACB"</span><span class="o">,</span><span class="s">"ABC"</span><span class="o">,</span><span class="s">"ACB"</span><span class="o">,</span><span class="s">"ACB"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">votes1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">rankTeams</span><span class="o">(</span><span class="n">votes1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: ACB"</span><span class="o">);</span>

        <span class="c1">// Test case 2: Minimal votes with different preferences</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">votes2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"WXYZ"</span><span class="o">,</span><span class="s">"XYZW"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">votes2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">rankTeams</span><span class="o">(</span><span class="n">votes2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: XWYZ"</span><span class="o">);</span>

        <span class="c1">// Test case 3: Single vote with all letters</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">votes3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"ZMNAGUEDSJYLBOPHRQICWFXTVK"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">votes3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">rankTeams</span><span class="o">(</span><span class="n">votes3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: ZMNAGUEDSJYLBOPHRQICWFXTVK"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition. The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter. You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above. Return a string of all teams sorted by the ranking system.]]></summary></entry><entry><title type="html">1423. Maximum Points You Can Obtain from Cards</title><link href="https://zhengstar94.github.io//blog/2024/MaximumPointsYouCanObtainFromCards/" rel="alternate" type="text/html" title="1423. Maximum Points You Can Obtain from Cards"/><published>2024-12-28T00:00:00+00:00</published><updated>2024-12-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumPointsYouCanObtainFromCards</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumPointsYouCanObtainFromCards/"><![CDATA[<ul> <li>There are several cards <strong>arranged in a row</strong>, and each card has an associated number of points. The points are given in the integer array <code class="language-plaintext highlighter-rouge">cardPoints</code>.</li> <li>In one step, you can take one card from the beginning or from the end of the row. You have to take exactly <code class="language-plaintext highlighter-rouge">k</code> cards.</li> <li>Your score is the sum of the points of the cards you have taken.</li> <li>Given the integer array <code class="language-plaintext highlighter-rouge">cardPoints</code> and the integer <code class="language-plaintext highlighter-rouge">k</code>, return the <em>maximum score</em> you can obtain.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumPointsYouCanObtainFromCards</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cardPoints</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Total number of cards.</span>

        <span class="c1">// Calculate the total points of all cards.</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">point</span> <span class="o">:</span> <span class="n">cardPoints</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">point</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If `k` equals the total number of cards, return the total sum of the array.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">total</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Determine the size of the window to exclude from the selection.</span>
        <span class="c1">// This window contains the cards that are *not* part of the chosen `k` cards.</span>
        <span class="kt">int</span> <span class="n">windowSize</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span>

        <span class="c1">// Calculate the initial sum of the first `windowSize` cards.</span>
        <span class="kt">int</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">windowSize</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Initialize the minimum window sum to the sum of the first `windowSize` cards.</span>
        <span class="kt">int</span> <span class="n">minWindowSum</span> <span class="o">=</span> <span class="n">windowSum</span><span class="o">;</span>

        <span class="c1">// Slide the window across the array, updating the window sum and tracking the minimum.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">windowSize</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add the next card in the window and remove the first card of the previous window.</span>
            <span class="n">windowSum</span> <span class="o">=</span> <span class="n">windowSum</span> <span class="o">+</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">windowSize</span><span class="o">];</span>

            <span class="c1">// Update the minimum window sum if the current window sum is smaller.</span>
            <span class="n">minWindowSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minWindowSum</span><span class="o">,</span> <span class="n">windowSum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// The maximum score is the total sum minus the smallest sum of the excluded window.</span>
        <span class="k">return</span> <span class="n">total</span> <span class="o">-</span> <span class="n">minWindowSum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">cardPoints1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: 12</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">cardPoints2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: 4</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxScore</span><span class="o">(</span><span class="n">cardPoints3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected: 55</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain.]]></summary></entry></feed>