<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-31T13:19:16+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">5.Longest Palindromic Substring</title><link href="https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring/" rel="alternate" type="text/html" title="5.Longest Palindromic Substring"/><published>2024-10-31T00:00:00+00:00</published><updated>2024-10-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the longest</em> <em>palindromic</em> <em>substring</em> in <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cbbd"
Output: "bb"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n<span class="p">^</span>2) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of the input string</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Create a 2D boolean array for dynamic programming</span>
        <span class="c1">// dp[i][j] will be true if the substring from index i to j is a palindrome</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Variables to keep track of the longest palindrome found</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Starting index of the longest palindrome</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Length of the longest palindrome</span>

        <span class="c1">// Initialize base case: all substrings of length 1 are palindromes</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Fill the dp array</span>
        <span class="c1">// Outer loop: iterate over all possible lengths of substrings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">len</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Inner loop: check all substrings of the current length</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Calculate the ending index of the current substring</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Check if the current substring is a palindrome</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="c1">// Mark the current substring as a palindrome</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

                    <span class="c1">// Update the longest palindrome if necessary</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">maxLen</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the longest palindromic substring</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">maxLen</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="c1">// Main method for testing</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"babad"</span><span class="o">,</span>
                <span class="s">"cbbd"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"ac"</span><span class="o">,</span>
                <span class="s">"racecar"</span><span class="o">,</span>
                <span class="s">"aacabdkacaa"</span><span class="o">,</span>
                <span class="s">""</span>
        <span class="o">};</span>

        <span class="c1">// Expected results</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">expectedResults</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"bab"</span><span class="o">,</span>  <span class="c1">// or "aba"</span>
                <span class="s">"bb"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"racecar"</span><span class="o">,</span>
                <span class="s">"aca"</span><span class="o">,</span>
                <span class="s">""</span>
        <span class="o">};</span>

        <span class="c1">// Run tests</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">":"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: \""</span> <span class="o">+</span> <span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: \""</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: \""</span> <span class="o">+</span> <span class="n">expectedResults</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">expectedResults</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div> <h2 id="method-2">Method 2</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the input string is null or has a length less than 1, return an empty string</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize starting index of the longest palindrome and its maximum length</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Loop through each character in the string to consider it as a center of potential palindrome</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check for longest palindrome with odd length (center at i)</span>
            <span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="c1">// Check for longest palindrome with even length (center between i and i+1)</span>
            <span class="kt">int</span> <span class="n">len2</span> <span class="o">=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Take the maximum length found from odd and even cases</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">len1</span><span class="o">,</span> <span class="n">len2</span><span class="o">);</span>

            <span class="c1">// If we found a longer palindrome, update maxLen and starting index</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
                <span class="c1">// Calculate the starting index of the current longest palindrome</span>
                <span class="c1">// "len - 1" represents the number of characters on either side of the center.</span>
                <span class="c1">// Dividing it by 2 gives the left-side distance from i to start of the palindrome.</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the substring starting from 'start' and with length 'maxLen'</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">maxLen</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">expandAroundCenter</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Expand as long as the characters on the left and right match and stay within bounds</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">left</span><span class="o">--;</span>
            <span class="n">right</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="c1">// Length is right - left - 1 because left and right have moved one extra position</span>
        <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// Test case 1: A normal case with palindrome in the middle</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"babad"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>
        <span class="c1">// Expected output: "bab" or "aba"</span>

        <span class="c1">// Test case 2: The entire string is a palindrome</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"racecar"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>
        <span class="c1">// Expected output: "racecar"</span>

        <span class="c1">// Test case 3: No palindrome longer than one character</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span>
        <span class="c1">// Expected output: "a" or "b" or "c"</span>

        <span class="c1">// Test case 4: Even-length palindrome</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"cbbd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s4</span><span class="o">));</span>
        <span class="c1">// Expected output: "bb"</span>

        <span class="c1">// Test case 5: Single character</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s5</span><span class="o">));</span>
        <span class="c1">// Expected output: "a"</span>

        <span class="c1">// Test case 6: Empty string</span>
        <span class="nc">String</span> <span class="n">s6</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s6</span><span class="o">));</span>
        <span class="c1">// Expected output: ""</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given a string s, return the longest palindromic substring in s.]]></summary></entry><entry><title type="html">31.Next Permutation</title><link href="https://zhengstar94.github.io//blog/2024/NextPermutation/" rel="alternate" type="text/html" title="31.Next Permutation"/><published>2024-10-30T00:00:00+00:00</published><updated>2024-10-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NextPermutation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NextPermutation/"><![CDATA[<ul> <li>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order. <ul> <li>For example, for <code class="language-plaintext highlighter-rouge">arr = [1,2,3]</code>, the following are all the permutations of <code class="language-plaintext highlighter-rouge">arr</code>: <code class="language-plaintext highlighter-rouge">[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li> </ul> </li> <li>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). <ul> <li>For example, the next permutation of <code class="language-plaintext highlighter-rouge">arr = [1,2,3]</code> is <code class="language-plaintext highlighter-rouge">[1,3,2]</code>.</li> <li>Similarly, the next permutation of <code class="language-plaintext highlighter-rouge">arr = [2,3,1]</code> is <code class="language-plaintext highlighter-rouge">[3,1,2]</code>.</li> <li>While the next permutation of <code class="language-plaintext highlighter-rouge">arr = [3,2,1]</code> is <code class="language-plaintext highlighter-rouge">[1,2,3]</code> because <code class="language-plaintext highlighter-rouge">[3,2,1]</code> does not have a lexicographical larger rearrangement.</li> </ul> </li> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>, <em>find the next permutation of</em> <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm">in place</a></strong> and use only constant extra memory.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: [1,3,2]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1]
Output: [1,2,3]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,5]
Output: [1,5,1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NextPermutation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">nextPermutation</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1. Boundary check - return if array is null or has length &lt;= 1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// 2. Find first decreasing element from right</span>
        <span class="c1">// Example: in [1,5,8,4,7,6,5,3,1], find 4 because 4 &lt; 7</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">i</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="c1">// 3. If we found a decreasing element (i.e., i &gt;= 0)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// Find the smallest element from right that's greater than nums[i]</span>
            <span class="c1">// This element will exist because nums[i] &lt; nums[i+1]</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="c1">// Swap nums[i] with this element</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 4. Reverse all elements after position i to get the smallest permutation</span>
        <span class="c1">// This works because elements after i are in descending order</span>
        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">start</span><span class="o">++,</span> <span class="n">end</span><span class="o">--);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="n">nextPermutation</span><span class="o">(</span><span class="n">test1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 1: [ 1,2,3 ] -&gt; "</span> <span class="o">+</span> <span class="n">arrayToString</span><span class="o">(</span><span class="n">test1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" (Expected: [ 1,3,2 ] )"</span><span class="o">);</span>

        <span class="c1">// Test Case 2: Decreasing order - should return increasing order</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="n">nextPermutation</span><span class="o">(</span><span class="n">test2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 2: [ 3,2,1 ] -&gt; "</span> <span class="o">+</span> <span class="n">arrayToString</span><span class="o">(</span><span class="n">test2</span><span class="o">)</span> <span class="o">+</span> <span class="s">" (Expected: [ 1,2,3 ] )"</span><span class="o">);</span>

        <span class="c1">// Test Case 3: Array with duplicates</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="n">nextPermutation</span><span class="o">(</span><span class="n">test3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 3: [ 1,1,5 ] -&gt; "</span> <span class="o">+</span> <span class="n">arrayToString</span><span class="o">(</span><span class="n">test3</span><span class="o">)</span> <span class="o">+</span> <span class="s">" (Expected: [ 1,5,1 ] )"</span><span class="o">);</span>

        <span class="c1">// Test Case 4: Larger array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="n">nextPermutation</span><span class="o">(</span><span class="n">test4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test 4: [ 1,3,5,4,2 ] -&gt; "</span> <span class="o">+</span> <span class="n">arrayToString</span><span class="o">(</span><span class="n">test4</span><span class="o">)</span> <span class="o">+</span> <span class="s">" (Expected: [ 1,4,2,3,5 ] )"</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">arrayToString</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="s">"null"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><summary type="html"><![CDATA[A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr=[1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr=[1,2,3] is [1,3,2]. Similarly, the next permutation of arr=[2,3,1] is [3,1,2]. While the next permutation of arr=[3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory.]]></summary></entry><entry><title type="html">735.Asteroid Collision</title><link href="https://zhengstar94.github.io//blog/2024/AsteroidCollision/" rel="alternate" type="text/html" title="735.Asteroid Collision"/><published>2024-10-29T00:00:00+00:00</published><updated>2024-10-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/AsteroidCollision</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/AsteroidCollision/"><![CDATA[<ul> <li>We are given an array <code class="language-plaintext highlighter-rouge">asteroids</code> of integers representing asteroids in a row.</li> <li>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</li> <li>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>


<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsteroidCollision</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">asteroidCollision</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">asteroids</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Use a deque to store asteroids, more efficient than a stack</span>
        <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">asteroid</span> <span class="o">:</span> <span class="n">asteroids</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">asteroid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Case 1: Queue is empty, add the asteroid directly</span>
                <span class="c1">// Case 2: Current asteroid is moving right, no collision with previous asteroids</span>
                <span class="n">q</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">asteroid</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Current asteroid is moving left (asteroid &lt; 0), so handle collisions</span>

                <span class="c1">// Loop to handle collisions: if the asteroid at the end of the queue</span>
                <span class="c1">// is moving right and has less mass than the current asteroid</span>
                <span class="c1">// (q.peekLast() + asteroid &lt; 0 means the right-moving asteroid is smaller in mass</span>
                <span class="c1">// because asteroid is negative, and their sum &lt; 0 implies |asteroid| is larger)</span>
                <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">+</span> <span class="n">asteroid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span> <span class="c1">// Remove the asteroid at the end of the queue (it explodes)</span>
                <span class="o">}</span>

                <span class="c1">// Three situations after handling collisions:</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">q</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Case 1: Queue is empty, add the asteroid directly</span>
                    <span class="c1">// Case 2: Asteroid at the end of the queue is moving left, no collision, add directly</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">asteroid</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">+</span> <span class="n">asteroid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Case 3: Equal mass, both explode, remove the last asteroid from the queue and do not add the current one</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">// Implicit Case 4: Current asteroid has smaller mass and is destroyed, no action needed</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert the deque to an array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span> <span class="o">},</span>          <span class="c1">// No collision, output [ 5, 10 ]</span>
                <span class="o">{</span> <span class="mi">8</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span> <span class="o">},</span>              <span class="c1">// Equal mass, both explode, output []</span>
                <span class="o">{</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span> <span class="o">},</span>          <span class="c1">// -5 collides with 2, 2 explodes, final output [ 10]</span>
                <span class="o">{</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span> <span class="o">},</span>       <span class="c1">// All asteroids move left or right, no collision, output [ -2, -1, 1, 2 ]</span>
                <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">},</span>       <span class="c1">// Each pair 1 and -1 collide, all explode, output []</span>
                <span class="o">{</span> <span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">15</span><span class="o">,</span> <span class="mi">20</span> <span class="o">}</span> <span class="c1">// 10 and -10 collide, 5 and -15 collide, output [ 20 ]</span>
        <span class="o">};</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">asteroidCollision</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.]]></summary></entry><entry><title type="html">72.Edit Distance</title><link href="https://zhengstar94.github.io//blog/2024/EditDistance/" rel="alternate" type="text/html" title="72.Edit Distance"/><published>2024-10-28T00:00:00+00:00</published><updated>2024-10-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/EditDistance</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/EditDistance/"><![CDATA[<ul> <li>Given two strings <code class="language-plaintext highlighter-rouge">word1</code> and <code class="language-plaintext highlighter-rouge">word2</code>, return <em>the minimum number of operations required to convert <code class="language-plaintext highlighter-rouge">word1</code> to <code class="language-plaintext highlighter-rouge">word2</code></em>.</li> <li>You have the following three operations permitted on a word: <ul> <li>Insert a character</li> <li>Delete a character</li> <li>Replace a character</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -&gt; rorse (replace 'h' with 'r')
rorse -&gt; rose (remove 'r')
rose -&gt; ros (remove 'e')
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -&gt; inention (remove 't')
inention -&gt; enention (replace 'i' with 'e')
enention -&gt; exention (replace 'n' with 'x')
exention -&gt; exection (replace 'n' with 'c')
exection -&gt; execution (insert 'u')
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EditDistance</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Initialize dp array for base cases</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// Minimum steps when word2 is empty (deletions only)</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> <span class="c1">// Minimum steps when word1 is empty (insertions only)</span>
        <span class="o">}</span>

        <span class="c1">// Fill the dp array using dynamic programming</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If characters are equal, carry forward the value from dp[i-1][j-1]</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Compute minimum operations by comparing:</span>
                    <span class="c1">// 1. Replacement (dp[i-1][j-1] + 1)</span>
                    <span class="c1">// 2. Insertion (dp[i][j-1] + 1)</span>
                    <span class="c1">// 3. Deletion (dp[i-1][j] + 1)</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span>
                            <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span> <span class="c1">// Final edit distance</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">word1</span> <span class="o">=</span> <span class="s">"horse"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"ros"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDistance</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">));</span>  <span class="c1">// Expected: 3</span>

        <span class="c1">// Test case 2</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">"intention"</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"execution"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDistance</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">));</span>  <span class="c1">// Expected: 5</span>

        <span class="c1">// Test case 3</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDistance</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">));</span>  <span class="c1">// Expected: 3</span>

        <span class="c1">// Test case 4</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDistance</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">));</span>  <span class="c1">// Expected: 3</span>

        <span class="c1">// Test case 5</span>
        <span class="n">word1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">word2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minDistance</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">));</span>  <span class="c1">// Expected: 0</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character]]></summary></entry><entry><title type="html">283.Move Zeroes</title><link href="https://zhengstar94.github.io//blog/2024/MoveZeroes/" rel="alternate" type="text/html" title="283.Move Zeroes"/><published>2024-10-26T00:00:00+00:00</published><updated>2024-10-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MoveZeroes</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MoveZeroes/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, move all <code class="language-plaintext highlighter-rouge">0</code>’s to the end of it while maintaining the relative order of the non-zero elements.</li> <li><strong>Note</strong> that you must do this in-place without making a copy of the array.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MoveZeroes</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">moveZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">nonZeroIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// First pass: Move all non-zero elements to the beginning of the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">nonZeroIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Second pass: Fill the rest of the array with zeroes</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nonZeroIndex</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">12</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before moveZeroes:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="n">moveZeroes</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After moveZeroes:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nBefore moveZeroes:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="n">moveZeroes</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After moveZeroes:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.]]></summary></entry><entry><title type="html">75.Sort Colors</title><link href="https://zhengstar94.github.io//blog/2024/SortColors/" rel="alternate" type="text/html" title="75.Sort Colors"/><published>2024-10-26T00:00:00+00:00</published><updated>2024-10-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/SortColors</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/SortColors/"><![CDATA[<ul> <li>Given an array <code class="language-plaintext highlighter-rouge">nums</code> with <code class="language-plaintext highlighter-rouge">n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</li> <li>We will use the integers <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, and <code class="language-plaintext highlighter-rouge">2</code> to represent the color red, white, and blue, respectively.</li> <li>You must solve this problem without using the library’s sort function.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,0,1]
Output: [0,1,2]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SortColors</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sortColors</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate until mid passes high</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Case 1: Current element is 0, swap with the element at 'low' pointer</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="c1">// Increment both low and mid pointers after swap</span>
                <span class="n">mid</span><span class="o">++;</span>
                <span class="n">low</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Case 2: Current element is 1, it's already in the correct place</span>
                <span class="c1">// Just move the mid pointer to the right</span>
                <span class="n">mid</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Case 3: Current element is 2, swap with the element at 'high' pointer</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="c1">// Decrement high pointer, but keep mid at the same position to recheck swapped element</span>
                <span class="n">high</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before sortColors:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="n">sortColors</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After sortColors:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nBefore sortColors:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="n">sortColors</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After sortColors:"</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library’s sort function.]]></summary></entry><entry><title type="html">408.Valid Word Abbreviation</title><link href="https://zhengstar94.github.io//blog/2024/ValidWordAbbreviation/" rel="alternate" type="text/html" title="408.Valid Word Abbreviation"/><published>2024-10-25T00:00:00+00:00</published><updated>2024-10-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ValidWordAbbreviation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ValidWordAbbreviation/"><![CDATA[<ul> <li> <p>Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.</p> </li> <li> <p>A string such as “word” contains only the following valid abbreviations:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
</code></pre></div> </div> <p>Notice that only the above abbreviations are valid abbreviations of the string “word”. Any other string is not a valid abbreviation of “word”.</p> <p>Note: Assume s contains only lowercase letters and abbr contains only lowercase letters and digits.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Given s = "internationalization", abbr = "i12iz4n":
Return true.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Given s = "apple", abbr = "a2e":
Return false.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidWordAbbreviation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validWordAbbreviation</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="nc">String</span> <span class="n">abbr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: if either string is null</span>
        <span class="k">if</span><span class="o">(</span><span class="n">word</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">abbr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize two pointers:</span>
        <span class="c1">// i: points to the current position in original word</span>
        <span class="c1">// j: points to the current position in abbreviation</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue while both pointers are within their respective strings</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">abbr</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="c1">// If current character in abbreviation is a digit</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">abbr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))){</span>
                <span class="c1">// Leading zeros are not allowed in valid abbreviation</span>
                <span class="k">if</span><span class="o">(</span><span class="n">abbr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Variable to store the complete number when encountering multiple consecutive digits</span>
                <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">// Process continuous digits (e.g., "12" in "i12iz4n")</span>
                <span class="c1">// For example: if we encounter "12":</span>
                <span class="c1">// First iteration: num = 0 * 10 + 1 = 1</span>
                <span class="c1">// Second iteration: num = 1 * 10 + 2 = 12</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">abbr</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">abbr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))){</span>
                    <span class="c1">// Convert char to int and accumulate the number</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">abbr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
                    <span class="c1">// Move to next digit</span>
                    <span class="n">j</span><span class="o">++;</span>
                <span class="o">}</span>

                <span class="c1">// Skip 'num' characters in the original word</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current characters don't match or we've exceeded word length</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">abbr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Move both pointers for character comparison</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Valid only if both strings are completely traversed</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">abbr</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected to return true</span>
        <span class="c1">// "internationalization" -&gt; "i12iz4n"</span>
        <span class="c1">// where 12 represents 12 characters and 4 represents 4 characters</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"internationalization"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">abbr1</span> <span class="o">=</span> <span class="s">"i12iz4n"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">validWordAbbreviation</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">abbr1</span><span class="o">));</span> <span class="c1">// Should print true</span>

        <span class="c1">// Test case 2: Expected to return false</span>
        <span class="c1">// "apple" cannot be abbreviated as "a2e"</span>
        <span class="c1">// because the middle part "ppl" is 3 characters, not 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"apple"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">abbr2</span> <span class="o">=</span> <span class="s">"a2e"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">validWordAbbreviation</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">abbr2</span><span class="o">));</span> <span class="c1">// Should print false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.]]></summary></entry><entry><title type="html">339.Nested List Weight Sum</title><link href="https://zhengstar94.github.io//blog/2024/NestedListWeightSum/" rel="alternate" type="text/html" title="339.Nested List Weight Sum"/><published>2024-10-24T00:00:00+00:00</published><updated>2024-10-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NestedListWeightSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NestedListWeightSum/"><![CDATA[<ul> <li>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</li> <li>Each element is either an integer, or a list – whose elements may also be integers or other lists.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: [ [ 1,1 ], 2, [ 1,1 ] ]
Output: 10 
Explanation: Four 1's at depth 2, one 2 at depth 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: [ 1, [ 4, [6 ] ] ]
Output: 27 
Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(d) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Trees</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NestedListWeightSum</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">depthSum</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">nestedList</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: if input is null or empty</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nestedList</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nestedList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Start DFS with depth 1</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">nestedList</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Depth-First Search helper method to recursively calculate the weighted sum
     * @param list current list being processed
     * @param depth current depth in the nested structure
     * @return weighted sum of all integers in this list and its sublists
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Iterate through each element in the current list</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">NestedInteger</span> <span class="nl">nested:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nested</span><span class="o">.</span><span class="na">isInteger</span><span class="o">()){</span>
                <span class="c1">// If element is an integer, multiply it by current depth</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nested</span><span class="o">.</span><span class="na">getInteger</span><span class="o">()</span> <span class="o">*</span> <span class="n">depth</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If element is a list, recurse deeper with increased depth</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">nested</span><span class="o">.</span><span class="na">getList</span><span class="o">(),</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: [ [ 1,1 ] , 2, [1,1 ] ]</span>
        <span class="c1">// Expected output: 10 (four 1's at depth 2, one 2 at depth 1)</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Create first [1,1]</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">subList1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">subList1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// First 1 at depth 2</span>
        <span class="n">subList1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// Second 1 at depth 2</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="n">subList1</span><span class="o">));</span>

        <span class="c1">// Add single integer 2</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>       <span class="c1">// 2 at depth 1</span>

        <span class="c1">// Create second [1,1]</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">subList2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">subList2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// Third 1 at depth 2</span>
        <span class="n">subList2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>    <span class="c1">// Fourth 1 at depth 2</span>
        <span class="n">test1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="n">subList2</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">depthSum</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Should output 10</span>

        <span class="c1">// Test Case 2: [1, [ 4, [ 6 ] ] ]</span>
        <span class="c1">// Expected output: 27 (1 at depth 1, 4 at depth 2, 6 at depth 3)</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>       <span class="c1">// 1 at depth 1</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">subList3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">subList3</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>    <span class="c1">// 4 at depth 2</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">subList4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">subList4</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="mi">6</span><span class="o">));</span>    <span class="c1">// 6 at depth 3</span>
        <span class="n">subList3</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="n">subList4</span><span class="o">));</span>
        <span class="n">test2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedIntegerImpl</span><span class="o">(</span><span class="n">subList3</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">depthSum</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Should output 27</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">NestedIntegerImpl</span> <span class="kd">implements</span> <span class="nc">NestedInteger</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">value</span><span class="o">;</span>                  <span class="c1">// Holds the integer value if this is a single number</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>       <span class="c1">// Holds the list if this is a nested list</span>

    <span class="cm">/**
     * Constructor for integer value
     * @param value the integer to store
     */</span>
    <span class="kd">public</span> <span class="nf">NestedIntegerImpl</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">list</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Constructor for nested list
     * @param list the list of NestedIntegers to store
     */</span>
    <span class="kd">public</span> <span class="nf">NestedIntegerImpl</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isInteger</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>              <span class="c1">// Returns true if this holds an integer</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getInteger</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>                      <span class="c1">// Returns the integer value or null</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="nf">getList</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">list</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;()</span> <span class="o">:</span> <span class="n">list</span><span class="o">;</span>  <span class="c1">// Returns the list or empty list</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Interface defining the structure for nested integers
 * Each NestedInteger can be either an integer or a list of NestedIntegers
 */</span>
<span class="kd">interface</span> <span class="nc">NestedInteger</span> <span class="o">{</span>
    <span class="c1">// Returns true if this NestedInteger holds a single integer, rather than a nested list</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isInteger</span><span class="o">();</span>

    <span class="c1">// Returns the single integer that this NestedInteger holds if it holds a single integer</span>
    <span class="c1">// Returns null if this NestedInteger holds a nested list</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getInteger</span><span class="o">();</span>

    <span class="c1">// Returns the nested list that this NestedInteger holds if it holds a nested list</span>
    <span class="c1">// Returns an empty list if this NestedInteger holds a single integer</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="nf">getList</span><span class="o">();</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Trees"/><summary type="html"><![CDATA[Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list – whose elements may also be integers or other lists.]]></summary></entry><entry><title type="html">973.K Closest Points to Origin</title><link href="https://zhengstar94.github.io//blog/2024/KClosestPointsToOrigin/" rel="alternate" type="text/html" title="973.K Closest Points to Origin"/><published>2024-10-23T00:00:00+00:00</published><updated>2024-10-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/KClosestPointsToOrigin</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/KClosestPointsToOrigin/"><![CDATA[<ul> <li>Given an array of <code class="language-plaintext highlighter-rouge">points</code> where <code class="language-plaintext highlighter-rouge">points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code class="language-plaintext highlighter-rouge">k</code>, return the <code class="language-plaintext highlighter-rouge">k</code> closest points to the origin <code class="language-plaintext highlighter-rouge">(0, 0)</code>.</li> <li>The distance between two points on the <strong>X-Y</strong> plane is the Euclidean distance (i.e., <code class="language-plaintext highlighter-rouge">√(x1 - x2)^2 + (y1 - y2)^2</code>).</li> <li>You may return the answer in <strong>any order</strong>. The answer is <strong>guaranteed</strong> to be <strong>unique</strong> (except for the order that it is in).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [1,3],[-2,2] ], k = 1
Output: [ [-2,2] ]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [ [-2,2] ].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [3,3],[5,-1],[-2,4] ], k = 2
Output: [ [3,3],[-2,4] ]
Explanation: The answer [ [-2,4],[3,3] ] would also be accepted.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KClosestPointsToOrigin</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">kClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span>  <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">points</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">quickSelect</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSelect</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: if left &gt;= right, partition contains 1 or 0 elements</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Choose random pivot to avoid worst case scenario</span>
        <span class="kt">int</span> <span class="n">pivotIndex</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
        <span class="c1">// Partition array around pivot and get final position of pivot</span>
        <span class="n">pivotIndex</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">pivotIndex</span><span class="o">);</span>

        <span class="c1">// If pivot is at k-1, we've found our k elements</span>
        <span class="k">if</span><span class="o">(</span><span class="n">pivotIndex</span> <span class="o">==</span> <span class="n">k</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// If pivot index is less than k-1, search right partition</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pivotIndex</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">quickSelect</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">pivotIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// If pivot index is greater than k-1, search left partition</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">quickSelect</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">pivotIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Implementation steps:
     * 1. SWAP 1: Move pivot to end (temporary storage)
     *    - swap(points, pivotIndex, right)
     * 2. Partition array:
     *    - SWAP 2: For each point with distance &lt; pivot distance
     *      swap(points, current, storeIndex)
     * 3. SWAP 3: Move pivot to final position
     *    - swap(points, storeIndex, right)
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pivotIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate distance of pivot point from origin</span>
        <span class="kt">int</span> <span class="n">pivotDist</span> <span class="o">=</span> <span class="n">distance</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">pivotIndex</span><span class="o">]);</span>

        <span class="c1">// Move pivot to end of array</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">pivotIndex</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">storeIndex</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>

        <span class="c1">// Partition array around pivot distance</span>
        <span class="c1">// Move all points with distance less than pivot distance to left side</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">distance</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;</span> <span class="n">pivotDist</span><span class="o">){</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">storeIndex</span><span class="o">);</span>
                <span class="n">storeIndex</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Move pivot to its final position</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">storeIndex</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">storeIndex</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">distance</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">point</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">point</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="n">point</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">point</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">point</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case with multiple points</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},{-</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">2</span><span class="o">,-</span><span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">kClosest</span><span class="o">(</span><span class="n">points1</span><span class="o">,</span> <span class="n">k1</span><span class="o">)));</span>

        <span class="c1">// Test Case 2: When k equals array length</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">5</span><span class="o">,-</span><span class="mi">1</span><span class="o">},{-</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">kClosest</span><span class="o">(</span><span class="n">points2</span><span class="o">,</span> <span class="n">k2</span><span class="o">)));</span>

        <span class="c1">// Test Case 3: Single point case</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">kClosest</span><span class="o">(</span><span class="n">points3</span><span class="o">,</span> <span class="n">k3</span><span class="o">)));</span>

        <span class="c1">// Test Case 4: Case with origin point</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points4</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},{-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">},{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">kClosest</span><span class="o">(</span><span class="n">points4</span><span class="o">,</span> <span class="n">k4</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><summary type="html"><![CDATA[Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)^2 + (y1 - y2)^2). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).]]></summary></entry><entry><title type="html">453.Minimum Moves to Equal Array Elements</title><link href="https://zhengstar94.github.io//blog/2024/MinimumMovesToEqualArrayElements/" rel="alternate" type="text/html" title="453.Minimum Moves to Equal Array Elements"/><published>2024-10-22T00:00:00+00:00</published><updated>2024-10-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MinimumMovesToEqualArrayElements</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MinimumMovesToEqualArrayElements/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.</li> <li>In one move, you can increment <code class="language-plaintext highlighter-rouge">n - 1</code> elements of the array by <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumMovesToEqualArrayElements</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minMoves</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases: null array or array with length &lt;= 1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 1: Find the minimum value in the array</span>
        <span class="c1">// This is our target value that all other elements will eventually equal to</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Calculate the total moves needed</span>
        <span class="c1">// For each element, we need (current value - minimum value) moves to reach the minimum</span>
        <span class="kt">int</span> <span class="n">moves</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">moves</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">-</span> <span class="n">min</span><span class="o">;</span>  <span class="c1">// Add the difference between current element and minimum</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">moves</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test Case </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 8</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:  "</span> <span class="o">+</span> <span class="n">minMoves</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">)</span> <span class="o">);</span>  <span class="c1">// Expected output: 6</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><summary type="html"><![CDATA[Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment n - 1 elements of the array by 1.]]></summary></entry></feed>