<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-03T02:59:15+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">3274. Check if Two Chessboard Squares Have the Same Color</title><link href="https://zhengstar94.github.io//blog/2024/CheckSameColor/" rel="alternate" type="text/html" title="3274. Check if Two Chessboard Squares Have the Same Color"/><published>2024-12-03T00:00:00+00:00</published><updated>2024-12-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CheckSameColor</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CheckSameColor/"><![CDATA[<ul> <li>You are given two strings, <code class="language-plaintext highlighter-rouge">coordinate1</code> and <code class="language-plaintext highlighter-rouge">coordinate2</code>, representing the coordinates of a square on an <code class="language-plaintext highlighter-rouge">8 x 8</code> chessboard.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if these two squares have the same color and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li> <li>The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coordinate1 = "a1", coordinate2 = "c3"
Output: true
Explanation:
Both squares are black.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coordinate1 = "a1", coordinate2 = "h3"
Output: false
Explanation:
Square "a1" is black and "h3" is white.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckSameColor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkTwoChessboards</span><span class="o">(</span><span class="nc">String</span> <span class="n">coordinate1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">coordinate2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert the first character (column) to numeric index</span>
        <span class="c1">// 'a' becomes 1, 'b' becomes 2, etc.</span>
        <span class="kt">int</span> <span class="n">col1</span> <span class="o">=</span> <span class="n">coordinate1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Convert the second character (row) to numeric index</span>
        <span class="c1">// '1' becomes 1, '2' becomes 2, etc.</span>
        <span class="kt">int</span> <span class="n">row1</span> <span class="o">=</span> <span class="n">coordinate1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>

        <span class="c1">// Repeat the same for the second coordinate</span>
        <span class="kt">int</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">coordinate2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">row2</span> <span class="o">=</span> <span class="n">coordinate2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>

        <span class="c1">// Core color determination logic:</span>
        <span class="c1">// 1. Sum the row and column indexes of both squares</span>
        <span class="c1">// 2. Check if the total sum is even or odd</span>
        <span class="c1">// 3. Even sum means both squares are the same color (black)</span>
        <span class="c1">// 4. Odd sum means the squares have different colors</span>
        <span class="c1">//</span>
        <span class="c1">// Mathematical explanation:</span>
        <span class="c1">// - In a chessboard, square color depends on row + column sum</span>
        <span class="c1">// - If row + column is even, the square is black</span>
        <span class="c1">// - If row + column is odd, the square is white</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">row1</span> <span class="o">+</span> <span class="n">col1</span> <span class="o">+</span> <span class="n">row2</span> <span class="o">+</span> <span class="n">col2</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Same color squares (both black)</span>
        <span class="nc">String</span> <span class="n">coordinate1</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate2</span> <span class="o">=</span> <span class="s">"c3"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate1</span><span class="o">,</span> <span class="n">coordinate2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate1</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate2</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test case 2: Different color squares</span>
        <span class="nc">String</span> <span class="n">coordinate3</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate4</span> <span class="o">=</span> <span class="s">"h3"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate3</span><span class="o">,</span> <span class="n">coordinate4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate3</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate4</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test case 3: Border test - first row and last column</span>
        <span class="nc">String</span> <span class="n">coordinate5</span> <span class="o">=</span> <span class="s">"a1"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate6</span> <span class="o">=</span> <span class="s">"h1"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate5</span><span class="o">,</span> <span class="n">coordinate6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate5</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate6</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>

        <span class="c1">// Test case 4: Middle area test</span>
        <span class="nc">String</span> <span class="n">coordinate7</span> <span class="o">=</span> <span class="s">"d4"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">coordinate8</span> <span class="o">=</span> <span class="s">"e5"</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">checkTwoChessboards</span><span class="o">(</span><span class="n">coordinate7</span><span class="o">,</span> <span class="n">coordinate8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">coordinate7</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">coordinate8</span> <span class="o">+</span> <span class="s">" have the same color: "</span> <span class="o">+</span> <span class="n">result4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard. Return true if these two squares have the same color and false otherwise. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).]]></summary></entry><entry><title type="html">636. Exclusive Time of Functions</title><link href="https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions/" rel="alternate" type="text/html" title="636. Exclusive Time of Functions"/><published>2024-12-02T00:00:00+00:00</published><updated>2024-12-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ExclusiveTimeOfFunctions/"><![CDATA[<ul> <li>On a <strong>single-threaded</strong> CPU, we execute a program containing <code class="language-plaintext highlighter-rouge">n</code> functions. Each function has a unique ID between <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">n-1</code>.</li> <li>Function calls are <strong>stored in a <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a></strong>: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is <strong>the current function being executed</strong>. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.</li> <li>You are given a list <code class="language-plaintext highlighter-rouge">logs</code>, where <code class="language-plaintext highlighter-rouge">logs[i]</code> represents the <code class="language-plaintext highlighter-rouge">ith</code> log message formatted as a string <code class="language-plaintext highlighter-rouge">"{function_id}:{"start" | "end"}:{timestamp}"</code>. For example, <code class="language-plaintext highlighter-rouge">"0:start:3"</code> means a function call with function ID <code class="language-plaintext highlighter-rouge">0</code> <strong>started at the beginning</strong> of timestamp <code class="language-plaintext highlighter-rouge">3</code>, and <code class="language-plaintext highlighter-rouge">"1:end:2"</code> means a function call with function ID <code class="language-plaintext highlighter-rouge">1</code> <strong>ended at the end</strong> of timestamp <code class="language-plaintext highlighter-rouge">2</code>. Note that a function can be called <strong>multiple times, possibly recursively</strong>.</li> <li>A function’s <strong>exclusive time</strong> is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for <code class="language-plaintext highlighter-rouge">2</code> time units and another call executing for <code class="language-plaintext highlighter-rouge">1</code> time unit, the <strong>exclusive time</strong> is <code class="language-plaintext highlighter-rouge">2 + 1 = 3</code>.</li> <li>Return <em>the <strong>exclusive time</strong> of each function in an array, where the value at the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>index represents the exclusive time for the function with ID</em> <code class="language-plaintext highlighter-rouge">i</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3,4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
Output: [8]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls itself again.
Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.
Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.
So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
Output: [7,1]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls function 1.
Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.
Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.
So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(L) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExclusiveTimeOfFunctions</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">exclusiveTime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">// Initialize the result array to store the exclusive time for each function</span>

        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span> <span class="c1">// Stack to simulate the call stack of functions</span>

        <span class="kt">int</span> <span class="n">prevTime</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Variable to keep track of the previous timestamp for calculating time intervals</span>

        <span class="c1">// Loop through each log entry</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">log</span> <span class="o">:</span> <span class="n">logs</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">);</span> <span class="c1">// Split each log entry into parts</span>
            <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// Get the function ID from the log entry</span>
            <span class="nc">String</span> <span class="n">type</span> <span class="o">=</span> <span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// Get the type of the log (either "start" or "end")</span>
            <span class="kt">int</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span> <span class="c1">// Get the timestamp from the log entry</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"start"</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// If the log indicates the start of a function</span>
                <span class="c1">// Before pushing the new function onto the stack, update the execution time of the function currently at the top of the stack</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">+=</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="n">prevTime</span><span class="o">;</span> <span class="c1">// Update the exclusive time of the function currently on top of the stack</span>
                <span class="o">}</span>

                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">id</span><span class="o">);</span> <span class="c1">// Push the current function's ID onto the stack (this function is now running)</span>
                <span class="n">prevTime</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">;</span> <span class="c1">// Update prevTime to the current timestamp, as we now know when the function started</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// If the log indicates the end of a function</span>
                <span class="c1">// Pop the current function from the stack (this function has finished execution)</span>
                <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()]</span> <span class="o">+=</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="n">prevTime</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Calculate the exclusive time of the function that has finished and update the result array</span>
                <span class="n">prevTime</span> <span class="o">=</span> <span class="n">timestamp</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Update prevTime to the next timestamp after the current function ends, for the next operation</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="c1">// Return the result array, containing the exclusive times for all functions</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> 
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"1:start:2"</span><span class="o">,</span><span class="s">"1:end:5"</span><span class="o">,</span><span class="s">"0:end:6"</span><span class="o">);</span>
        <span class="c1">// Function 0 runs for 3 units of time (from 0 to 1 and from 6 to 7), and function 1 runs for 4 units of time (from 2 to 5)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">logs1</span><span class="o">)));</span> <span class="c1">// Output: [3, 4]</span>

        <span class="c1">// Example 2:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"0:start:2"</span><span class="o">,</span><span class="s">"0:end:5"</span><span class="o">,</span><span class="s">"0:start:6"</span><span class="o">,</span><span class="s">"0:end:6"</span><span class="o">,</span><span class="s">"0:end:7"</span><span class="o">);</span>
        <span class="c1">// Function 0 is recursively called. It runs for 2 units of time, then calls itself, runs for 4 units, and then continues</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">logs2</span><span class="o">)));</span> <span class="c1">// Output: [8]</span>

        <span class="c1">// Example 3:</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">logs3</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"0:start:0"</span><span class="o">,</span><span class="s">"0:start:2"</span><span class="o">,</span><span class="s">"0:end:5"</span><span class="o">,</span><span class="s">"1:start:6"</span><span class="o">,</span><span class="s">"1:end:6"</span><span class="o">,</span><span class="s">"0:end:7"</span><span class="o">);</span>
        <span class="c1">// Function 0 runs for 7 units of time (from 0 to 5, then from 6 to 7), and function 1 runs for 1 unit of time (from 6 to 6)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">exclusiveTime</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">logs3</span><span class="o">)));</span> <span class="c1">// Output: [7, 1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1. Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list logs, where logs[i] represents the ith log message formatted as a string "{function_id}:{"start" | "end"}:{timestamp}". For example, "0:start:3" means a function call with function ID 0 started at the beginning of timestamp 3, and "1:end:2" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively. A function’s exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1=3. Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.]]></summary></entry><entry><title type="html">52. N-Queens II</title><link href="https://zhengstar94.github.io//blog/2024/NQueens/" rel="alternate" type="text/html" title="52. N-Queens II"/><published>2024-12-02T00:00:00+00:00</published><updated>2024-12-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NQueens%7C%7C</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NQueens/"><![CDATA[<ul> <li>The <strong>n-queens</strong> puzzle is the problem of placing <code class="language-plaintext highlighter-rouge">n</code> queens on an <code class="language-plaintext highlighter-rouge">n x n</code> chessboard such that no two queens attack each other.</li> <li>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, return <em>the number of distinct solutions to the <strong>n-queens puzzle</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n!) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NQueensII</span> <span class="o">{</span>
    <span class="c1">// This method is the entry point. It calls the recursive solve method to find the number of solutions.</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">totalNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>  <span class="c1">// Initial call with row = 0 and all bitmasks set to 0.</span>
    <span class="o">}</span>

    <span class="c1">// Recursive backtracking method to solve N-Queens problem</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">columns</span><span class="o">,</span> <span class="kt">int</span> <span class="n">diagonals</span><span class="o">,</span> <span class="kt">int</span> <span class="n">antiDiagonals</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// If we've placed queens in all rows, return 1 as we've found a valid solution.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">solutions</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Variable to count the number of valid solutions</span>

        <span class="c1">// Try placing a queen in every column of the current row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate the bitmask for the current column (only i-th column in the row).</span>
            <span class="kt">int</span> <span class="n">currColumn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// Calculate the bitmask for the current main diagonal.</span>
            <span class="c1">// The main diagonal can be uniquely identified by (row - col), and we add (n-1) to ensure it stays positive.</span>
            <span class="kt">int</span> <span class="n">currDiagonal</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Calculate the bitmask for the current anti-diagonal (row + col).</span>
            <span class="kt">int</span> <span class="n">currAntiDiagonal</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>

            <span class="c1">// Check if placing the queen at (row, i) conflicts with any previously placed queens.</span>
            <span class="c1">// We check each of the three potential conflicts (column, diagonal, anti-diagonal) using bitwise AND.</span>
            <span class="c1">// If the result is not 0, it means that a queen already exists in that column, diagonal, or anti-diagonal.</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">columns</span> <span class="o">&amp;</span> <span class="n">currColumn</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">diagonals</span> <span class="o">&amp;</span> <span class="n">currDiagonal</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">antiDiagonals</span> <span class="o">&amp;</span> <span class="n">currAntiDiagonal</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>  <span class="c1">// If there's a conflict, skip this column.</span>
            <span class="o">}</span>

            <span class="c1">// If no conflicts, place the queen at (row, i) and move to the next row (row + 1).</span>
            <span class="c1">// We update the bitmasks (columns, diagonals, and antiDiagonals) by setting the corresponding bits to 1.</span>
            <span class="n">solutions</span> <span class="o">+=</span> <span class="n">solve</span><span class="o">(</span>
                    <span class="n">n</span><span class="o">,</span>
                    <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span>  <span class="c1">// Move to the next row</span>
                    <span class="n">columns</span> <span class="o">|</span> <span class="n">currColumn</span><span class="o">,</span>  <span class="c1">// Mark the current column as occupied</span>
                    <span class="n">diagonals</span> <span class="o">|</span> <span class="n">currDiagonal</span><span class="o">,</span>  <span class="c1">// Mark the current main diagonal as occupied</span>
                    <span class="n">antiDiagonals</span> <span class="o">|</span> <span class="n">currAntiDiagonal</span>  <span class="c1">// Mark the current anti-diagonal as occupied</span>
            <span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of solutions found for this configuration</span>
        <span class="k">return</span> <span class="n">solutions</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Main method to test the N-Queens solution</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// You can modify n to test different board sizes</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total solutions for N="</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">" Queens: "</span> <span class="o">+</span> <span class="n">totalNQueens</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><category term="Hard"/><summary type="html"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle.]]></summary></entry><entry><title type="html">394. Decode String</title><link href="https://zhengstar94.github.io//blog/2024/DecodeString/" rel="alternate" type="text/html" title="394. Decode String"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DecodeString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DecodeString/"><![CDATA[<ul> <li>Given an encoded string, return its decoded string.</li> <li>The encoding rule is: <code class="language-plaintext highlighter-rouge">k[encoded_string]</code>, where the <code class="language-plaintext highlighter-rouge">encoded_string</code> inside the square brackets is being repeated exactly <code class="language-plaintext highlighter-rouge">k</code> times. Note that <code class="language-plaintext highlighter-rouge">k</code> is guaranteed to be a positive integer.</li> <li>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code class="language-plaintext highlighter-rouge">k</code>. For example, there will not be input like <code class="language-plaintext highlighter-rouge">3a</code> or <code class="language-plaintext highlighter-rouge">2[4]</code>.</li> <li>The test cases are generated so that the length of the output will never exceed <code class="language-plaintext highlighter-rouge">10^5</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "3[a]2[bc]"
Output: "aaabcbc"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "3[a2[c]]"
Output: "accaccacc"
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
</code></pre></div></div> <p><strong>Example 4</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc3[cd]xyz"
Output: "abccdcdcdxyz"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * k) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecodeString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">decodeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Stack to track the repeat counts for each nested level</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Stack to track previous strings at each nested level</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Current number being processed (supports multi-digit numbers)</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Current string being built at the current processing level</span>
        <span class="nc">StringBuilder</span> <span class="n">currentString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// Process each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 1. Number Processing: Build multi-digit numbers</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// Convert character to digit and accumulate</span>
                <span class="c1">// Handles multi-digit numbers like 10, 23 etc.</span>
                <span class="c1">// Example: '1' -&gt; num = 0*10 + 1 = 1</span>
                <span class="c1">//          '23' -&gt; num = 1*10 + 3 = 13</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 2. Left Bracket: Start of a new encoding block</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span><span class="sc">'['</span><span class="o">){</span>
                <span class="c1">// Push current number of repeats to count stack</span>
                <span class="c1">// This allows tracking nested repeat counts</span>
                <span class="n">countStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>

                <span class="c1">// Push current string to string stack</span>
                <span class="c1">// Preserves previous string context before entering new block</span>
                <span class="n">stringStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">currentString</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

                <span class="c1">// Reset for new block processing</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">currentString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 3. Right Bracket: End of an encoding block, time to decode</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">']'</span><span class="o">){</span>
                <span class="c1">// Retrieve repeat count for current block</span>
                <span class="kt">int</span> <span class="n">repeatTimes</span> <span class="o">=</span> <span class="n">countStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="c1">// Retrieve previous string context</span>
                <span class="c1">// This handles nested and sequential encodings</span>
                <span class="nc">StringBuilder</span> <span class="n">previousString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">stringStack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>

                <span class="c1">// Create a new string to store repeated content</span>
                <span class="nc">StringBuilder</span> <span class="n">repeatedString</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

                <span class="c1">// Repeat current block string specified number of times</span>
                <span class="c1">// Example: If currentString is "abc" and repeatTimes is 3</span>
                <span class="c1">// repeatedString becomes "abcabcabc"</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">repeatTimes</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">repeatedString</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">currentString</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// Combine previous context with repeated string</span>
                <span class="c1">// This resolves nested and sequential encodings</span>
                <span class="n">currentString</span> <span class="o">=</span> <span class="n">previousString</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">repeatedString</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 4. Letter Processing: Accumulate characters in current string</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">currentString</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the fully decoded string</span>
        <span class="k">return</span> <span class="n">currentString</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Comprehensive test cases covering various scenarios</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"3[a]2[bc]"</span><span class="o">,</span>           <span class="c1">// Simple repetition</span>
                <span class="s">"3[a2[c]]"</span><span class="o">,</span>             <span class="c1">// Nested repetition</span>
                <span class="s">"2[abc]3[cd]ef"</span><span class="o">,</span>        <span class="c1">// Multi-level repetition</span>
                <span class="s">"abc3[cd]xyz"</span><span class="o">,</span>          <span class="c1">// Repetition with prefix/suffix</span>
                <span class="s">"10[a]"</span><span class="o">,</span>                <span class="c1">// Multi-digit number</span>
                <span class="s">""</span>                      <span class="c1">// Empty string</span>
        <span class="o">};</span>

        <span class="c1">// Execute and print results for each test case</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">testCase</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original Encoded String: "</span> <span class="o">+</span> <span class="n">testCase</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">decodeString</span><span class="o">(</span><span class="n">testCase</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Decoded Result: "</span> <span class="o">+</span> <span class="n">decoded</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Decoding Error: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-------------------"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4]. The test cases are generated so that the length of the output will never exceed 10^5.]]></summary></entry><entry><title type="html">51. N-Queens</title><link href="https://zhengstar94.github.io//blog/2024/NQueens/" rel="alternate" type="text/html" title="51. N-Queens"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NQueens</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NQueens/"><![CDATA[<ul> <li>The <strong>n-queens</strong> puzzle is the problem of placing <code class="language-plaintext highlighter-rouge">n</code> queens on an <code class="language-plaintext highlighter-rouge">n x n</code> chessboard such that no two queens attack each other.</li> <li>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</li> <li>Each solution contains a distinct board configuration of the n-queens’ placement, where <code class="language-plaintext highlighter-rouge">'Q'</code> and <code class="language-plaintext highlighter-rouge">'.'</code> both indicate a queen and an empty space, respectively.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 4
Output: [ [ ".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.." ] ]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: [ [ "Q" ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n!) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NQueens</span> <span class="o">{</span>
    <span class="cm">/**
     * Main method to solve the N-Queens problem for a given board size.
     *
     * This method initializes the solving process and returns all valid queen arrangements.
     *
     * @param n The size of the chessboard (number of queens to place)
     * @return A list of all possible queen arrangements, where each arrangement
     *         is represented as a list of string representations of board rows
     *
     * Key Steps:
     * 1. Create an empty result list to store solutions
     * 2. Initialize a queens array to track queen positions
     * 3. Start the backtracking process from the first row
     * 4. Return all found solutions
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// List to store all valid solutions</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Array to track queen positions (index = row, value = column)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// Initialize all positions as unoccupied</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Start backtracking from the first row</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Recursive backtracking method to explore all possible queen placements.
     *
     * This is the core algorithm that systematically tries to place queens
     * on the board while maintaining the N-Queens constraints.
     *
     * @param queens Array representing current queen positions
     * @param row Current row being processed
     * @param n Total board size
     * @param result List to store all valid solutions
     *
     * Detailed Algorithm:
     * 1. Base Case: If all rows are processed, add current solution to results
     * 2. For each column in the current row:
     *    - Check if placing a queen is valid
     *    - If valid, place the queen
     *    - Recursively process the next row
     *    - Implicitly backtrack by trying next column positions
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If we've successfully placed queens in all rows, we've found a solution</span>
        <span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">constructSolution</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">n</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Try placing a queen in each column of the current row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if placing a queen at this position is valid</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">)){</span>
                <span class="c1">// Place the queen</span>
                <span class="n">queens</span><span class="o">[</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>

                <span class="c1">// Recursively process the next row</span>
                <span class="n">backtrack</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="cm">/**
     * Validates whether a queen can be placed at the given position.
     *
     * Checks two key constraints:
     * 1. No queen in the same column
     * 2. No queen on the same diagonal
     *
     * @param queens Current queen positions
     * @param row Row of the new queen
     * @param col Column of the new queen
     * @return true if queen placement is valid, false otherwise
     *
     * Validation Logic:
     * - Column Check: Ensure no queen in the same column
     * - Diagonal Check: Use absolute value difference to detect diagonal conflicts
     *   - Diagonal conflict occurs when |row1 - row2| == |col1 - col2|
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check all previous rows</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check column conflict</span>
            <span class="k">if</span><span class="o">(</span><span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">col</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check diagonal conflicts using absolute value difference</span>
            <span class="c1">// If |row distance| == |column distance|, queens are on the same diagonal</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Converts the internal queens array representation to a visual board layout.
     *
     * Transforms the queens array into a list of strings where:
     * - 'Q' represents a queen
     * - '.' represents an empty square
     *
     * @param queens Array representing queen positions
     * @param n Board size
     * @return A list of strings representing the board configuration
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">constructSolution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Create a row filled with '.' initially</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="sc">'.'</span><span class="o">);</span>

            <span class="c1">// Place queen at the correct column</span>
            <span class="n">row</span><span class="o">[</span><span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="o">;</span>

            <span class="c1">// Convert row to string and add to solution</span>
            <span class="n">solution</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">solution</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases for different board sizes</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"N = "</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">" Queens Problem Solutions:"</span><span class="o">);</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">solutions</span> <span class="o">=</span> <span class="n">solveNQueens</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

            <span class="c1">// Print number of solutions</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of Solutions: "</span> <span class="o">+</span> <span class="n">solutions</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

            <span class="c1">// Print each solution's board layout</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">solutions</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Solution "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">":"</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">row</span> <span class="o">:</span> <span class="n">solutions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span> <span class="c1">// Separator between solutions</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-------------------"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><category term="Hard"/><summary type="html"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.]]></summary></entry><entry><title type="html">71. Simplify Path</title><link href="https://zhengstar94.github.io//blog/2024/SimplifyPath/" rel="alternate" type="text/html" title="71. Simplify Path"/><published>2024-11-29T00:00:00+00:00</published><updated>2024-11-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/SimplifyPath</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/SimplifyPath/"><![CDATA[<ul> <li>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code class="language-plaintext highlighter-rouge">'/'</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</li> <li>The <em>rules</em> of a Unix-style file system are as follows: <ul> <li>A single period <code class="language-plaintext highlighter-rouge">'.'</code> represents the current directory.</li> <li>A double period <code class="language-plaintext highlighter-rouge">'..'</code> represents the previous/parent directory.</li> <li>Multiple consecutive slashes such as <code class="language-plaintext highlighter-rouge">'//'</code> and <code class="language-plaintext highlighter-rouge">'///'</code> are treated as a single slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file</strong> <strong>name</strong>. For example, <code class="language-plaintext highlighter-rouge">'...' </code>and <code class="language-plaintext highlighter-rouge">'....'</code> are valid directory or file names.</li> </ul> </li> <li>The simplified canonical path should follow these <em>rules</em>: <ul> <li>The path must start with a single slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Directories within the path must be separated by exactly one slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>The path must not end with a slash <code class="language-plaintext highlighter-rouge">'/'</code>, unless it is the root directory.</li> <li>The path must not have any single or double periods (<code class="language-plaintext highlighter-rouge">'.'</code> and <code class="language-plaintext highlighter-rouge">'..'</code>) used to denote current or parent directories.</li> </ul> </li> <li>Return the <strong>simplified canonical path</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home/"
Output: "/home"
Explanation:
The trailing slash should be removed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home//foo/"
Output: "/home/foo"
Explanation:
Multiple consecutive slashes are replaced by a single one.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home/user/Documents/../Pictures"
Output: "/home/user/Pictures"
Explanation:
A double period ".." refers to the directory up a level (the parent directory).
</code></pre></div></div> <p><strong>Example 4</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/../"
Output: "/"
Explanation:
Going one level up from the root directory is not possible.
</code></pre></div></div> <p><strong>Example 5</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/.../a/../b/c/../d/./"
Output: "/.../b/d"
Explanation:
"..." is a valid name for a directory in this problem.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimplifyPath</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">simplifyPath</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a double-ended queue (stack) to store valid directory components</span>
        <span class="c1">// Using ArrayDeque provides more efficient stack operations compared to traditional Stack</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Split the path into components using "/" as the delimiter</span>
        <span class="c1">// This handles multiple scenarios like consecutive slashes, leading/trailing slashes</span>
        <span class="c1">// Example: "/a//b" → ["", "a", "", "b"]</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">components</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>

        <span class="c1">// Iterate through each path component to process and simplify</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">component</span> <span class="o">:</span> <span class="n">components</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Skip empty strings and current directory markers (".")</span>
            <span class="c1">// This handles cases like "//" or "./"</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">component</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">component</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"."</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Handle parent directory navigation ("..")</span>
            <span class="c1">// If the stack is not empty, remove the last directory (go up one level)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">component</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">".."</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Prevents going above root directory</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Add valid directory names to the stack</span>
            <span class="c1">// This includes special directory names like "..."</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Reconstruct the simplified canonical path</span>
        <span class="c1">// Start with a root slash "/"</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>

        <span class="c1">// Append each directory from the stack</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">dir</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Remove the trailing slash for non-root paths</span>
        <span class="c1">// Ensures the path follows canonical format</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic path with trailing slash</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"/home/"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 1: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Multiple consecutive slashes</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"/home//foo/"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 2: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Path with parent directory navigation</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"/home/user/Documents/../Pictures"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 3: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Trying to navigate above root directory</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"/../"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 4: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Complex path with multiple scenarios</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"/.../a/../b/c/../d/./"</span><span class="o">;;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 5: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path. The rules of a Unix-style file system are as follows: A single period '.' represents the current directory. A double period '..' represents the previous/parent directory. Multiple consecutive slashes such as '//' and '///' are treated as a single slash '/'. Any sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, '...' and '....' are valid directory or file names. The simplified canonical path should follow these rules: The path must start with a single slash '/'. Directories within the path must be separated by exactly one slash '/'. The path must not end with a slash '/', unless it is the root directory. The path must not have any single or double periods ('.' and '..') used to denote current or parent directories. Return the simplified canonical path.]]></summary></entry><entry><title type="html">1209. Remove All Adjacent Duplicates in String II</title><link href="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesinStringII/" rel="alternate" type="text/html" title="1209. Remove All Adjacent Duplicates in String II"/><published>2024-11-29T00:00:00+00:00</published><updated>2024-11-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesinStringII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesinStringII/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, a <code class="language-plaintext highlighter-rouge">k</code> <strong>duplicate removal</strong> consists of choosing <code class="language-plaintext highlighter-rouge">k</code> adjacent and equal letters from <code class="language-plaintext highlighter-rouge">s</code> and removing them, causing the left and the right side of the deleted substring to concatenate together.</li> <li>We repeatedly make <code class="language-plaintext highlighter-rouge">k</code> <strong>duplicate removals</strong> on <code class="language-plaintext highlighter-rouge">s</code> until we no longer can.</li> <li>Return <em>the final string after all such duplicate removals have been made</em>. It is guaranteed that the answer is <strong>unique</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: 
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveAllAdjacentDuplicatesinStringII</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="no">K</span> <span class="n">key</span><span class="o">;</span>
        <span class="kd">private</span> <span class="no">V</span> <span class="n">value</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">key</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="no">V</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a stack to store characters and their frequencies</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Check if the stack is not empty and the current character matches the top of the stack</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">getKey</span><span class="o">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Get the current frequency of the character</span>
                <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">getValue</span><span class="o">();</span>

                <span class="c1">// If the frequency is k-1, remove the entire block of k characters</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">// Otherwise, increment the frequency</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">c</span><span class="o">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// If it's a new character or different from the top of the stack</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Push the character with initial frequency of 1</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">c</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Rebuild the final string from the remaining characters in the stack</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Use Collections.nCopies to repeat the character based on its frequency</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">nCopies</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">getValue</span><span class="o">(),</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Original example with multiple removals</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"deeedbbcccbdaa"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: No characters to remove</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Multiple removal scenarios</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"pbbcggttciiippooaais"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.]]></summary></entry><entry><title type="html">1047. Remove All Adjacent Duplicates In String</title><link href="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesInString/" rel="alternate" type="text/html" title="1047. Remove All Adjacent Duplicates In String"/><published>2024-11-28T00:00:00+00:00</published><updated>2024-11-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesInString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesInString/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>adjacent</strong> and <strong>equal</strong> letters and removing them.</li> <li>We repeatedly make <strong>duplicate removals</strong> on <code class="language-plaintext highlighter-rouge">s</code> until we no longer can.</li> <li>Return <em>the final string after all such duplicate removals have been made</em>. It can be proven that the answer is <strong>unique</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "azxxzy"
Output: "ay"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveAllAdjacentDuplicatesInString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Use StringBuilder as a stack to track characters</span>
        <span class="nc">StringBuilder</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()){</span>
            <span class="c1">// If stack is not empty and current char matches the top of the stack</span>
            <span class="k">if</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">c</span><span class="o">){</span>
                <span class="c1">// Remove the top character (eliminate adjacent duplicates)</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, add the current character to the stack</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the final processed string</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Original example</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"abbaca"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 1: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Another original example</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"azxxzy"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 2: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test case 3: All same characters</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"aaaaaa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 3: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test case 4: No duplicate characters</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 4: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test case 5: Complex repeated pattern</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"aaabbccddee"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 5: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.]]></summary></entry><entry><title type="html">266. Palindrome Permutation</title><link href="https://zhengstar94.github.io//blog/2024/PalindromePermutation/" rel="alternate" type="text/html" title="266. Palindrome Permutation"/><published>2024-11-27T00:00:00+00:00</published><updated>2024-11-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PalindromePermutation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PalindromePermutation/"><![CDATA[<ul> <li>Given a string, determine if a permutation of the string could form a palindrome.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: "code"
Output: false
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: "aab"
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: "carerac"
Output: true
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PalindromePermutation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canPermutePalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashSet to track character occurrences</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// If the character is already in the set, remove it</span>
            <span class="c1">// If not, add it to the set</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// A palindrome can have at most one character with odd occurrence</span>
        <span class="c1">// So the set size should be 0 or 1</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: String that cannot form a palindrome</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"code"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test case 2: String that can form a palindrome (odd length)</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"aab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test case 3: String that can form a palindrome (even length)</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"carerac"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test case 4: Empty string</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test case 5: Single character</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given a string, determine if a permutation of the string could form a palindrome.]]></summary></entry><entry><title type="html">447. Number of Boomerangs</title><link href="https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs/" rel="alternate" type="text/html" title="447. Number of Boomerangs"/><published>2024-11-26T00:00:00+00:00</published><updated>2024-11-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs/"><![CDATA[<ul> <li>You are given <code class="language-plaintext highlighter-rouge">n</code> <code class="language-plaintext highlighter-rouge">points</code> in the plane that are all <strong>distinct</strong>, where <code class="language-plaintext highlighter-rouge">points[i] = [xi, yi]</code>. A <strong>boomerang</strong> is a tuple of points <code class="language-plaintext highlighter-rouge">(i, j, k)</code> such that the distance between <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> equals the distance between <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">k</code> <strong>(the order of the tuple matters)</strong>.</li> <li>Return <em>the number of boomerangs</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [0,0],[1,0],[2,0] ]
Output: 2
Explanation: The two boomerangs are [ [1,0],[0,0],[2,0] ] and [ [1,0],[2,0],[0,0] ].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [1,1],[2,2],[3,3] ]
Output: 2
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [ 1,1 ] ]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfBoomerangs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfBoomerangs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Variable to store the total boomerang count</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each point as the potential central point</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// HashMap to store distances and their point frequencies</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">distanceMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// Calculate distances from current point to all other points</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Skip calculating distance to the same point</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Calculate squared distance between points</span>
                    <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">calculateDistance</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>

                    <span class="c1">// Update frequency of this distance in the map</span>
                    <span class="c1">// If distance not exists, set count to 1; otherwise, increment</span>
                    <span class="n">distanceMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">distanceMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Calculate boomerang combinations for each distance group</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="n">distanceMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                <span class="cm">/*
                 * Boomerang Calculation Logic:
                 * - 'count' represents points at the same distance from central point
                 * - For each distance group, calculate possible boomerang arrangements
                 *
                 * Mathematical Combination Explanation:
                 * 1. Total points at same distance: count
                 * 2. Choose first point: count options
                 * 3. Choose second point: (count - 1) options
                 * 4. Calculation: count * (count - 1)
                 *
                 * Example:
                 * If 4 points are at same distance:
                 * - First point selection: 4 ways
                 * - Second point selection: 3 ways
                 * - Total boomerang arrangements: 4 * 3 = 12
                 */</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculateDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">point1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">point2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate x and y coordinate differences</span>
        <span class="kt">int</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">point1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">point2</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">point1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">point2</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Return squared distance (Pythagorean theorem without square root)</span>
        <span class="k">return</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Points in a diagonal line</span>
        <span class="c1">// Expected to have some boomerang arrangements</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Points in a horizontal line</span>
        <span class="c1">// High likelihood of boomerang formations</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Single point</span>
        <span class="c1">// No boomerangs possible</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Return the number of boomerangs.]]></summary></entry></feed>