<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-21T15:17:10+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">91.Decode Ways</title><link href="https://zhengstar94.github.io//blog/2024/DecodeWays/" rel="alternate" type="text/html" title="91.Decode Ways"/><published>2024-09-21T00:00:00+00:00</published><updated>2024-09-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DecodeWays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DecodeWays/"><![CDATA[<h1 id="91-decode-ways">91. Decode Ways</h1> <ul> <li> <p>You have intercepted a secret message encoded as a string of numbers. The message is <strong>decoded</strong> via the following mapping:</p> <p><code class="language-plaintext highlighter-rouge">"1" -&gt; 'A' "2" -&gt; 'B' ... "25" -&gt; 'Y' "26" -&gt; 'Z'</code></p> </li> <li> <p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (<code class="language-plaintext highlighter-rouge">"2"</code> and <code class="language-plaintext highlighter-rouge">"5"</code> vs <code class="language-plaintext highlighter-rouge">"25"</code>).</p> <p>For example, <code class="language-plaintext highlighter-rouge">"11106"</code> can be decoded into:</p> <ul> <li><code class="language-plaintext highlighter-rouge">"AAJF"</code> with the grouping <code class="language-plaintext highlighter-rouge">(1, 1, 10, 6)</code></li> <li><code class="language-plaintext highlighter-rouge">"KJF"</code> with the grouping <code class="language-plaintext highlighter-rouge">(11, 10, 6)</code></li> <li>The grouping <code class="language-plaintext highlighter-rouge">(1, 11, 06)</code> is invalid because <code class="language-plaintext highlighter-rouge">"06"</code> is not a valid code (only <code class="language-plaintext highlighter-rouge">"6"</code> is valid).</li> </ul> <p>Note: there may be strings that are impossible to decode.</p> <p>Given a string s containing only digits, return the <strong>number of ways</strong> to <strong>decode</strong> it. If the entire string cannot be decoded in any valid way, return <code class="language-plaintext highlighter-rouge">0</code>.</p> <p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "12"

Output: 2

Explanation:

"12" could be decoded as "AB" (1 2) or "L" (12).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "226"

Output: 3

Explanation:

"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "06"

Output: 0

Explanation:

"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecodeWays</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the number of ways to decode a string of digits.
     * @param s The input string containing digits.
     * @return The number of possible decodings.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numDecodings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// dp[i] represents the number of ways to decode the first i characters</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Base case: empty string has one way to decode (do nothing)</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if single digit decoding is possible</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current digit is not '0', it can be decoded alone</span>
                <span class="c1">// So we add the number of ways to decode the string up to the previous position</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// Check if two-digit decoding is possible</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">twoDigitNum</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">26</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the last two digits form a valid number (10-26),</span>
                <span class="c1">// we add the number of ways to decode the string up to two positions back</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of ways to decode the entire string</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Converts two consecutive digits in the string to an integer.
     * @param s The input string.
     * @param i The current position (we look at i-2 and i-1).
     * @return The integer value of the two digits.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">twoDigitNum</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert char to int by subtracting '0'</span>
        <span class="c1">// Multiply the tens digit by 10 and add the ones digit</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution with various test cases.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test cases</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"12"</span><span class="o">,</span>    <span class="c1">// Expected output: 2 (AB (1 2) or L (12))</span>
                <span class="s">"226"</span><span class="o">,</span>   <span class="c1">// Expected output: 3 (BZ (2 26) or VF (22 6) or BBF (2 2 6))</span>
                <span class="s">"0"</span><span class="o">,</span>     <span class="c1">// Expected output: 0 (cannot be decoded)</span>
                <span class="s">"06"</span><span class="o">,</span>    <span class="c1">// Expected output: 0 (cannot be decoded)</span>
                <span class="s">"10"</span><span class="o">,</span>    <span class="c1">// Expected output: 1 (J (10))</span>
                <span class="s">"27"</span><span class="o">,</span>    <span class="c1">// Expected output: 1 (BG (2 7))</span>
                <span class="s">"234"</span><span class="o">,</span>   <span class="c1">// Expected output: 3 (BCD (2 3 4) or WD (23 4) or BW (2 34))</span>
                <span class="s">"1111"</span>   <span class="c1">// Expected output: 5 (AAAA, KAA, AKA, AAK, KK)</span>
        <span class="o">};</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">testCase</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">numDecodings</span><span class="o">(</span><span class="n">testCase</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: \""</span> <span class="o">+</span> <span class="n">testCase</span> <span class="o">+</span> <span class="s">"\", Output: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[91. Decode Ways]]></summary></entry><entry><title type="html">647.Palindromic Substrings</title><link href="https://zhengstar94.github.io//blog/2024/PalindromicSubstrings/" rel="alternate" type="text/html" title="647.Palindromic Substrings"/><published>2024-09-18T00:00:00+00:00</published><updated>2024-09-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PalindromicSubstrings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PalindromicSubstrings/"><![CDATA[<h1 id="647-palindromic-substrings">647. Palindromic Substrings</h1> <ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</li> <li>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</li> <li>A <strong>substring</strong> is a contiguous sequence of characters within the string.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n<span class="p">^</span>2) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of the input string</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Create a 2D boolean array to store whether substrings are palindromes</span>
        <span class="c1">// dp[i][j] will be true if the substring from index i to j is a palindrome</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Initialize the count of palindromic substrings</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Base case: All substrings of length 1 are palindromes</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Check for substrings of length 2 and above</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">len</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Calculate the ending index j based on the current starting index i and length</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Check if the substring is a palindrome:</span>
                <span class="c1">// 1. The characters at both ends should be the same</span>
                <span class="c1">// 2. For length &gt; 2, the inner substring (excluding the ends) should be a palindrome</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">count</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total count of palindromic substrings</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div> <h2 id="method-2">Method 2</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>

    <span class="c1">// Main method to count the number of palindromic substrings in the input string `s`</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// Loop through each character of the string</span>
        <span class="c1">// Each character is considered the center of a potential palindrome</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// Count odd-length palindromes with center at `i`</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span> <span class="c1">// Expand around a single center (odd-length palindrome)</span>
            
            <span class="c1">// Count even-length palindromes with center between `i` and `i + 1`</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// Expand around two adjacent characters (even-length palindrome)</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span> <span class="c1">// Return the total count of palindromic substrings</span>
    <span class="o">}</span>
    
    <span class="c1">// Helper method to expand around the center and count palindromes</span>
    <span class="c1">// `left` and `right` define the boundaries to expand from the center</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">expandAroundCenter</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// Expand while the characters at `left` and `right` are the same (palindrome condition)</span>
        <span class="c1">// and ensure we stay within the bounds of the string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>    <span class="c1">// Increment count for each valid palindrome found</span>
            <span class="n">left</span><span class="o">--;</span>     <span class="c1">// Move left pointer outward</span>
            <span class="n">right</span><span class="o">++;</span>    <span class="c1">// Move right pointer outward</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span> <span class="c1">// Return the count of palindromes found in this expansion</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[647. Palindromic Substrings]]></summary></entry><entry><title type="html">5.Longest Palindromic Substring</title><link href="https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring/" rel="alternate" type="text/html" title="5.Longest Palindromic Substring"/><published>2024-08-31T00:00:00+00:00</published><updated>2024-08-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring/"><![CDATA[<h1 id="5-longest-palindromic-substring">5. Longest Palindromic Substring</h1> <ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the longest</em> <em>palindromic</em> <em>substring</em> in <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cbbd"
Output: "bb"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n<span class="p">^</span>2) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of the input string</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Create a 2D boolean array for dynamic programming</span>
        <span class="c1">// dp[i][j] will be true if the substring from index i to j is a palindrome</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Variables to keep track of the longest palindrome found</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Starting index of the longest palindrome</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Length of the longest palindrome</span>

        <span class="c1">// Initialize base case: all substrings of length 1 are palindromes</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Fill the dp array</span>
        <span class="c1">// Outer loop: iterate over all possible lengths of substrings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">len</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Inner loop: check all substrings of the current length</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Calculate the ending index of the current substring</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Check if the current substring is a palindrome</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="c1">// Mark the current substring as a palindrome</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

                    <span class="c1">// Update the longest palindrome if necessary</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">maxLen</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the longest palindromic substring</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">maxLen</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="c1">// Main method for testing</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"babad"</span><span class="o">,</span>
                <span class="s">"cbbd"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"ac"</span><span class="o">,</span>
                <span class="s">"racecar"</span><span class="o">,</span>
                <span class="s">"aacabdkacaa"</span><span class="o">,</span>
                <span class="s">""</span>
        <span class="o">};</span>

        <span class="c1">// Expected results</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">expectedResults</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"bab"</span><span class="o">,</span>  <span class="c1">// or "aba"</span>
                <span class="s">"bb"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"racecar"</span><span class="o">,</span>
                <span class="s">"aca"</span><span class="o">,</span>
                <span class="s">""</span>
        <span class="o">};</span>

        <span class="c1">// Run tests</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">":"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: \""</span> <span class="o">+</span> <span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: \""</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: \""</span> <span class="o">+</span> <span class="n">expectedResults</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">expectedResults</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[5. Longest Palindromic Substring]]></summary></entry><entry><title type="html">198.House Robber II</title><link href="https://zhengstar94.github.io//blog/2024/HouseRobberII/" rel="alternate" type="text/html" title="198.House Robber II"/><published>2024-08-19T00:00:00+00:00</published><updated>2024-08-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/HouseRobberII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/HouseRobberII/"><![CDATA[<h1 id="213-house-robber-ii">213. House Robber II</h1> <ul> <li>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</li> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 3
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HouseRobberII</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the maximum amount of money that can be robbed from a circular street of houses
     * without alerting the police.
     * @param nums an integer array representing the amount of money in each house
     * @return the maximum amount of money that can be robbed
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If there is only one house, rob it and return its value</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Case 1: Rob houses from index 0 to n-2 (excluding the last house)</span>
        <span class="c1">// This array includes houses from the first house to the second-to-last house.</span>
        <span class="kt">int</span> <span class="n">rob1</span> <span class="o">=</span> <span class="n">robLinear</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>

        <span class="c1">// Case 2: Rob houses from index 1 to n-1 (excluding the first house)</span>
        <span class="c1">// This array includes houses from the second house to the last house.</span>
        <span class="kt">int</span> <span class="n">rob2</span> <span class="o">=</span> <span class="n">robLinear</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">));</span>

        <span class="c1">// Return the maximum amount that can be robbed from either case</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">rob1</span><span class="o">,</span> <span class="n">rob2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to calculate the maximum amount of money that can be robbed
     * from a linear street of houses.
     * @param nums an integer array representing the amount of money in each house
     * @return the maximum amount of money that can be robbed
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">robLinear</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Iterate through the array to compute the maximum amount of money that can be robbed</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the new maximum amount that can be robbed including the current house</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">prev</span> <span class="o">+</span> <span class="n">num</span><span class="o">,</span> <span class="n">curr</span><span class="o">);</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">curr</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Rob houses with amounts [2, 3, 2]</span>
        <span class="c1">// Expected output: 3 (rob house 2)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Maximum amount for [2, 3, 2]: "</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Rob houses with amounts [1, 2, 3, 1]</span>
        <span class="c1">// Expected output: 4 (rob house 1 and house 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Maximum amount for [1, 2, 3, 1]: "</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test case 3: Rob houses with amounts [1, 2, 3]</span>
        <span class="c1">// Expected output: 3 (rob house 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Maximum amount for [1, 2, 3]: "</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[213. House Robber II]]></summary></entry><entry><title type="html">198.House Robber</title><link href="https://zhengstar94.github.io//blog/2024/HouseRobber/" rel="alternate" type="text/html" title="198.House Robber"/><published>2024-08-17T00:00:00+00:00</published><updated>2024-08-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/HouseRobber</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/HouseRobber/"><![CDATA[<h1 id="198-house-robber">198. House Robber</h1> <ul> <li>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</li> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HouseRobber</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Handle edge cases</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Initialize the dp array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="c1">// Only one house to rob</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// Two houses to choose the maximum between</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

        <span class="c1">// Fill the dp array based on the above rules</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// dp[i] represents the maximum amount of money that can be robbed from the first i + 1 houses.</span>
            <span class="c1">// To determine dp[i], we have two choices:</span>
            <span class="c1">// 1. Rob the current house (nums[i]). In this case, we cannot rob the previous house (i-1), so the maximum amount is nums[i] + dp[i-2].</span>
            <span class="c1">// 2. Do not rob the current house. The maximum amount in this case would be the same as if we had only considered the first i houses, which is dp[i-1].</span>

            <span class="c1">// Choose the maximum amount from the two options above</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// Return the result from the last house</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">maxRob1</span> <span class="o">=</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxRob1</span><span class="o">);</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">maxRob2</span> <span class="o">=</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxRob2</span><span class="o">);</span> <span class="c1">// Expected output: 12</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">maxRob3</span> <span class="o">=</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxRob3</span><span class="o">);</span> <span class="c1">// Expected output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[198. House Robber]]></summary></entry><entry><title type="html">70.Climbing Stairs</title><link href="https://zhengstar94.github.io//blog/2024/ClimbingStairs/" rel="alternate" type="text/html" title="70.Climbing Stairs"/><published>2024-08-02T00:00:00+00:00</published><updated>2024-08-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ClimbingStairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ClimbingStairs/"><![CDATA[<h1 id="70-climbing-stairs">70. Climbing Stairs</h1> <ul> <li>You are climbing a staircase. It takes <code class="language-plaintext highlighter-rouge">n</code> steps to reach the top.</li> <li>Each time you can either climb <code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">2</code> steps. In how many distinct ways can you climb to the top?</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * Solution for LeetCode problem: 70. Climbing Stairs
 * @author zhengstars
 * @date 2024/08/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClimbingStairs</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the number of distinct ways to climb n stairs
     * @param n the number of stairs
     * @return the number of distinct ways to climb the stairs
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">climbStairs</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: if n is 0 or 1, there's only one way to climb</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize variables for the first two steps</span>
        <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate from 2 to n, calculating the number of ways for each step</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate the next number in the sequence</span>
            <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">curr</span><span class="o">;</span>
            <span class="c1">// Update prev and curr for the next iteration</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Return the final result, which represents the number of ways to climb n stairs</span>
        <span class="k">return</span> <span class="n">curr</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method for testing the climbStairs function
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: 2 stairs</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of ways to climb 2 stairs: "</span> <span class="o">+</span> <span class="n">climbStairs</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>

        <span class="c1">// Test case 2: 3 stairs</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of ways to climb 3 stairs: "</span> <span class="o">+</span> <span class="n">climbStairs</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[70. Climbing Stairs]]></summary></entry><entry><title type="html">261.Graph Valid Tree</title><link href="https://zhengstar94.github.io//blog/2024/GraphValidTree/" rel="alternate" type="text/html" title="261.Graph Valid Tree"/><published>2024-07-14T00:00:00+00:00</published><updated>2024-07-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/GraphValidTree</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/GraphValidTree/"><![CDATA[<h1 id="261-graph-valid-tree">261. Graph Valid Tree</h1> <ul> <li>Given <code class="language-plaintext highlighter-rouge">n</code> nodes labeled from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + E) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="cm">/**
 * A class to determine if a given graph is a valid tree.
 * @author zhengstars
 * @date 2024/07/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GraphValidTree</span> <span class="o">{</span>

    <span class="cm">/**
     * Determines if a graph with 'n' nodes and 'edges' is a valid tree.
     * @param n Number of nodes in the graph.
     * @param edges Edges representing connections between nodes.
     * @return True if the graph is a valid tree, false otherwise.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize an array to keep track of parent nodes for each node</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Initialize each node's parent to itself (initially each node is its own parent)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Iterate through each edge in the graph</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Find the root parent of both nodes of the current edge</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">findParent</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">findParent</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

            <span class="c1">// If both nodes have the same root parent, a cycle is detected</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// It's not a valid tree if there's a cycle</span>
            <span class="o">}</span>

            <span class="c1">// Union operation: Set the parent of v's root to u's root to merge the sets</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Count the number of distinct root parents</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="c1">// If more than one distinct root parent is found, the graph is not fully connected</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// It's not a valid tree if it's not fully connected</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If there is exactly one distinct root parent, the graph is a valid tree</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Finds the root parent of a node using path compression technique.
     * @param parent Array representing parent nodes for each node.
     * @param node The node whose root parent needs to be found.
     * @return The root parent of the node.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findParent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">!=</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">node</span><span class="o">];</span> <span class="c1">// Path compression: set current node's parent to its grandparent</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span> <span class="c1">// Return the root parent of the node</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the GraphValidTree class.
     * @param args Command line arguments (not used).
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">}};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">validTree</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">edges1</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">}};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">validTree</span><span class="o">(</span><span class="n">n2</span><span class="o">,</span> <span class="n">edges2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><summary type="html"><![CDATA[261. Graph Valid Tree]]></summary></entry><entry><title type="html">207.Course Schedule</title><link href="https://zhengstar94.github.io//blog/2024/CourseSchedule/" rel="alternate" type="text/html" title="207.Course Schedule"/><published>2024-07-13T00:00:00+00:00</published><updated>2024-07-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CourseSchedule</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CourseSchedule/"><![CDATA[<h1 id="207-course-schedule">207. Course Schedule</h1> <ul> <li>There are a total of <code class="language-plaintext highlighter-rouge">numCourses</code> courses you have to take, labeled from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">numCourses - 1</code>. You are given an array <code class="language-plaintext highlighter-rouge">prerequisites</code> where <code class="language-plaintext highlighter-rouge">prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code class="language-plaintext highlighter-rouge">bi</code> first if you want to take course <code class="language-plaintext highlighter-rouge">ai</code>. <ul> <li>For example, the pair <code class="language-plaintext highlighter-rouge">[0, 1]</code>, indicates that to take course <code class="language-plaintext highlighter-rouge">0</code> you have to first take course <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> </li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if you can finish all courses. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(V + E) time | O(V + E) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 *
 * @author zhengstars
 * @date 2024/07/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CourseSchedule</span> <span class="o">{</span>
    <span class="c1">// Node visit status: 0-Not Visited, 1-Currently Visiting, 2-Visited</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="c1">// Adjacency list representing the graph relationships</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">adjacencyList</span><span class="o">;</span>
    <span class="c1">// Whether a cycle exists</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">hasCycle</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
        <span class="n">adjacencyList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Initialize the adjacency list</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">adjacencyList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>

        <span class="c1">// Build the graph</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">adjacencyList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pair</span><span class="o">[</span><span class="mi">1</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">pair</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// Check each node</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="o">!</span><span class="n">hasCycle</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">course</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Mark as currently visiting</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">course</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Recursively visit adjacent nodes</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjacencyList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">course</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">neighbor</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">neighbor</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">hasCycle</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">neighbor</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Encountered a currently visiting node, indicating a cycle</span>
                <span class="n">hasCycle</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Mark as visited</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">course</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">CourseSchedule</span> <span class="n">cs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CourseSchedule</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">numCourses1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">}};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cs</span><span class="o">.</span><span class="na">canFinish</span><span class="o">(</span><span class="n">numCourses1</span><span class="o">,</span> <span class="n">prerequisites1</span><span class="o">));</span> <span class="c1">// Output: true</span>

        <span class="kt">int</span> <span class="n">numCourses2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">}};</span>
        <span class="c1">//System.out.println(cs.canFinish(numCourses2, prerequisites2)); // Output: false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><summary type="html"><![CDATA[207. Course Schedule]]></summary></entry><entry><title type="html">417.Pacific Atlantic Water Flow</title><link href="https://zhengstar94.github.io//blog/2024/PacificAtlanticWaterFlow/" rel="alternate" type="text/html" title="417.Pacific Atlantic Water Flow"/><published>2024-07-12T00:00:00+00:00</published><updated>2024-07-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PacificAtlanticWaterFlow</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PacificAtlanticWaterFlow/"><![CDATA[<h1 id="417-pacific-atlantic-water-flow">417. Pacific Atlantic Water Flow</h1> <ul> <li>There is an <code class="language-plaintext highlighter-rouge">m x n</code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocean</strong> touches the island’s left and top edges, and the <strong>Atlantic Ocean</strong> touches the island’s right and bottom edges.</li> <li>The island is partitioned into a grid of square cells. You are given an <code class="language-plaintext highlighter-rouge">m x n</code> integer matrix <code class="language-plaintext highlighter-rouge">heights</code> where <code class="language-plaintext highlighter-rouge">heights[r][c]</code> represents the <strong>height above sea level</strong> of the cell at coordinate <code class="language-plaintext highlighter-rouge">(r, c)</code>.</li> <li>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell’s height is <strong>less than or equal to</strong> the current cell’s height. Water can flow from any cell adjacent to an ocean into the ocean.</li> <li>Return <em>a <strong>2D list</strong> of grid coordinates</em> <code class="language-plaintext highlighter-rouge">result</code> <em>where</em> <code class="language-plaintext highlighter-rouge">result[i] = [ri, ci]</code> <em>denotes that rain water can flow from cell</em> <code class="language-plaintext highlighter-rouge">(ri, ci)</code> <em>to <strong>both</strong> the Pacific and Atlantic oceans</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -&gt; Pacific Ocean 
       [0,4] -&gt; Atlantic Ocean
[1,3]: [1,3] -&gt; [0,3] -&gt; Pacific Ocean 
       [1,3] -&gt; [1,4] -&gt; Atlantic Ocean
[1,4]: [1,4] -&gt; [1,3] -&gt; [0,3] -&gt; Pacific Ocean 
       [1,4] -&gt; Atlantic Ocean
[2,2]: [2,2] -&gt; [1,2] -&gt; [0,2] -&gt; Pacific Ocean 
       [2,2] -&gt; [2,3] -&gt; [2,4] -&gt; Atlantic Ocean
[3,0]: [3,0] -&gt; Pacific Ocean 
       [3,0] -&gt; [4,0] -&gt; Atlantic Ocean
[3,1]: [3,1] -&gt; [3,0] -&gt; Pacific Ocean 
       [3,1] -&gt; [4,1] -&gt; Atlantic Ocean
[4,0]: [4,0] -&gt; Pacific Ocean 
       [4,0] -&gt; Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: heights = [ [1]]
Output: [ [0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n*m) time | O(n*m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/07/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PacificAtlanticWaterFlow</span> <span class="o">{</span>

    <span class="cm">/**
     * Main function to perform the water flow problem for the Pacific and Atlantic oceans.
     * @param heights the input matrix representing the heights of the land
     * @return a 2D list of grid coordinates where water can flow to both oceans
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">pacificAtlantic</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">heights</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">heights</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">heights</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">heights</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">canReachPacific</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">canReachAtlantic</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Start DFS from the left and right boundaries to mark reachable cells for Pacific and Atlantic</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">heights</span><span class="o">,</span> <span class="n">canReachPacific</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">heights</span><span class="o">,</span> <span class="n">canReachAtlantic</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Start DFS from the top and bottom boundaries to mark reachable cells for Pacific and Atlantic</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">heights</span><span class="o">,</span> <span class="n">canReachPacific</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">heights</span><span class="o">,</span> <span class="n">canReachAtlantic</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Check for cells that can reach both oceans and add them to the result list</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">canReachPacific</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">canReachAtlantic</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cell</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                    <span class="n">cell</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">cell</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cell</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Depth-first search to mark reachable cells from a given cell (x, y) in the matrix heights.
     * @param heights the input matrix representing the heights of the land
     * @param canReach boolean matrix to mark cells that can be reached from a given cell
     * @param x the row index of the current cell
     * @param y the column index of the current cell
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">heights</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">canReach</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">canReach</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">heights</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="n">canReach</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">directions</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}};</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">direction</span> <span class="o">:</span> <span class="n">directions</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">newX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">newY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">newX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">newX</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">newY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">newY</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="o">[</span><span class="n">newX</span><span class="o">][</span><span class="n">newY</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">heights</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">heights</span><span class="o">,</span> <span class="n">canReach</span><span class="o">,</span> <span class="n">newX</span><span class="o">,</span> <span class="n">newY</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution.
     * @param args the command line arguments
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">heights</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">}};</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pacificAtlantic</span><span class="o">(</span><span class="n">heights</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><summary type="html"><![CDATA[417. Pacific Atlantic Water Flow]]></summary></entry><entry><title type="html">133.Clone Graph</title><link href="https://zhengstar94.github.io//blog/2024/CloneGraph/" rel="alternate" type="text/html" title="133.Clone Graph"/><published>2024-07-11T00:00:00+00:00</published><updated>2024-07-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CloneGraph</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CloneGraph/"><![CDATA[<h1 id="133-clone-graph">133. Clone Graph</h1> <ul> <li>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph">connected</a></strong> undirected graph.</li> <li>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> (clone) of the graph.</li> <li>Each node in the graph contains a value (<code class="language-plaintext highlighter-rouge">int</code>) and a list (<code class="language-plaintext highlighter-rouge">List[Node]</code>) of its neighbors.</li> </ul> <blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Node {
    public int val;
    public List&lt;Node&gt; neighbors;
}
</code></pre></div> </div> </blockquote> <p><strong>Test case format:</strong></p> <p>For simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with <code class="language-plaintext highlighter-rouge">val == 1</code>, the second node with <code class="language-plaintext highlighter-rouge">val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p> <p><strong>An adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p> <p>The given node will always be the first node with <code class="language-plaintext highlighter-rouge">val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: adjList = [ [2,4],[1,3],[2,4],[1,3]]
Output: [ [2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: adjList = [ []]
Output: [ []]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * This class contains a solution for the LeetCode problem "133. Clone Graph".
 * Given a reference of a node in a connected undirected graph, clone the graph and return the reference of the cloned node.
 *
 * @author zhengstars
 * @date 2024/07/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CloneGraph</span> <span class="o">{</span>

  <span class="cm">/**
   * Clone the given graph starting from the given node.
   * @param node the starting node to clone
   * @return the reference of the cloned node
   */</span>
  <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">cloneGraph</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Handle the case where the input node is null</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Create a mapping to store the original nodes and their corresponding cloned nodes</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">return</span> <span class="nf">cloneGraphDFS</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * Depth-first search function to recursively clone the graph.
   * @param node the current node to clone
   * @param map a mapping of original nodes to cloned nodes
   * @return the cloned node
   */</span>
  <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">cloneGraphDFS</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// If the node is already cloned, return the cloned node</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Create a new node with the same value as the original node</span>
    <span class="nc">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>

    <span class="c1">// Recursively clone the neighbors of the node</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">neighbors</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">newNode</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cloneGraphDFS</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span> <span class="n">map</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
   * Main method to test the clone graph functionality.
   */</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">CloneGraph</span> <span class="n">cg</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CloneGraph</span><span class="o">();</span>

    <span class="c1">// Create a test case with nodes and neighbors</span>
    <span class="nc">Node</span> <span class="n">node1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">Node</span> <span class="n">node2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="nc">Node</span> <span class="n">node3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
    <span class="nc">Node</span> <span class="n">node4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

    <span class="c1">// Establish neighbor relationships</span>
    <span class="n">node1</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node2</span><span class="o">);</span>
    <span class="n">node1</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node4</span><span class="o">);</span>
    <span class="n">node2</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node1</span><span class="o">);</span>
    <span class="n">node2</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node3</span><span class="o">);</span>
    <span class="n">node3</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node2</span><span class="o">);</span>
    <span class="n">node3</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node4</span><span class="o">);</span>
    <span class="n">node4</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node1</span><span class="o">);</span>
    <span class="n">node4</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node3</span><span class="o">);</span>

    <span class="c1">// Clone the graph starting from node1</span>
    <span class="nc">Node</span> <span class="n">clone</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="na">cloneGraph</span><span class="o">(</span><span class="n">node1</span><span class="o">);</span>

    <span class="c1">// Print whether the original and clone have the same structure</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original and Clone have the same structure: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">clone</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">node1</span><span class="o">.</span><span class="na">val</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Node class representing a single node in the graph.
 */</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span><span class="o">;</span>

  <span class="cm">/**
   * Constructor to create a new Node with a given value and an empty list of neighbors.
   * @param val the value of the node
   */</span>
  <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">neighbors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><summary type="html"><![CDATA[133. Clone Graph]]></summary></entry></feed>