<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-05T14:50:51+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1143.Longest Common Subsequence</title><link href="https://zhengstar94.github.io//blog/2024/LongestCommonSubsequence/" rel="alternate" type="text/html" title="1143.Longest Common Subsequence"/><published>2024-10-05T00:00:00+00:00</published><updated>2024-10-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestCommonSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestCommonSubsequence/"><![CDATA[<ul> <li> <p>Given two strings <code class="language-plaintext highlighter-rouge">text1</code> and <code class="language-plaintext highlighter-rouge">text2</code>, return <em>the length of their longest <strong>common subsequence</strong>.</em> If there is no <strong>common subsequence</strong>, return <code class="language-plaintext highlighter-rouge">0</code>.</p> </li> <li> <p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p> <ul> <li>For example, <code class="language-plaintext highlighter-rouge">"ace"</code> is a subsequence of <code class="language-plaintext highlighter-rouge">"abcde"</code>.</li> </ul> <p>A <strong>common subsequence</strong> of two strings is a subsequence that is common to both strings.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestCommonSubsequence</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestCommonSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">text1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">text2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the lengths of the input strings</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">text1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">text2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Create a 2D array to store the lengths of LCS</span>
        <span class="c1">// The size is (m+1) x (n+1) to handle empty string cases</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Iterate through both strings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If the characters at the current positions match</span>
                <span class="k">if</span><span class="o">(</span><span class="n">text1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">text2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)){</span>
                    <span class="c1">// Increment the LCS length from the previous state</span>
                    <span class="c1">// dp[i-1][j-1] represents the LCS length without these characters</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// If characters don't match, take the maximum of:</span>
                    <span class="c1">// 1. LCS without the current character of text1 (dp[i-1][j])</span>
                    <span class="c1">// 2. LCS without the current character of text2 (dp[i][j-1])</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The bottom-right cell contains the length of the LCS of the entire strings</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test Case 1: Different strings with a common subsequence</span>
        <span class="nc">String</span> <span class="n">text1</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">text2</span> <span class="o">=</span> <span class="s">"ace"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">longestCommonSubsequence</span><span class="o">(</span><span class="n">text1</span><span class="o">,</span> <span class="n">text2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Identical strings</span>
        <span class="n">text1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">text2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">longestCommonSubsequence</span><span class="o">(</span><span class="n">text1</span><span class="o">,</span> <span class="n">text2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Completely different strings</span>
        <span class="n">text1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">text2</span> <span class="o">=</span> <span class="s">"def"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">longestCommonSubsequence</span><span class="o">(</span><span class="n">text1</span><span class="o">,</span> <span class="n">text2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 0"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.]]></summary></entry><entry><title type="html">62.Unique Paths</title><link href="https://zhengstar94.github.io//blog/2024/UniquePaths/" rel="alternate" type="text/html" title="62.Unique Paths"/><published>2024-10-01T00:00:00+00:00</published><updated>2024-10-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/UniquePaths</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/UniquePaths/"><![CDATA[<ul> <li> <p>There is a robot on an <code class="language-plaintext highlighter-rouge">m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code class="language-plaintext highlighter-rouge">grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code class="language-plaintext highlighter-rouge">grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p> <p>Given the two integers <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p> <p>The test cases are generated so that the answer will be less than or equal to <code class="language-plaintext highlighter-rouge">2 * 10^9</code>.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 7
Output: 28
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Down
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: m = 3, n = 3
Output: 6
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * Solution for LeetCode 62: Unique Paths
 * @author zhengstars
 * @date 2024/10/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UniquePaths</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the number of unique paths from top-left to bottom-right corner of a m x n grid.
     *
     * @param m Number of rows in the grid
     * @param n Number of columns in the grid
     * @return The total number of unique paths
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a 1D array to store the number of paths for each column</span>
        <span class="c1">// The size is n because we only need to keep track of one row at a time</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Fill the array with 1s initially</span>
        <span class="c1">// This represents the first row where there's only one way to reach each cell</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Iterate through each row (starting from the second row)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For each column (starting from the second column)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Update the number of paths to the current cell</span>
                <span class="c1">// It's the sum of paths from the cell above (current dp[j])</span>
                <span class="c1">// and the cell to the left (dp[j-1])</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The last element of dp array contains the total number of unique paths</span>
        <span class="c1">// to reach the bottom-right corner</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method for testing the uniquePaths function
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">UniquePaths</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UniquePaths</span><span class="o">();</span>

        <span class="c1">// Test case 1: 3x7 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x7 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">));</span> <span class="c1">// Expected output: 28</span>

        <span class="c1">// Test case 2: 3x2 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x2 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 3: 7x3 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"7x3 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected output: 28</span>

        <span class="c1">// Test case 4: 3x3 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3x3 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 5: 1x1 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1x1 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 6: 10x10 grid</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"10x10 grid: "</span> <span class="o">+</span> <span class="n">solution</span><span class="o">.</span><span class="na">uniquePaths</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span> <span class="c1">// Expected output: 48620</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.]]></summary></entry><entry><title type="html">300.Longest Increasing Subsequence</title><link href="https://zhengstar94.github.io//blog/2024/LongestIncreasingSubsequence/" rel="alternate" type="text/html" title="300.Longest Increasing Subsequence"/><published>2024-09-29T00:00:00+00:00</published><updated>2024-09-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestIncreasingSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestIncreasingSubsequence/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a dictionary of strings <code class="language-plaintext highlighter-rouge">wordDict</code>, return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">s</code> can be segmented into a space-separated sequence of one or more dictionary words.</li> <li><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</li> </ul> <p><strong>Example 1</strong></p> <ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the length of the longest <strong>strictly increasing</strong></em> <strong><em>subsequence</em></strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0,3,2,3]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [7,7,7,7,7,7,7]
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestIncreasingSubsequence</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if the input array is null or empty, return 0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// dp array to store the smallest tail of all increasing subsequences</span>
        <span class="c1">// of lengths i+1 in dp[i]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// len keeps track of the current length of the longest increasing subsequence</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Use binary search to find the position where num should be placed in dp</span>
            <span class="c1">// This is more efficient than linear search, reducing time complexity to O(log n)</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>

            <span class="c1">// If the element is not found, binarySearch returns (-(insertion point) - 1)</span>
            <span class="c1">// We need to convert this to the actual insertion point</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">i</span> <span class="o">=</span> <span class="o">-(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Place the current number in its correct position in dp</span>
            <span class="c1">// This either replaces a larger element or extends the sequence</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>

            <span class="c1">// If i equals len, it means we've found a new largest element</span>
            <span class="c1">// This extends our longest increasing subsequence, so we increment len</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">len</span><span class="o">){</span>
                <span class="n">len</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Note: If i &lt; len, we're just replacing an existing element</span>
            <span class="c1">// This doesn't increase the length, but might help form a longer sequence later</span>
        <span class="o">}</span>

        <span class="c1">// The final value of len is the length of the longest increasing subsequence</span>
        <span class="k">return</span> <span class="n">len</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">101</span><span class="o">,</span><span class="mi">18</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Length of Longest Increasing Subsequence: "</span> <span class="o">+</span> <span class="n">lengthOfLIS</span><span class="o">(</span><span class="n">nums</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.]]></summary></entry><entry><title type="html">139.Word Break</title><link href="https://zhengstar94.github.io//blog/2024/WordBreak/" rel="alternate" type="text/html" title="139.Word Break"/><published>2024-09-26T00:00:00+00:00</published><updated>2024-09-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/WordBreak</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/WordBreak/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a dictionary of strings <code class="language-plaintext highlighter-rouge">wordDict</code>, return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">s</code> can be segmented into a space-separated sequence of one or more dictionary words.</li> <li><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n + m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordBreak</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">wordBreak</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert wordDict to a HashSet for O(1) lookup time</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">wordDict</span><span class="o">);</span>

        <span class="c1">// Create a boolean array to store the results of subproblems</span>
        <span class="c1">// dp[i] will be true if the substring s[0,i) can be segmented into words from the dictionary</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Base case: empty string is always valid</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="c1">// Iterate through all possible end positions of substrings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Try all possible starting positions for the last word</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If the substring s[0,j) can be segmented (dp[j] is true)</span>
                <span class="c1">// and the substring s[j,i) is in the dictionary</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">wordSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                    <span class="c1">// Then the substring s[0,i) can be segmented</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="c1">// No need to check further for this i</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return whether the entire string can be segmented</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"leetcode"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"leet"</span><span class="o">,</span> <span class="s">"code"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">wordDict1</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"applepenapple"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pen"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">wordDict2</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"catsandog"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict3</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"cats"</span><span class="o">,</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"sand"</span><span class="o">,</span> <span class="s">"and"</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">wordDict3</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test case 4 (Empty string)</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict4</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s4</span><span class="o">,</span> <span class="n">wordDict4</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 5 (Single character)</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict5</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s5</span><span class="o">,</span> <span class="n">wordDict5</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 6 (No valid segmentation)</span>
        <span class="nc">String</span> <span class="n">s6</span> <span class="o">=</span> <span class="s">"aaaaaaa"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict6</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"aaaa"</span><span class="o">,</span> <span class="s">"aaaa"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 6: "</span> <span class="o">+</span> <span class="n">wordBreak</span><span class="o">(</span><span class="n">s6</span><span class="o">,</span> <span class="n">wordDict6</span><span class="o">));</span> <span class="c1">// Expected: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.]]></summary></entry><entry><title type="html">152.Maximum Product Subarray</title><link href="https://zhengstar94.github.io//blog/2024/MaximumProductSubarray/" rel="alternate" type="text/html" title="152.Maximum Product Subarray"/><published>2024-09-25T00:00:00+00:00</published><updated>2024-09-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaximumProductSubarray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaximumProductSubarray/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, find a subarray that has the largest product, and return <em>the product</em>.</li> <li>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumProductSubarray</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: if the array is null or empty, return 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize max as the first element of the array</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// imax/imin stores the max/min product of subarray that ends with the current number</span>
        <span class="kt">int</span> <span class="n">imax</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">imin</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If we encounter a negative number, swap imax and imin</span>
            <span class="c1">// This is because a negative number will make the bigger number smaller and the smaller number bigger</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">imax</span><span class="o">;</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="n">imin</span><span class="o">;</span>
                <span class="n">imin</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Update imax: compare current number with product of current number and previous imax</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">imax</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// Update imin: compare current number with product of current number and previous imin</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">imin</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Update max if we have found a larger product</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">imax</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: Normal case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 2: All positive numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 24</span>

        <span class="c1">// Test case 3: All negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 4: Mixed positive and negative with zero</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 5: Single element array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: -5</span>

        <span class="c1">// Test case 6: Empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums6</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 6 result: "</span> <span class="o">+</span> <span class="n">maxProduct</span><span class="o">(</span><span class="n">nums6</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer.]]></summary></entry><entry><title type="html">322.Coin Change</title><link href="https://zhengstar94.github.io//blog/2024/CoinChange/" rel="alternate" type="text/html" title="322.Coin Change"/><published>2024-09-23T00:00:00+00:00</published><updated>2024-09-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CoinChange</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CoinChange/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">coins</code> representing coins of different denominations and an integer <code class="language-plaintext highlighter-rouge">amount</code> representing a total amount of money.</li> <li>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> <li>You may assume that you have an infinite number of each kind of coin.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coins = [2], amount = 3
Output: -1
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: coins = [1], amount = 0
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(amount * n) time | O(amount) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoinChange</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the minimum number of coins needed to make the specified amount.
     *
     * @param coins An array of integers representing the coin denominations.
     * @param amount The target amount to be made using the coins.
     * @return The minimum number of coins needed to make the amount, or -1 if not possible.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Set a maximum value for comparison, which is greater than any possible number of coins.</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Create a dynamic programming array to store the minimum coins needed for each amount.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Initialize the dp array with max values to signify that those amounts cannot be made initially.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>

        <span class="c1">// Base case: 0 coins are needed to make the amount of 0.</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each amount from 1 to the target amount.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check each coin denomination.</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Only proceed if the coin value is less than or equal to the current amount.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Update the dp array at index i with the minimum value between the current value</span>
                    <span class="c1">// and the value at (i - coins[j]) + 1 (which represents using the current coin).</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If dp[amount] is still greater than amount, it means it's not possible to form that amount.</span>
        <span class="c1">// Otherwise, return the minimum coins needed.</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">amount</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test cases</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">coins1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">amount1</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum coins needed: "</span> <span class="o">+</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">coins1</span><span class="o">,</span> <span class="n">amount1</span><span class="o">));</span> <span class="c1">// Output: 3</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">coins2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">amount2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum coins needed: "</span> <span class="o">+</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">coins2</span><span class="o">,</span> <span class="n">amount2</span><span class="o">));</span> <span class="c1">// Output: -1</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">coins3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">amount3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum coins needed: "</span> <span class="o">+</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">coins3</span><span class="o">,</span> <span class="n">amount3</span><span class="o">));</span> <span class="c1">// Output: 0</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">coins4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">amount4</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum coins needed: "</span> <span class="o">+</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">coins4</span><span class="o">,</span> <span class="n">amount4</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">coins5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">amount5</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Minimum coins needed: "</span> <span class="o">+</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">coins5</span><span class="o">,</span> <span class="n">amount5</span><span class="o">));</span> <span class="c1">// Output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.]]></summary></entry><entry><title type="html">91.Decode Ways</title><link href="https://zhengstar94.github.io//blog/2024/DecodeWays/" rel="alternate" type="text/html" title="91.Decode Ways"/><published>2024-09-21T00:00:00+00:00</published><updated>2024-09-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DecodeWays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DecodeWays/"><![CDATA[<h1 id="91-decode-ways">91. Decode Ways</h1> <ul> <li> <p>You have intercepted a secret message encoded as a string of numbers. The message is <strong>decoded</strong> via the following mapping:</p> <p><code class="language-plaintext highlighter-rouge">"1" -&gt; 'A' "2" -&gt; 'B' ... "25" -&gt; 'Y' "26" -&gt; 'Z'</code></p> </li> <li> <p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (<code class="language-plaintext highlighter-rouge">"2"</code> and <code class="language-plaintext highlighter-rouge">"5"</code> vs <code class="language-plaintext highlighter-rouge">"25"</code>).</p> <p>For example, <code class="language-plaintext highlighter-rouge">"11106"</code> can be decoded into:</p> <ul> <li><code class="language-plaintext highlighter-rouge">"AAJF"</code> with the grouping <code class="language-plaintext highlighter-rouge">(1, 1, 10, 6)</code></li> <li><code class="language-plaintext highlighter-rouge">"KJF"</code> with the grouping <code class="language-plaintext highlighter-rouge">(11, 10, 6)</code></li> <li>The grouping <code class="language-plaintext highlighter-rouge">(1, 11, 06)</code> is invalid because <code class="language-plaintext highlighter-rouge">"06"</code> is not a valid code (only <code class="language-plaintext highlighter-rouge">"6"</code> is valid).</li> </ul> <p>Note: there may be strings that are impossible to decode.</p> <p>Given a string s containing only digits, return the <strong>number of ways</strong> to <strong>decode</strong> it. If the entire string cannot be decoded in any valid way, return <code class="language-plaintext highlighter-rouge">0</code>.</p> <p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "12"

Output: 2

Explanation:

"12" could be decoded as "AB" (1 2) or "L" (12).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "226"

Output: 3

Explanation:

"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "06"

Output: 0

Explanation:

"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/09/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecodeWays</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the number of ways to decode a string of digits.
     * @param s The input string containing digits.
     * @return The number of possible decodings.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numDecodings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// dp[i] represents the number of ways to decode the first i characters</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Base case: empty string has one way to decode (do nothing)</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if single digit decoding is possible</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the current digit is not '0', it can be decoded alone</span>
                <span class="c1">// So we add the number of ways to decode the string up to the previous position</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// Check if two-digit decoding is possible</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">twoDigitNum</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">26</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If the last two digits form a valid number (10-26),</span>
                <span class="c1">// we add the number of ways to decode the string up to two positions back</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of ways to decode the entire string</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Converts two consecutive digits in the string to an integer.
     * @param s The input string.
     * @param i The current position (we look at i-2 and i-1).
     * @return The integer value of the two digits.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">twoDigitNum</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert char to int by subtracting '0'</span>
        <span class="c1">// Multiply the tens digit by 10 and add the ones digit</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the solution with various test cases.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test cases</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"12"</span><span class="o">,</span>    <span class="c1">// Expected output: 2 (AB (1 2) or L (12))</span>
                <span class="s">"226"</span><span class="o">,</span>   <span class="c1">// Expected output: 3 (BZ (2 26) or VF (22 6) or BBF (2 2 6))</span>
                <span class="s">"0"</span><span class="o">,</span>     <span class="c1">// Expected output: 0 (cannot be decoded)</span>
                <span class="s">"06"</span><span class="o">,</span>    <span class="c1">// Expected output: 0 (cannot be decoded)</span>
                <span class="s">"10"</span><span class="o">,</span>    <span class="c1">// Expected output: 1 (J (10))</span>
                <span class="s">"27"</span><span class="o">,</span>    <span class="c1">// Expected output: 1 (BG (2 7))</span>
                <span class="s">"234"</span><span class="o">,</span>   <span class="c1">// Expected output: 3 (BCD (2 3 4) or WD (23 4) or BW (2 34))</span>
                <span class="s">"1111"</span>   <span class="c1">// Expected output: 5 (AAAA, KAA, AKA, AAK, KK)</span>
        <span class="o">};</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">testCase</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">numDecodings</span><span class="o">(</span><span class="n">testCase</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: \""</span> <span class="o">+</span> <span class="n">testCase</span> <span class="o">+</span> <span class="s">"\", Output: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[91. Decode Ways]]></summary></entry><entry><title type="html">647.Palindromic Substrings</title><link href="https://zhengstar94.github.io//blog/2024/PalindromicSubstrings/" rel="alternate" type="text/html" title="647.Palindromic Substrings"/><published>2024-09-18T00:00:00+00:00</published><updated>2024-09-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PalindromicSubstrings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PalindromicSubstrings/"><![CDATA[<h1 id="647-palindromic-substrings">647. Palindromic Substrings</h1> <ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</li> <li>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</li> <li>A <strong>substring</strong> is a contiguous sequence of characters within the string.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n<span class="p">^</span>2) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of the input string</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Create a 2D boolean array to store whether substrings are palindromes</span>
        <span class="c1">// dp[i][j] will be true if the substring from index i to j is a palindrome</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Initialize the count of palindromic substrings</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Base case: All substrings of length 1 are palindromes</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Check for substrings of length 2 and above</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">len</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Calculate the ending index j based on the current starting index i and length</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Check if the substring is a palindrome:</span>
                <span class="c1">// 1. The characters at both ends should be the same</span>
                <span class="c1">// 2. For length &gt; 2, the inner substring (excluding the ends) should be a palindrome</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">count</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total count of palindromic substrings</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div> <h2 id="method-2">Method 2</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>

    <span class="c1">// Main method to count the number of palindromic substrings in the input string `s`</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// Loop through each character of the string</span>
        <span class="c1">// Each character is considered the center of a potential palindrome</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// Count odd-length palindromes with center at `i`</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span> <span class="c1">// Expand around a single center (odd-length palindrome)</span>
            
            <span class="c1">// Count even-length palindromes with center between `i` and `i + 1`</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// Expand around two adjacent characters (even-length palindrome)</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span> <span class="c1">// Return the total count of palindromic substrings</span>
    <span class="o">}</span>
    
    <span class="c1">// Helper method to expand around the center and count palindromes</span>
    <span class="c1">// `left` and `right` define the boundaries to expand from the center</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">expandAroundCenter</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// Expand while the characters at `left` and `right` are the same (palindrome condition)</span>
        <span class="c1">// and ensure we stay within the bounds of the string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>    <span class="c1">// Increment count for each valid palindrome found</span>
            <span class="n">left</span><span class="o">--;</span>     <span class="c1">// Move left pointer outward</span>
            <span class="n">right</span><span class="o">++;</span>    <span class="c1">// Move right pointer outward</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span> <span class="c1">// Return the count of palindromes found in this expansion</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[647. Palindromic Substrings]]></summary></entry><entry><title type="html">5.Longest Palindromic Substring</title><link href="https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring/" rel="alternate" type="text/html" title="5.Longest Palindromic Substring"/><published>2024-08-31T00:00:00+00:00</published><updated>2024-08-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/LongestPalindromicSubstring/"><![CDATA[<h1 id="5-longest-palindromic-substring">5. Longest Palindromic Substring</h1> <ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the longest</em> <em>palindromic</em> <em>substring</em> in <code class="language-plaintext highlighter-rouge">s</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cbbd"
Output: "bb"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n<span class="p">^</span>2) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalindromicSubstring</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the length of the input string</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// Create a 2D boolean array for dynamic programming</span>
        <span class="c1">// dp[i][j] will be true if the substring from index i to j is a palindrome</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Variables to keep track of the longest palindrome found</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Starting index of the longest palindrome</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Length of the longest palindrome</span>

        <span class="c1">// Initialize base case: all substrings of length 1 are palindromes</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Fill the dp array</span>
        <span class="c1">// Outer loop: iterate over all possible lengths of substrings</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">len</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Inner loop: check all substrings of the current length</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Calculate the ending index of the current substring</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

                <span class="c1">// Check if the current substring is a palindrome</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="c1">// Mark the current substring as a palindrome</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

                    <span class="c1">// Update the longest palindrome if necessary</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">maxLen</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the longest palindromic substring</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">maxLen</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="c1">// Main method for testing</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"babad"</span><span class="o">,</span>
                <span class="s">"cbbd"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"ac"</span><span class="o">,</span>
                <span class="s">"racecar"</span><span class="o">,</span>
                <span class="s">"aacabdkacaa"</span><span class="o">,</span>
                <span class="s">""</span>
        <span class="o">};</span>

        <span class="c1">// Expected results</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">expectedResults</span> <span class="o">=</span> <span class="o">{</span>
                <span class="s">"bab"</span><span class="o">,</span>  <span class="c1">// or "aba"</span>
                <span class="s">"bb"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"a"</span><span class="o">,</span>
                <span class="s">"racecar"</span><span class="o">,</span>
                <span class="s">"aca"</span><span class="o">,</span>
                <span class="s">""</span>
        <span class="o">};</span>

        <span class="c1">// Run tests</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">":"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: \""</span> <span class="o">+</span> <span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: \""</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: \""</span> <span class="o">+</span> <span class="n">expectedResults</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">expectedResults</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">?</span> <span class="s">"PASS"</span> <span class="o">:</span> <span class="s">"FAIL"</span><span class="o">));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[5. Longest Palindromic Substring]]></summary></entry><entry><title type="html">198.House Robber II</title><link href="https://zhengstar94.github.io//blog/2024/HouseRobberII/" rel="alternate" type="text/html" title="198.House Robber II"/><published>2024-08-19T00:00:00+00:00</published><updated>2024-08-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/HouseRobberII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/HouseRobberII/"><![CDATA[<h1 id="213-house-robber-ii">213. House Robber II</h1> <ul> <li>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</li> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 3
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/08/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HouseRobberII</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculates the maximum amount of money that can be robbed from a circular street of houses
     * without alerting the police.
     * @param nums an integer array representing the amount of money in each house
     * @return the maximum amount of money that can be robbed
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If there is only one house, rob it and return its value</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Case 1: Rob houses from index 0 to n-2 (excluding the last house)</span>
        <span class="c1">// This array includes houses from the first house to the second-to-last house.</span>
        <span class="kt">int</span> <span class="n">rob1</span> <span class="o">=</span> <span class="n">robLinear</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>

        <span class="c1">// Case 2: Rob houses from index 1 to n-1 (excluding the first house)</span>
        <span class="c1">// This array includes houses from the second house to the last house.</span>
        <span class="kt">int</span> <span class="n">rob2</span> <span class="o">=</span> <span class="n">robLinear</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">));</span>

        <span class="c1">// Return the maximum amount that can be robbed from either case</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">rob1</span><span class="o">,</span> <span class="n">rob2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to calculate the maximum amount of money that can be robbed
     * from a linear street of houses.
     * @param nums an integer array representing the amount of money in each house
     * @return the maximum amount of money that can be robbed
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">robLinear</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Iterate through the array to compute the maximum amount of money that can be robbed</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the new maximum amount that can be robbed including the current house</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">prev</span> <span class="o">+</span> <span class="n">num</span><span class="o">,</span> <span class="n">curr</span><span class="o">);</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">curr</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Rob houses with amounts [2, 3, 2]</span>
        <span class="c1">// Expected output: 3 (rob house 2)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Maximum amount for [2, 3, 2]: "</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Rob houses with amounts [1, 2, 3, 1]</span>
        <span class="c1">// Expected output: 4 (rob house 1 and house 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Maximum amount for [1, 2, 3, 1]: "</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test case 3: Rob houses with amounts [1, 2, 3]</span>
        <span class="c1">// Expected output: 3 (rob house 3)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Maximum amount for [1, 2, 3]: "</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><summary type="html"><![CDATA[213. House Robber II]]></summary></entry></feed>