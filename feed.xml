<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-03T10:06:24+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2874. Maximum Value of an Ordered Triplet II</title><link href="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII/" rel="alternate" type="text/html" title="2874. Maximum Value of an Ordered Triplet II"/><published>2025-04-03T00:00:00+00:00</published><updated>2025-04-03T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletII/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <strong><em>the maximum value over all triplets of indices</em></strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code><em>.</em> If all such triplets have a negative value, return <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>The <strong>value of a triplet of indices</strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is equal to <code class="language-plaintext highlighter-rouge">(nums[i] - nums[j]) * nums[k]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/03
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumValueOfAnOrderedTripletII</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumTripletValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                <span class="c1">// Stores maximum triplet value</span>
        <span class="kt">int</span> <span class="n">maxDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>            <span class="c1">// Tracks maximum difference between any two previous elements</span>
        <span class="kt">int</span> <span class="n">preMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>             <span class="c1">// Keeps track of maximum element seen so far</span>

        <span class="c1">// Iterate through each element in array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Update maximum triplet value using current element as nums[k]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">maxDiff</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span>

            <span class="c1">// Update maximum difference considering current element as nums[j]</span>
            <span class="n">maxDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDiff</span><span class="o">,</span> <span class="n">preMax</span> <span class="o">-</span> <span class="n">x</span><span class="o">);</span>

            <span class="c1">// Update maximum value seen so far (potential nums[i])</span>
            <span class="n">preMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">preMax</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases array with example inputs</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span>    <span class="c1">// Expected output: 77  ( ( 12-1)*7)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">19</span><span class="o">},</span>   <span class="c1">// Expected output: 133 ( ( 10-3)*19)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>            <span class="c1">// Expected output: 0   (no valid positive value possible)</span>
        <span class="o">};</span>

        <span class="c1">// Run all test cases and print results</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maximumTripletValue</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i &lt; j &lt; k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].]]></summary></entry><entry><title type="html">2873. Maximum Value of an Ordered Triplet I</title><link href="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI/" rel="alternate" type="text/html" title="2873. Maximum Value of an Ordered Triplet I"/><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumValueOfAnOrderedTripletI/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <strong><em>the maximum value over all triplets of indices</em></strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">i &lt; j &lt; k</code>. If all such triplets have a negative value, return <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>The <strong>value of a triplet of indices</strong> <code class="language-plaintext highlighter-rouge">(i, j, k)</code> is equal to <code class="language-plaintext highlighter-rouge">(nums[i] - nums[j ] ) * nums[k]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2 ] ) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2 ] ) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1 ] ) * nums[2] = -3. Hence, the answer would be 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/04/02
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumValueOfAnOrderedTripletI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">maximumTripletValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the answer to store the maximum triplet value</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the maximum difference (nums[i] - nums[j]) encountered so far</span>
        <span class="kt">int</span> <span class="n">maxDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Store the maximum value encountered so far (potential nums[i])</span>
        <span class="kt">int</span> <span class="n">preMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each number in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate potential answer using current number as nums[k]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">maxDiff</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span>
            <span class="c1">// Update maxDiff: current number could be nums[j]</span>
            <span class="n">maxDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDiff</span><span class="o">,</span> <span class="n">preMax</span> <span class="o">-</span> <span class="n">x</span><span class="o">);</span>
            <span class="c1">// Update preMax: current number could be nums[i]</span>
            <span class="n">preMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">preMax</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases array with example inputs</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span>    <span class="c1">// Expected output: 77  ( ( 12-1)*7)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">19</span><span class="o">},</span>   <span class="c1">// Expected output: 133 ( ( 10-3)*19)</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>            <span class="c1">// Expected output: 0   (no valid positive value possible)</span>
        <span class="o">};</span>

        <span class="c1">// Run all test cases and print results</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testCases</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maximumTripletValue</span><span class="o">(</span><span class="n">testCases</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i &lt; j &lt; k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j ] ) * nums[k].]]></summary></entry><entry><title type="html">2140. Solving Questions With Brainpower</title><link href="https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower/" rel="alternate" type="text/html" title="2140. Solving Questions With Brainpower"/><published>2025-04-01T00:00:00+00:00</published><updated>2025-04-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/SolvingQuestionsWithBrainpower/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D integer array <code class="language-plaintext highlighter-rouge">questions</code> where <code class="language-plaintext highlighter-rouge">questions[i] = [pointsi, brainpoweri]</code>.</li> <li>The array describes the questions of an exam, where you have to process the questions <strong>in order</strong> (i.e., starting from question <code class="language-plaintext highlighter-rouge">0</code>) and make a decision whether to <strong>solve</strong> or <strong>skip</strong> each question. Solving question <code class="language-plaintext highlighter-rouge">i</code> will <strong>earn</strong> you <code class="language-plaintext highlighter-rouge">pointsi</code> points but you will be <strong>unable</strong> to solve each of the next <code class="language-plaintext highlighter-rouge">brainpoweri</code> questions. If you skip question <code class="language-plaintext highlighter-rouge">i</code>, you get to make the decision on the next question. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">questions = [ [ 3, 2], [4, 3], [4, 4], [2, 5 ] ]</code>: <ul> <li>If question <code class="language-plaintext highlighter-rouge">0</code> is solved, you will earn <code class="language-plaintext highlighter-rouge">3</code> points but you will be unable to solve questions <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">2</code>.</li> <li>If instead, question <code class="language-plaintext highlighter-rouge">0</code> is skipped and question <code class="language-plaintext highlighter-rouge">1</code> is solved, you will earn <code class="language-plaintext highlighter-rouge">4</code> points but you will be unable to solve questions <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code>.</li> </ul> </li> </ul> </li> <li>Return <em>the <strong>maximum</strong> points you can earn for the exam</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: questions = [ [ 3,2],[4,3],[4,4],[2,5 ] ]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: questions = [ [ 1,1],[2,2],[3,3],[4,4],[5,5 ] ]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengxingxing
 * Date: 2025/04/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SolvingQuestionsWithBrainpower</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">mostPoints</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">questions</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Total number of questions.</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">questions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// dp[i] stores the maximum points obtainable from question i to the end.</span>
        <span class="c1">// dp[n] is the base case (0 points) for when we are beyond the last question.</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Iterate from the last question backwards.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="c1">// Retrieve the points for the current question.</span>
            <span class="kt">int</span> <span class="n">points</span> <span class="o">=</span> <span class="n">questions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="c1">// Retrieve the brainpower value (number of questions to skip after solving this question).</span>
            <span class="kt">int</span> <span class="n">jump</span> <span class="o">=</span> <span class="n">questions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Determine the next question index after solving the current one.</span>
            <span class="c1">// Ensure that nextPosition does not exceed the array bounds.</span>
            <span class="kt">int</span> <span class="n">nextPosition</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">jump</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="c1">// Two options at this question:</span>
            <span class="c1">// Option 1: Solve this question → points + dp[nextPosition]</span>
            <span class="c1">// Option 2: Skip this question → dp[i + 1]</span>
            <span class="c1">// Choose the maximum of the two.</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">points</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">nextPosition</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// dp[0] holds the maximum points obtainable starting from the first question.</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1:</span>
        <span class="c1">// Explanation: Optimal strategy is to solve question 0 (3 points) and question 3 (2 points),</span>
        <span class="c1">// resulting in a total of 5 points.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">questions1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">mostPoints</span><span class="o">(</span><span class="n">questions1</span><span class="o">));</span>  <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 2:</span>
        <span class="c1">// Explanation: Optimal strategy is to skip question 0, solve question 1 (2 points)</span>
        <span class="c1">// and question 4 (5 points), resulting in a total of 7 points.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">questions2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">mostPoints</span><span class="o">(</span><span class="n">questions2</span><span class="o">));</span>  <span class="c1">// Expected output: 7</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri]. The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question. For example, given questions=[ [ 3, 2], [4, 3], [4, 4], [2, 5 ] ]: If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2. If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3. Return the maximum points you can earn for the exam.]]></summary></entry><entry><title type="html">1898. Maximum Number of Removable Characters</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfRemovableCharacters/" rel="alternate" type="text/html" title="1898. Maximum Number of Removable Characters"/><published>2025-03-31T00:00:00+00:00</published><updated>2025-03-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfRemovableCharacters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfRemovableCharacters/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">p</code> where <code class="language-plaintext highlighter-rouge">p</code> is a <strong>subsequence</strong> of <code class="language-plaintext highlighter-rouge">s</code>. You are also given a <strong>distinct 0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">removable</code> containing a subset of indices of <code class="language-plaintext highlighter-rouge">s</code> (<code class="language-plaintext highlighter-rouge">s</code> is also <strong>0-indexed</strong>).</li> <li>You want to choose an integer <code class="language-plaintext highlighter-rouge">k</code> (<code class="language-plaintext highlighter-rouge">0 &lt;= k &lt;= removable.length</code>) such that, after removing <code class="language-plaintext highlighter-rouge">k</code> characters from <code class="language-plaintext highlighter-rouge">s</code> using the <strong>first</strong> <code class="language-plaintext highlighter-rouge">k</code> indices in <code class="language-plaintext highlighter-rouge">removable</code>, <code class="language-plaintext highlighter-rouge">p</code> is still a <strong>subsequence</strong> of <code class="language-plaintext highlighter-rouge">s</code>. More formally, you will mark the character at <code class="language-plaintext highlighter-rouge">s[removable[i]]</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; k</code>, then remove all marked characters and check if <code class="language-plaintext highlighter-rouge">p</code> is still a subsequence.</li> <li>Return <em>the <strong>maximum</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>you can choose such that</em> <code class="language-plaintext highlighter-rouge">p</code> <em>is still a <strong>subsequence</strong> of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>after the removals</em>.</li> <li>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcacb", p = "ab", removable = [3,1,0]
Output: 2
Explanation: After removing the characters at indices 3 and 1, "abcacb" becomes "accb".
"ab" is a subsequence of "accb".
If we remove the characters at indices 3, 1, and 0, "abcacb" becomes "ccb", and "ab" is no longer a subsequence.
Hence, the maximum k is 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcbddddd", p = "abcd", removable = [3,2,1,4,5,6]
Output: 1
Explanation: After removing the character at index 3, "abcbddddd" becomes "abcddddd".
"abcd" is a subsequence of "abcddddd".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcab", p = "abc", removable = [0,1,2,3,4]
Output: 0
Explanation: If you remove the first index in the array removable, "abc" is no longer a subsequence.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(m)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfRemovableCharacters</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumRemovals</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">removable</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize binary search boundaries</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">removable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Binary search process</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate middle point (using ceiling division to avoid infinite loop)</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If we can remove mid characters, try removing more</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canRemoveKCharacters</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">removable</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we can't remove mid characters, try removing fewer</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canRemoveKCharacters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">removable</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create boolean array to mark characters that should be removed</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">removed</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>

        <span class="c1">// Mark first k positions from removable array as true</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">removed</span><span class="o">[</span><span class="n">removable</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Use two pointers to check if p is still a subsequence</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Pointer for string p</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Skip removed characters</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">removed</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If characters match, advance pointer for string p</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return true if we found all characters of p</span>
        <span class="k">return</span> <span class="n">j</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcacb"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">p1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">removable1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maximumRemovals</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">p1</span><span class="o">,</span> <span class="n">removable1</span><span class="o">));</span>

        <span class="c1">// Test Case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcbddddd"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">p2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">removable2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maximumRemovals</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">p2</span><span class="o">,</span> <span class="n">removable2</span><span class="o">));</span>

        <span class="c1">// Test Case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abcab"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">p3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">removable3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maximumRemovals</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">p3</span><span class="o">,</span> <span class="n">removable3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed). You want to choose an integer k (0 &lt;= k &lt;= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 &lt;= i &lt; k, then remove all marked characters and check if p is still a subsequence. Return the maximum k you can choose such that p is still a subsequence of s after the removals. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.]]></summary></entry><entry><title type="html">2278. Percentage of Letter in String</title><link href="https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString/" rel="alternate" type="text/html" title="2278. Percentage of Letter in String"/><published>2025-03-31T00:00:00+00:00</published><updated>2025-03-31T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PercentageOfLetterInString/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a character <code class="language-plaintext highlighter-rouge">letter</code>, return <em>the <strong>percentage</strong> of characters in</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that equal</em> <code class="language-plaintext highlighter-rouge">letter</code> <em><strong>rounded down</strong> to the nearest whole percent.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "foobar", letter = "o"
Output: 33
Explanation:
The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "jjjj", letter = "k"
Output: 0
Explanation:
The percentage of characters in s that equal the letter 'k' is 0%, so we return 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/31
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PercentageOfLetterInString</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">percentageLetter</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">letter</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize counter to track letter occurrences</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Increment counter when matching letter is found</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">letter</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Calculate and return the percentage rounded down</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">count</span> <span class="o">*</span> <span class="mi">100</span><span class="o">)</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String with multiple occurrences of target letter</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"foobar"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter1</span> <span class="o">=</span> <span class="sc">'o'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">letter1</span><span class="o">));</span> <span class="c1">// Expected output: 33</span>

        <span class="c1">// Test Case 2: String without any occurrence of target letter</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"jjjj"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter2</span> <span class="o">=</span> <span class="sc">'k'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">letter2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test Case 3: Additional test case with target letter 'e'</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"percentage"</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">letter3</span> <span class="o">=</span> <span class="sc">'e'</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">percentageLetter</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">letter3</span><span class="o">));</span> <span class="c1">// Expected output: 30</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.]]></summary></entry><entry><title type="html">2109. Adding Spaces to a String</title><link href="https://zhengstar94.github.io//blog/2025/AddingSpacesToAString/" rel="alternate" type="text/html" title="2109. Adding Spaces to a String"/><published>2025-03-30T00:00:00+00:00</published><updated>2025-03-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AddingSpacesToAString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AddingSpacesToAString/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> string <code class="language-plaintext highlighter-rouge">s</code> and a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">spaces</code> that describes the indices in the original string where spaces will be added. Each space should be inserted <strong>before</strong> the character at the given index. <ul> <li>For example, given <code class="language-plaintext highlighter-rouge">s = "EnjoyYourCoffee"</code> and <code class="language-plaintext highlighter-rouge">spaces = [5, 9]</code>, we place spaces before <code class="language-plaintext highlighter-rouge">'Y'</code> and <code class="language-plaintext highlighter-rouge">'C'</code>, which are at indices <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">9</code> respectively. Thus, we obtain <code class="language-plaintext highlighter-rouge">"Enjoy **Y**our **C**offee"</code>.</li> </ul> </li> <li>Return <em>the modified string <strong>after</strong> the spaces have been added.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "LeetcodeHelpsMeLearn", spaces = [8,13,15]
Output: "Leetcode Helps Me Learn"
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in "LeetcodeHelpsMeLearn".
We then place spaces before those characters.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "icodeinpython", spaces = [1,5,7,9]
Output: "i code in py thon"
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in "icodeinpython".
We then place spaces before those characters.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "spacing", spaces = [0,1,2,3,4,5,6]
Output: " s p a c i n g"
Explanation:
We are also able to place spaces before the first character of the string.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddingSpacesToAString</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">addSpaces</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize StringBuilder with optimal capacity to avoid resizing</span>
        <span class="nc">StringBuilder</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="n">spaces</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

        <span class="c1">// Counter for tracking the current position in spaces array</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if we need to add a space at current position</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">spaces</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">spaces</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">' '</span><span class="o">);</span>
                <span class="n">j</span><span class="o">++;</span> <span class="c1">// Move to next space position</span>
            <span class="o">}</span>
            <span class="c1">// Append the current character from input string</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Adding spaces in a camel case string</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"LeetcodeHelpsMeLearn"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">spaces1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Adding spaces in a lowercase string</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"icodeinpython"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">spaces2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Adding spaces between every character</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"spacing"</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">spaces3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">addSpaces</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">spaces3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode TwoPointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index. For example, given s="EnjoyYourCoffee" and spaces=[5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain "Enjoy **Y**our **C**offee". Return the modified string after the spaces have been added.]]></summary></entry><entry><title type="html">763. Partition Labels</title><link href="https://zhengstar94.github.io//blog/2025/PartitionLabels/" rel="alternate" type="text/html" title="763. Partition Labels"/><published>2025-03-30T00:00:00+00:00</published><updated>2025-03-30T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PartitionLabels</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PartitionLabels/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string <code class="language-plaintext highlighter-rouge">"ababcc"</code> can be partitioned into <code class="language-plaintext highlighter-rouge">["abab", "cc"]</code>, but partitions such as <code class="language-plaintext highlighter-rouge">["aba", "bcc"]</code> or <code class="language-plaintext highlighter-rouge">["ab", "ab", "cc"]</code> are invalid.</li> <li>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Return <em>a list of integers representing the size of these parts</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "eccbbbbdec"
Output: [10]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PartitionLabels</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">partitionLabels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the last position of each character (a-z)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">lastPos</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// First pass: Record the last occurrence of each character</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lastPos</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// List to store the sizes of partitions</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Variables to track partition boundaries</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Start index of current partition</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// End index of current partition</span>

        <span class="c1">// Second pass: Determine partition boundaries</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update the end position of current partition</span>
            <span class="c1">// by taking the maximum of current end and last occurrence of current character</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">lastPos</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]);</span>

            <span class="c1">// If we've reached the end of current partition</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Calculate partition size and add to result</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update start position for next partition</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: String with multiple partitions</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"ababcbacadefegdehijhklij"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span> <span class="c1">// Expected output: [9,7,8]</span>

        <span class="c1">// Test Case 2: String with single partition</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"eccbbbbdec"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected output: [10]</span>

        <span class="c1">// Test Case 3: String where each character forms its own partition</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">partitionLabels</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span> <span class="c1">// Expected output: [1,1,1]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string "ababcc" can be partitioned into ["abab", "cc"], but partitions such as ["aba", "bcc"] or ["ab", "ab", "cc"] are invalid. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.]]></summary></entry><entry><title type="html">1023. Camelcase Matching</title><link href="https://zhengstar94.github.io//blog/2025/CamelcaseMatching/" rel="alternate" type="text/html" title="1023. Camelcase Matching"/><published>2025-03-28T00:00:00+00:00</published><updated>2025-03-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CamelcaseMatching</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CamelcaseMatching/"><![CDATA[<ul> <li>Given an array of strings <code class="language-plaintext highlighter-rouge">queries</code> and a string <code class="language-plaintext highlighter-rouge">pattern</code>, return a boolean array <code class="language-plaintext highlighter-rouge">answer</code> where <code class="language-plaintext highlighter-rouge">answer[i]</code> is <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">queries[i]</code> matches <code class="language-plaintext highlighter-rouge">pattern</code>, and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li> <li>A query word <code class="language-plaintext highlighter-rouge">queries[i]</code> matches <code class="language-plaintext highlighter-rouge">pattern</code> if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters <strong>at all</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
Output: [true,false,true,true,false]
Explanation: "FooBar" can be generated like this "F" + "oo" + "B" + "ar".
"FootBall" can be generated like this "F" + "oot" + "B" + "all".
"FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
Output: [true,false,true,false,false]
Explanation: "FooBar" can be generated like this "Fo" + "o" + "Ba" + "r".
"FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
Output: [false,true,false,false,false]
Explanation: "FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CamelcaseMatching</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="nf">camelMatch</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">queries</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize result list to store matching results</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Check each query string against the pattern</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">query:</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">isMatch</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="n">pattern</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">query</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize pattern pointer</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in query</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Case 1: Current characters match</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span> <span class="c1">// Move pattern pointer forward</span>
            <span class="o">}</span>
            <span class="c1">// Case 2: Current query character is uppercase but doesn't match</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">(</span><span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Uppercase must match pattern</span>
            <span class="o">}</span>
            <span class="c1">// Case 3: Current query character is lowercase and doesn't match</span>
            <span class="c1">// Simply continue to next character (implicit)</span>
        <span class="o">}</span>

        <span class="c1">// Return true only if we've matched all characters in pattern</span>
        <span class="k">return</span> <span class="n">j</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Pattern "FB"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">queries1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"FooBar"</span><span class="o">,</span><span class="s">"FooBarTest"</span><span class="o">,</span><span class="s">"FootBall"</span><span class="o">,</span><span class="s">"FrameBuffer"</span><span class="o">,</span><span class="s">"ForceFeedBack"</span><span class="o">};</span>
        <span class="nc">String</span> <span class="n">pattern1</span> <span class="o">=</span> <span class="s">"FB"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">camelMatch</span><span class="o">(</span><span class="n">queries1</span><span class="o">,</span> <span class="n">pattern1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

        <span class="c1">// Test case 2: Pattern "FoBa"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">queries2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"FooBar"</span><span class="o">,</span><span class="s">"FooBarTest"</span><span class="o">,</span><span class="s">"FootBall"</span><span class="o">,</span><span class="s">"FrameBuffer"</span><span class="o">,</span><span class="s">"ForceFeedBack"</span><span class="o">};</span>
        <span class="nc">String</span> <span class="n">pattern2</span> <span class="o">=</span> <span class="s">"FoBa"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">camelMatch</span><span class="o">(</span><span class="n">queries2</span><span class="o">,</span> <span class="n">pattern2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>

        <span class="c1">// Test case 3: Pattern "FoBaT"</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">queries3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"FooBar"</span><span class="o">,</span><span class="s">"FooBarTest"</span><span class="o">,</span><span class="s">"FootBall"</span><span class="o">,</span><span class="s">"FrameBuffer"</span><span class="o">,</span><span class="s">"ForceFeedBack"</span><span class="o">};</span>
        <span class="nc">String</span> <span class="n">pattern3</span> <span class="o">=</span> <span class="s">"FoBaT"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">camelMatch</span><span class="o">(</span><span class="n">queries3</span><span class="o">,</span> <span class="n">pattern3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise. A query word queries[i] matches pattern if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters at all.]]></summary></entry><entry><title type="html">2825. Make String a Subsequence Using Cyclic Increments</title><link href="https://zhengstar94.github.io//blog/2025/MakeStringASubsequenceUsingCyclicIncrements/" rel="alternate" type="text/html" title="2825. Make String a Subsequence Using Cyclic Increments"/><published>2025-03-27T00:00:00+00:00</published><updated>2025-03-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MakeStringASubsequenceUsingCyclicIncrements</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MakeStringASubsequenceUsingCyclicIncrements/"><![CDATA[<ul> <li>You are given two <strong>0-indexed</strong> strings <code class="language-plaintext highlighter-rouge">str1</code> and <code class="language-plaintext highlighter-rouge">str2</code>.</li> <li>In an operation, you select a <strong>set</strong> of indices in <code class="language-plaintext highlighter-rouge">str1</code>, and for each index <code class="language-plaintext highlighter-rouge">i</code> in the set, increment <code class="language-plaintext highlighter-rouge">str1[i]</code> to the next character <strong>cyclically</strong>. That is <code class="language-plaintext highlighter-rouge">'a'</code> becomes <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'b'</code> becomes <code class="language-plaintext highlighter-rouge">'c'</code>, and so on, and <code class="language-plaintext highlighter-rouge">'z'</code> becomes <code class="language-plaintext highlighter-rouge">'a'</code>.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if it is possible to make</em> <code class="language-plaintext highlighter-rouge">str2</code> <em>a subsequence of</em> <code class="language-plaintext highlighter-rouge">str1</code> <em>by performing the operation <strong>at most once</strong></em>, <em>and</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> <li><strong>Note:</strong> A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: str1 = "abc", str2 = "ad"
Output: true
Explanation: Select index 2 in str1.
Increment str1[2] to become 'd'. 
Hence, str1 becomes "abd" and str2 is now a subsequence. Therefore, true is returned.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: str1 = "zc", str2 = "ad"
Output: true
Explanation: Select indices 0 and 1 in str1. 
Increment str1[0] to become 'a'. 
Increment str1[1] to become 'd'. 
Hence, str1 becomes "ad" and str2 is now a subsequence. Therefore, true is returned.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: str1 = "ab", str2 = "d"
Output: false
Explanation: In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once. 
Therefore, false is returned.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MakeStringASubsequenceUsingCyclicIncrements</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canMakeSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">str1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">str2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers: i for str1 and j for str2</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue while we haven't reached the end of either string</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Calculate the next character after cyclic increment</span>
            <span class="c1">// For example: 'a' -&gt; 'b', 'b' -&gt; 'c', ..., 'z' -&gt; 'a'</span>
            <span class="c1">// Formula explanation:</span>
            <span class="c1">// 1. str1.charAt(i) - 'a': Convert char to 0-based index (0-25)</span>
            <span class="c1">// 2. + 1: Increment to next character</span>
            <span class="c1">// 3. % 26: Handle cyclic wrap-around ('z' -&gt; 'a')</span>
            <span class="c1">// 4. + 'a': Convert back to character</span>
            <span class="kt">char</span> <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)((</span><span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="mi">26</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">);</span>

            <span class="c1">// If current character in str1 matches str2</span>
            <span class="c1">// OR the next character after increment matches str2</span>
            <span class="c1">// then advance the j pointer</span>
            <span class="k">if</span><span class="o">(</span><span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">||</span> <span class="n">next</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Always advance the i pointer to check next character in str1</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Return true if we matched all characters in str2 (j reached the end)</span>
        <span class="k">return</span> <span class="n">j</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Should return true</span>
        <span class="c1">// We can change 'c' to 'd' to make "abd", which contains "ad"</span>
        <span class="nc">String</span> <span class="n">str1_1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str2_1</span> <span class="o">=</span> <span class="s">"ad"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">canMakeSubsequence</span><span class="o">(</span><span class="n">str1_1</span><span class="o">,</span> <span class="n">str2_1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Should return true</span>
        <span class="c1">// We can change 'z' to 'a' and 'c' to 'd' to make "ad"</span>
        <span class="nc">String</span> <span class="n">str1_2</span> <span class="o">=</span> <span class="s">"zc"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str2_2</span> <span class="o">=</span> <span class="s">"ad"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">canMakeSubsequence</span><span class="o">(</span><span class="n">str1_2</span><span class="o">,</span> <span class="n">str2_2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Should return false</span>
        <span class="c1">// Cannot make "d" a subsequence with just one increment operation</span>
        <span class="nc">String</span> <span class="n">str1_3</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str2_3</span> <span class="o">=</span> <span class="s">"d"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">canMakeSubsequence</span><span class="o">(</span><span class="n">str1_3</span><span class="o">,</span> <span class="n">str2_3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two 0-indexed strings str1 and str2. In an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'. Return true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise. Note: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.]]></summary></entry><entry><title type="html">2486. Append Characters to String to Make Subsequence</title><link href="https://zhengstar94.github.io//blog/2025/AppendCharactersToStringToMakeSubsequence/" rel="alternate" type="text/html" title="2486. Append Characters to String to Make Subsequence"/><published>2025-03-26T00:00:00+00:00</published><updated>2025-03-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/AppendCharactersToStringToMakeSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/AppendCharactersToStringToMakeSubsequence/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> consisting of only lowercase English letters.</li> <li>Return <em>the minimum number of characters that need to be appended to the end of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>so that</em> <code class="language-plaintext highlighter-rouge">t</code> <em>becomes a <strong>subsequence</strong> of</em> <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "coaching", t = "coding"
Output: 4
Explanation: Append the characters "ding" to the end of s so that s = "coachingding".
Now, t is a subsequence of s ("coachingding").
It can be shown that appending any 3 characters to the end of s will never make t a subsequence.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcde", t = "a"
Output: 0
Explanation: t is already a subsequence of s ("abcde").
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "z", t = "abcde"
Output: 5
Explanation: Append the characters "abcde" to the end of s so that s = "zabcde".
Now, t is a subsequence of s ("zabcde").
It can be shown that appending any 4 characters to the end of s will never make t a subsequence.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer.DoubleSeqSubsequencePointers</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/03/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppendCharactersToStringToMakeSubsequence</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">appendCharacters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers, i for string s and j for string t</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Loop until we reach the end of either string s or string t</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// If the current characters of s and t match</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Move the pointer j to the next character in t</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// Always move the pointer i to the next character in s</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// The number of characters that need to be appended is the remaining characters in t</span>
        <span class="c1">// that have not been matched, which is t.length() - j</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"coaching"</span><span class="o">;</span> <span class="c1">// Original string</span>
        <span class="nc">String</span> <span class="n">t1</span> <span class="o">=</span> <span class="s">"coding"</span><span class="o">;</span>   <span class="c1">// Target string</span>
        <span class="c1">// Output the result of the appendCharacters method</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 1 Output: "</span> <span class="o">+</span> <span class="n">appendCharacters</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">t1</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span> <span class="c1">// Original string</span>
        <span class="nc">String</span> <span class="n">t2</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>     <span class="c1">// Target string</span>
        <span class="c1">// Output the result of the appendCharacters method</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 2 Output: "</span> <span class="o">+</span> <span class="n">appendCharacters</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">t2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 3</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"z"</span><span class="o">;</span>     <span class="c1">// Original string</span>
        <span class="nc">String</span> <span class="n">t3</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span> <span class="c1">// Target string</span>
        <span class="c1">// Output the result of the appendCharacters method</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Example 3 Output: "</span> <span class="o">+</span> <span class="n">appendCharacters</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">t3</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DoubleSeqSubsequencePointers"/><category term="Medium"/><category term="TwoPointers"/><summary type="html"><![CDATA[You are given two strings s and t consisting of only lowercase English letters. Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.]]></summary></entry></feed>