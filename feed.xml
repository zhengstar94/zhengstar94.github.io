<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-15T02:29:13+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">3136. Valid Word</title><link href="https://zhengstar94.github.io//blog/2025/ValidWord/" rel="alternate" type="text/html" title="3136. Valid Word"/><published>2025-07-15T00:00:00+00:00</published><updated>2025-07-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ValidWord</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ValidWord/"><![CDATA[<ul> <li>A word is considered <strong>valid</strong> if: <ul> <li>It contains a <strong>minimum</strong> of 3 characters.</li> <li>It contains only digits (0-9), and English letters (uppercase and lowercase).</li> <li>It includes <strong>at least</strong> one <strong>vowel</strong>.</li> <li>It includes <strong>at least</strong> one <strong>consonant</strong>.</li> </ul> </li> <li>You are given a string <code class="language-plaintext highlighter-rouge">word</code>.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">word</code> is valid, otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> <li><strong>Notes:</strong> <ul> <li><code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'e'</code>, <code class="language-plaintext highlighter-rouge">'i'</code>, <code class="language-plaintext highlighter-rouge">'o'</code>, <code class="language-plaintext highlighter-rouge">'u'</code>, and their uppercases are <strong>vowels</strong>.</li> <li>A <strong>consonant</strong> is an English letter that is not a vowel.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "234Adas"

Output: true

Explanation:

This word satisfies the conditions.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "b3"

Output: false

Explanation:

The length of this word is fewer than 3, and does not have a vowel.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "a3$e"

Output: false

Explanation:

This word contains a '$' character and does not have a consonant.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidWord</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the word has fewer than 3 characters, it is automatically invalid.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Flags to track if at least one vowel and one consonant are present.</span>
        <span class="kt">boolean</span> <span class="n">hasVowel</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">hasConsonant</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="c1">// String containing all vowels (both lowercase and uppercase).</span>
        <span class="nc">String</span> <span class="n">vowels</span> <span class="o">=</span> <span class="s">"aeiouAEIOU"</span><span class="o">;</span>

        <span class="c1">// Iterate through each character in the word.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Check if the character is a letter.</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// If the character is a vowel, set hasVowel to true.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">vowels</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">hasVowel</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// If the character is a letter but not a vowel, it's a consonant.</span>
                    <span class="n">hasConsonant</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// If the character is neither a letter nor a digit, the word is invalid.</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If the character is a digit, do nothing (digits are allowed).</span>
        <span class="o">}</span>

        <span class="c1">// The word is valid only if it contains at least one vowel and one consonant.</span>
        <span class="c1">// Note: Use logical AND (&amp;&amp;) to ensure both conditions are met.</span>
        <span class="k">return</span> <span class="n">hasVowel</span> <span class="o">&amp;&amp;</span> <span class="n">hasConsonant</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to verify the implementation.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"234Adas"</span><span class="o">));</span> <span class="c1">// true: meets all conditions</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"b3"</span><span class="o">));</span>      <span class="c1">// false: too short and no vowel</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="s">"a3$e"</span><span class="o">));</span>    <span class="c1">// false: contains invalid character '$'</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Easy"/><summary type="html"><![CDATA[A word is considered valid if: It contains a minimum of 3 characters. It contains only digits (0-9), and English letters (uppercase and lowercase). It includes at least one vowel. It includes at least one consonant. You are given a string word. Return true if word is valid, otherwise, return false. Notes: 'a', 'e', 'i', 'o', 'u', and their uppercases are vowels. A consonant is an English letter that is not a vowel.]]></summary></entry><entry><title type="html">1290. Convert Binary Number in a Linked List to Integer</title><link href="https://zhengstar94.github.io//blog/2025/ConvertBinaryNumberInALinkedListToInteger/" rel="alternate" type="text/html" title="1290. Convert Binary Number in a Linked List to Integer"/><published>2025-07-14T00:00:00+00:00</published><updated>2025-07-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ConvertBinaryNumberInALinkedListToInteger</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ConvertBinaryNumberInALinkedListToInteger/"><![CDATA[<ul> <li>Given <code class="language-plaintext highlighter-rouge">head</code> which is a reference node to a singly-linked list. The value of each node in the linked list is either <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">1</code>. The linked list holds the binary representation of a number.</li> <li>Return the <em>decimal value</em> of the number in the linked list.</li> <li>The <strong>most significant bit</strong> is at the head of the linked list.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [0]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.LinkList</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/14
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConvertBinaryNumberInALinkedListToInteger</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getDecimalValue</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This variable will store the final decimal result.</span>

        <span class="c1">// Traverse the linked list from head to tail.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Shift the current result left by 1 bit (multiply by 2).</span>
            <span class="c1">// This makes space for the next bit at the least significant position.</span>
            <span class="c1">// Then add the current node's value (0 or 1) to the result.</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

            <span class="c1">// Move to the next node in the list.</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// After traversing all nodes, 'res' contains the decimal value.</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: Linked list [1,0,1] represents binary 101, which is 5 in decimal.</span>
        <span class="nc">ListNode</span> <span class="n">head1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getDecimalValue</span><span class="o">(</span><span class="n">head1</span><span class="o">));</span> <span class="c1">// Output: 5</span>

        <span class="c1">// Example 2: Linked list [0] represents binary 0, which is 0 in decimal.</span>
        <span class="nc">ListNode</span> <span class="n">head2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getDecimalValue</span><span class="o">(</span><span class="n">head2</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode LinkedList"/><category term="Easy"/><summary type="html"><![CDATA[Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list.]]></summary></entry><entry><title type="html">2410. Maximum Matching of Players With Trainers</title><link href="https://zhengstar94.github.io//blog/2025/MaximumMatchingOfPlayersWithTrainers/" rel="alternate" type="text/html" title="2410. Maximum Matching of Players With Trainers"/><published>2025-07-13T00:00:00+00:00</published><updated>2025-07-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumMatchingOfPlayersWithTrainers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumMatchingOfPlayersWithTrainers/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">players</code>, where <code class="language-plaintext highlighter-rouge">players[i]</code> represents the <strong>ability</strong> of the <code class="language-plaintext highlighter-rouge">ith</code> player.</li> <li>You are also given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">trainers</code>, where <code class="language-plaintext highlighter-rouge">trainers[j]</code> represents the <strong>training capacity</strong> of the <code class="language-plaintext highlighter-rouge">jth</code> trainer.</li> <li>The <code class="language-plaintext highlighter-rouge">ith</code> player can <strong>match</strong> with the <code class="language-plaintext highlighter-rouge">jth</code> trainer if the player’s ability is <strong>less than or equal to</strong> the trainer’s training capacity. Additionally, the <code class="language-plaintext highlighter-rouge">ith</code> player can be matched with at most one trainer, and the <code class="language-plaintext highlighter-rouge">jth</code> trainer can be matched with at most one player.</li> <li>Return <em>the <strong>maximum</strong> number of matchings between</em> <code class="language-plaintext highlighter-rouge">players</code> <em>and</em> <code class="language-plaintext highlighter-rouge">trainers</code> <em>that satisfy these conditions.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: players = [4,7,9], trainers = [8,2,5,8]
Output: 2
Explanation:
One of the ways we can form two matchings is as follows:
- players[0] can be matched with trainers[0] since 4 &lt;= 8.
- players[1] can be matched with trainers[3] since 7 &lt;= 8.
It can be proven that 2 is the maximum number of matchings that can be formed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: players = [1,1,1], trainers = [10]
Output: 1
Explanation:
The trainer can be matched with any of the 3 players.
Each player can only be matched with one trainer, so the maximum answer is 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn + mlogm) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumMatchingOfPlayersWithTrainers</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">matchPlayersAndTrainers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">players</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">trainers</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort both arrays in ascending order.</span>
        <span class="c1">// This allows us to use the greedy strategy: always try to match the weakest available player</span>
        <span class="c1">// with the weakest available trainer who can train them.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">players</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">trainers</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for players array</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for trainers array</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Counter for successful matchings</span>

        <span class="c1">// Use two pointers to traverse both arrays</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">players</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">trainers</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the current player can be matched with the current trainer</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">players</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">trainers</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Successful match: increment the count</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="c1">// Move to the next player and the next trainer</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If the current trainer is too weak for the current player,</span>
                <span class="c1">// try the next trainer (since trainers are sorted, no later trainer will be weaker)</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the total number of successful matchings</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output is 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">players1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">trainers1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">matchPlayersAndTrainers</span><span class="o">(</span><span class="n">players1</span><span class="o">,</span> <span class="n">trainers1</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="c1">// Test case 2: Expected output is 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">players2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">trainers2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">matchPlayersAndTrainers</span><span class="o">(</span><span class="n">players2</span><span class="o">,</span> <span class="n">trainers2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer. The ith player can match with the jth trainer if the player’s ability is less than or equal to the trainer’s training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player. Return the maximum number of matchings between players and trainers that satisfy these conditions.]]></summary></entry><entry><title type="html">3169. Count Days Without Meetings</title><link href="https://zhengstar94.github.io//blog/2025/CountDaysWithoutMeetings/" rel="alternate" type="text/html" title="3169. Count Days Without Meetings"/><published>2025-07-11T00:00:00+00:00</published><updated>2025-07-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountDaysWithoutMeetings</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountDaysWithoutMeetings/"><![CDATA[<ul> <li>You are given a positive integer <code class="language-plaintext highlighter-rouge">days</code> representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array <code class="language-plaintext highlighter-rouge">meetings</code> of size <code class="language-plaintext highlighter-rouge">n</code> where, <code class="language-plaintext highlighter-rouge">meetings[i] = [start_i, end_i]</code> represents the starting and ending days of meeting <code class="language-plaintext highlighter-rouge">i</code> (inclusive).</li> <li>Return the count of days when the employee is available for work but no meetings are scheduled.</li> <li><strong>Note:</strong> The meetings may overlap.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: days = 10, meetings = [ [ 5,7],[1,3],[9,10 ] ]

Output: 2

Explanation:

There is no meeting scheduled on the 4th and 8th days.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: days = 5, meetings = [ [ 2,4],[1,3 ] ]

Output: 1

Explanation:

There is no meeting scheduled on the 5th day.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: days = 6, meetings = [ [ 1,6 ] ]

Output: 0

Explanation:

Meetings are scheduled for all working days.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountDaysWithoutMeetings</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countDays</span><span class="o">(</span><span class="kt">int</span> <span class="n">days</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the meetings by their start day in ascending order.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">meetings</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">q</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// 'start' and 'end' represent the current merged meeting interval.</span>
        <span class="c1">// Initialize 'start' to 1 (the first day), and 'end' to 0 (no interval yet).</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each meeting interval.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">p</span> <span class="o">:</span> <span class="n">meetings</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the current meeting starts after the end of the last merged interval,</span>
            <span class="c1">// it means there is a gap (no meeting) between intervals.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">end</span><span class="o">){</span>
                <span class="c1">// Subtract the number of days covered by the previous merged interval from 'days'.</span>
                <span class="c1">// (end - start + 1) is the length of the previous interval.</span>
                <span class="n">days</span> <span class="o">-=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="c1">// Start a new merged interval from the current meeting's start day.</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">p</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="c1">// Extend the end of the current merged interval if needed.</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">p</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">// After the loop, subtract the days covered by the last merged interval.</span>
        <span class="n">days</span> <span class="o">-=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// The remaining 'days' is the number of days without any meetings.</span>
        <span class="k">return</span> <span class="n">days</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span> <span class="n">days1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countDays</span><span class="o">(</span><span class="n">days1</span><span class="o">,</span> <span class="n">meetings1</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span> <span class="n">days2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countDays</span><span class="o">(</span><span class="n">days2</span><span class="o">,</span> <span class="n">meetings2</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span> <span class="n">days3</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">meetings3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">6</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">countDays</span><span class="o">(</span><span class="n">days3</span><span class="o">,</span> <span class="n">meetings3</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive). Return the count of days when the employee is available for work but no meetings are scheduled. Note: The meetings may overlap.]]></summary></entry><entry><title type="html">3439. Reschedule Meetings for Maximum Free Time I</title><link href="https://zhengstar94.github.io//blog/2025/RescheduleMeetingsForMaximumFreeTimeI/" rel="alternate" type="text/html" title="3439. Reschedule Meetings for Maximum Free Time I"/><published>2025-07-09T00:00:00+00:00</published><updated>2025-07-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RescheduleMeetingsForMaximumFreeTimeI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RescheduleMeetingsForMaximumFreeTimeI/"><![CDATA[<ul> <li> <p>You are given an integer <code class="language-plaintext highlighter-rouge">eventTime</code> denoting the duration of an event, where the event occurs from time <code class="language-plaintext highlighter-rouge">t = 0</code> to time <code class="language-plaintext highlighter-rouge">t = eventTime</code>.</p> </li> <li> <p>You are also given two integer arrays <code class="language-plaintext highlighter-rouge">startTime</code> and <code class="language-plaintext highlighter-rouge">endTime</code>, each of length <code class="language-plaintext highlighter-rouge">n</code>. These represent the start and end time of <code class="language-plaintext highlighter-rouge">n</code> <strong>non-overlapping</strong> meetings, where the <code class="language-plaintext highlighter-rouge">ith</code> meeting occurs during the time <code class="language-plaintext highlighter-rouge">[startTime[i], endTime[i]]</code>.</p> </li> <li> <p>You can reschedule <strong>at most</strong> <code class="language-plaintext highlighter-rouge">k</code> meetings by moving their start time while maintaining the <strong>same duration</strong>, to <strong>maximize</strong> the <strong>longest</strong> <em>continuous period of free time</em> during the event.</p> </li> <li> <p>The <strong>relative</strong> order of all the meetings should stay the <em>same</em> and they should remain non-overlapping.</p> <p>Return the <strong>maximum</strong> amount of free time possible after rearranging the meetings.</p> <p><strong>Note</strong> that the meetings can <strong>not</strong> be rescheduled to a time outside the event.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: eventTime = 5, k = 1, startTime = [1,3], endTime = [2,5]
Output: 2

Explanation:

Reschedule the meeting at [1, 2] to [2, 3], leaving no meetings during the time [0, 2].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: eventTime = 10, k = 1, startTime = [0,2,9], endTime = [1,4,10]

Output: 6

Explanation:

Reschedule the meeting at [2, 4] to [1, 3], leaving no meetings during the time [3, 9].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: eventTime = 5, k = 2, startTime = [0,1,2,3,4], endTime = [1,2,3,4,5]

Output: 0

Explanation:

There is no time during the event not occupied by meetings.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/09
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RescheduleMeetingsForMaximumFreeTimeI</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxFreeTime</span><span class="o">(</span><span class="kt">int</span> <span class="n">eventTime</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">startTime</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">endTime</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">startTime</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// The gaps array stores all free time intervals between meetings and at the boundaries.</span>
        <span class="c1">// gaps[0]: Free time from the start of the event to the first meeting.</span>
        <span class="c1">// gaps[i]: Free time between the end of meeting i-1 and the start of meeting i.</span>
        <span class="c1">// gaps[n]: Free time from the end of the last meeting to the end of the event.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">gaps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="n">gaps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">startTime</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Free time before the first meeting.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">gaps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">startTime</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">endTime</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// Free time between consecutive meetings.</span>
        <span class="o">}</span>
        <span class="n">gaps</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">eventTime</span> <span class="o">-</span> <span class="n">endTime</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// Free time after the last meeting.</span>

        <span class="c1">// Use a sliding window of size k+1 to merge k+1 consecutive free intervals.</span>
        <span class="kt">int</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Calculate the sum of the first window.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">gaps</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">windowSum</span><span class="o">;</span>
        <span class="c1">// Slide the window across the gaps array, updating the sum and tracking the maximum.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gaps</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">gaps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">gaps</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">windowSum</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">eventTime</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">startTime</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">endTime</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="c1">// Expected output: 6</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxFreeTime</span><span class="o">(</span><span class="n">eventTime</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">startTime</span><span class="o">,</span> <span class="n">endTime</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer eventTime denoting the duration of an event, where the event occurs from time t=0 to time t=eventTime.]]></summary></entry><entry><title type="html">1353. Maximum Number of Events That Can Be Attended</title><link href="https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum/" rel="alternate" type="text/html" title="1353. Maximum Number of Events That Can Be Attended"/><published>2025-07-07T00:00:00+00:00</published><updated>2025-07-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum/"><![CDATA[<ul> <li>You are given an array of <code class="language-plaintext highlighter-rouge">events</code> where <code class="language-plaintext highlighter-rouge">events[i] = [startDayi, endDayi]</code>. Every event <code class="language-plaintext highlighter-rouge">i</code> starts at <code class="language-plaintext highlighter-rouge">startDayi</code> and ends at <code class="language-plaintext highlighter-rouge">endDayi</code>.</li> <li>You can attend an event <code class="language-plaintext highlighter-rouge">i</code> at any day <code class="language-plaintext highlighter-rouge">d</code> where <code class="language-plaintext highlighter-rouge">startTimei &lt;= d &lt;= endTimei</code>. You can only attend one event at any time <code class="language-plaintext highlighter-rouge">d</code>.</li> <li>Return <em>the maximum number of events you can attend</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: events = [ [ 1,2],[2,3],[3,4 ] ]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: events= [ [ 1,2],[2,3],[3,4],[1,2 ] ]
Output: 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(U+nlogn) time | O(U) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindingPairsWithACertainSum</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxEvents</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">events</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Sort all events by their end day in ascending order.</span>
        <span class="c1">// Greedy strategy: Always try to attend the event that ends earliest.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">events</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

        <span class="c1">// Step 2: Find the latest end day among all events.</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">events</span><span class="o">[</span><span class="n">events</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Step 3: Initialize the Disjoint Set Union (DSU) parent array.</span>
        <span class="c1">// fa[x] represents the earliest available day &gt;= x.</span>
        <span class="c1">// The array size is mx + 2 to avoid out-of-bounds when marking the last day as used.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">fa</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">mx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fa</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">fa</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// Initially, each day is its own parent (available).</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Counter for the maximum number of events attended.</span>

        <span class="c1">// Step 4: Iterate through each event and try to schedule it.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">e</span> <span class="o">:</span> <span class="n">events</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Use DSU to find the earliest available day to attend this event,</span>
            <span class="c1">// starting from its start day.</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">e</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">fa</span><span class="o">);</span>

            <span class="c1">// If the found day is within the event's interval, attend the event.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">ans</span><span class="o">++;</span> <span class="c1">// Attend this event.</span>

                <span class="c1">// Mark this day as used by setting its parent to the next day.</span>
                <span class="c1">// This means the next search will skip this day.</span>
                <span class="n">fa</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If x &gt; e[1], it means there is no available day for this event.</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">fa</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fa</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Recursively find the root parent and compress the path.</span>
            <span class="n">fa</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">fa</span><span class="o">[</span><span class="n">x</span><span class="o">],</span> <span class="n">fa</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">fa</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">// Test cases to verify the implementation.</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">events1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">events2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxEvents</span><span class="o">(</span><span class="n">events1</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxEvents</span><span class="o">(</span><span class="n">events2</span><span class="o">));</span> <span class="c1">// Output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi. You can attend an event i at any day d where startTimei &lt;= d &lt;= endTimei. You can only attend one event at any time d. Return the maximum number of events you can attend.]]></summary></entry><entry><title type="html">1865. Finding Pairs With a Certain Sum</title><link href="https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum/" rel="alternate" type="text/html" title="1865. Finding Pairs With a Certain Sum"/><published>2025-07-06T00:00:00+00:00</published><updated>2025-07-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindingPairsWithACertainSum/"><![CDATA[<ul> <li>You are given two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>. You are tasked to implement a data structure that supports queries of two types: <ul> <li><strong>Add</strong> a positive integer to an element of a given index in the array <code class="language-plaintext highlighter-rouge">nums2</code>.</li> <li><strong>Count</strong> the number of pairs <code class="language-plaintext highlighter-rouge">(i, j)</code> such that <code class="language-plaintext highlighter-rouge">nums1[i] + nums2[j]</code> equals a given value (<code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; nums1.length</code> and <code class="language-plaintext highlighter-rouge">0 &lt;= j &lt; nums2.length</code>).</li> </ul> </li> <li>Implement the <code class="language-plaintext highlighter-rouge">FindSumPairs</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">FindSumPairs(int[] nums1, int[] nums2)</code> Initializes the <code class="language-plaintext highlighter-rouge">FindSumPairs</code> object with two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>.</li> <li><code class="language-plaintext highlighter-rouge">void add(int index, int val)</code> Adds <code class="language-plaintext highlighter-rouge">val</code> to <code class="language-plaintext highlighter-rouge">nums2[index]</code>, i.e., apply <code class="language-plaintext highlighter-rouge">nums2[index] += val</code>.</li> <li><code class="language-plaintext highlighter-rouge">int count(int tot)</code> Returns the number of pairs <code class="language-plaintext highlighter-rouge">(i, j)</code> such that <code class="language-plaintext highlighter-rouge">nums1[i] + nums2[j] == tot</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
[ [ [ 1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4 ] ], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7 ] ]
Output
[null, 8, null, 2, 1, null, null, 11]

Explanation
FindSumPairs findSumPairs = new FindSumPairs( [ 1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4 ] );
findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4
findSumPairs.add(3, 2); // now nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5
findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1
findSumPairs.add(0, 1); // now nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // now nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m) time | O(m + q) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindingPairsWithACertainSum</span> <span class="o">{</span>
    <span class="c1">// Store the first array as is, since it is not modified after initialization</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">;</span>
    <span class="c1">// Store the second array, which can be modified by add operations</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">;</span>
    <span class="c1">// HashMap to record the frequency of each number in nums2</span>
    <span class="c1">// Key: number in nums2, Value: how many times it appears in nums2</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">FindingPairsWithACertainSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums1</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">;</span>
        <span class="c1">// Build the frequency map for nums2</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each number x in nums2, increment its count in the map by 1.</span>
            <span class="c1">// If x is not present, it will be added with value 1.</span>
            <span class="c1">// If x is already present, its value will be increased by 1.</span>
            <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Decrease the count of the old value at nums2[index] in the frequency map.</span>
        <span class="c1">// This is because the value at this index is about to change.</span>
        <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">index</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>

        <span class="c1">// Step 2: Update nums2[index] by adding val to it.</span>
        <span class="n">nums2</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>

        <span class="c1">// Step 3: Increase the count of the new value at nums2[index] in the frequency map.</span>
        <span class="c1">// This ensures the map is always up-to-date with the current nums2.</span>
        <span class="n">cnt</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">index</span><span class="o">],</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">tot</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// For each element x in nums1, we want to find how many y in nums2 satisfy x + y == tot,</span>
        <span class="c1">// which is equivalent to y == tot - x.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// cnt.getOrDefault(tot - x, 0) gives the number of times (tot - x) appears in nums2.</span>
            <span class="c1">// Add this count to the answer.</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">tot</span> <span class="o">-</span> <span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Initialize the object with the given nums1 and nums2 arrays.</span>
        <span class="nc">FindingPairsWithACertainSum</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FindingPairsWithACertainSum</span><span class="o">(</span>
                <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span>
                <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">}</span>
        <span class="o">);</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// Constructor does not return a value.</span>

        <span class="c1">// Perform count and add operations as per the example.</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">7</span><span class="o">));</span> <span class="c1">// Returns 8</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// No return value</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">8</span><span class="o">));</span> <span class="c1">// Returns 2</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span> <span class="c1">// Returns 1</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// No return value</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// No return value</span>
        <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">7</span><span class="o">));</span> <span class="c1">// Returns 11</span>

        <span class="c1">// Print the output list, which matches the expected output format.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Medium"/><summary type="html"><![CDATA[You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types: Add a positive integer to an element of a given index in the array nums2. Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 &lt;= i &lt; nums1.length and 0 &lt;= j &lt; nums2.length). Implement the FindSumPairs class: FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2. void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val. int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums2[j] == tot.]]></summary></entry><entry><title type="html">Technical Guide to Distributed Unique IDs</title><link href="https://zhengstar94.github.io//blog/2025/TechnicalGuideToDistributedUniqueIDs/" rel="alternate" type="text/html" title="Technical Guide to Distributed Unique IDs"/><published>2025-07-06T00:00:00+00:00</published><updated>2025-07-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/TechnicalGuideToDistributedUniqueIDs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/TechnicalGuideToDistributedUniqueIDs/"><![CDATA[<h2 id="1-the-need-for-distributed-globally-unique-ids">1. The Need for Distributed, Globally Unique IDs</h2> <p>In traditional monolithic architectures, systems typically rely on a single database. The primary keys for business tables are often generated using the database’s <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> feature. This method is simple, reliable, and guarantees uniqueness within that single database.</p> <p>However, in modern distributed and microservices architectures, systems are often partitioned to handle high concurrency and massive data volumes. This means that data for a single business entity, such as “orders,” is spread across multiple database instances or tables. In such a scenario, if each shard independently uses its own <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> mechanism, ID collisions become inevitable, as illustrated below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/07/6-480.webp 480w,/assets/img/2025/07/6-800.webp 800w,/assets/img/2025/07/6-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/07/6.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Although the system architecture is distributed, at the business logic and user level, an order ID must be globally unique. Duplicate primary keys are unacceptable.</p> <p>Therefore, designing a high-performance, highly available, and globally unique ID generation scheme is a foundational requirement for any distributed system. This document provides an in-depth analysis of common distributed ID generation solutions.</p> <h2 id="2-common-distributed-id-generation-schemes">2. Common Distributed ID Generation Schemes</h2> <h3 id="21-uuid-universally-unique-identifier">2.1. UUID (Universally Unique Identifier)</h3> <p>A UUID is a 128-bit number used to identify information in computer systems. The theoretical number of possible UUIDs is <code class="language-plaintext highlighter-rouge">2^128</code>, making collisions practically impossible for the foreseeable future. The standard format is <code class="language-plaintext highlighter-rouge">8-4-4-4-12</code>, though hyphens are often removed in practice.</p> <p><strong>Key UUID Versions:</strong></p> <ul> <li><strong>Version 1 (Time-based):</strong> Generated from a timestamp, a random number, and the local MAC address. While unique, it can expose the MAC address, posing a security risk.</li> <li><strong>Version 2 (DCE Security):</strong> Similar to Version 1, but replaces parts of the timestamp with POSIX UID/GID. It is rarely used.</li> <li><strong>Version 3 (Name-based, MD 5):</strong> Generated from the MD 5 hash of a namespace and a name. It is deterministic: the same input produces the same UUID.</li> <li><strong>Version 4 (Random):</strong> Generated from random or pseudo-random numbers. This is the most common version, and it’s what <code class="language-plaintext highlighter-rouge">UUID.randomUUID()</code> in Java generates.</li> <li><strong>Version 5 (Name-based, SHA-1):</strong> Similar to Version 3 but uses the SHA-1 hashing algorithm.</li> </ul> <p><strong>Java Code Example:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.UUID</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UuidExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Version 4: Random UUID</span>
        <span class="no">UUID</span> <span class="n">randomUuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Random UUID: "</span> <span class="o">+</span> <span class="n">randomUuid</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>

        <span class="c1">// Version 3: Name-based UUID</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">nameBytes</span> <span class="o">=</span> <span class="s">"hello-world"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
        <span class="no">UUID</span> <span class="n">nameUuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">nameUUIDFromBytes</span><span class="o">(</span><span class="n">nameBytes</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Name-based UUID: "</span> <span class="o">+</span> <span class="n">nameUuid</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Analysis:</strong></p> <ul> <li><strong>Pros:</strong></li> <li><strong>Local Generation:</strong> Extremely high performance as no network requests are needed.</li> <li><strong>Global Uniqueness:</strong> The probability of collision is infinitesimally small.</li> <li><strong>Simplicity:</strong> Natively supported in most languages, often requiring just a single line of code.</li> <li><strong>Cons:</strong></li> <li><strong>Storage Inefficiency:</strong> UUIDs are long strings (36 characters with hyphens), consuming more storage space than numerical IDs.</li> <li><strong>Poor Indexing Performance:</strong> UUIDs are non-sequential. Using them as primary keys in database engines like InnoDB (which uses B+ trees) leads to frequent index page splits and random data inserts, severely degrading write performance.</li> <li><strong>Lack of Readability:</strong> The ID itself is opaque and carries no discernible information.</li> </ul> <h3 id="22-database-auto-increment-scheme">2.2. Database Auto-Increment Scheme</h3> <p>This scheme extends the single-database auto-increment concept to a distributed environment through careful configuration.</p> <p><strong>Core Idea:</strong> Configure each database instance with a different <strong>starting value (offset)</strong> and a common <strong>step (increment)</strong>.</p> <p>For example, with three MySQL servers, the configuration could be:</p> <ul> <li><strong>DB 1:</strong> <code class="language-plaintext highlighter-rouge">auto_increment_offset=1</code>, <code class="language-plaintext highlighter-rouge">auto_increment_increment=3</code> → Generated IDs: 1, 4, 7, 10, …</li> <li><strong>DB 2:</strong> <code class="language-plaintext highlighter-rouge">auto_increment_offset=2</code>, <code class="language-plaintext highlighter-rouge">auto_increment_increment=3</code> → Generated IDs: 2, 5, 8, 11, …</li> <li><strong>DB 3:</strong> <code class="language-plaintext highlighter-rouge">auto_increment_offset=3</code>, <code class="language-plaintext highlighter-rouge">auto_increment_increment=3</code> → Generated IDs: 3, 6, 9, 12, …</li> </ul> <p><strong>Analysis:</strong></p> <ul> <li><strong>Pros:</strong></li> <li><strong>Simple Implementation:</strong> Requires only database configuration, no extra components.</li> <li><strong>Ordered IDs:</strong> Generates numeric, incrementally ordered IDs, which are friendly to database indexes.</li> <li><strong>Cons:</strong></li> <li><strong>Strong Database Dependency:</strong> The database becomes a performance bottleneck and a single point of failure for ID generation.</li> <li><strong>Poor Scalability:</strong> Adding or removing database instances is a high-risk operation, requiring recalculation and reconfiguration across all instances.</li> <li><strong>Consistency Risks:</strong> In scenarios like master-slave failover, there’s a risk of data inconsistency that could lead to duplicate IDs.</li> </ul> <h3 id="23-redis-atomic-increment-scheme">2.3. Redis Atomic Increment Scheme</h3> <p>Redis provides atomic commands like <code class="language-plaintext highlighter-rouge">INCR</code> and <code class="language-plaintext highlighter-rouge">INCRBY</code>. Because Redis executes commands in a single-threaded manner, it naturally guarantees the uniqueness and order of generated IDs.</p> <p><strong>Core Idea:</strong> Use Redis’s atomic operations to generate a globally unique sequence.</p> <p><strong>Implementation:</strong> For each ID request, a client sends an <code class="language-plaintext highlighter-rouge">INCR a_unique_key</code> command to Redis. To prevent the ID from growing indefinitely, it’s often combined with a business prefix or a timestamp.</p> <p><strong>Analysis:</strong></p> <ul> <li><strong>Pros:</strong></li> <li><strong>High Performance:</strong> Operations are in-memory and significantly faster than a database.</li> <li><strong>Ordered IDs:</strong> The generated IDs are strictly increasing.</li> <li><strong>Cons:</strong></li> <li><strong>Introduces a New Component:</strong> Requires the introduction and maintenance of Redis, increasing architectural complexity.</li> <li><strong>Strong Redis Dependency:</strong> The availability of the ID service is tied to Redis. A highly available Redis cluster (e.g., Sentinel or Cluster mode) is necessary to mitigate this.</li> <li><strong>Network Overhead:</strong> Every ID generation requires a network round-trip, which can be a significant cost under high concurrency.</li> </ul> <h2 id="3-a-milestone-twitters-snowflake-algorithm">3. A Milestone: Twitter’s Snowflake Algorithm</h2> <p>The previous solutions all have significant drawbacks. In 2010, Twitter open-sourced its Snowflake algorithm, an elegant solution for generating IDs locally in a distributed environment. It has since become the foundational model for many modern distributed ID schemes.</p> <h3 id="31-core-idea-and-id-structure">3.1. Core Idea and ID Structure</h3> <p>Snowflake’s core idea is to <strong>partition a 64-bit long integer into several sections at the binary level, with each section having a specific meaning</strong>. This allows each node to generate globally unique IDs locally, without communicating with other nodes.</p> <p>A standard Snowflake ID is structured as follows:</p> <table> <thead> <tr> <th style="text-align: left">Section</th> <th style="text-align: center">Sign Bit</th> <th style="text-align: center">Timestamp</th> <th style="text-align: center">Datacenter ID</th> <th style="text-align: center">Worker ID</th> <th style="text-align: center">Sequence</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Bits</strong></td> <td style="text-align: center">1 bit</td> <td style="text-align: center">41 bits</td> <td style="text-align: center">5 bits</td> <td style="text-align: center">5 bits</td> <td style="text-align: center">12 bits</td> </tr> <tr> <td style="text-align: left"><strong>Meaning</strong></td> <td style="text-align: center">Fixed to 0 (for positive IDs)</td> <td style="text-align: center">Millisecond timestamp offset</td> <td style="text-align: center">Identifies the datacenter</td> <td style="text-align: center">Identifies the node/machine</td> <td style="text-align: center">Intra-millisecond counter</td> </tr> </tbody> </table> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p>Think of the Snowflake algorithm as a system for <strong>minting highly precise, unique identification cards</strong>.</p> <ul> <li><strong>The 64-bit ID</strong> is the blank ID card.</li> <li><strong>The Timestamp (41 bits)</strong> is the <strong>“Date of Issue,”</strong> precise to the millisecond. It defines the “era” of the ID and is its most significant part.</li> <li><strong>The Datacenter ID (5 bits)</strong> is the <strong>“Issuing Province.”</strong></li> <li><strong>The Worker ID (5 bits)</strong> is the specific <strong>“Issuing City Office”</strong> within that province.</li> <li><strong>The Sequence (12 bits)</strong> is the <strong>“Serial Number”</strong> issued by that specific office within the same millisecond.</li> </ul> <p>By combining the <strong>time of issue + location of issue (province + city) + local serial number</strong>, this system guarantees that every ID card produced is globally unique.</p> </blockquote> <h3 id="32-detailed-breakdown-of-each-section">3.2. Detailed Breakdown of Each Section</h3> <h4 id="321-sign-bit-1-bit">3.2.1. Sign Bit (1 bit)</h4> <p>The most significant bit of a <code class="language-plaintext highlighter-rouge">long</code> in Java is the sign bit. It is fixed to <code class="language-plaintext highlighter-rouge">0</code> to ensure all generated IDs are positive and to simplify cross-language compatibility.</p> <h4 id="322-timestamp-41-bits">3.2.2. Timestamp (41 bits)</h4> <ul> <li><strong>Content:</strong> This section stores the difference between the <code class="language-plaintext highlighter-rouge">current timestamp (in milliseconds)</code> and a <code class="language-plaintext highlighter-rouge">custom epoch timestamp</code>.</li> <li><strong>The <code class="language-plaintext highlighter-rouge">twepoch</code>:</strong> In Twitter’s official implementation, this epoch is set to <code class="language-plaintext highlighter-rouge">1288834974657L</code>, which corresponds to <strong>Nov 04, 2010 01:42:54 UTC</strong>.</li> <li><strong>Why a Custom Epoch?</strong> 41 bits cannot store the full number of milliseconds since the Unix epoch (Jan 1, 1970). By using a more recent starting point, a large absolute timestamp is converted into a smaller relative one. This allows 41 bits to cover a span of approximately <strong>69 years</strong> ($2^{41} / (1000 \cdot 60 \cdot 60 \cdot 24 \cdot 365) \approx 69$ years). The algorithm can thus be used until around the year 2079.</li> </ul> <h4 id="323-datacenter-id-5-bits--worker-id-5-bits--10-bits">3.2.3. Datacenter ID (5 bits) + Worker ID (5 bits) = 10 bits</h4> <p>These 10 bits collectively form the <strong>worker node ID</strong>, distinguishing different ID generation nodes.</p> <ul> <li><strong>Capacity:</strong></li> <li>Datacenter ID (5 bits): Supports $2^5 = 32$ datacenters.</li> <li>Worker ID (5 bits): Supports $2^5 = 32$ machines per datacenter.</li> <li>This allows for a total of $32 \times 32 = 1024$ nodes.</li> <li><strong>Allocation Mechanism:</strong> Manually configuring worker IDs in a dynamic cloud environment is infeasible. The standard practice is to <strong>rely on a coordination service like ZooKeeper for automatic allocation</strong>.</li> <li><strong>Process:</strong> On startup, a service instance creates an <strong>ephemeral sequential node</strong> in a designated ZooKeeper path. ZooKeeper assigns a globally unique sequence number to this node, which is then used as the <code class="language-plaintext highlighter-rouge">workerId</code>.</li> <li><strong>Automatic Reclamation:</strong> Because the node is ephemeral, it is automatically deleted if the service instance crashes or loses its connection to ZooKeeper. This allows the <code class="language-plaintext highlighter-rouge">workerId</code> to be reused by a new instance, preventing ID waste.</li> </ul> <h4 id="324-sequence-12-bits">3.2.4. Sequence (12 bits)</h4> <ul> <li><strong>Purpose:</strong> Resolves collisions when multiple IDs are generated on the <strong>same node within the same millisecond</strong>.</li> <li><strong>Capacity:</strong> 12 bits can represent $2^{12} = 4096$ values (0-4095).</li> <li><strong>Mechanism:</strong></li> <li>The sequence number is incremented for each ID generated within the same millisecond.</li> <li><strong>What if the sequence is exhausted (reaches 4095)?</strong> The original Snowflake implementation performs a <strong>spin-wait</strong>, pausing the thread until the next millisecond arrives.</li> <li>Once the clock ticks to the next millisecond, the sequence number is reset to <code class="language-plaintext highlighter-rouge">0</code>.</li> <li><strong>Performance Limit:</strong> This design sets the theoretical performance ceiling for a single Snowflake node at <strong>4095 IDs/millisecond</strong>, or approximately <strong>4.09 million IDs/second</strong>, which is more than sufficient for most use cases.</li> </ul> <h3 id="33-the-core-challenge-clock-skew">3.3. The Core Challenge: Clock Skew</h3> <p>This is Snowflake’s most famous “Achilles’ heel.” Server clocks can drift backwards due to NTP synchronization or other reasons.</p> <ul> <li><strong>Critical Impact:</strong> If the clock moves backward, the <code class="language-plaintext highlighter-rouge">current timestamp</code> could be less than the <code class="language-plaintext highlighter-rouge">last recorded timestamp</code>, potentially leading to duplicate IDs and breaking the algorithm’s time-ordered nature.</li> <li><strong>Twitter’s Original Solution:</strong> A <strong>Fail-Fast</strong> strategy.</li> <li>The code detects if the current time is earlier than the last recorded time and <strong>immediately throws an exception</strong>.</li> <li>This means the node becomes <strong>unavailable</strong> for ID generation until the clock issue is resolved.</li> <li>This strategy prioritizes data correctness over availability (“better to be down than to be wrong”).</li> </ul> <h3 id="34-snowflake-summary">3.4. Snowflake Summary</h3> <table> <thead> <tr> <th style="text-align: left">Pros</th> <th style="text-align: left">Cons</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>High Performance:</strong> Local generation with low latency.</td> <td style="text-align: left"><strong>Strong Clock Dependency:</strong> Clock skew is a critical issue.</td> </tr> <tr> <td style="text-align: left"><strong>Time-Ordered IDs:</strong> IDs are roughly sortable by time.</td> <td style="text-align: left"><strong>Requires Coordination Service:</strong> Worker ID allocation depends on components like ZooKeeper.</td> </tr> <tr> <td style="text-align: left"><strong>Embedded Information:</strong> IDs contain timestamp and node data.</td> <td style="text-align: left"><strong>Fixed Bit Allocation:</strong> The 1024-node limit can be a constraint in large-scale deployments.</td> </tr> <tr> <td style="text-align: left"><strong>Numeric Type:</strong> Efficient storage and querying as a 64-bit long.</td> <td style="text-align: left"><strong>Frontend Overflow Risk:</strong> JavaScript cannot precisely handle 64-bit integers.</td> </tr> </tbody> </table> <h2 id="4-industry-evolutions-and-variants">4. Industry Evolutions and Variants</h2> <p>While Snowflake’s design is brilliant, its complexity in worker ID allocation and its vulnerability to clock skew left room for improvement. Major tech companies like Baidu and Meituan have developed and open-sourced their own enhanced solutions.</p> <h3 id="41-baidus-uidgenerator-engineered-for-performance-and-ease-of-use">4.1. Baidu’s UidGenerator: Engineered for Performance and Ease of Use</h3> <p>UidGenerator is an open-source ID generator from Baidu that improves upon Snowflake with a focus on <strong>usability</strong> and <strong>concurrent performance</strong>.</p> <h4 id="411-core-design-a-restructured-id-1-28-22-13">4.1.1. Core Design: A Restructured ID (1-28-22-13)</h4> <p>UidGenerator significantly alters the 64-bit structure, changing the time unit from milliseconds to seconds.</p> <table> <thead> <tr> <th style="text-align: left">Section</th> <th style="text-align: center">Sign Bit</th> <th style="text-align: center">Delta Seconds</th> <th style="text-align: center">Worker ID</th> <th style="text-align: center">Sequence</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Bits</strong></td> <td style="text-align: center">1 bit</td> <td style="text-align: center">28 bits</td> <td style="text-align: center">22 bits</td> <td style="text-align: center">13 bits</td> </tr> </tbody> </table> <ul> <li><strong>Timestamp (28 bits, seconds):</strong></li> <li><strong>Sacrifice:</strong> The usable lifespan is reduced from 69 years to approximately <strong>8.5 years</strong> ($2^{28}$ seconds). This is a major trade-off that requires careful system lifecycle planning.</li> <li><strong>Gain:</strong> Frees up <code class="language-plaintext highlighter-rouge">41 - 28 = 13</code> bits for other sections.</li> <li><strong>Worker ID (22 bits):</strong></li> <li><strong>Pain Point Solved:</strong> Supports $2^{22}$ (over <strong>4 million</strong>) nodes. This completely resolves the <code class="language-plaintext highlighter-rouge">workerId</code> limitation of classic Snowflake, making it highly suitable for containerized cloud environments with frequent instance churn.</li> <li><strong>Sequence (13 bits):</strong></li> <li><strong>Capacity:</strong> Supports $2^{13} = 8192$.</li> <li><strong>Meaning:</strong> Allows for 8192 unique IDs to be generated <strong>per second</strong> on a single node.</li> </ul> <h4 id="412-worker-id-allocation-from-zookeeper-to-the-database">4.1.2. Worker ID Allocation: From ZooKeeper to the Database</h4> <p>UidGenerator replaces the ZooKeeper dependency with a component that nearly every project already has: a <strong>database</strong>.</p> <ul> <li><strong>Implementation:</strong> On startup, the service inserts a record into a <code class="language-plaintext highlighter-rouge">WORKER_NODE</code> table containing its host and port. The <strong>auto-incremented primary key</strong> generated by the database for this record is used as the <code class="language-plaintext highlighter-rouge">workerId</code>.</li> <li><strong>Advantage:</strong> <strong>Drastically reduces operational overhead and technology stack complexity</strong>, as there is no need to maintain a ZK cluster.</li> <li><strong>Disadvantages:</strong></li> <li><strong>Startup Dependency on DB:</strong> New instances cannot start if the database is down.</li> <li><strong>ID Waste:</strong> The default strategy consumes a new <code class="language-plaintext highlighter-rouge">workerId</code> on every restart.</li> </ul> <h4 id="413-the-performance-weapon-cacheduidgenerator-and-the-ringbuffer">4.1.3. The Performance Weapon: CachedUidGenerator and the RingBuffer</h4> <p>This is the core of UidGenerator and its recommended mode of operation. It uses a <strong>“space-for-time”</strong> trade-off to deliver extreme performance.</p> <ul> <li><strong>Core Idea:</strong> <strong>Pre-generation and caching of IDs.</strong> This decouples the “production” of IDs from their “consumption.”</li> <li><strong>The RingBuffer:</strong></li> <li><strong>Producer:</strong> A <strong>background thread</strong> asynchronously generates IDs in batches and populates a RingBuffer (a circular array).</li> <li><strong>Consumer:</strong> When a business thread requests an ID, it does not compute it on the spot. Instead, it retrieves one from the RingBuffer <strong>lock-free (via CAS atomic operations)</strong>.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p><code class="language-plaintext highlighter-rouge">CachedUidGenerator</code> operates like a <strong>highly efficient, modern coffee shop</strong>.</p> <ul> <li><strong>Business Requests</strong> are the customers.</li> <li><strong>The RingBuffer</strong> is a <strong>large, pre-filled dispenser of freshly brewed coffee</strong>.</li> <li><strong>Getting an ID (Consumption):</strong> A customer orders, and the barista <strong>instantly</strong> dispenses a cup from the machine. The process is immediate, with no waiting.</li> <li><strong>The Background Thread (Production):</strong> A staff member in the back is constantly monitoring the coffee level in the dispenser. When it drops below a certain threshold (e.g., 50%), they <strong>brew a large new batch</strong> and quickly refill the machine.</li> </ul> <p>Through this “front-of-house for sales, back-of-house for preparation” model, the customer (the business logic) experiences lightning-fast service, completely unaware of the “time-consuming” brewing process. This is the secret to <code class="language-plaintext highlighter-rouge">CachedUidGenerator</code> ‘s high performance.</p> </blockquote> <ul> <li><strong>Benefits:</strong></li> <li><strong>Extreme Performance:</strong> The business thread’s action is reduced to a memory access operation with virtually no lock contention, resulting in massive throughput.</li> <li><strong>Eliminates Jitter:</strong> It smooths out the performance “hiccups” that can occur at time boundaries (e.g., the start of a new second) in other implementations.</li> <li>It also employs advanced techniques like <strong>Cache-Line Padding</strong> to avoid “False Sharing” on multi-core CPUs, demonstrating a commitment to squeezing out every last drop of performance.</li> </ul> <h4 id="414-the-unresolved-challenge-clock-skew">4.1.4. The Unresolved Challenge: Clock Skew</h4> <p>On this issue, UidGenerator still adheres to the original <strong>“Fail-Fast”</strong> strategy, throwing an exception upon detecting clock skew.</p> <h4 id="415-uidgenerator-summary">4.1.5. UidGenerator Summary</h4> <table> <thead> <tr> <th style="text-align: left">Pros</th> <th style="text-align: left">Cons</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Exceptional Performance:</strong> Cached mode offers lock-free retrieval.</td> <td style="text-align: left"><strong>Shorter ID Lifespan:</strong> ~8.5 years by default, requires planning.</td> </tr> <tr> <td style="text-align: left"><strong>High Usability:</strong> Worker ID allocation depends only on a database.</td> <td style="text-align: left"><strong>Clock Skew Unresolved:</strong> Still uses the fail-fast approach.</td> </tr> <tr> <td style="text-align: left"><strong>Massive Worker ID Space:</strong> 22 bits support over 4 M nodes.</td> <td style="text-align: left"><strong>Potential Worker ID Waste:</strong> Restarts consume new IDs by default.</td> </tr> </tbody> </table> <h3 id="42-meituans-leaf-engineered-for-robustness-and-high-availability">4.2. Meituan’s Leaf: Engineered for Robustness and High Availability</h3> <p>Leaf is Meituan’s open-source ID service, offering two distinct solutions to cater to different needs: <strong><code class="language-plaintext highlighter-rouge">Leaf-segment</code></strong> and <strong><code class="language-plaintext highlighter-rouge">Leaf-snowflake</code></strong>.</p> <h4 id="421-leaf-segment-the-ultimate-optimization-of-segment-mode">4.2.1. Leaf-segment: The Ultimate Optimization of Segment Mode</h4> <p>This solution takes a completely different approach from Snowflake, focusing on optimizing the database-based model.</p> <ul> <li><strong>Core Idea:</strong> <strong>Database Segment Mode.</strong> Instead of fetching one ID at a time, Leaf fetches a large “segment” (or batch) of IDs from the database into memory.</li> <li>For example, it might fetch the range <code class="language-plaintext highlighter-rouge">[1, 1000]</code> in a single database transaction. For the next 1000 requests, Leaf serves IDs from memory by simply incrementing a counter, with zero database interaction.</li> <li><strong>Dual Buffer Mechanism:</strong></li> <li><strong>Pain Point Solved:</strong> In a simple segment model, there’s a performance jitter when one segment is exhausted and the next one needs to be fetched from the database.</li> <li><strong>Leaf’s Solution:</strong> It maintains two buffers. While one buffer is actively serving IDs, an <strong>asynchronous thread</strong> pre-fetches the next segment into the second (standby) buffer once the active buffer’s usage crosses a threshold (e.g., 10%). When the active buffer is depleted, the system <strong>instantly and seamlessly</strong> switches to the standby buffer.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p><code class="language-plaintext highlighter-rouge">Leaf-segment</code> is like the <strong>ticketing machine at a bank or hospital</strong>.</p> <ul> <li><strong>Getting an ID</strong> is a customer pressing a button and taking a ticket.</li> <li><strong>A Segment</strong> is an entire <strong>roll of ticket paper</strong> inside the machine (e.g., 1000 tickets).</li> <li><strong>Fetching from DB</strong> is the lobby manager noticing the paper is low and getting a new roll from the storeroom.</li> <li><strong>The Dual Buffer Mechanism</strong> means this is an advanced machine with <strong>two cartridge slots</strong>. While cartridge 1 is in use, the manager is prompted to load a new roll into cartridge 2. When cartridge 1 runs out, the machine instantly switches to cartridge 2, ensuring uninterrupted service.</li> </ul> </blockquote> <ul> <li><strong>High Availability Design:</strong> Leaf recommends setting the segment <code class="language-plaintext highlighter-rouge">step</code> to a multiple of the peak QPS (e.g., enough for 10 minutes). This means that even if the database goes down, Leaf can continue to serve IDs from its in-memory buffers for 10-20 minutes, buying valuable time for database recovery.</li> </ul> <h4 id="422-leaf-snowflake-a-hardened-snowflake">4.2.2. Leaf-snowflake: A Hardened Snowflake</h4> <p>This solution enhances the classic Snowflake algorithm, specifically addressing its two major pain points.</p> <ul> <li><strong>Worker ID Allocation (ZK + Local Cache):</strong></li> <li><strong>Still Uses ZooKeeper:</strong> Leaf acknowledges ZK’s strengths for initial, unique <code class="language-plaintext highlighter-rouge">workerId</code> allocation via persistent sequential nodes.</li> <li><strong>Introduces a Local File Cache:</strong> After obtaining a <code class="language-plaintext highlighter-rouge">workerId</code> from ZK, Leaf <strong>caches it in a local disk file</strong>.</li> <li><strong>High Availability Impact:</strong> On subsequent restarts, Leaf <strong>first reads the local file</strong> to get its <code class="language-plaintext highlighter-rouge">workerId</code>. It only contacts ZK if the file doesn’t exist. This dramatically reduces its dependency on ZK; a service can restart successfully even if the ZK cluster is down.</li> <li><strong>Clock Skew Handling (ZK + Proactive Shutdown):</strong></li> <li>This is Leaf-snowflake’s most significant contribution. It uses ZK as a <strong>“third-party time authority.”</strong></li> <li><strong>Detection:</strong> Each node periodically reports its timestamp to its ZK node. If it detects its local clock is earlier than the last timestamp it reported, it knows a clock skew has occurred.</li> <li><strong>Handling Strategy:</strong> The recommended best practice is <strong>automatic node removal</strong>. * Upon detecting clock skew, the node proactively changes its status to “unavailable” and removes itself from the load balancer’s pool. * Traffic is automatically routed to healthy nodes, ensuring the overall cluster remains available. * Simultaneously, it raises a high-priority alert for operators to investigate the “sick” machine.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p><code class="language-plaintext highlighter-rouge">Leaf-snowflake</code> is like a <strong>highly responsible, experienced chain store manager</strong>.</p> <ul> <li><strong>Worker ID Allocation:</strong> <blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*   When opening a new store, the manager calls headquarters (ZooKeeper) to get a permanent **store ID**.
</code></pre></div> </div> </blockquote> <ul> <li>He immediately makes a copy of the ID and <strong>locks it in the store’s safe</strong> (local file cache).</li> <li>For all future re-openings (restarts), he checks the safe first and <strong>doesn’t need to call headquarters</strong>, ensuring he can open even if HQ’s phone lines are down.</li> </ul> </li> <li><strong>Clock Skew Handling:</strong> <blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*   The manager notices the clock on his wall is wrong (clock skew).
</code></pre></div> </div> </blockquote> <ul> <li>Instead of shutting down chaotically (throwing an exception), he quietly flips the “Open” sign to “Under Maintenance” and <strong>proactively informs</strong> the central delivery platform (load balancer): “Stop sending me orders for now; I have an equipment issue.”</li> <li>Customer orders are automatically routed to other stores, and the <strong>brand’s overall service is unaffected</strong>. Meanwhile, he has already sent a maintenance request to headquarters. This is a model of professional fault handling.</li> </ul> </li> </ul> </blockquote> <h4 id="423-leaf-summary">4.2.3. Leaf Summary</h4> <p>Leaf provides two excellent, distinct solutions:</p> <ul> <li><strong>Leaf-segment:</strong> Ideal for scenarios requiring <strong>strictly ordered, purely numeric</strong> IDs. It offers exceptional performance and availability.</li> <li><strong>Leaf-snowflake:</strong> A <strong>hardened version of Snowflake</strong>. It masterfully solves the critical issues of ZK dependency and clock skew, offering extreme robustness.</li> </ul> <h3 id="43-the-mist-algorithm-a-timestamp-less-approach">4.3. The Mist Algorithm: A Timestamp-less Approach</h3> <p>This algorithm takes a radical approach, positing that the dependency on time is the root of all evil. Therefore, it <strong>eliminates the timestamp entirely</strong>.</p> <ul> <li><strong>Core Design:</strong> <strong>Complete decoupling from time.</strong></li> <li><strong>Advantage:</strong> <strong>Completely immune to clock skew.</strong> Server time fluctuations have no impact on ID generation, making the system incredibly robust.</li> <li><strong>Trade-off:</strong> It must rely on an <strong>external, centralized service (like Redis)</strong> to provide a globally unique, incrementing sequence.</li> <li><strong>ID Structure (1-47-8-8):</strong></li> <li><code class="language-plaintext highlighter-rouge">1</code> Sign Bit</li> <li><code class="language-plaintext highlighter-rouge">47</code> bits for an incrementing number (from Redis <code class="language-plaintext highlighter-rouge">INCR</code>). This guarantees strict ordering and a very long lifespan.</li> <li><code class="language-plaintext highlighter-rouge">16</code> bits for random factors. This makes the final ID <strong>unpredictable</strong>, protecting business data (like order volume) from being easily estimated.</li> </ul> <blockquote> <p><strong>Conceptual Analogy:</strong></p> <p>The <strong>Mist Algorithm</strong> is like a <strong>central bank issuing currency</strong>.</p> <ul> <li><strong>The ID</strong> is a unique banknote.</li> <li><strong>The centralized Redis</strong> is the <strong>one and only national mint</strong>. All ID generation instances must request “batch numbers” from it.</li> <li><strong>The 47-bit incrementing number</strong> is the <strong>unique, strictly increasing serial number</strong> on each banknote.</li> <li><strong>The 16-bit random factor</strong> represents the banknote’s <strong>security features, like watermarks and security threads</strong>. It makes two consecutive serial numbers look completely different, preventing counterfeiting and analysis.</li> </ul> <p>The advantage of this model is absolute authority, security, and immunity to local “clock” inaccuracies. The disadvantage is that if the mint shuts down, the entire nation’s money supply is halted.</p> </blockquote> <ul> <li><strong>Architectural Trade-off:</strong></li> <li><strong>Introduces a Central Bottleneck:</strong> The system’s overall performance is capped by the QPS and network latency of the central Redis instance.</li> <li><strong>Introduces a Single Point of Failure:</strong> If the Redis cluster fails, the entire ID generation service fails.</li> <li><strong>Use Cases:</strong></li> <li>Scenarios with <strong>zero tolerance for clock skew</strong>.</li> <li>Scenarios requiring <strong>unpredictable IDs</strong> for security (e.g., financial transactions, e-commerce orders).</li> <li>Scenarios where the business QPS is within the limits of a highly available Redis cluster.</li> </ul> <h2 id="5-solution-comparison-and-conclusion">5. Solution Comparison and Conclusion</h2> <table> <thead> <tr> <th style="text-align: left">Scheme</th> <th style="text-align: left">ID Trend</th> <th style="text-align: left">Performance</th> <th style="text-align: left">Core Dependency</th> <th style="text-align: left">WorkerID Allocation</th> <th style="text-align: left">Clock Skew Handling</th> <th style="text-align: left">Key Advantage</th> <th style="text-align: left">Core Drawback</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>UUID</strong></td> <td style="text-align: left">Unordered</td> <td style="text-align: left">Extreme (Local)</td> <td style="text-align: left">None</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Simplicity, no network cost</td> <td style="text-align: left">String, unordered, poor index perf</td> </tr> <tr> <td style="text-align: left"><strong>DB Auto-Inc</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">Low</td> <td style="text-align: left">Database</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Simplicity, ordered IDs</td> <td style="text-align: left">DB dependency, poor scalability</td> </tr> <tr> <td style="text-align: left"><strong>Redis Inc</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">High</td> <td style="text-align: left">Redis</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Good performance, ordered IDs</td> <td style="text-align: left">Redis dependency, network cost</td> </tr> <tr> <td style="text-align: left"><strong>Snowflake</strong></td> <td style="text-align: left">Time-ordered</td> <td style="text-align: left">Extreme (Local)</td> <td style="text-align: left">ZooKeeper</td> <td style="text-align: left">ZK Ephemeral Node</td> <td style="text-align: left"><strong>Throws Exception</strong></td> <td style="text-align: left">Balanced performance, embedded info</td> <td style="text-align: left">Strong clock dependency, ZK complexity</td> </tr> <tr> <td style="text-align: left"><strong>UidGenerator</strong></td> <td style="text-align: left">Time-ordered</td> <td style="text-align: left">Ultimate (Local)</td> <td style="text-align: left">Database</td> <td style="text-align: left">DB Auto-Inc ID</td> <td style="text-align: left"><strong>Throws Exception</strong></td> <td style="text-align: left">Extreme performance, massive WorkerID space</td> <td style="text-align: left">Short lifespan (~8.5 yrs), clock skew unresolved</td> </tr> <tr> <td style="text-align: left"><strong>Leaf-segment</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">Extreme (Mem)</td> <td style="text-align: left">Database</td> <td style="text-align: left">N/A</td> <td style="text-align: left">Irrelevant</td> <td style="text-align: left">Smooth perf, HA, sequential IDs</td> <td style="text-align: left">Predictable IDs, DB dependency</td> </tr> <tr> <td style="text-align: left"><strong>Leaf-snowflake</strong></td> <td style="text-align: left">Time-ordered</td> <td style="text-align: left">Extreme (Local)</td> <td style="text-align: left">ZooKeeper</td> <td style="text-align: left">ZK + Local Cache</td> <td style="text-align: left"><strong>Proactive Shutdown</strong></td> <td style="text-align: left"><strong>Extreme Robustness</strong>, solves clock skew</td> <td style="text-align: left">ZK dependency, slightly complex</td> </tr> <tr> <td style="text-align: left"><strong>Mist</strong></td> <td style="text-align: left">Strictly Inc</td> <td style="text-align: left">High (Limited)</td> <td style="text-align: left">Redis</td> <td style="text-align: left">N/A</td> <td style="text-align: left"><strong>Immune</strong></td> <td style="text-align: left"><strong>Clock immune, unpredictable IDs</strong></td> <td style="text-align: left">Centralized dependency &amp; bottleneck</td> </tr> </tbody> </table> <p><strong>Conclusion:</strong></p> <p>There is no “best” distributed ID solution, only the one that is “most suitable” for your specific context.</p> <ul> <li>For <strong>simplicity and rapid integration</strong> where ID order is not critical, <strong>UUID</strong> is an option.</li> <li>For a <strong>high-performance, time-ordered, and information-rich ID</strong>, <strong>Snowflake</strong> is the classic benchmark.</li> <li>To build on that with a focus on <strong>extreme ease-of-use and massive node support</strong> (while accepting a limited lifespan), <strong>Baidu’s UidGenerator</strong> is an excellent choice.</li> <li>For systems with the <strong>highest requirements for robustness and availability</strong>, especially for gracefully handling clock skew, <strong>Meituan’s Leaf-snowflake</strong> is arguably the most complete solution in the industry.</li> <li>If your business requires <strong>strictly sequential, purely numeric IDs</strong>, <strong>Meituan’s Leaf-segment</strong> offers unparalleled performance and smoothness.</li> <li>Finally, if <strong>clock safety and ID unpredictability</strong> are paramount, and you can accept the architectural cost of centralization, the <strong>Mist algorithm</strong> provides a novel and effective alternative.</li> </ul> <p>When making a selection, always consider your application’s QPS, requirements for ID format and order, your team’s operational capabilities, and the specific trade-offs you are willing to make between availability and data consistency.</p>]]></content><author><name></name></author><category term="System Design Other"/><summary type="html"><![CDATA[1. The Need for Distributed, Globally Unique IDs]]></summary></entry><entry><title type="html">1394. Find Lucky Integer in an Array</title><link href="https://zhengstar94.github.io//blog/2025/FindLuckyIntegerInAnArray/" rel="alternate" type="text/html" title="1394. Find Lucky Integer in an Array"/><published>2025-07-05T00:00:00+00:00</published><updated>2025-07-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindLuckyIntegerInAnArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindLuckyIntegerInAnArray/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">arr</code>, a <strong>lucky integer</strong> is an integer that has a frequency in the array equal to its value.</li> <li>Return <em>the largest <strong>lucky integer</strong> in the array</em>. If there is no <strong>lucky integer</strong> return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/05
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindLuckyIntegerInAnArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findLucky</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashMap to store the frequency of each integer in the array</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Iterate through the array and count the occurrences of each number</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If num is already in the map, increment its count by 1; otherwise, set it to 1</span>
            <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">freq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Initialize the result variable to -1 (default if no lucky integer is found)</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Iterate through all entries in the frequency map</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>    <span class="c1">// The integer value</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span> <span class="c1">// The frequency of this integer</span>
            <span class="c1">// Check if the integer is a lucky integer (its value equals its frequency)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update the result if this lucky integer is larger than the current result</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the largest lucky integer found, or -1 if none exists</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span> <span class="c1">// Output: -1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">findLucky</span><span class="o">(</span><span class="n">arr4</span><span class="o">));</span> <span class="c1">// Output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><category term="Easy"/><summary type="html"><![CDATA[Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value. Return the largest lucky integer in the array. If there is no lucky integer return -1.]]></summary></entry><entry><title type="html">1091. Shortest Path in Binary Matrix</title><link href="https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix/" rel="alternate" type="text/html" title="1091. Shortest Path in Binary Matrix"/><published>2025-07-04T00:00:00+00:00</published><updated>2025-07-04T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ShortestPathInBinaryMatrix/"><![CDATA[<ul> <li>Given an <code class="language-plaintext highlighter-rouge">n x n</code> binary matrix <code class="language-plaintext highlighter-rouge">grid</code>, return <em>the length of the shortest <strong>clear path</strong> in the matrix</em>. If there is no clear path, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> <li>A <strong>clear path</strong> in a binary matrix is a path from the <strong>top-left</strong> cell (i.e., <code class="language-plaintext highlighter-rouge">(0, 0)</code>) to the <strong>bottom-right</strong> cell (i.e., <code class="language-plaintext highlighter-rouge">(n - 1, n - 1)</code>) such that: <ul> <li>All the visited cells of the path are <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>All the adjacent cells of the path are <strong>8-directionally</strong> connected (i.e., they are different and they share an edge or a corner).</li> </ul> </li> <li>The <strong>length of a clear path</strong> is the number of visited cells of this path.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,1],[1,0 ] ]
Output: 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 0,0,0],[1,1,0],[1,1,0 ] ]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,0,0],[1,1,0],[1,1,0 ] ]
Output: -1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n²) time | O(n²) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BFS</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/07/04
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestPathInBinaryMatrix</span> <span class="o">{</span>
    <span class="c1">// Define the 8 possible directions for movement (up, down, left, right, and 4 diagonals)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">DIRS</span> <span class="o">=</span> <span class="o">{</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>   <span class="c1">// down</span>
            <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>  <span class="c1">// up</span>
            <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>   <span class="c1">// right</span>
            <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>  <span class="c1">// left</span>
            <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>  <span class="c1">// up-right</span>
            <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span> <span class="c1">// up-left</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>   <span class="c1">// down-right</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}</span>   <span class="c1">// down-left</span>
    <span class="o">};</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">shortestPathBinaryMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Special case: if the start or end cell is blocked, there is no valid path</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">grid</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Initialize the BFS queue. Each element is an array: [x, y, pathLength]</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Start from the top-left cell (0,0) with a path length of 1</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span>
        <span class="c1">// Mark the starting cell as visited by setting it to 1</span>
        <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Begin BFS traversal</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Remove the front element from the queue for processing</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">len</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="c1">// If we've reached the bottom-right cell, return the current path length</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">len</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Explore all 8 possible directions from the current cell</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">dir</span> <span class="o">:</span> <span class="no">DIRS</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                <span class="c1">// Check if the new cell is within bounds and is open (not blocked or visited)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="n">nx</span><span class="o">][</span><span class="n">ny</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Add the new cell to the queue with an incremented path length</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nx</span><span class="o">,</span> <span class="n">ny</span><span class="o">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span>
                    <span class="c1">// Mark the new cell as visited to prevent revisiting</span>
                    <span class="n">grid</span><span class="o">[</span><span class="n">nx</span><span class="o">][</span><span class="n">ny</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// If the queue is empty and we haven't reached the end, there is no valid path</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">shortestPathBinaryMatrix</span><span class="o">(</span><span class="n">copyGrid</span><span class="o">(</span><span class="n">grid1</span><span class="o">)));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">shortestPathBinaryMatrix</span><span class="o">(</span><span class="n">copyGrid</span><span class="o">(</span><span class="n">grid2</span><span class="o">)));</span> <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">shortestPathBinaryMatrix</span><span class="o">(</span><span class="n">copyGrid</span><span class="o">(</span><span class="n">grid3</span><span class="o">)));</span> <span class="c1">// Output: -1</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">copyGrid</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">copy</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BFS"/><category term="Medium"/><summary type="html"><![CDATA[Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path.]]></summary></entry></feed>