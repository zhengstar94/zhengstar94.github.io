<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-17T04:53:57+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">986. Interval List Intersections</title><link href="https://zhengstar94.github.io//blog/2024/IntervalListIntersections/" rel="alternate" type="text/html" title="986. Interval List Intersections"/><published>2024-11-17T00:00:00+00:00</published><updated>2024-11-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/IntervalListIntersections</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/IntervalListIntersections/"><![CDATA[<ul> <li>You are given two lists of closed intervals, <code class="language-plaintext highlighter-rouge">firstList</code> and <code class="language-plaintext highlighter-rouge">secondList</code>, where <code class="language-plaintext highlighter-rouge">firstList[i] = [starti, endi]</code> and <code class="language-plaintext highlighter-rouge">secondList[j] = [startj, endj]</code>. Each list of intervals is pairwise <strong>disjoint</strong> and in <strong>sorted order</strong>.</li> <li>Return <em>the intersection of these two interval lists</em>.</li> <li>A <strong>closed interval</strong> <code class="language-plaintext highlighter-rouge">[a, b]</code> (with <code class="language-plaintext highlighter-rouge">a &lt;= b</code>) denotes the set of real numbers <code class="language-plaintext highlighter-rouge">x</code> with <code class="language-plaintext highlighter-rouge">a &lt;= x &lt;= b</code>.</li> <li>The <strong>intersection</strong> of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of <code class="language-plaintext highlighter-rouge">[1, 3]</code> and <code class="language-plaintext highlighter-rouge">[2, 4]</code> is <code class="language-plaintext highlighter-rouge">[2, 3]</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: firstList = [ [0,2],[5,10],[13,23],[24,25] ], secondList = [ [1,5],[8,12],[15,24],[25,26] ]
Output: [ [1,2],[5,5],[8,10],[15,23],[24,24],[25,25] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: firstList = [ [1,3],[5,9] ], secondList = []
Output: []
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(n + m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntervalListIntersections</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">intervalIntersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ArrayList to store intersection intervals</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Two pointers to traverse both lists</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for firstList</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// pointer for secondList</span>

        <span class="c1">// Continue until we reach the end of either list</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">firstList</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">secondList</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Extract start and end points of current intervals</span>
            <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">firstList</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>   <span class="c1">// start of interval from first list</span>
            <span class="kt">int</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">firstList</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>     <span class="c1">// end of interval from first list</span>

            <span class="kt">int</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">secondList</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>   <span class="c1">// start of interval from second list</span>
            <span class="kt">int</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">secondList</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>     <span class="c1">// end of interval from second list</span>

            <span class="c1">// Find the intersection points</span>
            <span class="c1">// Intersection start is the maximum of both starts</span>
            <span class="kt">int</span> <span class="n">intersectStart</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">start1</span><span class="o">,</span> <span class="n">start2</span><span class="o">);</span>
            <span class="c1">// Intersection end is the minimum of both ends</span>
            <span class="kt">int</span> <span class="n">intersectEnd</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">end1</span><span class="o">,</span> <span class="n">end2</span><span class="o">);</span>

            <span class="c1">// If we have a valid intersection (start &lt;= end)</span>
            <span class="c1">// add it to our result list</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intersectStart</span> <span class="o">&lt;=</span> <span class="n">intersectEnd</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">intersectStart</span><span class="o">,</span> <span class="n">intersectEnd</span><span class="o">});</span>
            <span class="o">}</span>

            <span class="c1">// Move the pointer of the interval that ends first</span>
            <span class="c1">// This is crucial for not missing any potential intersections</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">end1</span> <span class="o">&lt;</span> <span class="n">end2</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>  <span class="c1">// first interval ends earlier, move to next interval in first list</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>  <span class="c1">// second interval ends earlier or at same time, move to next interval in second list</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert ArrayList to array and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple intersections</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">13</span><span class="o">,</span><span class="mi">23</span><span class="o">},</span> <span class="o">{</span><span class="mi">24</span><span class="o">,</span><span class="mi">25</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span><span class="mi">24</span><span class="o">},</span> <span class="o">{</span><span class="mi">25</span><span class="o">,</span><span class="mi">26</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList1</span><span class="o">,</span> <span class="n">secondList1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Empty list scenario</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">9</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList2</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList2</span><span class="o">,</span> <span class="n">secondList2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Complete overlap scenario</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">firstList3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span> <span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">secondList3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (Complete Overlap):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"firstList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">firstList3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"secondList = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">secondList3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Intersection Result = "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">intervalIntersection</span><span class="o">(</span><span class="n">firstList3</span><span class="o">,</span> <span class="n">secondList3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].]]></summary></entry><entry><title type="html">1868. Product of Two Run-Length Encoded Arrays</title><link href="https://zhengstar94.github.io//blog/2024/ProductOfTwoRunLengthEncodedArrays/" rel="alternate" type="text/html" title="1868. Product of Two Run-Length Encoded Arrays"/><published>2024-11-17T00:00:00+00:00</published><updated>2024-11-17T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ProductOfTwoRunLengthEncodedArrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ProductOfTwoRunLengthEncodedArrays/"><![CDATA[<ul> <li><strong>Run-length encoding</strong> is a compression algorithm that allows for an integer array <code class="language-plaintext highlighter-rouge">nums</code> with many segments of <strong>consecutive repeated</strong> numbers to be represented by a (generally smaller) 2D array <code class="language-plaintext highlighter-rouge">encoded</code>. Each <code class="language-plaintext highlighter-rouge">encoded[i] = [vali, freqi]</code> describes the <code class="language-plaintext highlighter-rouge">ith</code> segment of repeated numbers in <code class="language-plaintext highlighter-rouge">nums</code> where <code class="language-plaintext highlighter-rouge">vali</code> is the value that is repeated <code class="language-plaintext highlighter-rouge">freqi</code> times. <ul> <li>For example, <code class="language-plaintext highlighter-rouge">nums = [1,1,1,2,2,2,2,2]</code> is represented by the <strong>run-length encoded</strong> array <code class="language-plaintext highlighter-rouge">encoded = [ [1,3],[2,5] ]</code>. Another way to read this is “three <code class="language-plaintext highlighter-rouge">1</code>’s followed by five <code class="language-plaintext highlighter-rouge">2</code>’s”.</li> </ul> </li> <li>The <strong>product</strong> of two run-length encoded arrays <code class="language-plaintext highlighter-rouge">encoded1</code> and <code class="language-plaintext highlighter-rouge">encoded2</code> can be calculated using the following steps: <ol> <li><strong>Expand</strong> both <code class="language-plaintext highlighter-rouge">encoded1</code> and <code class="language-plaintext highlighter-rouge">encoded2</code> into the full arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> respectively.</li> <li>Create a new array <code class="language-plaintext highlighter-rouge">prodNums</code> of length <code class="language-plaintext highlighter-rouge">nums1.length</code> and set <code class="language-plaintext highlighter-rouge">prodNums[i] = nums1[i] * nums2[i]</code>.</li> <li><strong>Compress</strong> <code class="language-plaintext highlighter-rouge">prodNums</code> into a run-length encoded array and return it.</li> </ol> </li> <li>You are given two <strong>run-length encoded</strong> arrays <code class="language-plaintext highlighter-rouge">encoded1</code> and <code class="language-plaintext highlighter-rouge">encoded2</code> representing full arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> respectively. Both <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> have the <strong>same length</strong>. Each <code class="language-plaintext highlighter-rouge">encoded1[i] = [vali, freqi]</code> describes the <code class="language-plaintext highlighter-rouge">ith</code> segment of <code class="language-plaintext highlighter-rouge">nums1</code>, and each <code class="language-plaintext highlighter-rouge">encoded2[j] = [valj, freqj]</code> describes the <code class="language-plaintext highlighter-rouge">jth</code> segment of <code class="language-plaintext highlighter-rouge">nums2</code>.</li> <li>Return <em>the <strong>product</strong> of</em> <code class="language-plaintext highlighter-rouge">encoded1</code> <em>and</em> <code class="language-plaintext highlighter-rouge">encoded2</code>.</li> <li><strong>Note:</strong> Compression should be done such that the run-length encoded array has the <strong>minimum</strong> possible length.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: encoded1 = [ [1,3],[2,3] ], encoded2 = [ [6,3],[3,3] ]
Output: [ [6,6] ]
Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3].
prodNums = [6,6,6,6,6,6], which is compressed into the run-length encoded array [ [6,6] ].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: encoded1 = [ [1,3],[2,1],[3,2] ], encoded2 = [ [2,3],[3,3] ]
Output: [ [2,3],[6,1],[9,2] ]
Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3].
prodNums = [2,2,2,6,9,9], which is compressed into the run-length encoded array [ [2,3],[6,1],[9,2] ].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/17
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductOfTwoRunLengthEncodedArrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">findRLEArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for traversing encoded1</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Pointer for traversing encoded2</span>
        <span class="kt">int</span> <span class="n">pos1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Remaining frequency count in current segment of encoded1</span>
        <span class="kt">int</span> <span class="n">pos2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// Remaining frequency count in current segment of encoded2</span>

        <span class="c1">// Process both arrays until we reach the end of either array</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">encoded1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">encoded2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Get current values from both arrays</span>
            <span class="kt">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">encoded1</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// Current value from encoded1</span>
            <span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">encoded2</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// Current value from encoded2</span>

            <span class="c1">// If pos1 is 0, get new frequency from encoded1</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">pos1</span> <span class="o">=</span> <span class="n">encoded1</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// If pos2 is 0, get new frequency from encoded2</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">pos2</span> <span class="o">=</span> <span class="n">encoded2</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// Calculate the product of current values and the overlap length</span>
            <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">val1</span> <span class="o">*</span> <span class="n">val2</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">overlap</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">pos1</span><span class="o">,</span> <span class="n">pos2</span><span class="o">);</span>   <span class="c1">// Get minimum frequency between two current segments</span>

            <span class="c1">// Handle the result:</span>
            <span class="c1">// If result is empty OR current product is different from the last product in result</span>
            <span class="k">if</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">!=</span> <span class="n">product</span><span class="o">){</span>
                <span class="c1">// Add new entry with current product and overlap frequency</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">product</span><span class="o">,</span> <span class="n">overlap</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If current product equals last product in result, merge frequencies</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">// Update frequency by adding the overlap</span>
                <span class="c1">// last.get(1) gets current frequency, overlap adds new frequency</span>
                <span class="n">last</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">last</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">overlap</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Update remaining frequencies</span>
            <span class="n">pos1</span> <span class="o">-=</span> <span class="n">overlap</span><span class="o">;</span>
            <span class="n">pos2</span> <span class="o">-=</span> <span class="n">overlap</span><span class="o">;</span>

            <span class="c1">// Move pointer i if we've used up current segment in encoded1</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Move pointer j if we've used up current segment in encoded2</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with same length arrays</span>
        <span class="c1">// Expected result: [ [6,6] ] (as 1×6=6 three times, and 2×3=6 three times)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">findRLEArray</span><span class="o">(</span><span class="n">encoded1</span><span class="o">,</span> <span class="n">encoded2</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Different length arrays</span>
        <span class="c1">// Expected result: [ [2,3], [6,1], [9,2] ]</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded4</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">findRLEArray</span><span class="o">(</span><span class="n">encoded3</span><span class="o">,</span> <span class="n">encoded4</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Case with same products requiring merging</span>
        <span class="c1">// Expected result: [ [6,5], [4,1] ]</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded5</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">encoded6</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded1: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"encoded2: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">encoded6</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">findRLEArray</span><span class="o">(</span><span class="n">encoded5</span><span class="o">,</span> <span class="n">encoded6</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Run-length encoding is a compression algorithm that allows for an integer array nums with many segments of consecutive repeated numbers to be represented by a (generally smaller) 2D array encoded. Each encoded[i] = [vali, freqi] describes the ith segment of repeated numbers in nums where vali is the value that is repeated freqi times. For example, nums=[1,1,1,2,2,2,2,2] is represented by the run-length encoded array encoded=[ [1,3],[2,5] ]. Another way to read this is “three 1’s followed by five 2’s”. The product of two run-length encoded arrays encoded1 and encoded2 can be calculated using the following steps: Expand both encoded1 and encoded2 into the full arrays nums1 and nums2 respectively. Create a new array prodNums of length nums1.length and set prodNums[i] = nums1[i] * nums2[i]. Compress prodNums into a run-length encoded array and return it. You are given two run-length encoded arrays encoded1 and encoded2 representing full arrays nums1 and nums2 respectively. Both nums1 and nums2 have the same length. Each encoded1[i] = [vali, freqi] describes the ith segment of nums1, and each encoded2[j] = [valj, freqj] describes the jth segment of nums2. Return the product of encoded1 and encoded2. Note: Compression should be done such that the run-length encoded array has the minimum possible length.]]></summary></entry><entry><title type="html">443. String Compression</title><link href="https://zhengstar94.github.io//blog/2024/StringCompression/" rel="alternate" type="text/html" title="443. String Compression"/><published>2024-11-16T00:00:00+00:00</published><updated>2024-11-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/StringCompression</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/StringCompression/"><![CDATA[<ul> <li>Given an array of characters <code class="language-plaintext highlighter-rouge">chars</code>, compress it using the following algorithm:</li> <li>Begin with an empty string <code class="language-plaintext highlighter-rouge">s</code>. For each group of <strong>consecutive repeating characters</strong> in <code class="language-plaintext highlighter-rouge">chars</code>: <ul> <li>If the group’s length is <code class="language-plaintext highlighter-rouge">1</code>, append the character to <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Otherwise, append the character followed by the group’s length.</li> </ul> </li> <li>The compressed string <code class="language-plaintext highlighter-rouge">s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code class="language-plaintext highlighter-rouge">chars</code></strong>. Note that group lengths that are <code class="language-plaintext highlighter-rouge">10</code> or longer will be split into multiple characters in <code class="language-plaintext highlighter-rouge">chars</code>.</li> <li>After you are done <strong>modifying the input array,</strong> return <em>the new length of the array</em>.</li> <li>You must write an algorithm that uses only constant extra space.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: chars = [ "a","a","b","b","c","c","c" ]
Output: Return 6, and the first 6 characters of the input array should be: [ "a","2","b","2","c","3" ]
Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: chars = [ "a" ]
Output: Return 1, and the first character of the input array should be: [ "a" ]
Explanation: The only group is "a", which remains uncompressed since it's a single character.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: chars = [ "a","b","b","b","b","b","b","b","b","b","b","b","b" ]
Output: Return 4, and the first 4 characters of the input array should be: [ "a","b","1","2" ].
Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringCompression</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">compress</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// writeIndex: points to the position where we should write next character</span>
        <span class="c1">// index: points to the current character being processed</span>
        <span class="kt">int</span> <span class="n">writeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Process each character in the array</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Store the current character for consecutive count</span>
            <span class="kt">char</span> <span class="n">currentChar</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// Count consecutive occurrences of the current character</span>
            <span class="c1">// Key Logic: Keep moving index forward as long as we see the same character</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">==</span> <span class="n">currentChar</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">index</span><span class="o">++;</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Write the character at writeIndex position and increment writeIndex</span>
            <span class="n">chars</span><span class="o">[</span><span class="n">writeIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">currentChar</span><span class="o">;</span>

            <span class="c1">// If count &gt; 1, we need to write the count after the character</span>
            <span class="c1">// Important: Handle multi-digit numbers correctly</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Convert count to string to handle multi-digit numbers</span>
                <span class="nc">String</span> <span class="n">countStr</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
                <span class="c1">// Write each digit of the count individually</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">countStr</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">chars</span><span class="o">[</span><span class="n">writeIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the length of the compressed array</span>
        <span class="k">return</span> <span class="n">writeIndex</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Multiple characters with different frequencies</span>
        <span class="c1">// Expected output: "a2b2c3"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span> <span class="sc">'a'</span><span class="o">,</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'c'</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">compress</span><span class="o">(</span><span class="n">test1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Compressed length: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Single character</span>
        <span class="c1">// Expected output: "a"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span> <span class="sc">'a'</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">compress</span><span class="o">(</span><span class="n">test2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Compressed length: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Character with double-digit frequency</span>
        <span class="c1">// Expected output: "ab12"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span> <span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'b'</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">compress</span><span class="o">(</span><span class="n">test3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Compressed length: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After compression: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s. For each group of consecutive repeating characters in chars: If the group’s length is 1, append the character to s. Otherwise, append the character followed by the group’s length. The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars. After you are done modifying the input array, return the new length of the array. You must write an algorithm that uses only constant extra space.]]></summary></entry><entry><title type="html">26. Remove Duplicates from Sorted Array</title><link href="https://zhengstar94.github.io//blog/2024/RemoveDuplicatesFromSortedArray/" rel="alternate" type="text/html" title="26. Remove Duplicates from Sorted Array"/><published>2024-11-14T00:00:00+00:00</published><updated>2024-11-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RemoveDuplicatesFromSortedArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RemoveDuplicatesFromSortedArray/"><![CDATA[<ul> <li> <p>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>. Then return <em>the number of unique elements in</em> <code class="language-plaintext highlighter-rouge">nums</code>.</p> </li> <li> <p>Consider the number of unique elements of <code class="language-plaintext highlighter-rouge">nums</code> to be <code class="language-plaintext highlighter-rouge">k</code>, to get accepted, you need to do the following things:</p> <ul> <li>Change the array <code class="language-plaintext highlighter-rouge">nums</code> such that the first <code class="language-plaintext highlighter-rouge">k</code> elements of <code class="language-plaintext highlighter-rouge">nums</code> contain the unique elements in the order they were present in <code class="language-plaintext highlighter-rouge">nums</code> initially. The remaining elements of <code class="language-plaintext highlighter-rouge">nums</code> are not important as well as the size of <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Return <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> </li> <li> <p><strong>Custom Judge:</strong></p> <p>The judge will test your solution with the following code:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length
  
int k = removeDuplicates(nums); // Calls your implementation
  
assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre></div> </div> <p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveDuplicatesFromSortedArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the array is null or has no elements, return 0 as there are no elements to process</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Initialize a variable k to track the position of the next unique element; start from 1 as the first element is always unique</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Loop through the array starting from the second element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current element is not equal to the previous one, it is unique</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Place the unique element at the position k, then increment k</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the count of unique elements, which is stored in k</span>
        <span class="k">return</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test array with sorted elements including duplicates</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>

        <span class="c1">// Call removeDuplicates to get the count of unique elements and modify the array in place</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unique count: "</span> <span class="o">+</span> <span class="n">k</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Modified array: "</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.]]></summary></entry><entry><title type="html">16. 3Sum Closest</title><link href="https://zhengstar94.github.io//blog/2024/ThreeSumClosest/" rel="alternate" type="text/html" title="16. 3Sum Closest"/><published>2024-11-13T00:00:00+00:00</published><updated>2024-11-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ThreeSumClosest</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ThreeSumClosest/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code> and an integer <code class="language-plaintext highlighter-rouge">target</code>, find three integers in <code class="language-plaintext highlighter-rouge">nums</code> such that the sum is closest to <code class="language-plaintext highlighter-rouge">target</code>.</li> <li>Return <em>the sum of the three integers</em>.</li> <li>You may assume that each input would have exactly one solution.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeSumClosest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">threeSumClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the array first to use two-pointer technique</span>
        <span class="c1">// This allows us to move pointers based on sum comparison</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// Initialize result with first three numbers</span>
        <span class="c1">// This ensures we have a valid sum to start with</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

        <span class="c1">// Iterate through the array, fixing the first number</span>
        <span class="c1">// We stop at length-2 because we need at least 2 more numbers after i</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="c1">// Skip duplicates for the first number to avoid duplicate combinations</span>
            <span class="c1">// This optimization reduces unnecessary calculations</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Initialize two pointers:</span>
            <span class="c1">// left: starts right after current number i</span>
            <span class="c1">// right: starts from the end of array</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// Use two pointers to find the other two numbers</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
                <span class="c1">// Calculate current sum of three numbers</span>
                <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

                <span class="c1">// If we find an exact match, we can return immediately</span>
                <span class="c1">// as this is the closest possible sum to target</span>
                <span class="k">if</span><span class="o">(</span><span class="n">currentSum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                    <span class="k">return</span> <span class="n">currentSum</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Update result if current sum is closer to target than previous result</span>
                <span class="c1">// Using absolute difference to compare distances to target</span>
                <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">currentSum</span> <span class="o">-</span> <span class="n">target</span><span class="o">)</span> <span class="o">&lt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">result</span> <span class="o">-</span> <span class="n">target</span><span class="o">)){</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">currentSum</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// If current sum is less than target, we need a larger sum</span>
                <span class="c1">// So move left pointer to the right to get larger numbers</span>
                <span class="k">if</span><span class="o">(</span><span class="n">currentSum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                    <span class="n">left</span><span class="o">++;</span>

                    <span class="c1">// Skip duplicates for the second number</span>
                    <span class="c1">// This optimization avoids duplicate combinations</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                        <span class="n">left</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">// If current sum is greater than target, we need a smaller sum</span>
                <span class="c1">// So move right pointer to the left to get smaller numbers</span>
                <span class="k">else</span><span class="o">{</span>
                    <span class="n">right</span><span class="o">--;</span>

                    <span class="c1">// Skip duplicates for the third number</span>
                    <span class="c1">// This optimization avoids duplicate combinations</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]){</span>
                        <span class="n">right</span><span class="o">--;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Return the closest sum found</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case</span>
        <span class="c1">// nums = [ -1, 2, 1, -4 ], target = 1</span>
        <span class="c1">// Expected output: 2 (sum of -1 + 1 + 2)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Print input array, target value, and result</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input array: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Target value: "</span> <span class="o">+</span> <span class="n">target</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Closest three sum: "</span> <span class="o">+</span> <span class="n">threeSumClosest</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.]]></summary></entry><entry><title type="html">88.Merge Sorted Array</title><link href="https://zhengstar94.github.io//blog/2024/MergeSortedArray/" rel="alternate" type="text/html" title="88.Merge Sorted Array"/><published>2024-11-12T00:00:00+00:00</published><updated>2024-11-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MergeSortedArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MergeSortedArray/"><![CDATA[<ul> <li>You are given two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code>, representing the number of elements in <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> respectively.</li> <li><strong>Merge</strong> <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</li> <li>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code class="language-plaintext highlighter-rouge">nums1</code>. To accommodate this, <code class="language-plaintext highlighter-rouge">nums1</code> has a length of <code class="language-plaintext highlighter-rouge">m + n</code>, where the first <code class="language-plaintext highlighter-rouge">m</code> elements denote the elements that should be merged, and the last <code class="language-plaintext highlighter-rouge">n</code> elements are set to <code class="language-plaintext highlighter-rouge">0</code> and should be ignored. <code class="language-plaintext highlighter-rouge">nums2</code> has a length of <code class="language-plaintext highlighter-rouge">n</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m+n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeSortedArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize pointers:</span>
        <span class="c1">// p1 points to the last valid element in nums1</span>
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// p2 points to the last element in nums2</span>
        <span class="kt">int</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// p points to the last position in the merged array</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Compare elements from both arrays and place them in correct position</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">p1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">[</span><span class="n">p2</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// If element from nums1 is larger, place it at the end</span>
                <span class="n">nums1</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">p1</span><span class="o">];</span>
                <span class="n">p1</span><span class="o">--;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If element from nums2 is larger or equal, place it at the end</span>
                <span class="n">nums1</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">p2</span><span class="o">];</span>
                <span class="n">p2</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="c1">// Move the merger pointer one position back</span>
            <span class="n">p</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="c1">// If there are remaining elements in nums2, copy them to the beginning of nums1</span>
        <span class="c1">// Note: if p1 &gt;= 0, no action needed as elements are already in place</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">p2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Regular case with equal length arrays</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>  <span class="c1">// Array with extra space at end</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>  <span class="c1">// Number of elements in nums1</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>  <span class="c1">// Number of elements in nums2</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Before merge nums1: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"nums2: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>

        <span class="n">merge</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"After merge: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Edge case where second array is empty</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Before merge nums1: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"nums2: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums4</span><span class="o">);</span>

        <span class="n">merge</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums4</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"After merge: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Edge case where first array is empty</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums6</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Before merge nums1: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"nums2: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums6</span><span class="o">);</span>

        <span class="n">merge</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums6</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"After merge: "</span><span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span><span class="n">nums5</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to print array contents in a formatted way
     *
     * @param arr The array to be printed
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.]]></summary></entry><entry><title type="html">680.Valid Palindrome II</title><link href="https://zhengstar94.github.io//blog/2024/ValidPalindromeII/" rel="alternate" type="text/html" title="680.Valid Palindrome II"/><published>2024-11-11T00:00:00+00:00</published><updated>2024-11-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ValidPalindromeII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ValidPalindromeII/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if the</em> <code class="language-plaintext highlighter-rouge">s</code> <em>can be palindrome after deleting <strong>at most one</strong> character from it</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "aba"
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abc"
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidPalindromeII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers, left starts from beginning, right starts from end</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Keep checking characters from both ends moving towards center</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="c1">// If characters at left and right pointers don't match</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)){</span>
                <span class="c1">// Try two possibilities:</span>
                <span class="c1">// 1. Remove character at left pointer (check substring from left+1 to right)</span>
                <span class="c1">// 2. Remove character at right pointer (check substring from left to right-1)</span>
                <span class="k">return</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">||</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Move pointers towards center if characters match</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">// If we get here, string is already a palindrome</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Compare characters from both ends moving towards center</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Move pointers towards center if characters match</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">// If we get here, substring is a palindrome</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Already a palindrome</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">validPalindrome</span><span class="o">(</span><span class="s">"aba"</span><span class="o">));</span>  <span class="c1">// Should print: true</span>

        <span class="c1">// Test case 2: Can become palindrome by removing one character</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">validPalindrome</span><span class="o">(</span><span class="s">"abca"</span><span class="o">));</span> <span class="c1">// Should print: true</span>

        <span class="c1">// Test case 3: Cannot become palindrome by removing one character</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">validPalindrome</span><span class="o">(</span><span class="s">"abd"</span><span class="o">));</span>  <span class="c1">// Should print: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given a string s, return true if the s can be palindrome after deleting at most one character from it.]]></summary></entry><entry><title type="html">716.Max Stack</title><link href="https://zhengstar94.github.io//blog/2024/MaxStack/" rel="alternate" type="text/html" title="716.Max Stack"/><published>2024-11-10T00:00:00+00:00</published><updated>2024-11-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MaxStack</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MaxStack/"><![CDATA[<ul> <li>Design a max stack data structure that supports the stack operations and supports finding the stack’s maximum element.</li> <li>Implement the <code class="language-plaintext highlighter-rouge">MaxStack</code> class: <ul> <li><code class="language-plaintext highlighter-rouge">MaxStack()</code> Initializes the stack object.</li> <li><code class="language-plaintext highlighter-rouge">void push(int x)</code> Pushes element <code class="language-plaintext highlighter-rouge">x</code> onto the stack.</li> <li><code class="language-plaintext highlighter-rouge">int pop()</code> Removes the element on top of the stack and returns it.</li> <li><code class="language-plaintext highlighter-rouge">int top()</code> Gets the element on the top of the stack without removing it.</li> <li><code class="language-plaintext highlighter-rouge">int peekMax()</code> Retrieves the maximum element in the stack without removing it.</li> <li><code class="language-plaintext highlighter-rouge">int popMax()</code> Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the top-most one.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["MaxStack", "push", "push", "push", "top", "popMax", "top", "peekMax", "pop", "top"]
[[], [5], [1], [5], [], [], [], [], [], []]
Output
[null, null, null, null, 5, 5, 1, 5, 1, 5]

Explanation
MaxStack stk = new MaxStack();
stk.push(5);   // [5] the top of the stack and the maximum number is 5.
stk.push(1);   // [5, 1] the top of the stack is 1, but the maximum is 5.
stk.push(5);   // [5, 1, 5] the top of the stack is 5, which is also the maximum, because it is the top most one.
stk.top();     // return 5, [5, 1, 5] the stack did not change.
stk.popMax();  // return 5, [5, 1] the stack is changed now, and the top is different from the max.
stk.top();     // return 1, [5, 1] the stack did not change.
stk.peekMax(); // return 5, [5, 1] the stack did not change.
stk.pop();     // return 1, [5] the top of the stack and the max element is now 5.
stk.top();     // return 5, [5] the stack did not change.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(log n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.TreeMap</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxStack</span> <span class="o">{</span>
    <span class="c1">// Node class for doubly linked list</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">prev</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span><span class="o">;</span>  <span class="c1">// Head node of doubly linked list</span>
    <span class="kd">private</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="o">;</span>  <span class="c1">// Map from value to nodes</span>

    <span class="kd">public</span> <span class="nf">MaxStack</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>  <span class="c1">// Sentinel node</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="c1">// Insert new node at the head of linked list</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="c1">// Update TreeMap</span>
        <span class="n">map</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;()).</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>  <span class="c1">// Get top node</span>
        <span class="c1">// Remove node from linked list</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="c1">// Remove node from TreeMap</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peekMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">lastKey</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">popMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="n">peekMax</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxVal</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">// Remove the last (topmost) max value node</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">maxVal</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>  <span class="c1">// Remove node from linked list</span>
        <span class="k">return</span> <span class="n">maxVal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create and execute test cases</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Start testing MaxStack:"</span><span class="o">);</span>

        <span class="c1">// Test case 1: Example from the problem</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 1 - Problem example:"</span><span class="o">);</span>
        <span class="nc">MaxStack</span> <span class="n">stk1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MaxStack</span><span class="o">();</span>
        <span class="n">stk1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(5)"</span><span class="o">);</span>
        <span class="n">stk1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(1)"</span><span class="o">);</span>
        <span class="n">stk1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(5)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"top() = "</span> <span class="o">+</span> <span class="n">stk1</span><span class="o">.</span><span class="na">top</span><span class="o">());</span>  <span class="c1">// Expected output: 5</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"popMax() = "</span> <span class="o">+</span> <span class="n">stk1</span><span class="o">.</span><span class="na">popMax</span><span class="o">());</span>  <span class="c1">// Expected output: 5</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"top() = "</span> <span class="o">+</span> <span class="n">stk1</span><span class="o">.</span><span class="na">top</span><span class="o">());</span>  <span class="c1">// Expected output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"peekMax() = "</span> <span class="o">+</span> <span class="n">stk1</span><span class="o">.</span><span class="na">peekMax</span><span class="o">());</span>  <span class="c1">// Expected output: 5</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pop() = "</span> <span class="o">+</span> <span class="n">stk1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>  <span class="c1">// Expected output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"top() = "</span> <span class="o">+</span> <span class="n">stk1</span><span class="o">.</span><span class="na">top</span><span class="o">());</span>  <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 2: Testing duplicate elements</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2 - Duplicate elements:"</span><span class="o">);</span>
        <span class="nc">MaxStack</span> <span class="n">stk2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MaxStack</span><span class="o">();</span>
        <span class="n">stk2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(1)"</span><span class="o">);</span>
        <span class="n">stk2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(1)"</span><span class="o">);</span>
        <span class="n">stk2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(2)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"popMax() = "</span> <span class="o">+</span> <span class="n">stk2</span><span class="o">.</span><span class="na">popMax</span><span class="o">());</span>  <span class="c1">// Expected output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"top() = "</span> <span class="o">+</span> <span class="n">stk2</span><span class="o">.</span><span class="na">top</span><span class="o">());</span>  <span class="c1">// Expected output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"peekMax() = "</span> <span class="o">+</span> <span class="n">stk2</span><span class="o">.</span><span class="na">peekMax</span><span class="o">());</span>  <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 3: Testing continuous operations</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3 - Continuous operations:"</span><span class="o">);</span>
        <span class="nc">MaxStack</span> <span class="n">stk3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MaxStack</span><span class="o">();</span>
        <span class="n">stk3</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(3)"</span><span class="o">);</span>
        <span class="n">stk3</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(2)"</span><span class="o">);</span>
        <span class="n">stk3</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"push(4)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"peekMax() = "</span> <span class="o">+</span> <span class="n">stk3</span><span class="o">.</span><span class="na">peekMax</span><span class="o">());</span>  <span class="c1">// Expected output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pop() = "</span> <span class="o">+</span> <span class="n">stk3</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>  <span class="c1">// Expected output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"top() = "</span> <span class="o">+</span> <span class="n">stk3</span><span class="o">.</span><span class="na">top</span><span class="o">());</span>  <span class="c1">// Expected output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"peekMax() = "</span> <span class="o">+</span> <span class="n">stk3</span><span class="o">.</span><span class="na">peekMax</span><span class="o">());</span>  <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"popMax() = "</span> <span class="o">+</span> <span class="n">stk3</span><span class="o">.</span><span class="na">popMax</span><span class="o">());</span>  <span class="c1">// Expected output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"top() = "</span> <span class="o">+</span> <span class="n">stk3</span><span class="o">.</span><span class="na">top</span><span class="o">());</span>  <span class="c1">// Expected output: 2</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[Design a max stack data structure that supports the stack operations and supports finding the stack’s maximum element. Implement the MaxStack class: MaxStack() Initializes the stack object. void push(int x) Pushes element x onto the stack. int pop() Removes the element on top of the stack and returns it. int top() Gets the element on the top of the stack without removing it. int peekMax() Retrieves the maximum element in the stack without removing it. int popMax() Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the top-most one.]]></summary></entry><entry><title type="html">290.Word Pattern</title><link href="https://zhengstar94.github.io//blog/2024/WordPattern/" rel="alternate" type="text/html" title="290.Word Pattern"/><published>2024-11-09T00:00:00+00:00</published><updated>2024-11-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/WordPattern</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/WordPattern/"><![CDATA[<ul> <li>Given a <code class="language-plaintext highlighter-rouge">pattern</code> and a string <code class="language-plaintext highlighter-rouge">s</code>, find if <code class="language-plaintext highlighter-rouge">s</code> follows the same pattern.</li> <li>Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code class="language-plaintext highlighter-rouge">pattern</code> and a <strong>non-empty</strong> word in <code class="language-plaintext highlighter-rouge">s</code>. Specifically: <ul> <li>Each letter in <code class="language-plaintext highlighter-rouge">pattern</code> maps to <strong>exactly</strong> one unique word in <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Each unique word in <code class="language-plaintext highlighter-rouge">s</code> maps to <strong>exactly</strong> one letter in <code class="language-plaintext highlighter-rouge">pattern</code>.</li> <li>No two letters map to the same word, and no two words map to the same letter.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: pattern = "abba", s = "dog cat cat dog"
Output: true

Explanation:

The bijection can be established as:
'a' maps to "dog".
'b' maps to "cat".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: pattern = "abba", s = "dog cat cat fish"
Output: false
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: pattern = "aaaa", s = "dog cat cat dog"
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/09
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordPattern</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">wordPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Split the input string into an array of words</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>

        <span class="c1">// Check if the length of pattern matches the number of words</span>
        <span class="c1">// If not, they can't possibly follow the same pattern</span>
        <span class="k">if</span><span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Create two HashMaps for bidirectional mapping</span>
        <span class="c1">// charToWord: maps each character in pattern to its corresponding word</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">charToWord</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// wordToChar: maps each word to its corresponding character in pattern</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Character</span><span class="o">&gt;</span> <span class="n">wordToChar</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each character in pattern and its corresponding word</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="c1">// Check character to word mapping</span>
            <span class="k">if</span><span class="o">(</span><span class="n">charToWord</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="c1">// If this character has been mapped before,</span>
                <span class="c1">// verify it maps to the same word</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">charToWord</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">word</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>  <span class="c1">// Violation: same char maps to different words</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If this is a new character, add the mapping</span>
                <span class="n">charToWord</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">word</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Check word to character mapping</span>
            <span class="k">if</span><span class="o">(</span><span class="n">wordToChar</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">word</span><span class="o">)){</span>
                <span class="c1">// If this word has been mapped before,</span>
                <span class="c1">// verify it maps to the same character</span>
                <span class="k">if</span><span class="o">(</span><span class="n">wordToChar</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>  <span class="c1">// Violation: same word maps to different chars</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">// If this is a new word, add the mapping</span>
                <span class="n">wordToChar</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// If we reach here, all mappings are valid</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Should return true</span>
        <span class="c1">// Pattern "abba" matches with "dog cat cat dog"</span>
        <span class="nc">String</span> <span class="n">pattern1</span> <span class="o">=</span> <span class="s">"abba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"dog cat cat dog"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pattern = "</span> <span class="o">+</span> <span class="n">pattern1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s = "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">wordPattern</span><span class="o">(</span><span class="n">pattern1</span><span class="o">,</span> <span class="n">s1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Should return false</span>
        <span class="c1">// Pattern "abba" doesn't match with "dog cat cat fish"</span>
        <span class="nc">String</span> <span class="n">pattern2</span> <span class="o">=</span> <span class="s">"abba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"dog cat cat fish"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pattern = "</span> <span class="o">+</span> <span class="n">pattern2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s = "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">wordPattern</span><span class="o">(</span><span class="n">pattern2</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Should return false</span>
        <span class="c1">// Pattern "aaaa" doesn't match with "dog cat cat dog"</span>
        <span class="nc">String</span> <span class="n">pattern3</span> <span class="o">=</span> <span class="s">"aaaa"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"dog cat cat dog"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pattern = "</span> <span class="o">+</span> <span class="n">pattern3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s = "</span> <span class="o">+</span> <span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">wordPattern</span><span class="o">(</span><span class="n">pattern3</span><span class="o">,</span> <span class="n">s3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically: Each letter in pattern maps to exactly one unique word in s. Each unique word in s maps to exactly one letter in pattern. No two letters map to the same word, and no two words map to the same letter.]]></summary></entry><entry><title type="html">1249.Minimum Remove to Make Valid Parentheses</title><link href="https://zhengstar94.github.io//blog/2024/MinimumRemoveToMakeValidParentheses/" rel="alternate" type="text/html" title="1249.Minimum Remove to Make Valid Parentheses"/><published>2024-11-08T00:00:00+00:00</published><updated>2024-11-08T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MinimumRemoveToMakeValidParentheses</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MinimumRemoveToMakeValidParentheses/"><![CDATA[<ul> <li>Given a string s of <code class="language-plaintext highlighter-rouge">'('</code> , <code class="language-plaintext highlighter-rouge">')'</code> and lowercase English characters.</li> <li>Your task is to remove the minimum number of parentheses ( <code class="language-plaintext highlighter-rouge">'('</code> or <code class="language-plaintext highlighter-rouge">')'</code>, in any positions ) so that the resulting <em>parentheses string</em> is valid and return <strong>any</strong> valid string.</li> <li>Formally, a <em>parentheses string</em> is valid if and only if: <ul> <li>It is the empty string, contains only lowercase characters, or</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">AB</code> (<code class="language-plaintext highlighter-rouge">A</code> concatenated with <code class="language-plaintext highlighter-rouge">B</code>), where <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are valid strings, or</li> <li>It can be written as <code class="language-plaintext highlighter-rouge">(A)</code>, where <code class="language-plaintext highlighter-rouge">A</code> is a valid string.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "a)b(c)d"
Output: "ab(c)d"
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/08
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumRemoveToMakeValidParentheses</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">minRemoveToMakeValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// StringBuilder for first pass result</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// Counter for total left parentheses seen</span>
        <span class="kt">int</span> <span class="n">openSeen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Counter for currently unmatched left parentheses</span>
        <span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// First pass: Remove invalid right parentheses</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Increment both counters when seeing a left parenthesis</span>
                <span class="n">openSeen</span><span class="o">++;</span>    <span class="c1">// Track total left parentheses</span>
                <span class="n">balance</span><span class="o">++;</span>     <span class="c1">// Track unmatched left parentheses</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Skip this right parenthesis if there's no matching left parenthesis</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Found a matching pair, decrease unmatched count</span>
                <span class="n">balance</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="c1">// Add current character to result</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// StringBuilder for final result</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="c1">// Calculate how many left parentheses we need to keep</span>
        <span class="c1">// openToKeep = total left parentheses - unmatched left parentheses</span>
        <span class="kt">int</span> <span class="n">openToKeep</span> <span class="o">=</span> <span class="n">openSeen</span> <span class="o">-</span> <span class="n">balance</span><span class="o">;</span>

        <span class="c1">// Second pass: Remove excess left parentheses</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// For each left parenthesis, decrease the count to keep</span>
                <span class="n">openToKeep</span><span class="o">--;</span>
                <span class="c1">// Skip this left parenthesis if we already have enough</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">openToKeep</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// Add current character to final result</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Contains invalid right and left parentheses</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"lee(t(c)o)de)"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">test1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minRemoveToMakeValid</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Contains invalid right parenthesis</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"a)b(c)d"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">test2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minRemoveToMakeValid</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: All parentheses are invalid</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"))(("</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">test3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minRemoveToMakeValid</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Only right parentheses</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"a)))b"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">test4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minRemoveToMakeValid</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Complex nested parentheses</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"(a(b(c)d)e)))"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">test5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minRemoveToMakeValid</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 6: Empty string</span>
        <span class="nc">String</span> <span class="n">test6</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 6:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">test6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minRemoveToMakeValid</span><span class="o">(</span><span class="n">test6</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 7: Only letters</span>
        <span class="nc">String</span> <span class="n">test7</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 7:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: "</span> <span class="o">+</span> <span class="n">test7</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minRemoveToMakeValid</span><span class="o">(</span><span class="n">test7</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.]]></summary></entry></feed>