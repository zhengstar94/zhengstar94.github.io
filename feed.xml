<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-22T07:37:47+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2138. Divide a String Into Groups of Size k</title><link href="https://zhengstar94.github.io//blog/2025/DivideAStringIntoGroupsOfSizek/" rel="alternate" type="text/html" title="2138. Divide a String Into Groups of Size k"/><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DivideAStringIntoGroupsOfSizek</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DivideAStringIntoGroupsOfSizek/"><![CDATA[<ul> <li>A string <code class="language-plaintext highlighter-rouge">s</code> can be partitioned into groups of size <code class="language-plaintext highlighter-rouge">k</code> using the following procedure: <ul> <li>The first group consists of the first <code class="language-plaintext highlighter-rouge">k</code> characters of the string, the second group consists of the next <code class="language-plaintext highlighter-rouge">k</code> characters of the string, and so on. Each element can be a part of <strong>exactly one</strong> group.</li> <li>For the last group, if the string <strong>does not</strong> have <code class="language-plaintext highlighter-rouge">k</code> characters remaining, a character <code class="language-plaintext highlighter-rouge">fill</code> is used to complete the group.</li> </ul> </li> <li>Note that the partition is done so that after removing the <code class="language-plaintext highlighter-rouge">fill</code> character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be <code class="language-plaintext highlighter-rouge">s</code>.</li> <li>Given the string <code class="language-plaintext highlighter-rouge">s</code>, the size of each group <code class="language-plaintext highlighter-rouge">k</code> and the character <code class="language-plaintext highlighter-rouge">fill</code>, return <em>a string array denoting the <strong>composition of every group</strong></em> <code class="language-plaintext highlighter-rouge">s</code> <em>has been divided into, using the above procedure</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcdefghi", k = 3, fill = "x"
Output: ["abc","def","ghi"]
Explanation:
The first 3 characters "abc" form the first group.
The next 3 characters "def" form the second group.
The last 3 characters "ghi" form the third group.
Since all groups can be completely filled by characters from the string, we do not need to use fill.
Thus, the groups formed are "abc", "def", and "ghi".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcdefghij", k = 3, fill = "x"
Output: ["abc","def","ghi","jxx"]
Explanation:
Similar to the previous example, we are forming the first three groups "abc", "def", and "ghi".
For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.
Thus, the 4 groups formed are "abc", "def", "ghi", and "jxx".
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.String</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DivideAStringIntoGroupsOfSizek</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">divideString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">char</span> <span class="n">fill</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// Get the length of the input string.</span>

        <span class="c1">// Calculate the total number of groups needed.</span>
        <span class="c1">// (n + k - 1) / k is a common trick to perform integer division with rounding up.</span>
        <span class="c1">// For example, if n=10 and k=3, (10+3-1)/3 = 12/3 = 4 groups.</span>
        <span class="c1">// This ensures that if there are leftover characters, we still allocate a group for them.</span>
        <span class="kt">int</span> <span class="n">groupCount</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">k</span><span class="o">;</span>

        <span class="c1">// Create an array to store the resulting groups.</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">groupCount</span><span class="o">];</span>

        <span class="c1">// Iterate over each group index.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">groupCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate the starting index of the current group in the original string.</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span><span class="o">;</span>

            <span class="c1">// Calculate the ending index (exclusive) for the current group.</span>
            <span class="c1">// Use Math.min to avoid going out of bounds if the last group is shorter than k.</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

            <span class="c1">// Use StringBuilder for efficient string concatenation.</span>
            <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

            <span class="c1">// Append the substring for the current group.</span>
            <span class="c1">// This will add all available characters from start to end (end not included).</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

            <span class="c1">// If the current group is shorter than k, pad it with the fill character.</span>
            <span class="c1">// This loop will add as many fill characters as needed to reach length k.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">fill</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Convert the StringBuilder to a String and store it in the result array.</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Return the array containing all the groups.</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Main method with test cases to demonstrate the function.</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: String length is a multiple of k, no padding needed.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">divideString</span><span class="o">(</span><span class="s">"abcdefghi"</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="sc">'x'</span><span class="o">)</span> <span class="o">)</span> <span class="o">);</span> <span class="c1">// Output: ["abc", "def", "ghi"]</span>

        <span class="c1">// Test case 2: String length is not a multiple of k, last group needs padding.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">divideString</span><span class="o">(</span><span class="s">"abcdefghij"</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="sc">'x'</span><span class="o">)</span> <span class="o">)</span> <span class="o">);</span> <span class="c1">// Output: ["abc", "def", "ghi", "jxx"]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode String"/><category term="Easy"/><summary type="html"><![CDATA[A string s can be partitioned into groups of size k using the following procedure: The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each element can be a part of exactly one group. For the last group, if the string does not have k characters remaining, a character fill is used to complete the group. Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s. Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.]]></summary></entry><entry><title type="html">1673. Find the Most Competitive Subsequence</title><link href="https://zhengstar94.github.io//blog/2025/FindTheMostCompetitiveSubsequence/" rel="alternate" type="text/html" title="1673. Find the Most Competitive Subsequence"/><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheMostCompetitiveSubsequence</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheMostCompetitiveSubsequence/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and a positive integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the most <strong>competitive</strong> subsequence of</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>of size</em> <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>An array’s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.</li> <li>We define that a subsequence <code class="language-plaintext highlighter-rouge">a</code> is more <strong>competitive</strong> than a subsequence <code class="language-plaintext highlighter-rouge">b</code> (of the same length) if in the first position where <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> differ, subsequence <code class="language-plaintext highlighter-rouge">a</code> has a number <strong>less</strong> than the corresponding number in <code class="language-plaintext highlighter-rouge">b</code>. For example, <code class="language-plaintext highlighter-rouge">[1,3,4]</code> is more competitive than <code class="language-plaintext highlighter-rouge">[1,3,5]</code> because the first position they differ is at the final number, and <code class="language-plaintext highlighter-rouge">4</code> is less than <code class="language-plaintext highlighter-rouge">5</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,5,2,6], k = 2
Output: [2,6]
Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,3,3,5,4,9,6], k = 4
Output: [2,3,3,4]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheMostCompetitiveSubsequence</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">mostCompetitive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Use an array to simulate a stack, which will store the result subsequence.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="c1">// 'top' is the pointer to the next available position in the stack (also represents the current stack size).</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the input array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// While the stack is not empty,</span>
            <span class="c1">// and the current element is smaller than the top element of the stack,</span>
            <span class="c1">// and there are enough elements left in nums to fill the stack to size k after popping:</span>
            <span class="c1">//    - Pop the stack (i.e., remove the last element from the current subsequence).</span>
            <span class="c1">//    - This ensures that the subsequence remains as lexicographically small as possible.</span>
            <span class="c1">//    - The condition (n - i) &gt; (k - top) is crucial:</span>
            <span class="c1">//      It checks if, after popping, there are still enough elements left to fill the subsequence to length k.</span>
            <span class="c1">//      If not, we must keep the current stack elements to avoid ending up with fewer than k elements.</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">top</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">[</span><span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">top</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">top</span><span class="o">--;</span> <span class="c1">// Pop the top element from the stack.</span>
            <span class="o">}</span>
            <span class="c1">// If the stack is not yet full (less than k elements), push the current element onto the stack.</span>
            <span class="c1">// This ensures we always build a subsequence of exactly length k.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">[</span><span class="n">top</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// At the end, 'stack' contains the most competitive subsequence of length k.</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1: Input array [3,5,2,6], k = 2</span>
        <span class="c1">// Expected output: [2,6]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">mostCompetitive</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span> <span class="mi">2</span><span class="o">)));</span> <span class="c1">// [2,6]</span>

        <span class="c1">// Example 2: Input array [2,4,3,3,5,4,9,6], k = 4</span>
        <span class="c1">// Expected output: [2,3,3,4]</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">mostCompetitive</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span> <span class="mi">4</span><span class="o">)));</span> <span class="c1">// [2,3,3,4]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k. An array’s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5.]]></summary></entry><entry><title type="html">316. Remove Duplicate Letters</title><link href="https://zhengstar94.github.io//blog/2025/RemoveDuplicateLetters/" rel="alternate" type="text/html" title="316. Remove Duplicate Letters"/><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/RemoveDuplicateLetters</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/RemoveDuplicateLetters/"><![CDATA[<ul> <li>Given a string <code class="language-plaintext highlighter-rouge">s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <strong>the smallest in lexicographical order</strong> among all possible results.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "bcabc"
Output: "abc"
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "cbacdcbc"
Output: "acdb"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveDuplicateLetters</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">removeDuplicateLetters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span> <span class="c1">// Array to count the remaining occurrences of each character.</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">inStack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span> <span class="c1">// Flags to indicate if a character is already in the stack.</span>

        <span class="c1">// First pass: count the occurrences of each character in the string.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span> <span class="c1">// Monotonic stack to build the result.</span>

        <span class="c1">// Iterate through each character in the string.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span> <span class="c1">// Decrement the count for this character, as it's now being processed.</span>

            <span class="c1">// If the character is already in the stack, skip it to avoid duplicates.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">inStack</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * While the stack is not empty, and the current character is lexicographically
             * smaller than the character at the top of the stack, and the character at the
             * top of the stack will appear again later (count &gt; 0):
             *   - Pop the top character from the stack.
             *   - Mark it as not in the stack.
             * This ensures that:
             *   1. The result remains lexicographically smallest by removing bigger letters
             *      that can still be placed later.
             *   2. Each letter appears only once in the result.
             */</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span>
                    <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span>
                    <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">removed</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span> <span class="c1">// Remove the top character from the stack.</span>
                <span class="n">inStack</span><span class="o">[</span><span class="n">removed</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>    <span class="c1">// Mark the removed character as not in the stack.</span>
            <span class="o">}</span>

            <span class="c1">// Add the current character to the stack and mark it as present.</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="n">inStack</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Build the final result string from the characters in the stack.</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeDuplicateLetters</span><span class="o">(</span><span class="s">"bcabc"</span><span class="o">));</span>      <span class="c1">// Output: "abc"</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">removeDuplicateLetters</span><span class="o">(</span><span class="s">"cbacdcbc"</span><span class="o">));</span>   <span class="c1">// Output: "acdb"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><category term="Medium"/><summary type="html"><![CDATA[Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.]]></summary></entry><entry><title type="html">3085. Minimum Deletions to Make String K-Special</title><link href="https://zhengstar94.github.io//blog/2025/MinimumDeletionsToMakeStringKSpecial/" rel="alternate" type="text/html" title="3085. Minimum Deletions to Make String K-Special"/><published>2025-06-21T00:00:00+00:00</published><updated>2025-06-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumDeletionsToMakeStringKSpecial</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumDeletionsToMakeStringKSpecial/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">word</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>We consider <code class="language-plaintext highlighter-rouge">word</code> to be <strong>k-special</strong> if <code class="language-plaintext highlighter-rouge">|freq(word[i]) - freq(word[j])| &lt;= k</code> for all indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> in the string.</li> <li>Here, <code class="language-plaintext highlighter-rouge">freq(x)</code> denotes the frequency of the character <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">word</code>, and <code class="language-plaintext highlighter-rouge">|y|</code> denotes the absolute value of <code class="language-plaintext highlighter-rouge">y</code>.</li> <li>Return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code class="language-plaintext highlighter-rouge">word</code> <strong>*k-special*</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "aabcaba", k = 0

Output: 3

Explanation: We can make word 0-special by deleting 2 occurrences of "a" and 1 occurrence of "c". Therefore, word becomes equal to "baba" where freq('a') == freq('b') == 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "dabdcbdcdcd", k = 2

Output: 2

Explanation: We can make word 2-special by deleting 1 occurrence of "a" and 1 occurrence of "d". Therefore, word becomes equal to "bdcbdcdcd" where freq('b') == 2, freq('c') == 3, and freq('d') == 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: word = "aaabaaa", k = 2

Output: 1

Explanation: We can make word 2-special by deleting 1 occurrence of "b". Therefore, word becomes equal to "aaaaaa" where each letter's frequency is now uniformly 6.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumDeletionsToMakeStringKSpecial</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimumDeletions</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Count the frequency of each character in the string.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">freq</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Collect all non-zero frequencies into a list.</span>
        <span class="c1">// Only characters that appear in the string are relevant for further processing.</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freqList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">f</span> <span class="o">:</span> <span class="n">freq</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">freqList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Try every possible lower bound (lo) for the frequency interval [lo, lo + k].</span>
        <span class="c1">// The goal is to find the interval that requires the fewest deletions to fit all frequencies within it.</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="c1">// Initialize the answer with a large value.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lo</span> <span class="o">:</span> <span class="n">freqList</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// This will count the number of deletions needed for the current interval.</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">freqList</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// If the frequency is less than the lower bound, we must delete all occurrences of this character.</span>
                    <span class="n">cnt</span> <span class="o">+=</span> <span class="n">v</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// If the frequency is greater than the upper bound, we must delete the excess occurrences.</span>
                    <span class="n">cnt</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">-</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">k</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">// If v is within [lo, lo + k], no deletion is needed for this character.</span>
            <span class="o">}</span>
            <span class="c1">// Update the answer if the current interval requires fewer deletions.</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Step 4: Return the minimum deletions found.</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to verify the solution.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"aabcaba"</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"dabdcbdcdcd"</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Output: 2</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"aaabaaa"</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"abc"</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span> <span class="c1">// Output: 0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">minimumDeletions</span><span class="o">(</span><span class="s">"aaaaa"</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string word and an integer k. We consider word to be k-special if |freq(word[i]) - freq(word[j])| &lt;= k for all indices i and j in the string. Here, freq(x) denotes the frequency of the character x in word, and |y| denotes the absolute value of y. Return the minimum number of characters you need to delete to make word *k-special*.]]></summary></entry><entry><title type="html">3443. Maximum Manhattan Distance After K Changes</title><link href="https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK/" rel="alternate" type="text/html" title="3443. Maximum Manhattan Distance After K Changes"/><published>2025-06-20T00:00:00+00:00</published><updated>2025-06-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> consisting of the characters <code class="language-plaintext highlighter-rouge">'N'</code>, <code class="language-plaintext highlighter-rouge">'S'</code>, <code class="language-plaintext highlighter-rouge">'E'</code>, and <code class="language-plaintext highlighter-rouge">'W'</code>, where <code class="language-plaintext highlighter-rouge">s[i]</code> indicates movements in an infinite grid: <ul> <li><code class="language-plaintext highlighter-rouge">'N'</code> : Move north by 1 unit.</li> <li><code class="language-plaintext highlighter-rouge">'S'</code> : Move south by 1 unit.</li> <li><code class="language-plaintext highlighter-rouge">'E'</code> : Move east by 1 unit.</li> <li><code class="language-plaintext highlighter-rouge">'W'</code> : Move west by 1 unit.</li> </ul> </li> <li>Initially, you are at the origin <code class="language-plaintext highlighter-rouge">(0, 0)</code>. You can change <strong>at most</strong> <code class="language-plaintext highlighter-rouge">k</code> characters to any of the four directions.</li> <li>Find the <strong>maximum</strong> <strong>Manhattan distance</strong> from the origin that can be achieved <strong>at any time</strong> while performing the movements <strong>in order</strong>.</li> <li>The <strong>Manhattan Distance</strong> between two cells <code class="language-plaintext highlighter-rouge">(xi, yi)</code> and <code class="language-plaintext highlighter-rouge">(xj, yj)</code> is <code class="language-plaintext highlighter-rouge">|xi - xj| + |yi - yj|</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "NWSE", k = 1

Output: 3

Explanation:

Change s[2] from 'S' to 'N'. The string s becomes "NWNE".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "NSWWEW", k = 3

Output: 6

Explanation:

Change s[1] from 'S' to 'N', and s[4] from 'E' to 'W'. The string s becomes "NNWWWW".

The maximum Manhattan distance from the origin that can be achieved is 6. Hence, 6 is the output.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumManhattanDistanceAfterKChanges</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ans: stores the maximum Manhattan distance found so far</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// x, y: current coordinates on the infinite grid (starting from origin 0,0)</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Simulate the movement step by step</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="c1">// Update current position based on the movement character</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'N'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">y</span><span class="o">++;</span>  <span class="c1">// Move north: increase y-coordinate</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'S'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">y</span><span class="o">--;</span>  <span class="c1">// Move south: decrease y-coordinate  </span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'E'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">x</span><span class="o">++;</span>  <span class="c1">// Move east: increase x-coordinate</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>  <span class="c1">// c == 'W'</span>
                <span class="n">x</span><span class="o">--;</span>  <span class="c1">// Move west: decrease x-coordinate</span>
            <span class="o">}</span>

            <span class="cm">/*
             * CRITICAL FORMULA EXPLANATION:
             *
             * Math.abs(x) + Math.abs(y) + k * 2:
             * - This represents the THEORETICAL maximum distance we could achieve at this step
             * - Math.abs(x) + Math.abs(y): current actual Manhattan distance from origin
             * - k * 2: maximum additional distance we can gain through k character changes
             *   (each change can add up to 2 units of distance)
             *
             * i + 1:
             * - This represents the PHYSICAL maximum distance possible
             * - Since we've taken (i+1) steps total, we cannot be more than (i+1) units away from origin
             * - This is a fundamental physical constraint in any grid movement
             *
             * Math.min(theoretical_max, physical_max):
             * - We take the minimum because both constraints must be satisfied
             * - Even if we could theoretically reach distance 100 with our changes,
             *   if we've only taken 5 steps, we can't be more than 5 units away
             *
             * Example walkthrough:
             * s = "NWSE", k = 1, at step 3 (after "NWS"):
             * - Current position: (-1, 0), current distance = 1
             * - Theoretical max: 1 + 1*2 = 3 (current distance + max improvement from 1 change)
             * - Physical max: 3 (we've taken 3 steps)
             * - Actual max at this step: min(3, 3) = 3
             */</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic example showing the greedy approach</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"NWSE"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = \""</span> <span class="o">+</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">"\", k = "</span> <span class="o">+</span> <span class="n">k1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDistance</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Explanation: At step 2, current distance=2, 2+2*1=4, but only walked 2 steps, so min(4,2)=2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"             At step 3, current distance=1, 1+2*1=3, walked 3 steps, so min(3,3)=3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: More complex example with multiple changes</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"NSWWEW"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: s = \""</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="s">"\", k = "</span> <span class="o">+</span> <span class="n">k2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDistance</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Explanation: With 3 changes, we can potentially add up to 6 units of distance"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given a string s consisting of the characters 'N', 'S', 'E', and 'W', where s[i] indicates movements in an infinite grid: 'N' : Move north by 1 unit. 'S' : Move south by 1 unit. 'E' : Move east by 1 unit. 'W' : Move west by 1 unit. Initially, you are at the origin (0, 0). You can change at most k characters to any of the four directions. Find the maximum Manhattan distance from the origin that can be achieved at any time while performing the movements in order. The Manhattan Distance between two cells (xi, yi) and (xj, yj) is |xi - xj| + |yi - yj|.]]></summary></entry><entry><title type="html">2294. Partition Array Such That Maximum Difference Is K</title><link href="https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK/" rel="alternate" type="text/html" title="2294. Partition Array Such That Maximum Difference Is K"/><published>2025-06-19T00:00:00+00:00</published><updated>2025-06-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/PartitionArraySuchThatMaximumDifferenceIsK/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>. You may partition <code class="language-plaintext highlighter-rouge">nums</code> into one or more <strong>subsequences</strong> such that each element in <code class="language-plaintext highlighter-rouge">nums</code> appears in <strong>exactly</strong> one of the subsequences.</li> <li>Return <em>the <strong>minimum</strong> number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is <strong>at most</strong></em> <code class="language-plaintext highlighter-rouge">k</code><em>.</em></li> <li>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,6,1,2,5], k = 2
Output: 2
Explanation:
We can partition nums into the two subsequences [3,1,2] and [6,5].
The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.
The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.
Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,3], k = 1
Output: 2
Explanation:
We can partition nums into the two subsequences [1,2] and [3].
The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.
The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.
Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,2,4,5], k = 0
Output: 3
Explanation:
We can partition nums into the three subsequences [2,2], [4], and [5].
The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.
The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.
The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.
Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PartitionArraySuchThatMaximumDifferenceIsK</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partitionArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the array so we can process elements in ascending order</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Counter for the number of required subsequences</span>

        <span class="c1">// Initialize mn (the minimum value in the current group)</span>
        <span class="c1">// to a very small number to ensure the first element always starts a new group.</span>
        <span class="c1">// We use Integer.MIN_VALUE / 2 to avoid potential overflow in x - mn.</span>
        <span class="kt">int</span> <span class="n">mn</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// Traverse each number in the sorted array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the difference between the current number and the minimum value in</span>
            <span class="c1">// the current group exceeds k, we must start a new group</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mn</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span><span class="o">++;</span>   <span class="c1">// Start a new group, increment the group counter</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>  <span class="c1">// Set the current number as the new group's minimum</span>
            <span class="o">}</span>
            <span class="c1">// Else, this number can be included in the current group,</span>
            <span class="c1">// and we do not update ans or mn.</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">partitionArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">partitionArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">partitionArray</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences. Return the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.]]></summary></entry><entry><title type="html">2966. Divide Array Into Arrays With Max Difference</title><link href="https://zhengstar94.github.io//blog/2025/DivideArrayIntoArraysWithMaxDifference/" rel="alternate" type="text/html" title="2966. Divide Array Into Arrays With Max Difference"/><published>2025-06-18T00:00:00+00:00</published><updated>2025-06-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/DivideArrayIntoArraysWithMaxDifference</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/DivideArrayIntoArraysWithMaxDifference/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code> where <code class="language-plaintext highlighter-rouge">n</code> is a multiple of 3 and a positive integer <code class="language-plaintext highlighter-rouge">k</code>.</li> <li>Divide the array <code class="language-plaintext highlighter-rouge">nums</code> into <code class="language-plaintext highlighter-rouge">n / 3</code> arrays of size <strong>3</strong> satisfying the following condition: <ul> <li>The difference between <strong>any</strong> two elements in one array is <strong>less than or equal</strong> to <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> </li> <li>Return a <strong>2D</strong> array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return <strong>any</strong> of them.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,3,4,8,7,9,3,5,1], k = 2

Output: [[1,1,3],[3,4,5],[7,8,9]]

Explanation:

The difference between any two elements in each array is less than or equal to 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,4,2,2,5,2], k = 2

Output: []

Explanation:

Different ways to divide nums into 2 arrays of size 3 are:

[[2,2,2],[2,4,5]] (and its permutations)
[[2,2,4],[2,2,5]] (and its permutations)
Because there are four 2s there will be an array with the elements 2 and 5 no matter how we divide it. since 5 - 2 = 3 &gt; k, the condition is not satisfied and so there is no valid division.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,9,8,2,12,7,12,10,5,8,5,5,7,9,2,5,11], k = 14

Output: [[2,2,12],[4,8,5],[5,9,7],[7,8,5],[5,9,10],[11,12,2]]

Explanation:

The difference between any two elements in each array is less than or equal to 14.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DivideArrayIntoArraysWithMaxDifference</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">divideArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Sort the array so that close values are adjacent</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Step 2: Prepare the result array of size n / 3</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">3</span><span class="o">][];</span>

        <span class="c1">// Step 3: Iterate over the sorted array in chunks of 3 elements</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Step 4: Check if the current group of 3 elements satisfies the condition</span>
            <span class="c1">// Since the array is sorted, nums[i] is the largest, nums[i - 2] is the smallest</span>
            <span class="c1">// If the difference between them is greater than k, return an empty array</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{};</span>
            <span class="o">}</span>

            <span class="c1">// Step 5: Otherwise, construct a valid group of 3 elements</span>
            <span class="c1">// and assign it to the answer array</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]};</span>
        <span class="o">}</span>

        <span class="c1">// Step 6: Return the valid grouped array</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[]"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">divideArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="c1">// Expected output: [[1,1,3], [3,4,5], [7,8,9]]</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">divideArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="c1">// Expected output: [] (no valid grouping possible)</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">11</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">14</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3:"</span><span class="o">);</span>
        <span class="n">print2DArray</span><span class="o">(</span><span class="n">divideArray</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
        <span class="c1">// Expected output: One of many valid groupings where all 3-element groups have max diff &lt;= 14</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums of size n where n is a multiple of 3 and a positive integer k. Divide the array nums into n / 3 arrays of size 3 satisfying the following condition: The difference between any two elements in one array is less than or equal to k. Return a 2D array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.]]></summary></entry><entry><title type="html">2016. Maximum Difference Between Increasing Elements</title><link href="https://zhengstar94.github.io//blog/2025/MaximumDifferenceBetweenIncreasingElements/" rel="alternate" type="text/html" title="2016. Maximum Difference Between Increasing Elements"/><published>2025-06-16T00:00:00+00:00</published><updated>2025-06-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumDifferenceBetweenIncreasingElements</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumDifferenceBetweenIncreasingElements/"><![CDATA[<ul> <li>Given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code>, find the <strong>maximum difference</strong> between <code class="language-plaintext highlighter-rouge">nums[i]</code> and <code class="language-plaintext highlighter-rouge">nums[j]</code> (i.e., <code class="language-plaintext highlighter-rouge">nums[j] - nums[i]</code>), such that <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; j &lt; n</code> and <code class="language-plaintext highlighter-rouge">nums[i] &lt; nums[j]</code>.</li> <li>Return <em>the <strong>maximum difference</strong>.</em> If no such <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> exists, return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [7,1,5,4]
Output: 4
Explanation:
The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.
Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i &gt; j, so it is not valid.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [9,4,3,2]
Output: -1
Explanation:
There is no i and j such that i &lt; j and nums[i] &lt; nums[j].
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,5,2,10]
Output: 9
Explanation:
The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumDifferenceBetweenIncreasingElements</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maximumDifference</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize minVal to the first element.</span>
        <span class="c1">// This variable keeps track of the smallest value seen so far as we iterate.</span>
        <span class="kt">int</span> <span class="n">minVal</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Initialize maxDiff to -1.</span>
        <span class="c1">// This will store the maximum difference found that satisfies the condition.</span>
        <span class="kt">int</span> <span class="n">maxDiff</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Start iterating from the second element (index 1) to the end of the array.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current element is greater than the minimum value seen so far,</span>
            <span class="c1">// it means nums[i] can be nums[j] and minVal can be nums[i] for some i &lt; j.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">minVal</span><span class="o">){</span>
                <span class="c1">// Calculate the difference and update maxDiff if this difference is larger.</span>
                <span class="n">maxDiff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxDiff</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">minVal</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If the current element is less than or equal to minVal,</span>
                <span class="c1">// update minVal to the current element.</span>
                <span class="c1">// This ensures minVal always holds the smallest value up to the current index.</span>
                <span class="n">minVal</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After the loop, return the maximum difference found.</span>
        <span class="c1">// If no valid pair was found, maxDiff remains -1.</span>
        <span class="k">return</span> <span class="n">maxDiff</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Expected output is 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">maximumDifference</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Expected output is -1 (no valid pair exists)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">maximumDifference</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span>

        <span class="c1">// Test case 3: Expected output is 9</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">maximumDifference</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 &lt;= i &lt; j &lt; n and nums[i] &lt; nums[j]. Return the maximum difference. If no such i and j exists, return -1.]]></summary></entry><entry><title type="html">1432. Max Difference You Can Get From Changing an Integer</title><link href="https://zhengstar94.github.io//blog/2025/MaxDifferenceYouCanGetFromChangingAnInteger/" rel="alternate" type="text/html" title="1432. Max Difference You Can Get From Changing an Integer"/><published>2025-06-15T00:00:00+00:00</published><updated>2025-06-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxDifferenceYouCanGetFromChangingAnInteger</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxDifferenceYouCanGetFromChangingAnInteger/"><![CDATA[<ul> <li>You are given an integer <code class="language-plaintext highlighter-rouge">num</code>. You will apply the following steps to <code class="language-plaintext highlighter-rouge">num</code> <strong>two</strong> separate times: <ul> <li>Pick a digit <code class="language-plaintext highlighter-rouge">x (0 &lt;= x &lt;= 9)</code>.</li> <li>Pick another digit <code class="language-plaintext highlighter-rouge">y (0 &lt;= y &lt;= 9)</code>. Note <code class="language-plaintext highlighter-rouge">y</code> can be equal to <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>Replace all the occurrences of <code class="language-plaintext highlighter-rouge">x</code> in the decimal representation of <code class="language-plaintext highlighter-rouge">num</code> by <code class="language-plaintext highlighter-rouge">y</code>.</li> </ul> </li> <li>Let <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> be the two results from applying the operation to <code class="language-plaintext highlighter-rouge">num</code> <em>independently</em>.</li> <li>Return <em>the max difference</em> between <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>.</li> <li>Note that neither <code class="language-plaintext highlighter-rouge">a</code> nor <code class="language-plaintext highlighter-rouge">b</code> may have any leading zeros, and <strong>must not</strong> be 0.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num = 555
Output: 888
Explanation: The first time pick x = 5 and y = 9 and store the new integer in a.
The second time pick x = 5 and y = 1 and store the new integer in b.
We have now a = 999 and b = 111 and max difference = 888
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num = 9
Output: 8
Explanation: The first time pick x = 9 and y = 9 and store the new integer in a.
The second time pick x = 9 and y = 1 and store the new integer in b.
We have now a = 9 and b = 1 and max difference = 8
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxDifferenceYouCanGetFromChangingAnInteger</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxDiff</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert the integer to its string representation for easy digit manipulation.</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="c1">// Step 1: Find the maximum possible value (mx)</span>
        <span class="c1">// Start with the original number as the default maximum.</span>
        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="c1">// Iterate through each digit to find the first digit that is not '9'.</span>
        <span class="c1">// Replace all occurrences of this digit with '9' to maximize the number.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">d</span> <span class="o">:</span> <span class="n">cs</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="sc">'9'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">replace</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="sc">'9'</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span> <span class="c1">// Only replace the first such digit found.</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Find the minimum possible value (mn)</span>
        <span class="c1">// Start with the original number as the default minimum.</span>
        <span class="kt">int</span> <span class="n">mn</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="c1">// If the first digit is not '1', replace all its occurrences with '1' to minimize the number</span>
        <span class="c1">// (while avoiding leading zeros).</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cs</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'1'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="n">replace</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">cs</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="sc">'1'</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// If the first digit is '1', look for the first digit (from the second position onward)</span>
            <span class="c1">// that is greater than '1' (i.e., not '0' or '1').</span>
            <span class="c1">// Replace all its occurrences with '0' to minimize the number (again, avoiding leading zeros).</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">cs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="sc">'1'</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Not '0' and not '1'</span>
                    <span class="n">mn</span> <span class="o">=</span> <span class="n">replace</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">cs</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="sc">'0'</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span> <span class="c1">// Only replace the first such digit found.</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Return the difference between the maximum and minimum values obtained.</span>
        <span class="k">return</span> <span class="n">mx</span> <span class="o">-</span> <span class="n">mn</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">replace</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">oldChar</span><span class="o">,</span> <span class="kt">char</span> <span class="n">newChar</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Replace all occurrences of oldChar with newChar.</span>
        <span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">oldChar</span><span class="o">,</span> <span class="n">newChar</span><span class="o">);</span>
        <span class="c1">// Convert the modified string back to an integer.</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Input 555</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: Input 555"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDiff</span><span class="o">(</span><span class="mi">555</span><span class="o">));</span>  <span class="c1">// Expected output: 888</span>

        <span class="c1">// Test case 2: Input 9</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 2: Input 9"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDiff</span><span class="o">(</span><span class="mi">9</span><span class="o">));</span>    <span class="c1">// Expected output: 8</span>

        <span class="c1">// Test case 3: Input 123456</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 3: Input 123456"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDiff</span><span class="o">(</span><span class="mi">123456</span><span class="o">));</span>  <span class="c1">// Expected output: 820000</span>

        <span class="c1">// Test case 4: Input 10001</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest case 4: Input 10001"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">maxDiff</span><span class="o">(</span><span class="mi">10001</span><span class="o">));</span>   <span class="c1">// Expected output: 80008</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer num. You will apply the following steps to num two separate times: Pick a digit x (0 &lt;= x &lt;= 9). Pick another digit y (0 &lt;= y &lt;= 9). Note y can be equal to x. Replace all the occurrences of x in the decimal representation of num by y. Let a and b be the two results from applying the operation to num independently. Return the max difference between a and b. Note that neither a nor b may have any leading zeros, and must not be 0.]]></summary></entry><entry><title type="html">2566. Maximum Difference by Remapping a Digit</title><link href="https://zhengstar94.github.io//blog/2025/MaximumDifferenceByRemappingADigit/" rel="alternate" type="text/html" title="2566. Maximum Difference by Remapping a Digit"/><published>2025-06-14T00:00:00+00:00</published><updated>2025-06-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumDifferenceByRemappingADigit</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumDifferenceByRemappingADigit/"><![CDATA[<ul> <li>You are given an integer <code class="language-plaintext highlighter-rouge">num</code>. You know that Bob will sneakily <strong>remap</strong> one of the <code class="language-plaintext highlighter-rouge">10</code> possible digits (<code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">9</code>) to another digit.</li> <li>Return <em>the difference between the maximum and minimum values Bob can make by remapping <strong>exactly</strong> <strong>one</strong> digit in</em> <code class="language-plaintext highlighter-rouge">num</code>.</li> <li><strong>Notes:</strong> <ul> <li>When Bob remaps a digit d1 to another digit d2, Bob replaces all occurrences of <code class="language-plaintext highlighter-rouge">d1</code> in <code class="language-plaintext highlighter-rouge">num</code> with <code class="language-plaintext highlighter-rouge">d2</code>.</li> <li>Bob can remap a digit to itself, in which case <code class="language-plaintext highlighter-rouge">num</code> does not change.</li> <li>Bob can remap different digits for obtaining minimum and maximum values respectively.</li> <li>The resulting number after remapping can contain leading zeroes.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num = 11891
Output: 99009
Explanation: 
To achieve the maximum value, Bob can remap the digit 1 to the digit 9 to yield 99899.
To achieve the minimum value, Bob can remap the digit 1 to the digit 0, yielding 890.
The difference between these two numbers is 99009.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: num = 90
Output: 99
Explanation:
The maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).
Thus, we return 99.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @Author zhengxingxing
 * @Date 2025/06/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumDifferenceByRemappingADigit</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minMaxDifference</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Convert the input number to a string for easier manipulation.</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="c1">// Create a copy of the original string to manipulate for the minimum number.</span>
        <span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>

        <span class="c1">// Initialize a position variable to find the first non-'9' digit.</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Loop through the string until we find a digit that is not '9'.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pos</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'9'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pos</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// If we found a non-'9' digit, replace it with '9' in the string 's'.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pos</span><span class="o">),</span> <span class="sc">'9'</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Replace the first character of 't' with '0' to form the minimum number.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="sc">'0'</span><span class="o">);</span>

        <span class="c1">// Parse the modified strings back to integers and return their difference.</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">-</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to validate the functionality of the minMaxDifference method.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: 11891"</span><span class="o">);</span>
        <span class="c1">// Expected output: 99009 (by replacing '1' with '9' for max and '1' with '0' for min)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minMaxDifference</span><span class="o">(</span><span class="mi">11891</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: 90"</span><span class="o">);</span>
        <span class="c1">// Expected output: 99 (by replacing '0' with '9' for max and '9' with '0' for min)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">minMaxDifference</span><span class="o">(</span><span class="mi">90</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer num. You know that Bob will sneakily remap one of the 10 possible digits (0 to 9) to another digit. Return the difference between the maximum and minimum values Bob can make by remapping exactly one digit in num. Notes: When Bob remaps a digit d1 to another digit d2, Bob replaces all occurrences of d1 in num with d2. Bob can remap a digit to itself, in which case num does not change. Bob can remap different digits for obtaining minimum and maximum values respectively. The resulting number after remapping can contain leading zeroes.]]></summary></entry></feed>