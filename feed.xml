<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-22T03:14:32+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">1765. Map of Highest Peak</title><link href="https://zhengstar94.github.io//blog/2025/MapOfHighestPeak/" rel="alternate" type="text/html" title="1765. Map of Highest Peak"/><published>2025-01-22T00:00:00+00:00</published><updated>2025-01-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MapOfHighestPeak</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MapOfHighestPeak/"><![CDATA[<ul> <li> <p>You are given an integer matrix <code class="language-plaintext highlighter-rouge">isWater</code> of size <code class="language-plaintext highlighter-rouge">m x n</code> that represents a map of <strong>land</strong> and <strong>water</strong> cells.</p> <ul> <li>If <code class="language-plaintext highlighter-rouge">isWater [ i ] [ j ] == 0</code>, cell <code class="language-plaintext highlighter-rouge">(i, j)</code> is a <strong>land</strong> cell.</li> <li>If <code class="language-plaintext highlighter-rouge">isWater [ i ] [ j ] == 1</code>, cell <code class="language-plaintext highlighter-rouge">(i, j)</code> is a <strong>water</strong> cell.</li> </ul> </li> <li> <p>You must assign each cell a height in a way that follows these rules:</p> <ul> <li>The height of each cell must be non-negative.</li> <li>If the cell is a <strong>water</strong> cell, its height must be <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>Any two adjacent cells must have an absolute height difference of <strong>at most</strong> <code class="language-plaintext highlighter-rouge">1</code>. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</li> </ul> </li> <li> <p>Find an assignment of heights such that the maximum height in the matrix is <strong>maximized</strong>.</p> <p>Return <em>an integer matrix</em> <code class="language-plaintext highlighter-rouge">height</code> <em>of size</em> <code class="language-plaintext highlighter-rouge">m x n</code> <em>where</em> <code class="language-plaintext highlighter-rouge">height[i][j]</code> <em>is cell</em> <code class="language-plaintext highlighter-rouge">(i, j)</code><em>’s height. If there are multiple solutions, return <strong>any</strong> of them</em>.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: isWater = [ [ 0,1],[0,0 ] ]
Output: [ [ 1,0],[2,1 ] ]
Explanation: The image shows the assigned heights of each cell.
The blue cell is the water cell, and the green cells are the land cells.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: isWater = [ [ 0,0,1],[1,0,0],[0,0,0 ] ]
Output: [ [ 1,1,0],[0,1,1],[1,2,2 ] ]
Explanation: A height of 2 is the maximum possible height of any assignment.
Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * m) time | O(n * m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BFS</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MapOfHighestPeak</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">highestPeak</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Define directions for adjacent cells (up, down, left, right)</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">directions</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>

        <span class="c1">// Initialize queue for BFS (Breadth-First Search)</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Get matrix dimensions</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">isWater</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>    <span class="c1">// Number of rows</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">isWater</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Number of columns</span>

        <span class="c1">// Initialize the height matrix</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isWater</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Add water cells to queue as starting points</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="n">isWater</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Set water height to 0</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">isWater</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// Mark land cells as unvisited</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// BFS to assign heights to land cells</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Get current cell from queue</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">point</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Current row</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// Current column</span>

            <span class="c1">// Check all four adjacent cells</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">dir:</span> <span class="n">directions</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Calculate new coordinates</span>
                <span class="kt">int</span> <span class="n">newX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">newY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// Validate new coordinates and check if cell is unvisited</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">newX</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">newY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">newY</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">isWater</span><span class="o">[</span><span class="n">newX</span><span class="o">][</span><span class="n">newY</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Set height of new cell to current cell's height + 1</span>
                    <span class="n">isWater</span><span class="o">[</span><span class="n">newX</span><span class="o">][</span><span class="n">newY</span><span class="o">]</span> <span class="o">=</span> <span class="n">isWater</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="c1">// Add new cell to queue for further processing</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">newX</span><span class="o">,</span> <span class="n">newY</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">isWater</span><span class="o">;</span> <span class="c1">// Return the completed height matrix</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 测试用例</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Simple 2x2 matrix</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">highestPeak</span><span class="o">(</span><span class="n">isWater1</span><span class="o">));</span>
        <span class="c1">// Expected output:</span>
        <span class="c1">// [1, 0]</span>
        <span class="c1">// [2, 1]</span>

        <span class="c1">// Test Case 2: 3x3 matrix with multiple water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 2 Result:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">highestPeak</span><span class="o">(</span><span class="n">isWater2</span><span class="o">));</span>
        <span class="c1">// Expected output:</span>
        <span class="c1">// [1, 1, 0]</span>
        <span class="c1">// [0, 1, 1]</span>
        <span class="c1">// [1, 2, 2]</span>

        <span class="c1">// Test Case 3: All water cells</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">isWater4</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
                <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTest Case 3 Result:"</span><span class="o">);</span>
        <span class="n">printMatrix</span><span class="o">(</span><span class="n">highestPeak</span><span class="o">(</span><span class="n">isWater4</span><span class="o">));</span>
        <span class="c1">// Expected output:</span>
        <span class="c1">// [0, 0]</span>
        <span class="c1">// [0, 0]</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BFS"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer matrix isWater of size m x n that represents a map of land and water cells.]]></summary></entry><entry><title type="html">1561. Maximum Number of Coins You Can Get</title><link href="https://zhengstar94.github.io//blog/2025/MaximumNumberOfCoinsYouCanGet/" rel="alternate" type="text/html" title="1561. Maximum Number of Coins You Can Get"/><published>2025-01-22T00:00:00+00:00</published><updated>2025-01-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximumNumberOfCoinsYouCanGet</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximumNumberOfCoinsYouCanGet/"><![CDATA[<ul> <li> <p>There are <code class="language-plaintext highlighter-rouge">3n</code> piles of coins of varying size, you and your friends will take piles of coins as follows:</p> <ul> <li>In each step, you will choose <strong>any</strong> <code class="language-plaintext highlighter-rouge">3</code> piles of coins (not necessarily consecutive.</li> <li>Of your choice, Alice will pick the pile with the maximum number of coins.</li> <li>You will pick the next pile with the maximum number of coins.</li> <li>Your friend Bob will pick the last pile.</li> <li>Repeat until there are no more piles of coins.</li> </ul> </li> <li> <p>Given an array of integers <code class="language-plaintext highlighter-rouge">piles</code> where <code class="language-plaintext highlighter-rouge">piles[i]</code> is the number of coins in the <code class="language-plaintext highlighter-rouge">i^th</code> pile.</p> <p>Return the maximum number of coins that you can have.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: piles = [2,4,1,2,7,8]
Output: 9
Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: piles = [2,4,5]
Output: 4
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumNumberOfCoinsYouCanGet</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxCoins</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">piles</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Sort the piles array in ascending order</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">piles</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">piles</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// Store the number of piles</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// Variable to store the total coins you can get</span>

        <span class="c1">// Step 2: Traverse the array in reverse to select the "second largest" piles for yourself</span>
        <span class="c1">// Start from the second last pile (since the largest pile is for Alice),</span>
        <span class="c1">// stop at index n/3 (as Bob takes n/3 smallest piles), and decrement by 2 after each round</span>
        <span class="c1">// (to skip Alice's and Bob's piles).</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">piles</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Add the second largest pile to your total</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> <span class="c1">// Return the total coins you can get</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">piles1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for Test Case 1: "</span> <span class="o">+</span> <span class="n">maxCoins</span><span class="o">(</span><span class="n">piles1</span><span class="o">));</span> <span class="c1">// Expected Output: 9</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">piles2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for Test Case 2: "</span> <span class="o">+</span> <span class="n">maxCoins</span><span class="o">(</span><span class="n">piles2</span><span class="o">));</span> <span class="c1">// Expected Output: 4</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">piles3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for Test Case 3: "</span> <span class="o">+</span> <span class="n">maxCoins</span><span class="o">(</span><span class="n">piles3</span><span class="o">));</span> <span class="c1">// Expected Output: 18</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:]]></summary></entry><entry><title type="html">1838. Frequency of the Most Frequent Element</title><link href="https://zhengstar94.github.io//blog/2025/FrequencyOfTheMostFrequentElement/" rel="alternate" type="text/html" title="1838. Frequency of the Most Frequent Element"/><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FrequencyOfTheMostFrequentElement</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FrequencyOfTheMostFrequentElement/"><![CDATA[<ul> <li>The <strong>frequency</strong> of an element is the number of times it occurs in an array.</li> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>. In one operation, you can choose an index of <code class="language-plaintext highlighter-rouge">nums</code> and increment the element at that index by <code class="language-plaintext highlighter-rouge">1</code>.</li> <li>Return <em>the <strong>maximum possible frequency</strong> of an element after performing <strong>at most</strong></em> <code class="language-plaintext highlighter-rouge">k</code> <em>operations</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,9,6], k = 2
Output: 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FrequencyOfTheMostFrequentElement</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxFrequency</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort array to enable sliding window approach</span>
        <span class="c1">// After sorting, we ensure that elements in any window can only be increased to match the rightmost element</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// Initialize sliding window pointers and variables</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                  <span class="c1">// Left boundary of sliding window</span>
        <span class="kt">int</span> <span class="n">windowSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>             <span class="c1">// Sum of all elements in current window</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>                <span class="c1">// Minimum possible result is 1 (single element)</span>

        <span class="c1">// Iterate through array with right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to window sum</span>
            <span class="n">windowSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="cm">/**
             * Key Part: Window Validity Check
             * Formula: windowSum + k &lt; nums[right] * (right - left + 1)
             *
             * Left side (windowSum + k):
             * - windowSum: current sum of all elements in window
             * - k: available operations we can use
             * - Together they represent the maximum sum we can achieve with given operations
             *
             * Right side (nums[right] * (right - left + 1)):
             * - nums[right]: target value (maximum element in current window)
             * - (right - left + 1): window size
             * - Product represents total sum needed to make all elements equal to nums[right]
             *
             * If left side &lt; right side: window is invalid and needs shrinking
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">windowSum</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Shrink window by removing leftmost element</span>
                <span class="n">windowSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update result with current valid window size</span>
            <span class="c1">// Window size represents the frequency we can achieve</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic case with small array</span>
        <span class="c1">// We can increment 1 three times and 2 two times to get [4,4,4]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Test Case 2: Multiple optimal solutions possible</span>
        <span class="c1">// Can either make two 4s, two 8s, or two 13s</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected: 2</span>

        <span class="c1">// Test Case 3: Limited operations available</span>
        <span class="c1">// Can't make more than one element equal with only 2 operations</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span> <span class="c1">// Expected: 1</span>

        <span class="c1">// Test Case 4: Array with duplicates</span>
        <span class="c1">// Tests handling of already existing frequencies</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">maxFrequency</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span> <span class="c1">// Expected: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[The frequency of an element is the number of times it occurs in an array. You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1. Return the maximum possible frequency of an element after performing at most k operations.]]></summary></entry><entry><title type="html">2017. Grid Game</title><link href="https://zhengstar94.github.io//blog/2025/GridGame/" rel="alternate" type="text/html" title="2017. Grid Game"/><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/GridGame</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/GridGame/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> 2D array <code class="language-plaintext highlighter-rouge">grid</code> of size <code class="language-plaintext highlighter-rouge">2 x n</code>, where <code class="language-plaintext highlighter-rouge">grid[r][c]</code> represents the number of points at position <code class="language-plaintext highlighter-rouge">(r, c)</code> on the matrix. Two robots are playing a game on this matrix.</li> <li>Both robots initially start at <code class="language-plaintext highlighter-rouge">(0, 0)</code> and want to reach <code class="language-plaintext highlighter-rouge">(1, n-1)</code>. Each robot may only move to the <strong>right</strong> (<code class="language-plaintext highlighter-rouge">(r, c)</code> to <code class="language-plaintext highlighter-rouge">(r, c + 1)</code>) or <strong>down</strong> (<code class="language-plaintext highlighter-rouge">(r, c)</code> to <code class="language-plaintext highlighter-rouge">(r + 1, c)</code>).</li> <li>At the start of the game, the <strong>first</strong> robot moves from <code class="language-plaintext highlighter-rouge">(0, 0)</code> to <code class="language-plaintext highlighter-rouge">(1, n-1)</code>, collecting all the points from the cells on its path. For all cells <code class="language-plaintext highlighter-rouge">(r, c)</code> traversed on the path, <code class="language-plaintext highlighter-rouge">grid[r][c]</code> is set to <code class="language-plaintext highlighter-rouge">0</code>. Then, the <strong>second</strong> robot moves from <code class="language-plaintext highlighter-rouge">(0, 0)</code> to <code class="language-plaintext highlighter-rouge">(1, n-1)</code>, collecting the points on its path. Note that their paths may intersect with one another.</li> <li>The <strong>first</strong> robot wants to <strong>minimize</strong> the number of points collected by the <strong>second</strong> robot. In contrast, the <strong>second</strong> robot wants to <strong>maximize</strong> the number of points it collects. If both robots play <strong>optimally</strong>, return <em>the <strong>number of points</strong> collected by the <strong>second</strong> robot.</em></li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 2,5,4],[1,5,1 ] ]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 0 + 4 + 0 = 4 points.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 3,3,1],[8,5,2 ] ]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 3 + 1 + 0 = 4 points.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [ [ 1,3,1,15],[1,3,3,1 ] ]
Output: 7
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Math</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/21
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GridGame</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">gridGame</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Length of each row in the grid</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Prefix sum arrays for efficient range sum calculations</span>
        <span class="c1">// preSum1: prefix sums for top row</span>
        <span class="c1">// preSum2: prefix sums for bottom row</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">preSum1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">preSum2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Calculate prefix sums for both rows</span>
        <span class="c1">// This allows O(1) time range sum queries</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">preSum1</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
            <span class="n">preSum2</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Initialize answer with maximum possible value</span>
        <span class="c1">// We will minimize this value as we find better solutions</span>
        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// Try each possible turning point for Robot 1</span>
        <span class="c1">// For each column i, calculate the maximum points Robot 2 can get</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Calculate remaining points in top row after column i</span>
            <span class="c1">// This represents one possible path for Robot 2</span>
            <span class="kt">long</span> <span class="n">top</span> <span class="o">=</span> <span class="n">preSum1</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum1</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

            <span class="c1">// Calculate points in bottom row before column i</span>
            <span class="c1">// This represents another possible path for Robot 2</span>
            <span class="kt">long</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">preSum2</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="c1">// Robot 2 will choose the path with maximum points</span>
            <span class="kt">long</span> <span class="n">secondRobot</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">top</span><span class="o">,</span> <span class="n">bottom</span><span class="o">);</span>

            <span class="c1">// Update answer if this is the smallest maximum we've found</span>
            <span class="c1">// We want to minimize the maximum points Robot 2 can get</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">secondRobot</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the minimum possible maximum points for Robot 2</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 主方法，包含测试用例</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic example</span>
        <span class="c1">// Grid: [ [2,5,4],</span>
        <span class="c1">//        [1,5,1] ]</span>
        <span class="c1">// Expected output: 4</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span>

        <span class="c1">//Additional test cases can be uncommented for further testing</span>
        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">15</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: More complex example</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid4</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">20</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">15</span><span class="o">},</span>
                        <span class="o">{</span><span class="mi">20</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">gridGame</span><span class="o">(</span><span class="n">grid4</span><span class="o">));</span>

    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Math"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix. Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)). At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another. The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.]]></summary></entry><entry><title type="html">2239. Find Closest Number to Zero</title><link href="https://zhengstar94.github.io//blog/2025/FindClosestNumberToZero/" rel="alternate" type="text/html" title="2239. Find Closest Number to Zero"/><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindClosestNumberToZero</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindClosestNumberToZero/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> of size <code class="language-plaintext highlighter-rouge">n</code>, return <em>the number with the value <strong>closest</strong> to</em> <code class="language-plaintext highlighter-rouge">0</code> <em>in</em> <code class="language-plaintext highlighter-rouge">nums</code>. If there are multiple answers, return <em>the number with the <strong>largest</strong> value</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [-4,-2,1,4,8]
Output: 1
Explanation:
The distance from -4 to 0 is |-4| = 4.
The distance from -2 to 0 is |-2| = 2.
The distance from 1 to 0 is |1| = 1.
The distance from 4 to 0 is |4| = 4.
The distance from 8 to 0 is |8| = 8.
Thus, the closest number to 0 in the array is 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,-1,1]
Output: 1
Explanation: 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindClosestNumberToZero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findClosestNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// The result closest to zero</span>
        <span class="kt">int</span> <span class="n">minDif</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="c1">// Initialize minimum difference as positive infinity</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">dif</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// Calculate absolute difference from zero</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dif</span> <span class="o">&lt;</span> <span class="n">minDif</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// If current difference is smaller</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">minDif</span> <span class="o">=</span> <span class="n">dif</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">dif</span> <span class="o">==</span> <span class="n">minDif</span> <span class="o">&amp;&amp;</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// If differences are equal and current result is negative</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// Update to current number (prefer positive over negative)</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Mixed positive and negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">findClosestNumber</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 2: Numbers with same absolute value</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">findClosestNumber</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Edge case: Symmetric positive and negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">findClosestNumber</span><span class="o">(</span><span class="n">nums3</span><span class="o">));</span> <span class="c1">// Expected output: 5</span>

        <span class="c1">// Edge case: Single element array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">findClosestNumber</span><span class="o">(</span><span class="n">nums4</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Edge case: Only positive numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">15</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5 result: "</span> <span class="o">+</span> <span class="n">findClosestNumber</span><span class="o">(</span><span class="n">nums5</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Edge case: Only negative numbers</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums6</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">12</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 6 result: "</span> <span class="o">+</span> <span class="n">findClosestNumber</span><span class="o">(</span><span class="n">nums6</span><span class="o">));</span> <span class="c1">// Expected output: -3</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value.]]></summary></entry><entry><title type="html">2661. First Completely Painted Row or Column</title><link href="https://zhengstar94.github.io//blog/2025/FirstCompletelyPaintedRowOrColumn/" rel="alternate" type="text/html" title="2661. First Completely Painted Row or Column"/><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FirstCompletelyPaintedRowOrColumn</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FirstCompletelyPaintedRowOrColumn/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">arr</code>, and an <code class="language-plaintext highlighter-rouge">m x n</code> integer <strong>matrix</strong> <code class="language-plaintext highlighter-rouge">mat</code>. <code class="language-plaintext highlighter-rouge">arr</code> and <code class="language-plaintext highlighter-rouge">mat</code> both contain <strong>all</strong> the integers in the range <code class="language-plaintext highlighter-rouge">[1, m * n]</code>.</li> <li>Go through each index <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">arr</code> starting from index <code class="language-plaintext highlighter-rouge">0</code> and paint the cell in <code class="language-plaintext highlighter-rouge">mat</code> containing the integer <code class="language-plaintext highlighter-rouge">arr[i]</code>.</li> <li>Return <em>the smallest index</em> <code class="language-plaintext highlighter-rouge">i</code> <em>at which either a row or a column will be completely painted in</em> <code class="language-plaintext highlighter-rouge">mat</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,3,4,2], mat = [ [ 1,4],[2,3 ] ]
Output: 2
Explanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,8,7,4,1,3,5,6,9], mat = [ [ 3,2,5],[1,4,6],[8,7,9 ] ]
Output: 3
Explanation: The second column becomes fully painted at arr[3].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n*m) time | O(n*m) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstCompletelyPaintedRowOrColumn</span> <span class="o">{</span>

    <span class="c1">// Function to find the first index in `arr` such that a row or a column in the matrix `mat` is completely filled</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">firstCompleteIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Get the number of rows in the matrix</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Get the number of columns in the matrix</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mat</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Create a hash map to store the position (row and column) of each number in the matrix</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">numToPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Populate the hash map:</span>
        <span class="c1">// Loop through all rows (i)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Loop through all columns (j)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Add the current matrix element as the key, and its position [row, column] as the value</span>
                <span class="n">numToPos</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">mat</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Create two arrays to track the count of painted cells in each row and each column</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">rowCount</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">];</span> <span class="c1">// Keeps track of how many cells are painted in each row</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">colCount</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">// Keeps track of how many cells are painted in each column</span>

        <span class="c1">// Loop through the array `arr` in the given order</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Get the position of the current number from the hash map</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">numToPos</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// Row index of the current number in `mat`</span>
            <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// Column index of the current number in `mat`</span>

            <span class="c1">// Increment the count for the corresponding row and column</span>
            <span class="n">rowCount</span><span class="o">[</span><span class="n">row</span><span class="o">]++;</span>
            <span class="n">colCount</span><span class="o">[</span><span class="n">col</span><span class="o">]++;</span>

            <span class="c1">// Check if the current row has been completely painted</span>
            <span class="c1">// OR if the current column has been completely painted</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rowCount</span><span class="o">[</span><span class="n">row</span><span class="o">]</span> <span class="o">==</span> <span class="n">n</span> <span class="o">||</span> <span class="n">colCount</span><span class="o">[</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// If so, return the current index from `arr`</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no row or column is completely painted, return the last possible index</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="c1">// Expected output: 2, as the first completely painted row or column (row 0) is done on the 3rd element (index 2)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">firstCompleteIndex</span><span class="o">(</span><span class="n">arr1</span><span class="o">,</span> <span class="n">mat1</span><span class="o">));</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span> <span class="o">}</span> <span class="o">};</span>
        <span class="c1">// Expected output: 3, as the first completely painted column (column 1) is done on the 4th element (index 3)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">firstCompleteIndex</span><span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="n">mat2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Medium"/><summary type="html"><![CDATA[You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n]. Go through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i]. Return the smallest index i at which either a row or a column will be completely painted in mat.]]></summary></entry><entry><title type="html">1658. Minimum Operations to Reduce X to Zero</title><link href="https://zhengstar94.github.io//blog/2025/MinimumOperationsToReduceXToZero/" rel="alternate" type="text/html" title="1658. Minimum Operations to Reduce X to Zero"/><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-20T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumOperationsToReduceXToZero</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumOperationsToReduceXToZero/"><![CDATA[<ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code class="language-plaintext highlighter-rouge">nums</code> and subtract its value from <code class="language-plaintext highlighter-rouge">x</code>. Note that this <strong>modifies</strong> the array for future operations.</li> <li>Return <em>the <strong>minimum number</strong> of operations to reduce</em> <code class="language-plaintext highlighter-rouge">x</code> <em>to <strong>exactly</strong></em> <code class="language-plaintext highlighter-rouge">0</code> <em>if it is possible**, otherwise, return</em> <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,4,2,3], x = 5
Output: 2
Explanation: The optimal solution is to remove the last two elements to reduce x to zero.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,6,7,8,9], x = 4
Output: -1
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,20,1,1,3], x = 10
Output: 5
Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/20
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumOperationsToReduceXToZero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Step 1: Calculate the total sum of the array</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Calculate target sum for the sliding window</span>
        <span class="c1">// We want to find a subarray that sums to (total_sum - x)</span>
        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">x</span><span class="o">;</span>

        <span class="c1">// If target is negative, it's impossible to find a solution</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If target is zero, we need to remove all elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Initialize sliding window variables</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>              <span class="c1">// Left pointer of the window</span>
        <span class="kt">int</span> <span class="n">currentSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="c1">// Current sum within the window</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>          <span class="c1">// Length of longest subarray summing to target</span>

        <span class="c1">// Step 4: Implement sliding window technique</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add current element to window sum</span>
            <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="c1">// Shrink window while sum exceeds target</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">currentSum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">currentSum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// If window sum equals target, update maximum length</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">currentSum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Step 5: Return result</span>
        <span class="c1">// If no valid subarray found, return -1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">maxLen</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Return number of elements to remove (total length minus length of valid subarray)</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Normal case</span>
        <span class="c1">// Expected output: 2 (remove 2 and 3 from the end)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">x1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Impossible case</span>
        <span class="c1">// Expected output: -1 (no combination sums to 4)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">x2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Multiple operations needed</span>
        <span class="c1">// Expected output: 5 (remove [3,2] from left and [1,1,3] from right)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">x3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Edge case - Empty array</span>
        <span class="c1">// Expected output: -1 (impossible with empty array)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span> <span class="n">x4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">x4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Edge case - Single element</span>
        <span class="c1">// Expected output: 1 (remove the single element)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">x5</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">minOperations</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">x5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations. Return the minimum number of operations to reduce x to exactly 0 if it is possible**, otherwise, return -1.]]></summary></entry><entry><title type="html">2266. Count Number of Texts</title><link href="https://zhengstar94.github.io//blog/2025/CountNumberOfTexts/" rel="alternate" type="text/html" title="2266. Count Number of Texts"/><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/CountNumberOfTexts</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/CountNumberOfTexts/"><![CDATA[<ul> <li>Alice is texting Bob using her phone. The <strong>mapping</strong> of digits to letters is shown in the figure below.</li> <li>In order to <strong>add</strong> a letter, Alice has to <strong>press</strong> the key of the corresponding digit <code class="language-plaintext highlighter-rouge">i</code> times, where <code class="language-plaintext highlighter-rouge">i</code> is the position of the letter in the key. <ul> <li>For example, to add the letter <code class="language-plaintext highlighter-rouge">'s'</code>, Alice has to press <code class="language-plaintext highlighter-rouge">'7'</code> four times. Similarly, to add the letter <code class="language-plaintext highlighter-rouge">'k'</code>, Alice has to press <code class="language-plaintext highlighter-rouge">'5'</code> twice.</li> <li>Note that the digits <code class="language-plaintext highlighter-rouge">'0'</code> and <code class="language-plaintext highlighter-rouge">'1'</code> do not map to any letters, so Alice <strong>does not</strong> use them.</li> </ul> </li> <li>However, due to an error in transmission, Bob did not receive Alice’s text message but received a <strong>string of pressed keys</strong> instead. <ul> <li>For example, when Alice sent the message <code class="language-plaintext highlighter-rouge">"bob"</code>, Bob received the string <code class="language-plaintext highlighter-rouge">"2266622"</code>.</li> </ul> </li> <li>Given a string <code class="language-plaintext highlighter-rouge">pressedKeys</code> representing the string received by Bob, return <em>the <strong>total number of possible text messages</strong> Alice could have sent</em>.</li> <li>Since the answer may be very large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">10^9 + 7</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: pressedKeys = "22233"
Output: 8
Explanation:
The possible text messages Alice could have sent are:
"aaadd", "abdd", "badd", "cdd", "aaae", "abe", "bae", and "ce".
Since there are 8 possible messages, we return 8.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: pressedKeys = "222222222222222222222222222222222222"
Output: 82876089
Explanation:
There are 2082876103 possible text messages Alice could have sent.
Since we need to return the answer modulo 10^9 + 7, we return 2082876103 % (10^9 + 7) = 82876089.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.DynamicProgramming</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountNumberOfTexts</span> <span class="o">{</span>

    <span class="c1">// Define the modulus as required by the problem to avoid overflow</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOD</span> <span class="o">=</span> <span class="mi">1_000_000_007</span><span class="o">;</span>

    <span class="c1">// Method to calculate the total number of text messages that can be formed</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countTexts</span><span class="o">(</span><span class="nc">String</span> <span class="n">pressedKeys</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// Get the length of the input string pressedKeys</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>  <span class="c1">// Create a dp array of size n+1 to store results for subproblems</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// Base case: An empty sequence has exactly one way to form it (do nothing)</span>

        <span class="c1">// Iterate from the 1st pressed key to the nth pressed key</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add the number of ways using the last single key press (always valid)</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// Single key usage, inherits from dp[i-1]</span>

            <span class="c1">// Check if the current key can combine with the previous key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If they are the same, add the values from dp[i-2] (combining two keys)</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">])</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the current key can combine with the last two keys (three keys total)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If three consecutive keys are the same, add the values from dp[i-3]</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">])</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the current key can combine with the last three keys (four keys total)</span>
            <span class="c1">// This is only valid for the keys '7' and '9', as they can form up to 4-letter combinations</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'7'</span> <span class="o">||</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'9'</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span>
                    <span class="o">&amp;&amp;</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="n">pressedKeys</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">4</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If four consecutive keys are the same and the key is 7 or 9, add the values from dp[i-4]</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">4</span><span class="o">])</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The final result is stored in dp[n], the number of ways to form messages from the entire string</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">// Main method to test the implementation with examples</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">pressedKeys1</span> <span class="o">=</span> <span class="s">"22233"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">countTexts</span><span class="o">(</span><span class="n">pressedKeys1</span><span class="o">));</span> <span class="c1">// Expected output: 8</span>

        <span class="c1">// Test case 2</span>
        <span class="nc">String</span> <span class="n">pressedKeys2</span> <span class="o">=</span> <span class="s">"222222222222222222222222222222222222"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">countTexts</span><span class="o">(</span><span class="n">pressedKeys2</span><span class="o">));</span> <span class="c1">// Expected output: 82876089</span>

        <span class="c1">// Additional test case</span>
        <span class="nc">String</span> <span class="n">pressedKeys3</span> <span class="o">=</span> <span class="s">"2266622"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">countTexts</span><span class="o">(</span><span class="n">pressedKeys3</span><span class="o">));</span> <span class="c1">// Expected output depends on the pattern</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Dynamic Programming"/><category term="Medium"/><category term="Review"/><summary type="html"><![CDATA[Alice is texting Bob using her phone. The mapping of digits to letters is shown in the figure below. In order to add a letter, Alice has to press the key of the corresponding digit i times, where i is the position of the letter in the key. For example, to add the letter 's', Alice has to press '7' four times. Similarly, to add the letter 'k', Alice has to press '5' twice. Note that the digits '0' and '1' do not map to any letters, so Alice does not use them. However, due to an error in transmission, Bob did not receive Alice’s text message but received a string of pressed keys instead. For example, when Alice sent the message "bob", Bob received the string "2266622". Given a string pressedKeys representing the string received by Bob, return the total number of possible text messages Alice could have sent. Since the answer may be very large, return it modulo 10^9 + 7.]]></summary></entry><entry><title type="html">1004. Max Consecutive Ones III</title><link href="https://zhengstar94.github.io//blog/2025/MaxConsecutiveOnesIII/" rel="alternate" type="text/html" title="1004. Max Consecutive Ones III"/><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaxConsecutiveOnesIII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaxConsecutiveOnesIII/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the maximum number of consecutive</em> <code class="language-plaintext highlighter-rouge">1</code><em>’s in the array if you can flip at most</em> <code class="language-plaintext highlighter-rouge">k</code> <code class="language-plaintext highlighter-rouge">0</code>’s.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/19
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxConsecutiveOnesIII</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestOnes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize left pointer of the window</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Track the maximum length of valid sequence found so far</span>
        <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// Count of zeros in current window</span>
        <span class="kt">int</span> <span class="n">zeroCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through array with right pointer</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If current element is 0, increment zero counter</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zeroCount</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// While window contains more zeros than allowed (k)</span>
            <span class="c1">// Shrink window from left until constraint is satisfied</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">zeroCount</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If element at left pointer is 0, decrease zero counter</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">zeroCount</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Update maximum length if current window is larger</span>
            <span class="c1">// Window size is (right - left + 1)</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the maximum length found</span>
        <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 主方法，包含测试用例</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">longestOnes</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">longestOnes</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span> <span class="c1">// Expected output: 10</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[Given a binary array nums and an integer k, return the maximum number of consecutive 1’s in the array if you can flip at most k 0’s.]]></summary></entry><entry><title type="html">2024. Maximize the Confusion of an Exam</title><link href="https://zhengstar94.github.io//blog/2025/MaximizeTheConfusionOfAnExam/" rel="alternate" type="text/html" title="2024. Maximize the Confusion of an Exam"/><published>2025-01-18T00:00:00+00:00</published><updated>2025-01-18T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MaximizeTheConfusionOfAnExam</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MaximizeTheConfusionOfAnExam/"><![CDATA[<ul> <li>A teacher is writing a test with <code class="language-plaintext highlighter-rouge">n</code> true/false questions, with <code class="language-plaintext highlighter-rouge">'T'</code> denoting true and <code class="language-plaintext highlighter-rouge">'F'</code> denoting false. He wants to confuse the students by <strong>maximizing</strong> the number of <strong>consecutive (adj. 连续的；连贯的)</strong> questions with the <strong>same</strong> answer (multiple trues or multiple falses in a row).</li> <li>You are given a string <code class="language-plaintext highlighter-rouge">answerKey</code>, where <code class="language-plaintext highlighter-rouge">answerKey[i]</code> is the original answer to the <code class="language-plaintext highlighter-rouge">ith</code> question. In addition, you are given an integer <code class="language-plaintext highlighter-rouge">k</code>, the maximum number of times you may perform the following operation: <ul> <li>Change the answer key for any question to <code class="language-plaintext highlighter-rouge">'T'</code> or <code class="language-plaintext highlighter-rouge">'F'</code> (i.e., set <code class="language-plaintext highlighter-rouge">answerKey[i]</code> to <code class="language-plaintext highlighter-rouge">'T'</code> or <code class="language-plaintext highlighter-rouge">'F'</code>).</li> </ul> </li> <li>Return <em>the <strong>maximum</strong> number of consecutive (adj. 连续的；连贯的)</em> <code class="language-plaintext highlighter-rouge">'T'</code>s or <code class="language-plaintext highlighter-rouge">'F'</code>s <em>in the answer key after performing the operation at most</em> <code class="language-plaintext highlighter-rouge">k</code> <em>times</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answerKey = "TTFF", k = 2
Output: 4
Explanation: We can replace both the 'F's with 'T's to make answerKey = "TTTT".
There are four consecutive 'T's.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answerKey = "TFFT", k = 1
Output: 3
Explanation: We can replace the first 'T' with an 'F' to make answerKey = "FFFT".
Alternatively, we can replace the second 'T' with an 'F' to make answerKey = "TFFF".
In both cases, there are three consecutive 'F's.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: answerKey = "TTFTTFTT", k = 1
Output: 5
Explanation: We can replace the first 'F' to make answerKey = "TTTTTFTT"
Alternatively, we can replace the second 'F' to make answerKey = "TTFTTTTT". 
In both cases, there are five consecutive 'T's.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow.DynamicSlidingWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/01/18
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximizeTheConfusionOfAnExam</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxConsecutiveAnswers</span><span class="o">(</span><span class="nc">String</span> <span class="n">answerKey</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate max length by considering both cases: converting to 'T' and converting to 'F'</span>
        <span class="c1">// Return the maximum of these two scenarios</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">(</span><span class="n">answerKey</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="sc">'T'</span><span class="o">),</span> <span class="n">maxLength</span><span class="o">(</span><span class="n">answerKey</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="sc">'F'</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxLength</span><span class="o">(</span><span class="nc">String</span> <span class="n">answerKey</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">char</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="c1">// Track the maximum length of consecutive same characters</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>          <span class="c1">// Left pointer of sliding window</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>         <span class="c1">// Count of characters that need to be changed in current window</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">answerKey</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Step 1: Process the current character at right pointer</span>
            <span class="c1">// If current character is different from target, increment the count</span>
            <span class="c1">// This count represents how many characters we need to change in our window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">answerKey</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Step 2: Maintain window validity</span>
            <span class="c1">// If count exceeds k, we need to shrink the window from left</span>
            <span class="c1">// Keep shrinking until we have a valid window (count &lt;= k)</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If character at left pointer is different from target</span>
                <span class="c1">// Decrease count as this character will no longer be in our window</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">answerKey</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">count</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="c1">// Move left pointer to shrink window</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// Step 3: Update result</span>
            <span class="c1">// Current window size is (right - left + 1)</span>
            <span class="c1">// Update maxLen if current window is larger</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases to verify the solution</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxConsecutiveAnswers</span><span class="o">(</span><span class="s">"TTFF"</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>     <span class="c1">// Output: 4</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxConsecutiveAnswers</span><span class="o">(</span><span class="s">"TFFT"</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>     <span class="c1">// Output: 3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxConsecutiveAnswers</span><span class="o">(</span><span class="s">"TTFTTFTT"</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span> <span class="c1">// Output: 5</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode DynamicSlidingWindow"/><category term="Medium"/><summary type="html"><![CDATA[A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive (adj. 连续的；连贯的) questions with the same answer (multiple trues or multiple falses in a row). You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation: Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F'). Return the maximum number of consecutive (adj. 连续的；连贯的) 'T's or 'F's in the answer key after performing the operation at most k times.]]></summary></entry></feed>