<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-17T16:11:09+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">349.Intersection of Two Arrays</title><link href="https://zhengstar94.github.io//blog/2024/IntersectionOfTwoArrays/" rel="alternate" type="text/html" title="349.Intersection of Two Arrays"/><published>2024-10-16T00:00:00+00:00</published><updated>2024-10-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/IntersectionOfTwoArrays</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/IntersectionOfTwoArrays/"><![CDATA[<h1 id="349-intersection-of-two-arrays">349. Intersection of Two Arrays</h1> <ul> <li>Given two integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(min(n, m)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntersectionOfTwoArrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashSet to store unique elements from nums1</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// Create a HashSet to store the intersection elements</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Add all elements from nums1 to set1 (automatically removes duplicates)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">set1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Check each element in nums2</span>
        <span class="c1">// If it exists in set1, it's an intersection element</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set1</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">)){</span>
                <span class="n">resultSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert HashSet to array for return value</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">resultSet</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">resultSet</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method containing test cases
     * @param args command line arguments (not used)
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic test with duplicates</span>
        <span class="c1">// Expected output: [2]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums1 = [1,2,2,1], nums2 = [2,2]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: No intersection</span>
        <span class="c1">// Expected output: []</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">nums4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums1 = [1,2,3], nums2 = [4,5,6]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Multiple intersections</span>
        <span class="c1">// Expected output: [4,9]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums6</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">nums6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Empty array</span>
        <span class="c1">// Expected output: []</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums7</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums8</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums7</span><span class="o">,</span> <span class="n">nums8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums1 = [], nums2 = [1,2,3]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Identical arrays</span>
        <span class="c1">// Expected output: [1,2,3]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums9</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums10</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result5</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">(</span><span class="n">nums9</span><span class="o">,</span> <span class="n">nums10</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: nums1 = [1,2,3], nums2 = [1,2,3]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><summary type="html"><![CDATA[349. Intersection of Two Arrays]]></summary></entry><entry><title type="html">2. Add Two Numbers</title><link href="https://zhengstar94.github.io//blog/2024/AddTwoNumbers/" rel="alternate" type="text/html" title="2. Add Two Numbers"/><published>2024-10-14T00:00:00+00:00</published><updated>2024-10-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/AddTwoNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/AddTwoNumbers/"><![CDATA[<ul> <li>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</li> <li>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: l1 = [0], l2 = [0]
Output: [0]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(max(n, m)) time | O(max(n, m)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.LinkList</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddTwoNumbers</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a dummy head node to simplify the addition process</span>
        <span class="nc">ListNode</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="o">;</span>

        <span class="c1">// Initialize carry to 0</span>
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue loop while there are digits in either list or there's a carry</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Get the value of the current digit from l1, or 0 if l1 is null</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="c1">// Get the value of the current digit from l2, or 0 if l2 is null</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// Calculate the sum of current digits and the carry from the previous addition</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>

            <span class="c1">// Calculate the new carry for the next iteration</span>
            <span class="c1">// If sum &gt;= 10, carry will be 1; otherwise, it will be 0</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>

            <span class="c1">// Create a new node with the ones digit of the sum (sum % 10)</span>
            <span class="c1">// This effectively keeps only the ones digit and "carries" the tens digit</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

            <span class="c1">// Move to the next digits in the input lists, if available</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// After the main loop, check if there's still a carry left</span>
        <span class="c1">// This handles cases where the sum results in an additional digit</span>
        <span class="c1">// For example: 999 + 1 = 1000, so we need to add the final '1'</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Return the result, skipping the dummy head</span>
        <span class="k">return</span> <span class="n">dummyHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create the first linked list: 2 -&gt; 4 -&gt; 3 (representing 342)</span>
        <span class="nc">ListNode</span> <span class="n">l1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">l1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
        <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

        <span class="c1">// Create the second linked list: 5 -&gt; 6 -&gt; 4 (representing 465)</span>
        <span class="nc">ListNode</span> <span class="n">l2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">l2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
        <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

        <span class="c1">// Add the two numbers</span>
        <span class="nc">ListNode</span> <span class="n">result</span> <span class="o">=</span> <span class="n">addTwoNumbers</span><span class="o">(</span><span class="n">l1</span><span class="o">,</span> <span class="n">l2</span><span class="o">);</span>

        <span class="c1">// Print the result</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Result: "</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Expected output: 7 0 8 (representing 807, which is 342 + 465)</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode LinkedList"/><summary type="html"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.]]></summary></entry><entry><title type="html">138.Copy List with Random Pointer</title><link href="https://zhengstar94.github.io//blog/2024/CopyListWithRandomPointer/" rel="alternate" type="text/html" title="138.Copy List with Random Pointer"/><published>2024-10-13T00:00:00+00:00</published><updated>2024-10-13T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CopyListWithRandomPointer</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CopyListWithRandomPointer/"><![CDATA[<ul> <li>A linked list of length <code class="language-plaintext highlighter-rouge">n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code class="language-plaintext highlighter-rouge">null</code>.</li> <li>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code class="language-plaintext highlighter-rouge">n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code class="language-plaintext highlighter-rouge">next</code> and <code class="language-plaintext highlighter-rouge">random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</li> <li>For example, if there are two nodes <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> in the original list, where <code class="language-plaintext highlighter-rouge">X.random --&gt; Y</code>, then for the corresponding two nodes <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in the copied list, <code class="language-plaintext highlighter-rouge">x.random --&gt; y</code>.</li> <li>Return <em>the head of the copied linked list</em>.</li> <li>The linked list is represented in the input/output as a list of <code class="language-plaintext highlighter-rouge">n</code> nodes. Each node is represented as a pair of <code class="language-plaintext highlighter-rouge">[val, random_index]</code> where: <ul> <li><code class="language-plaintext highlighter-rouge">val</code>: an integer representing <code class="language-plaintext highlighter-rouge">Node.val</code></li> <li><code class="language-plaintext highlighter-rouge">random_index</code>: the index of the node (range from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>) that the <code class="language-plaintext highlighter-rouge">random</code> pointer points to, or <code class="language-plaintext highlighter-rouge">null</code> if it does not point to any node.</li> </ul> </li> <li>Your code will <strong>only</strong> be given the <code class="language-plaintext highlighter-rouge">head</code> of the original linked list.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [ [7,null],[13,0],[11,4],[10,2],[1,0] ]
Output: [ [7,null],[13,0],[11,4],[10,2],[1,0] ]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [ [1,1],[2,1] ]
Output: [ [1,1],[2,1] ]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: head = [ [3,null],[3,0],[3,null] ]
Output: [ [3,null],[3,0],[3,null] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.LinkList</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyListWithRandomPointer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Node</span> <span class="nf">copyRandomList</span><span class="o">(</span><span class="nc">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> 
        <span class="o">}</span>

        <span class="c1">// Step 1: Create copy nodes and insert them after original nodes</span>
        <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Create a new node with the same value as the current node</span>
            <span class="nc">Node</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="c1">// Insert the new node right after the current node</span>
            <span class="n">copy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">copy</span><span class="o">;</span>
            <span class="c1">// Move to the next original node</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 2: Set random pointers for the copy nodes</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the original node has a random pointer, set the copy's random pointer</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// curr.next is the copy of curr</span>
                <span class="c1">// curr.random.next is the copy of curr.random</span>
                <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">random</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Move to the next original node</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Step 3: Separate the original and copied lists</span>
        <span class="nc">Node</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// Dummy node to start the copied list</span>
        <span class="nc">Node</span> <span class="n">copyCurr</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Connect the copy nodes</span>
            <span class="n">copyCurr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// Restore the original list connection</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// Move both pointers</span>
            <span class="n">copyCurr</span> <span class="o">=</span> <span class="n">copyCurr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Return the head of the copied list</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: [ [ 7,null],[13,0],[11,4],[10,2],[1,0] ]</span>
        <span class="nc">Node</span> <span class="n">head1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node13</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">13</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node11</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node10</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node13</span><span class="o">;</span>
        <span class="n">node13</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node11</span><span class="o">;</span>
        <span class="n">node11</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node10</span><span class="o">;</span>
        <span class="n">node10</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
        <span class="n">head1</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">node13</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">head1</span><span class="o">;</span>
        <span class="n">node11</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
        <span class="n">node10</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node11</span><span class="o">;</span>
        <span class="n">node1</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">head1</span><span class="o">;</span>

        <span class="nc">Node</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 passed: "</span> <span class="o">+</span> <span class="n">validateCopy</span><span class="o">(</span><span class="n">head1</span><span class="o">,</span> <span class="n">result1</span><span class="o">));</span>

        <span class="c1">// Test case 2: [ [ 1,1],[2,1] ]</span>
        <span class="nc">Node</span> <span class="n">head2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">head2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
        <span class="n">head2</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
        <span class="n">node2</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>

        <span class="nc">Node</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 passed: "</span> <span class="o">+</span> <span class="n">validateCopy</span><span class="o">(</span><span class="n">head2</span><span class="o">,</span> <span class="n">result2</span><span class="o">));</span>

        <span class="c1">// Test case 3: [ [ 3,null],[3,0],[3,null] ]</span>
        <span class="nc">Node</span> <span class="n">head3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node3_2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node3_3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">head3</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node3_2</span><span class="o">;</span>
        <span class="n">node3_2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node3_3</span><span class="o">;</span>
        <span class="n">head3</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">node3_2</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">head3</span><span class="o">;</span>
        <span class="n">node3_3</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="nc">Node</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 passed: "</span> <span class="o">+</span> <span class="n">validateCopy</span><span class="o">(</span><span class="n">head3</span><span class="o">,</span> <span class="n">result3</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validateCopy</span><span class="o">(</span><span class="nc">Node</span> <span class="n">original</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">copy</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">original</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">copy</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">original</span><span class="o">.</span><span class="na">random</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span><span class="o">.</span><span class="na">random</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">random</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">original</span><span class="o">.</span><span class="na">random</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">copy</span><span class="o">.</span><span class="na">random</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">original</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">original</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">copy</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">random</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode LinkedList"/><summary type="html"><![CDATA[A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random --&gt; y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list.]]></summary></entry><entry><title type="html">567.Permutation in String</title><link href="https://zhengstar94.github.io//blog/2024/PermutationInString/" rel="alternate" type="text/html" title="567.Permutation in String"/><published>2024-10-12T00:00:00+00:00</published><updated>2024-10-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PermutationInString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PermutationInString/"><![CDATA[<ul> <li>Given two strings <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code>, return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">s2</code> contains a permutation of <code class="language-plaintext highlighter-rouge">s1</code>, or <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li> <li>In other words, return <code class="language-plaintext highlighter-rouge">true</code> if one of <code class="language-plaintext highlighter-rouge">s1</code>’s permutations is the substring of <code class="language-plaintext highlighter-rouge">s2</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s1 = "ab", s2 = "eidboaoo"
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PermutationInString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkInclusion</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If s1 is longer than s2, it's impossible for s1's permutation to be in s2</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Arrays to store character frequencies</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Count the frequency of characters in s1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s1</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count1</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Sliding window approach</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add the current character to count2</span>
            <span class="n">count2</span><span class="o">[</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>

            <span class="c1">// IMPORTANT: Remove the leftmost character of the previous window</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// i - s1.length() gives the index of the character to be removed</span>
                <span class="c1">// This ensures that we maintain a window of size s1.length()</span>
                <span class="n">count2</span><span class="o">[</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>

            <span class="c1">// Check if the current window is a permutation of s1</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">count1</span><span class="o">,</span> <span class="n">count2</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no permutation is found</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"eidbaooo"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 2</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"eidboaoo"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test case 3</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"adc"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"dcda"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: true</span>

        <span class="c1">// Test case 4</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"ooolleoooleh"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: false</span>

        <span class="c1">// Test case 5</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">checkInclusion</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span> <span class="c1">// Expected: true</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><summary type="html"><![CDATA[Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1’s permutations is the substring of s2.]]></summary></entry><entry><title type="html">853.Car Fleet</title><link href="https://zhengstar94.github.io//blog/2024/CarFleet/" rel="alternate" type="text/html" title="853.Car Fleet"/><published>2024-10-11T00:00:00+00:00</published><updated>2024-10-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CarFleet</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CarFleet/"><![CDATA[<ul> <li> <p>There are <code class="language-plaintext highlighter-rouge">n</code> cars at given miles away from the starting mile 0, traveling to reach the mile <code class="language-plaintext highlighter-rouge">target</code>.</p> </li> <li> <p>You are given two integer array <code class="language-plaintext highlighter-rouge">position</code> and <code class="language-plaintext highlighter-rouge">speed</code>, both of length <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">position[i]</code> is the starting mile of the <code class="language-plaintext highlighter-rouge">ith</code> car and <code class="language-plaintext highlighter-rouge">speed[i]</code> is the speed of the <code class="language-plaintext highlighter-rouge">ith</code> car in miles per hour.</p> </li> <li> <p>A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.</p> </li> <li> <p>A <strong>car fleet</strong> is a car or cars driving next to each other. The speed of the car fleet is the <strong>minimum</strong> speed of any car in the fleet.</p> <p>If a car catches up to a car fleet at the mile <code class="language-plaintext highlighter-rouge">target</code>, it will still be considered as part of the car fleet.</p> <p>Return the number of car fleets that will arrive at the destination.</p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]

Output: 3

Explanation:

The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at target.
The car starting at 0 (speed 1) does not catch up to any other car, so it is a fleet by itself.
The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: target = 10, position = [3], speed = [3]

Output: 1

Explanation:

There is only one car, hence there is only one fleet.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: target = 100, position = [0,2,4], speed = [4,2,1]

Output: 1

Explanation:

The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The car starting at 4 (speed 1) travels to 5.
Then, the fleet at 4 (speed 2) and the car at position 5 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n log n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarFleet</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">carFleet</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">position</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">speed</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a map to store the time each car takes to reach the target</span>
        <span class="c1">// Key: initial position, Value: time to reach target</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Double</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Calculate and store the time for each car to reach the target</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Time = (target distance - initial position) / speed</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">position</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">position</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span><span class="n">speed</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// Sort the positions in ascending order</span>
        <span class="c1">// This allows us to process cars from front to back</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">position</span><span class="o">);</span>

        <span class="c1">// Use a stack to keep track of car fleets</span>
        <span class="c1">// Each element in the stack represents the arrival time of a fleet</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through positions from back to front (rightmost to leftmost)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">position</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="c1">// If the current car reaches the target earlier or at the same time as the car in front,</span>
            <span class="c1">// it will join that fleet, so we skip it (don't add to stack)</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">position</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// If the current car reaches later, it forms a new fleet, so we add it to the stack</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">position</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
        <span class="o">}</span>

        <span class="c1">// The number of elements in the stack represents the number of fleets</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">12</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">position1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">speed1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">carFleet</span><span class="o">(</span><span class="n">target1</span><span class="o">,</span> <span class="n">position1</span><span class="o">,</span> <span class="n">speed1</span><span class="o">));</span> <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">position2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">speed2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">carFleet</span><span class="o">(</span><span class="n">target2</span><span class="o">,</span> <span class="n">position2</span><span class="o">,</span> <span class="n">speed2</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 3</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">position3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">speed3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">carFleet</span><span class="o">(</span><span class="n">target3</span><span class="o">,</span> <span class="n">position3</span><span class="o">,</span> <span class="n">speed3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.]]></summary></entry><entry><title type="html">739.Daily Temperatures</title><link href="https://zhengstar94.github.io//blog/2024/DailyTemperatures/" rel="alternate" type="text/html" title="739.Daily Temperatures"/><published>2024-10-10T00:00:00+00:00</published><updated>2024-10-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/DailyTemperatures</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/DailyTemperatures/"><![CDATA[<ul> <li>Given an array of integers <code class="language-plaintext highlighter-rouge">temperatures</code> represents the daily temperatures, return <em>an array</em> <code class="language-plaintext highlighter-rouge">answer</code> <em>such that</em> <code class="language-plaintext highlighter-rouge">answer[i]</code> <em>is the number of days you have to wait after the</em> <code class="language-plaintext highlighter-rouge">ith</code> <em>day to get a warmer temperature</em>. If there is no future day for which this is possible, keep <code class="language-plaintext highlighter-rouge">answer[i] == 0</code> instead.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: temperatures = [ 73,74,75,71,69,72,76,73]
Output: [ 1,1,4,2,1,1,0,0]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: temperatures = [ 30,40,50,60]
Output: [ 1,1,1,0]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: temperatures = [30,60,90]
Output: [1,1,0]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DailyTemperatures</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dailyTemperatures</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">temperatures</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">temperatures</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Initialize the result array with zeros</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// Use a stack to keep track of indices of temperatures</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each temperature</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// While the stack is not empty and the current temperature is warmer</span>
            <span class="c1">// than the temperature at the top of the stack</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">temperatures</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">temperatures</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()])</span> <span class="o">{</span>
                <span class="c1">// Pop the index of the cooler day</span>
                <span class="kt">int</span> <span class="n">prevIndex</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="c1">// Calculate the number of days to wait for a warmer temperature</span>
                <span class="c1">// i - prevIndex represents the number of days between the current day</span>
                <span class="c1">// and the day at prevIndex</span>
                <span class="c1">// This is the key operation: it calculates how many days you need to wait</span>
                <span class="c1">// from the day at prevIndex to get to a warmer day (the current day i)</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">prevIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">prevIndex</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Push the current day's index onto the stack</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test case</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">temperatures</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">73</span><span class="o">,</span> <span class="mi">74</span><span class="o">,</span> <span class="mi">75</span><span class="o">,</span> <span class="mi">71</span><span class="o">,</span> <span class="mi">69</span><span class="o">,</span> <span class="mi">72</span><span class="o">,</span> <span class="mi">76</span><span class="o">,</span> <span class="mi">73</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">dailyTemperatures</span><span class="o">(</span><span class="n">temperatures</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input temperatures: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">temperatures</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Days to wait for warmer temperature: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
        <span class="c1">// Expected output: [ 1, 1, 4, 2, 1, 1, 0, 0]</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.]]></summary></entry><entry><title type="html">Floyd’s Algorithm for Finding Duplicate Number</title><link href="https://zhengstar94.github.io//blog/2024/FloydAlgorithmForFindingDuplicateNumber/" rel="alternate" type="text/html" title="Floyd’s Algorithm for Finding Duplicate Number"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/FloydAlgorithmForFindingDuplicateNumber</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/FloydAlgorithmForFindingDuplicateNumber/"><![CDATA[<h2 id="1-introduction">1. Introduction</h2> <p>Floyd’s Cycle-Finding Algorithm, also known as the “Tortoise and Hare” algorithm, is a pointer algorithm that uses only two pointers, moving through the sequence at different speeds. This algorithm is particularly useful for detecting cycles in sequences and has an interesting application in solving the “Find the Duplicate Number” problem.</p> <h2 id="2-problem-statement">2. Problem Statement</h2> <p>Given an array <code class="language-plaintext highlighter-rouge">nums</code> containing <code class="language-plaintext highlighter-rouge">n + 1</code> integers where each integer is in the range <code class="language-plaintext highlighter-rouge">[1, n]</code> inclusive, prove that at least one duplicate number must exist. Assume that there is only one duplicate number, but it may be repeated more than once.</p> <p>The task is to find the duplicate number without modifying the array <code class="language-plaintext highlighter-rouge">nums</code> and using only constant extra space.</p> <h2 id="3-algorithm-description">3. Algorithm Description</h2> <p>Floyd’s algorithm can be adapted to solve this problem by treating the array as a linked list where <code class="language-plaintext highlighter-rouge">nums[i]</code> is treated as a pointer to index <code class="language-plaintext highlighter-rouge">nums[i]</code>.</p> <p>The algorithm consists of two phases:</p> <h3 id="phase-1-detecting-the-intersection-point-of-two-runners">Phase 1: Detecting the intersection point of two runners</h3> <ol> <li>Initialize two pointers, <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code>, to the first element of the array.</li> <li>Move <code class="language-plaintext highlighter-rouge">tortoise</code> one step at a time: <code class="language-plaintext highlighter-rouge">tortoise = nums[tortoise]</code></li> <li>Move <code class="language-plaintext highlighter-rouge">hare</code> two steps at a time: <code class="language-plaintext highlighter-rouge">hare = nums[nums[hare]]</code></li> <li>Repeat steps 2 and 3 until <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code> meet at the same element.</li> </ol> <h3 id="phase-2-finding-the-entrance-to-the-cycle-the-duplicate-number">Phase 2: Finding the entrance to the cycle (the duplicate number)</h3> <ol> <li>Reset the <code class="language-plaintext highlighter-rouge">tortoise</code> to the first element of the array.</li> <li>Move both <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code> one step at a time.</li> <li>The point at which they meet is the entrance to the cycle, which is the duplicate number.</li> </ol> <h2 id="4-implementation">4. Implementation</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Phase 1: Detecting the cycle</span>
    <span class="kt">int</span> <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// Initialize the slow pointer (tortoise)</span>
    <span class="kt">int</span> <span class="n">hare</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>      <span class="c1">// Initialize the fast pointer (hare)</span>

    <span class="k">do</span> <span class="o">{</span>
      <span class="c1">// Move the tortoise one step forward</span>
      <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">tortoise</span><span class="o">];</span>

      <span class="c1">// Move the hare two steps forward</span>
      <span class="n">hare</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">hare</span><span class="o">]];</span>

      <span class="c1">// Continue until the tortoise and hare meet</span>
      <span class="c1">// This meeting point is guaranteed to be inside the cycle</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">tortoise</span> <span class="o">!=</span> <span class="n">hare</span><span class="o">);</span>

    <span class="c1">// Phase 2: Finding the entrance to the cycle (the duplicate number)</span>
    <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// Reset the tortoise to the start of the array</span>

    <span class="c1">// Move both pointers at the same speed until they meet again</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">tortoise</span> <span class="o">!=</span> <span class="n">hare</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Move both pointers one step at a time</span>
      <span class="n">tortoise</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">tortoise</span><span class="o">];</span>
      <span class="n">hare</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">hare</span><span class="o">];</span>

      <span class="c1">// The point where they meet is the entrance to the cycle,</span>
      <span class="c1">// which is the duplicate number</span>
    <span class="o">}</span>

    <span class="c1">// Both pointers now point to the duplicate number</span>
    <span class="k">return</span> <span class="n">hare</span><span class="o">;</span>  <span class="c1">// We could return tortoise as well, they're the same at this point</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="5-proof-of-correctness">5. Proof of Correctness</h2> <p>The correctness of this algorithm relies on the following properties:</p> <ol> <li>If there is a cycle, the <code class="language-plaintext highlighter-rouge">tortoise</code> and <code class="language-plaintext highlighter-rouge">hare</code> will eventually meet.</li> <li>The meeting point is not necessarily the duplicate number, but it is guaranteed to be part of the cycle.</li> <li>The distance from the start of the array to the entrance of the cycle (duplicate number) is equal to the distance from the meeting point to the entrance of the cycle.</li> </ol> <h2 id="6-complexity-analysis">6. Complexity Analysis</h2> <ul> <li>Time Complexity: O(n), where n is the length of the array. The worst case occurs when the duplicate element is at the end of the array.</li> <li>Space Complexity: O(1), as only two pointers are used regardless of the input size.</li> </ul> <h2 id="7-advantages-and-disadvantages">7. Advantages and Disadvantages</h2> <h3 id="advantages">Advantages:</h3> <ul> <li>Meets the problem constraints of O(1) space complexity.</li> <li>Does not modify the original array.</li> <li>Has optimal time complexity of O(n).</li> </ul> <h3 id="disadvantages">Disadvantages:</h3> <ul> <li>Not intuitive and can be difficult to understand at first glance.</li> <li>Doesn’t provide information about all duplicates if multiple exist.</li> </ul> <h2 id="8-conclusion">8. Conclusion</h2> <p>Floyd’s Cycle-Finding Algorithm provides an elegant and efficient solution to the “Find the Duplicate Number” problem. While it may not be the most intuitive approach, it showcases how algorithmic thinking can lead to optimal solutions that satisfy strict constraints. Understanding this algorithm and its application can provide valuable insights into problem-solving techniques in computer science.</p> <h2 id="example-of-leetode">Example of Leetode</h2> <ol> <li>LeetCode 142 - Linked List Cycle II</li> </ol> <p>Problem: Given a linked list, return the node where the cycle begins. If there is no cycle, return <code class="language-plaintext highlighter-rouge">null</code>.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">detectCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="c1">// Phase 1: Detect the intersection point</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>            <span class="c1">// Move slow pointer one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>       <span class="c1">// Move fast pointer two steps</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>     <span class="c1">// They meet at the cycle</span>
        <span class="o">}</span>

        <span class="c1">// If fast reaches null, there is no cycle</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

        <span class="c1">// Phase 2: Find the entrance to the cycle</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>  <span class="c1">// This is the entrance to the cycle</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>LeetCode 202 - Happy Number</li> </ol> <p>Problem: Write an algorithm to determine if a number <code class="language-plaintext highlighter-rouge">n</code> is a “happy number.” A happy number is one where you repeatedly replace the number by the sum of the squares of its digits until it either equals <code class="language-plaintext highlighter-rouge">1</code> (which means it’s happy) or loops endlessly in a cycle.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHappy</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">getNext</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

        <span class="c1">// Phase 1: Detect cycle</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">getNext</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>             <span class="c1">// Slow pointer moves one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">getNext</span><span class="o">(</span><span class="n">getNext</span><span class="o">(</span><span class="n">fast</span><span class="o">));</span>    <span class="c1">// Fast pointer moves two steps</span>
        <span class="o">}</span>

        <span class="c1">// If fast reaches 1, it's a happy number</span>
        <span class="k">return</span> <span class="n">fast</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getNext</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">totalSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
            <span class="n">totalSum</span> <span class="o">+=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">totalSum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>LeetCode 41 - First Missing Positive</li> </ol> <p>Problem: Given an unsorted integer array, find the smallest missing positive integer. Although this problem doesn’t directly use Floyd’s algorithm, you can solve it by rearranging the array to simulate the cyclic behavior.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstMissingPositive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Place each number at its correct index (e.g., 1 goes to index 0, 2 goes to index 1)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Swap nums[i] with nums[nums[i] - 1]</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Find the first missing positive number</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// If all numbers are in the correct place, return n+1</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>Cycle Detection in Function Iteration</li> </ol> <p>In function iteration, we want to detect if a function eventually enters a cycle. You can apply Floyd’s algorithm here as well. Below is an example:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">detectCycleInFunction</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>

        <span class="c1">// Phase 1: Detect cycle</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>           <span class="c1">// Slow pointer moves one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">fast</span><span class="o">));</span>        <span class="c1">// Fast pointer moves two steps</span>
        <span class="o">}</span>

        <span class="c1">// Phase 2: Find the entrance of the cycle</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">fast</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>  <span class="c1">// Return the entrance of the cycle</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example of a function f</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>  <span class="c1">// For instance, square the number and add 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <ol> <li>Cycle Detection in Finite State Machines</li> </ol> <p>You can also use Floyd’s algorithm to detect cycles in state transitions of a finite state machine (FSM).</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">detectCycleInFSM</span><span class="o">(</span><span class="kt">int</span> <span class="n">state</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">transitions</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">state</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">transitions</span><span class="o">[</span><span class="n">state</span><span class="o">][</span><span class="mi">0</span><span class="o">]][</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Phase 1: Detect cycle</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">slow</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>               <span class="c1">// Slow pointer moves one step</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">transitions</span><span class="o">[</span><span class="n">fast</span><span class="o">][</span><span class="mi">0</span><span class="o">]][</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// Fast pointer moves two steps</span>
        <span class="o">}</span>

        <span class="c1">// Phase 2: Find the entrance of the cycle</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">slow</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">[</span><span class="n">fast</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>  <span class="c1">// Return the state where the cycle starts</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="Data Structure"/><summary type="html"><![CDATA[1. Introduction]]></summary></entry><entry><title type="html">22.Generate Parenthesesn</title><link href="https://zhengstar94.github.io//blog/2024/GenerateParentheses/" rel="alternate" type="text/html" title="22.Generate Parenthesesn"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/GenerateParentheses</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/GenerateParentheses/"><![CDATA[<ul> <li>Given <code class="language-plaintext highlighter-rouge">n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: ["()"]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(4<span class="p">^</span>n / √n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/08
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenerateParentheses</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">backtrac</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Recursive backtracking method to generate parentheses combinations
     * @param result The list to store all valid combinations
     * @param current The current combination being built
     * @param open The count of open parentheses in the current combination
     * @param close The count of close parentheses in the current combination
     * @param max The maximum number of pairs allowed (n)
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrac</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">current</span><span class="o">,</span> <span class="kt">int</span> <span class="n">open</span><span class="o">,</span> <span class="kt">int</span> <span class="n">close</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Base case: If the current combination has the correct length, add it to the result</span>
        <span class="k">if</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">max</span> <span class="o">*</span> <span class="mi">2</span><span class="o">){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Add an open parenthesis if we haven't used all n open parentheses yet</span>
        <span class="k">if</span><span class="o">(</span><span class="n">open</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">){</span>
            <span class="n">current</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"("</span><span class="o">);</span>
            <span class="n">backtrac</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">current</span><span class="o">,</span> <span class="n">open</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">close</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
            <span class="n">current</span><span class="o">.</span><span class="na">setLength</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">// Backtrack: remove the last added parenthesis</span>
        <span class="o">}</span>

        <span class="c1">// Add a close parenthesis if it's valid (close count &lt; open count)</span>
        <span class="k">if</span><span class="o">(</span><span class="n">close</span> <span class="o">&lt;</span> <span class="n">open</span><span class="o">){</span>
            <span class="n">current</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">")"</span><span class="o">);</span>
            <span class="n">backtrac</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">current</span><span class="o">,</span> <span class="n">open</span><span class="o">,</span> <span class="n">close</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
            <span class="n">current</span><span class="o">.</span><span class="na">setLength</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">// Backtrack: remove the last added parenthesis</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to run tests
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test different values of n</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Test method to generate and print results for a given n
     * @param n The number of pairs of parentheses to generate
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">generateParenthesis</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"n = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of combinations: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.]]></summary></entry><entry><title type="html">150.Evaluate Reverse Polish Notation</title><link href="https://zhengstar94.github.io//blog/2024/EvaluateReversePolishNotation/" rel="alternate" type="text/html" title="150.Evaluate Reverse Polish Notation"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/EvaluateReversePolishNotation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/EvaluateReversePolishNotation/"><![CDATA[<ul> <li>You are given an array of strings <code class="language-plaintext highlighter-rouge">tokens</code> that represents an arithmetic expression in a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</li> <li>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</li> <li><strong>Note</strong> that: <ul> <li>The valid operators are <code class="language-plaintext highlighter-rouge">'+'</code>, <code class="language-plaintext highlighter-rouge">'-'</code>, <code class="language-plaintext highlighter-rouge">'*'</code>, and <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Each operand may be an integer or another expression.</li> <li>The division between two integers always <strong>truncates toward zero</strong>.</li> <li>There will not be any division by zero.</li> <li>The input represents a valid arithmetic expression in a reverse polish notation.</li> <li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EvaluateReversePolishNotation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">evalRPN</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">tokens</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a stack to store operands</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each token in the input array</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">token</span> <span class="o">:</span> <span class="n">tokens</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"+"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Addition: pop two numbers, add them, and push the result</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"*"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Multiplication: pop two numbers, multiply them, and push the result</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">*</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"-"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Subtraction: pop two numbers (order matters), subtract, and push the result</span>
                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"/"</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Division: pop two numbers (order matters), divide, and push the result</span>
                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If the token is a number, parse it to integer and push onto the stack</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">token</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The final result is the only item left on the stack</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic addition and multiplication</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"2"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"*"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens1</span><span class="o">));</span> <span class="c1">// Expected output: 9</span>

        <span class="c1">// Test case 2: Division and addition</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens2</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"4"</span><span class="o">,</span><span class="s">"13"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"/"</span><span class="o">,</span><span class="s">"+"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens2</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 3: Complex expression with multiple operations</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens3</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"10"</span><span class="o">,</span><span class="s">"6"</span><span class="o">,</span><span class="s">"9"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"-11"</span><span class="o">,</span><span class="s">"*"</span><span class="o">,</span><span class="s">"/"</span><span class="o">,</span><span class="s">"*"</span><span class="o">,</span><span class="s">"17"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"+"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens3</span><span class="o">));</span> <span class="c1">// Expected output: 22</span>

        <span class="c1">// Test case 4: Expression with negative numbers</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens4</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"4"</span><span class="o">,</span><span class="s">"-2"</span><span class="o">,</span><span class="s">"/"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"-"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens4</span><span class="o">));</span> <span class="c1">// Expected output: -4</span>

        <span class="c1">// Test case 5: Expression with a single number</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens5</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"18"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5 result: "</span> <span class="o">+</span> <span class="n">evalRPN</span><span class="o">(</span><span class="n">tokens5</span><span class="o">));</span> <span class="c1">// Expected output: 18</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.]]></summary></entry><entry><title type="html">42.Trapping Rain Water</title><link href="https://zhengstar94.github.io//blog/2024/TrappingRainWater/" rel="alternate" type="text/html" title="42.Trapping Rain Water"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/TrappingRainWater</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/TrappingRainWater/"><![CDATA[<ul> <li>Given <code class="language-plaintext highlighter-rouge">n</code> non-negative integers representing an elevation map where the width of each bar is <code class="language-plaintext highlighter-rouge">1</code>, compute how much water it can trap after raining.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: height = [4,2,0,3,2,5]
Output: 9
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.TwoPointer</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/10/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrappingRainWater</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">trap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize two pointers: left starts from the beginning, right from the end</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Keep track of the maximum height encountered from left and right</span>
        <span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Variable to store the total amount of water trapped</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Continue until the two pointers meet</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Compare the heights at the left and right pointers</span>
            <span class="c1">// This comparison is crucial as it determines which side to process</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// Process the left side when its height is smaller</span>

                <span class="c1">// If current height is greater or equal to leftMax,</span>
                <span class="c1">// update leftMax as no water can be trapped here</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">leftMax</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">leftMax</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Water can be trapped at this position</span>
                    <span class="c1">// The amount is the difference between leftMax and current height</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">leftMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="c1">// Move the left pointer to the right</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Process the right side when its height is smaller or equal</span>

                <span class="c1">// If current height is greater or equal to rightMax,</span>
                <span class="c1">// update rightMax as no water can be trapped here</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">rightMax</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">rightMax</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Water can be trapped at this position</span>
                    <span class="c1">// The amount is the difference between rightMax and current height</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">rightMax</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="c1">// Move the right pointer to the left</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total amount of water trapped</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Test cases</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// Test case 1: Standard case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height1</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height1</span><span class="o">));</span> <span class="c1">// Expected output: 6</span>

        <span class="c1">// Test case 2: No water can be trapped</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height2</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 3: Single peak</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height3</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height3</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Test case 4: Multiple peaks</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height4</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height4</span><span class="o">));</span> <span class="c1">// Expected output: 7</span>

        <span class="c1">// Test case 5: Empty array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">height5</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">trap</span><span class="o">(</span><span class="n">height5</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Two Pointers"/><summary type="html"><![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.]]></summary></entry></feed>