<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-16T01:47:32+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">2616. Minimize the Maximum Difference of Pairs</title><link href="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs/" rel="alternate" type="text/html" title="2616. Minimize the Maximum Difference of Pairs"/><published>2025-05-16T00:00:00+00:00</published><updated>2025-05-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizeTheMaximumDifferenceOfPairs/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">p</code>. Find <code class="language-plaintext highlighter-rouge">p</code> pairs of indices of <code class="language-plaintext highlighter-rouge">nums</code> such that the <strong>maximum</strong> difference amongst all the pairs is <strong>minimized</strong>. Also, ensure no index appears more than once amongst the <code class="language-plaintext highlighter-rouge">p</code> pairs.</li> <li>Note that for a pair of elements at the index <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>, the difference of this pair is <code class="language-plaintext highlighter-rouge">|nums[i] - nums[j]|</code>, where <code class="language-plaintext highlighter-rouge">|x|</code> represents the <strong>absolute</strong> <strong>value</strong> of <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>Return <em>the <strong>minimum</strong> <strong>maximum</strong> difference among all</em> <code class="language-plaintext highlighter-rouge">p</code> <em>pairs.</em> We define the maximum of an empty set to be zero.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [10,1,2,7,1,3], p = 2
Output: 1
Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [4,2,1,2], p = 1
Output: 0
Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n*log(n)+n*log(U)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizeTheMaximumDifferenceOfPairs</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizeMax</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If no pairs are needed, return 0 immediately.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort the array so we can easily find close numbers (small differences).</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Initialize binary search boundaries.</span>
        <span class="c1">// left is the smallest possible difference (0),</span>
        <span class="c1">// right is the largest possible difference (max - min).</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Perform binary search to find the minimal threshold</span>
        <span class="c1">// such that we can form at least p valid pairs.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// If it's possible to form p pairs with max difference ≤ mid,</span>
            <span class="c1">// try smaller values (search left half).</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canFormPairs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">p</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, try larger threshold (search right half).</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After convergence, left is the smallest valid threshold.</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canFormPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If adjacent elements form a valid pair under the threshold</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">++;</span>  <span class="c1">// Count the valid pair</span>
                <span class="n">i</span><span class="o">++;</span>    <span class="c1">// Skip the next element, as it's already paired</span>
            <span class="o">}</span>
            <span class="c1">// If not valid, move to the next element to try a new pair</span>
        <span class="o">}</span>
        <span class="c1">// Return true if we've formed at least p pairs</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">p1</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">p2</span><span class="o">));</span> <span class="c1">// Expected output: 0</span>

        <span class="c1">// Additional test case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">p3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minimizeMax</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">p3</span><span class="o">));</span> <span class="c1">// Expected output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs. Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x. Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.]]></summary></entry><entry><title type="html">2900. Longest Unequal Adjacent Groups Subsequence I</title><link href="https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI/" rel="alternate" type="text/html" title="2900. Longest Unequal Adjacent Groups Subsequence I"/><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/LongestUnequalAdjacentGroupsSubsequenceI/"><![CDATA[<ul> <li>You are given a string array <code class="language-plaintext highlighter-rouge">words</code> and a <strong>binary</strong> array <code class="language-plaintext highlighter-rouge">groups</code> both of length <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">words[i]</code> is associated with <code class="language-plaintext highlighter-rouge">groups[i]</code>.</li> <li>Your task is to select the <strong>longest alternating</strong> subsequence from <code class="language-plaintext highlighter-rouge">words</code>. A subsequence of <code class="language-plaintext highlighter-rouge">words</code> is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array <code class="language-plaintext highlighter-rouge">groups</code> differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the <code class="language-plaintext highlighter-rouge">groups</code> array.</li> <li>Formally, you need to find the longest subsequence of an array of indices <code class="language-plaintext highlighter-rouge">[0, 1, ..., n - 1]</code> denoted as <code class="language-plaintext highlighter-rouge">[i0, i1, ..., ik-1]</code>, such that <code class="language-plaintext highlighter-rouge">groups[ij] != groups[ij+1]</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= j &lt; k - 1</code> and then find the words corresponding to these indices.</li> <li>Return <em>the selected subsequence. If there are multiple answers, return <strong>any</strong> of them.</em>**</li> <li><strong>Note:</strong> The elements in <code class="language-plaintext highlighter-rouge">words</code> are distinct.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["e","a","b"], groups = [0,0,1]

Output: ["e","b"]

Explanation: A subsequence that can be selected is ["e","b"] because groups[0] != groups[2]. Another subsequence that can be selected is ["a","b"] because groups[1] != groups[2]. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: words = ["a","b","c","d"], groups = [1,0,1,1]

Output: ["a","b","c"]

Explanation: A subsequence that can be selected is ["a","b","c"] because groups[0] != groups[1] and groups[1] != groups[2]. Another subsequence that can be selected is ["a","b","d"] because groups[0] != groups[1] and groups[1] != groups[3]. It can be shown that the length of the longest subsequence of indices that satisfies the condition is 3.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(max(nums) - min(nums))) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestUnequalAdjacentGroupsSubsequenceI</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getLongestSubsequence</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">groups</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the result list to store our subsequence</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Add the first element to the result</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// Remember the group value of the last added element</span>
        <span class="kt">int</span> <span class="n">lastGroup</span> <span class="o">=</span> <span class="n">groups</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// Iterate through the remaining elements</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current element's group is different from the last added element's group</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">lastGroup</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Add the current element to our result</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

                <span class="c1">// Update the last group value</span>
                <span class="n">lastGroup</span> <span class="o">=</span> <span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the longest subsequence</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words1</span><span class="o">,</span> <span class="n">groups1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words1</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [a, b, c] or [a, b, d]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"e"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words2</span><span class="o">,</span> <span class="n">groups2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words2</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [e, b] or [a, b]"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Additional Test Case 3</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"red"</span><span class="o">,</span> <span class="s">"green"</span><span class="o">,</span> <span class="s">"blue"</span><span class="o">,</span> <span class="s">"yellow"</span><span class="o">,</span> <span class="s">"purple"</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">getLongestSubsequence</span><span class="o">(</span><span class="n">words3</span><span class="o">,</span> <span class="n">groups3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: words = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">words3</span><span class="o">)</span> <span class="o">+</span> <span class="s">", groups = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">groups3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">result3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected: [red, green, blue, purple]"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given a string array words and a binary array groups both of length n, where words[i] is associated with groups[i]. Your task is to select the longest alternating subsequence from words. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array groups differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the groups array. Formally, you need to find the longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each 0 &lt;= j &lt; k - 1 and then find the words corresponding to these indices. Return the selected subsequence. If there are multiple answers, return any of them.** Note: The elements in words are distinct.]]></summary></entry><entry><title type="html">2560. House Robber IV</title><link href="https://zhengstar94.github.io//blog/2025/HouseRobberIV/" rel="alternate" type="text/html" title="2560. House Robber IV"/><published>2025-05-14T00:00:00+00:00</published><updated>2025-05-14T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/HouseRobberIV</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/HouseRobberIV/"><![CDATA[<ul> <li>There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he <strong>refuses to steal from adjacent homes</strong>.</li> <li>The <strong>capability</strong> of the robber is the maximum amount of money he steals from one house of all the houses he robbed.</li> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code> representing how much money is stashed in each house. More formally, the <code class="language-plaintext highlighter-rouge">ith</code> house from the left has <code class="language-plaintext highlighter-rouge">nums[i]</code> dollars.</li> <li>You are also given an integer <code class="language-plaintext highlighter-rouge">k</code>, representing the <strong>minimum</strong> number of houses the robber will steal from. It is always possible to steal at least <code class="language-plaintext highlighter-rouge">k</code> houses.</li> <li>Return <em>the <strong>minimum</strong> capability of the robber out of all the possible ways to steal at least</em> <code class="language-plaintext highlighter-rouge">k</code> <em>houses</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,5,9], k = 2
Output: 5
Explanation: 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,7,9,3,1], k = 2
Output: 2
Explanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n * log(max(nums) - min(nums))) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HouseRobberIV</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minCapability</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the binary search boundaries</span>
        <span class="c1">// Left boundary is the minimum value in the array (minimum possible capability)</span>
        <span class="c1">// Right boundary is the maximum value in the array (maximum possible capability)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Find the minimum and maximum values in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Binary search process to find the minimum capability</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle point to check</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if with capability 'mid', the robber can steal at least k houses</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canRob</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If it's possible to rob k houses with current capability,</span>
                <span class="c1">// try to lower the capability to find the minimum</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If it's not possible to rob k houses with current capability,</span>
                <span class="c1">// we need to increase the capability</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After binary search, 'left' will be the minimum capability required</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canRob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">capability</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Count of houses that have been robbed</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>      <span class="c1">// Current index in the array</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the money in the current house is less than or equal to the capability,</span>
            <span class="c1">// the robber can steal from this house</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">capability</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>  <span class="c1">// Increment the count of robbed houses</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>   <span class="c1">// Skip the next house (can't rob adjacent houses)</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>      <span class="c1">// Can't rob this house, move to the next one</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Check if the robber has stolen from at least k houses</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minCapability</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>  <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minCapability</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>  <span class="c1">// Expected output: 2</span>

        <span class="c1">// Additional test case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minCapability</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>  <span class="c1">// Expected output: 7</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes. The capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed. You are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars. You are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses. Return the minimum capability of the robber out of all the possible ways to steal at least k houses.]]></summary></entry><entry><title type="html">2094. Finding 3-Digit Even Numbers</title><link href="https://zhengstar94.github.io//blog/2025/Finding3DigitEvenNumbers/" rel="alternate" type="text/html" title="2094. Finding 3-Digit Even Numbers"/><published>2025-05-12T00:00:00+00:00</published><updated>2025-05-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/Finding3DigitEvenNumbers</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/Finding3DigitEvenNumbers/"><![CDATA[<ul> <li> <p>You are given an integer array <code class="language-plaintext highlighter-rouge">digits</code>, where each element is a digit. The array may contain duplicates.</p> </li> <li> <p>You need to find <strong>all</strong> the <strong>unique</strong> integers that follow the given requirements:</p> <ul> <li>The integer consists of the <strong>concatenation</strong> of <strong>three</strong> elements from <code class="language-plaintext highlighter-rouge">digits</code> in <strong>any</strong> arbitrary order.</li> <li>The integer does not have <strong>leading zeros</strong>.</li> <li>The integer is <strong>even</strong>.</li> </ul> </li> <li> <p>For example, if the given <code class="language-plaintext highlighter-rouge">digits</code> were <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>, integers <code class="language-plaintext highlighter-rouge">132</code> and <code class="language-plaintext highlighter-rouge">312</code> follow the requirements.</p> <p>Return <em>a <strong>sorted</strong> array of the unique integers.</em></p> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: digits = [2,1,3,0]
Output: [102,120,130,132,210,230,302,310,312,320]
Explanation: All the possible integers that follow the requirements are in the output array. 
Notice that there are no odd integers or integers with leading zeros.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: digits = [2,2,8,8,2]
Output: [222,228,282,288,822,828,882]
Explanation: The same digit can be used as many times as it appears in digits. 
In this example, the digit 8 is used twice each time in 288, 828, and 882. 
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: digits = [3,7,5]
Output: []
Explanation: No even integers can be formed using the given digits.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(1) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Finding3DigitEvenNumbers</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findEvenNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create an array to count the frequency of each digit (0-9) in the input array</span>
        <span class="c1">// This allows us to track how many times each digit appears in the input</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">digit</span> <span class="o">:</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">digit</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// List to store the valid 3-digit even numbers we find</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through all possible 3-digit even numbers</span>
        <span class="c1">// Start from 100 (smallest 3-digit number)</span>
        <span class="c1">// End at 998 (largest 3-digit even number)</span>
        <span class="c1">// Increment by 2 to only check even numbers (numbers ending with 0,2,4,6,8)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">998</span><span class="o">;</span> <span class="n">num</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Extract each digit from the current number</span>
            <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">100</span><span class="o">;</span>         <span class="c1">// Hundreds place (first digit)</span>
            <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>   <span class="c1">// Tens place (second digit)</span>
            <span class="kt">int</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>          <span class="c1">// Ones place (third digit)</span>

            <span class="c1">// Temporarily decrement the count for each digit we want to use</span>
            <span class="c1">// This simulates "using" these digits to form our number</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d1</span><span class="o">]--;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d2</span><span class="o">]--;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d3</span><span class="o">]--;</span>

            <span class="c1">// Check if we can form this number with the available digits</span>
            <span class="c1">// For each digit, if count &gt;= 0 after decrementing, it means:</span>
            <span class="c1">// 1. If count = 0: We've used exactly all occurrences of this digit</span>
            <span class="c1">// 2. If count &gt; 0: We still have more occurrences of this digit available</span>
            <span class="c1">// </span>
            <span class="c1">// If any count &lt; 0, it means we tried to use more occurrences of a digit</span>
            <span class="c1">// than what's available in the original array, which is invalid</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">d1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">d2</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">[</span><span class="n">d3</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If all counts are valid (&gt;= 0), we can form this number</span>
                <span class="c1">// so add it to our result list</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Restore the counts for the next iteration</span>
            <span class="c1">// This is critical because we're only "simulating" using these digits</span>
            <span class="c1">// and need to reset for checking the next number</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d1</span><span class="o">]++;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d2</span><span class="o">]++;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">d3</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// Convert the ArrayList to a primitive int array and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Mixed digits with an even digit and zero</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">digits1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findEvenNumbers</span><span class="o">(</span><span class="n">digits1</span><span class="o">)));</span>

        <span class="c1">// Test case 2: Repeated digits</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">digits2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findEvenNumbers</span><span class="o">(</span><span class="n">digits2</span><span class="o">)));</span>

        <span class="c1">// Test case 3: Only odd digits, no even numbers possible</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">digits3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">findEvenNumbers</span><span class="o">(</span><span class="n">digits3</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[You are given an integer array digits, where each element is a digit. The array may contain duplicates.]]></summary></entry><entry><title type="html">2064. Minimized Maximum of Products Distributed to Any Store</title><link href="https://zhengstar94.github.io//blog/2025/MinimizedMaximumOfProductsDistributedToAnyStore/" rel="alternate" type="text/html" title="2064. Minimized Maximum of Products Distributed to Any Store"/><published>2025-05-12T00:00:00+00:00</published><updated>2025-05-12T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimizedMaximumOfProductsDistributedToAnyStore</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimizedMaximumOfProductsDistributedToAnyStore/"><![CDATA[<ul> <li>You are given an integer <code class="language-plaintext highlighter-rouge">n</code> indicating there are <code class="language-plaintext highlighter-rouge">n</code> specialty retail stores. There are <code class="language-plaintext highlighter-rouge">m</code> product types of varying amounts, which are given as a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">quantities</code>, where <code class="language-plaintext highlighter-rouge">quantities[i]</code> represents the number of products of the <code class="language-plaintext highlighter-rouge">ith</code> product type.</li> <li>You need to distribute <strong>all products</strong> to the retail stores following these rules: <ul> <li>A store can only be given <strong>at most one product type</strong> but can be given <strong>any</strong> amount of it.</li> <li>After distribution, each store will have been given some number of products (possibly <code class="language-plaintext highlighter-rouge">0</code>). Let <code class="language-plaintext highlighter-rouge">x</code> represent the maximum number of products given to any store. You want <code class="language-plaintext highlighter-rouge">x</code> to be as small as possible, i.e., you want to <strong>minimize</strong> the <strong>maximum</strong> number of products that are given to any store.</li> </ul> </li> <li>Return <em>the minimum possible</em> <code class="language-plaintext highlighter-rouge">x</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 6, quantities = [11,6]
Output: 3
Explanation: One optimal way is:
- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3
- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3
The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.

</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 7, quantities = [15,10,10]
Output: 5
Explanation: One optimal way is:
- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5
- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5
- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5
The maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1, quantities = [100000]
Output: 100000
Explanation: The only optimal way is:
- The 100000 products of type 0 are distributed to the only store.
The maximum number of products given to any store is max(100000) = 100000.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(k * log(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.MinimizeMaximum</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/12
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimizedMaximumOfProductsDistributedToAnyStore</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minimizedMaximum</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// The minimum possible maxProducts is 1 (each store gets at least 1 product)</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Will hold the maximum of all quantities to initialize upper bound</span>

        <span class="c1">// Find the maximum product quantity among all types to set the upper bound</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">quantity</span> <span class="o">:</span> <span class="n">quantities</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">quantity</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Binary search for the smallest feasible maxProducts value</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// Avoids overflow</span>

            <span class="c1">// Check if it's possible to distribute all products with maxProducts = mid</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canDistribute</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">quantities</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If it's possible, try a smaller max value to minimize the maximum</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If not possible, we need to increase the allowed max per store</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After the loop, left == right and it's the smallest feasible maxProducts value</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canDistribute</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxProducts</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">storesNeeded</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// Total number of stores needed under current maxProducts constraint</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">quantity</span> <span class="o">:</span> <span class="n">quantities</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// For each product type, calculate how many stores are needed</span>
            <span class="c1">// Formula: ceil(quantity / maxProducts)</span>
            <span class="n">storesNeeded</span> <span class="o">+=</span> <span class="o">(</span><span class="n">quantity</span> <span class="o">+</span> <span class="n">maxProducts</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">maxProducts</span><span class="o">;</span>

            <span class="c1">// If more stores are needed than we have, the distribution fails</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">storesNeeded</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we can serve all products within n stores, return true</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">11</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Output: "</span> <span class="o">+</span> <span class="n">minimizedMaximum</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">quantities1</span><span class="o">));</span>
        <span class="c1">// Expected output: 3</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Output: "</span> <span class="o">+</span> <span class="n">minimizedMaximum</span><span class="o">(</span><span class="n">n2</span><span class="o">,</span> <span class="n">quantities2</span><span class="o">));</span>
        <span class="c1">// Expected output: 5</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">quantities3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100000</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Output: "</span> <span class="o">+</span> <span class="n">minimizedMaximum</span><span class="o">(</span><span class="n">n3</span><span class="o">,</span> <span class="n">quantities3</span><span class="o">));</span>
        <span class="c1">// Expected output: 100000</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.MinimizeMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type. You need to distribute all products to the retail stores following these rules: A store can only be given at most one product type but can be given any amount of it. After distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store. Return the minimum possible x.]]></summary></entry><entry><title type="html">1550. Three Consecutive Odds</title><link href="https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds/" rel="alternate" type="text/html" title="1550. Three Consecutive Odds"/><published>2025-05-11T00:00:00+00:00</published><updated>2025-05-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/ThreeConsecutiveOdds/"><![CDATA[<ul> <li>Given an integer array <code class="language-plaintext highlighter-rouge">arr</code>, return <code class="language-plaintext highlighter-rouge">true</code> if there are three consecutive odd numbers in the array. Otherwise, return <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.SlideWindow</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeConsecutiveOdds</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">threeConsecutiveOdds</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Edge case: If array length is less than 3, it's impossible to have three consecutive elements</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Counter to track the number of consecutive odd integers encountered</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each element in the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Check if the current number is odd (remainder when divided by 2 is 1)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="c1">// Increment the counter for consecutive odd numbers</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="c1">// If we've found three consecutive odd numbers, return true</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If we encounter an even number, reset the counter</span>
                <span class="c1">// as it breaks the consecutive sequence of odd numbers</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If we've traversed the entire array without finding three consecutive odd numbers, return false</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Array with no three consecutive odd numbers</span>
        <span class="c1">// Expected output: false</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr1</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>

        <span class="c1">// Test Case 2: Array with three consecutive odd numbers (5, 7, 23)</span>
        <span class="c1">// Expected output: true</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">12</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr2</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 3: Array with exactly three elements, all odd</span>
        <span class="c1">// Expected output: true</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr3</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 4: Array with consecutive odd numbers scattered throughout</span>
        <span class="c1">// Expected output: true (could be because of 7, 3, 1 or 3, 1, 9 or 1, 9, 5)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr4</span><span class="o">));</span>  <span class="c1">// Expected output: true</span>

        <span class="c1">// Test Case 5: Array with only even numbers</span>
        <span class="c1">// Expected output: false</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 Result: "</span> <span class="o">+</span> <span class="n">threeConsecutiveOdds</span><span class="o">(</span><span class="n">arr5</span><span class="o">));</span>  <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode SlideWindow"/><category term="Easy"/><summary type="html"><![CDATA[Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.]]></summary></entry><entry><title type="html">2918. Minimum Equal Sum of Two Arrays After Replacing Zeros</title><link href="https://zhengstar94.github.io//blog/2025/MinimumEqualSumOfTwoArraysAfterReplacingZeros/" rel="alternate" type="text/html" title="2918. Minimum Equal Sum of Two Arrays After Replacing Zeros"/><published>2025-05-10T00:00:00+00:00</published><updated>2025-05-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/MinimumEqualSumOfTwoArraysAfterReplacingZeros</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/MinimumEqualSumOfTwoArraysAfterReplacingZeros/"><![CDATA[<ul> <li>You are given two arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> consisting of positive integers.</li> <li>You have to replace <strong>all</strong> the <code class="language-plaintext highlighter-rouge">0</code>’s in both arrays with <strong>strictly</strong> positive integers such that the sum of elements of both arrays becomes <strong>equal</strong>.</li> <li>Return <em>the <strong>minimum</strong> equal sum you can obtain, or</em> <code class="language-plaintext highlighter-rouge">-1</code> <em>if it is impossible</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [3,2,0,1,0], nums2 = [6,5,0]
Output: 12
Explanation: We can replace 0's in the following way:
- Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4].
- Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1].
Both arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [2,0,2,0], nums2 = [1,4]
Output: -1
Explanation: It is impossible to make the sum of both arrays equal.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengxingxing
 * Date: 2025/05/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MinimumEqualSumOfTwoArraysAfterReplacingZeros</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">minimumEqualSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">zero1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">zero2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Calculate the sum and count the number of zeros in nums1</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum1</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zero1</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Calculate the sum and count the number of zeros in nums2</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum2</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zero2</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The minimum possible sum after replacing all zeros with 1</span>
        <span class="kt">long</span> <span class="n">minSum1</span> <span class="o">=</span> <span class="n">sum1</span> <span class="o">+</span> <span class="n">zero1</span><span class="o">;</span> <span class="c1">// Each zero in nums1 is replaced by 1</span>
        <span class="kt">long</span> <span class="n">minSum2</span> <span class="o">=</span> <span class="n">sum2</span> <span class="o">+</span> <span class="n">zero2</span><span class="o">;</span> <span class="c1">// Each zero in nums2 is replaced by 1</span>

        <span class="cm">/**
         * Case 1:
         * If both arrays already have the same sum AND there are no zeros,
         * it means the arrays are naturally equal without needing any replacements.
         * We can directly return the sum as the result.
         *
         * Example:
         * nums1 = {1, 2, 3}
         * nums2 = {3, 2, 1}
         * Both have sum = 6 and no zeros -&gt; return 6.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum1</span> <span class="o">==</span> <span class="n">sum2</span> <span class="o">&amp;&amp;</span> <span class="n">zero1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">zero2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">sum1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Case 2:
         * If the minimum possible sum of nums1 is greater than that of nums2,
         * and nums2 has zeros, we can potentially increase nums2's sum by
         * replacing its zeros with larger numbers to match nums1's sum.
         * We return the minSum1 as the minimum target.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">minSum1</span> <span class="o">&gt;</span> <span class="n">minSum2</span> <span class="o">&amp;&amp;</span> <span class="n">zero2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">minSum1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Case 3:
         * Similarly, if the minimum possible sum of nums2 is greater than that of nums1,
         * and nums1 has zeros, we can potentially increase nums1's sum by
         * replacing its zeros with larger numbers to match nums2's sum.
         * We return the minSum2 as the minimum target.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">minSum2</span> <span class="o">&gt;</span> <span class="n">minSum1</span> <span class="o">&amp;&amp;</span> <span class="n">zero1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">minSum2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Case 4:
         * This is a subtle and important case:
         * If both arrays' minimum possible sums (after replacing all zeros with 1)
         * are already equal, it means they can be balanced by just replacing all
         * zeros with 1 and nothing more needs to be done.
         *
         * Example:
         * nums1 = {0, 2, 3}  -&gt; sum1 = 5, zero1 = 1, minSum1 = 6
         * nums2 = {1, 0, 4}  -&gt; sum2 = 5, zero2 = 1, minSum2 = 6
         * Both minSum1 and minSum2 == 6 -&gt; return 6.
         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">minSum1</span> <span class="o">==</span> <span class="n">minSum2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">minSum1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * If none of the above cases apply, it's impossible to make the arrays equal,
         * even after replacing zeros.
         */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected: 12</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1Case2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2Case2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1Case2</span><span class="o">,</span> <span class="n">nums2Case2</span><span class="o">));</span> <span class="c1">// Expected: -1</span>

        <span class="c1">// Additional test case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1Case3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2Case3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1Case3</span><span class="o">,</span> <span class="n">nums2Case3</span><span class="o">));</span> <span class="c1">// Expected: 3</span>

        <span class="c1">// Additional test case 4</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1Case4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2Case4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4 result: "</span> <span class="o">+</span> <span class="n">minimumEqualSum</span><span class="o">(</span><span class="n">nums1Case4</span><span class="o">,</span> <span class="n">nums2Case4</span><span class="o">));</span> <span class="c1">// Expected: 6</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><category term="Medium"/><summary type="html"><![CDATA[You are given two arrays nums1 and nums2 consisting of positive integers. You have to replace all the 0’s in both arrays with strictly positive integers such that the sum of elements of both arrays becomes equal. Return the minimum equal sum you can obtain, or -1 if it is impossible.]]></summary></entry><entry><title type="html">1920. Build Array from Permutation</title><link href="https://zhengstar94.github.io//blog/2025/BuildArrayFromPermutation/" rel="alternate" type="text/html" title="1920. Build Array from Permutation"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BuildArrayFromPermutation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BuildArrayFromPermutation/"><![CDATA[<ul> <li>Given a <strong>zero-based permutation</strong> <code class="language-plaintext highlighter-rouge">nums</code> (<strong>0-indexed</strong>), build an array <code class="language-plaintext highlighter-rouge">ans</code> of the <strong>same length</strong> where <code class="language-plaintext highlighter-rouge">ans[i] = nums[nums[i]]</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; nums.length</code> and return it.</li> <li>A <strong>zero-based permutation</strong> <code class="language-plaintext highlighter-rouge">nums</code> is an array of <strong>distinct</strong> integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">nums.length - 1</code> (<strong>inclusive</strong>).</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]
Explanation: The array ans is built as follows: 
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]
Explanation: The array ans is built as follows:
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Array</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BuildArrayFromPermutation</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">buildArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// Create result array with same length as input array</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// Iterate through array and build result</span>
        <span class="c1">// For each position i, ans[i] = nums[nums[i]]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output [0,1,2,4,5,3]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">buildArray</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">result1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Expected output [4,5,0,1,2,3]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">buildArray</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">result2</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Array"/><category term="Easy"/><summary type="html"><![CDATA[Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 &lt;= i &lt; nums.length and return it. A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).]]></summary></entry><entry><title type="html">2576. Find the Maximum Number of Marked Indices</title><link href="https://zhengstar94.github.io//blog/2025/FindTheMaximumNumberOfMarkedIndices/" rel="alternate" type="text/html" title="2576. Find the Maximum Number of Marked Indices"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/FindTheMaximumNumberOfMarkedIndices</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/FindTheMaximumNumberOfMarkedIndices/"><![CDATA[<ul> <li>You are given a <strong>0-indexed</strong> integer array <code class="language-plaintext highlighter-rouge">nums</code>.</li> <li>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times: <ul> <li>Pick two <strong>different unmarked</strong> indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> such that <code class="language-plaintext highlighter-rouge">2 * nums[i] &lt;= nums[j]</code>, then mark <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>.</li> </ul> </li> <li>Return <em>the maximum possible number of marked indices in <code class="language-plaintext highlighter-rouge">nums</code> using the above operation any number of times</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,5,2,4]
Output: 2
Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] &lt;= nums[1]. Then mark index 2 and 1.
It can be shown that there's no other valid operation so the answer is 2.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [9,2,5,4]
Output: 4
Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] &lt;= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] &lt;= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [7,6,8]
Output: 0
Explanation: There is no valid operation to do, so the answer is 0.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.BinarySearch.FindMaximum</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2025/05/06
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindTheMaximumNumberOfMarkedIndices</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxNumOfMarkedIndices</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the array to enable our optimal pairing strategy</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// Initialize binary search boundaries</span>
        <span class="c1">// left: current best answer (starts at 0)</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// right: theoretical upper bound (n/2 + 1) - we use an open interval approach</span>
        <span class="c1">// The maximum possible number of pairs is n/2 (where n is the array length)</span>
        <span class="c1">// We add 1 to make it an exclusive upper bound for the binary search</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Binary search for the maximum valid k value</span>
        <span class="c1">// We use (left + 1 &lt; right) as our loop condition to avoid infinite loops</span>
        <span class="c1">// This approach will terminate when left and right are adjacent</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the middle point safely to avoid integer overflow</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Check if we can form 'mid' pairs that satisfy our condition</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// If yes, update our current best answer and try for more pairs</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If no, reduce the upper bound of our search space</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the total number of marked indices</span>
        <span class="c1">// Each valid pair allows us to mark 2 indices, so we multiply by 2</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check all k potential pairs</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// For each pair, check if the condition 2*nums[i] &lt;= nums[j] is satisfied</span>
            <span class="c1">// nums[i]: the i-th smallest element</span>
            <span class="c1">// nums[nums.length - k + i]: the i-th element from the k largest elements</span>
            <span class="c1">//</span>
            <span class="c1">// Why nums.length - k + i?</span>
            <span class="c1">// - nums.length - k: This points to the starting position of the k largest elements</span>
            <span class="c1">// - Adding i: As i increases from 0 to k-1, we move through these k largest elements</span>
            <span class="c1">//</span>
            <span class="c1">// For example, with array [2,3,5,7,10,12] and k=3:</span>
            <span class="c1">// i=0: compare nums[0]=2 with nums[6-3+0]=nums[3]=7</span>
            <span class="c1">// i=1: compare nums[1]=3 with nums[6-3+1]=nums[4]=10</span>
            <span class="c1">// i=2: compare nums[2]=5 with nums[6-3+2]=nums[5]=12</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// If any pair doesn't satisfy the condition, we can't form k valid pairs</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// All k pairs satisfy the condition</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">FindTheMaximumNumberOfMarkedIndices</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FindTheMaximumNumberOfMarkedIndices</span><span class="o">();</span>

        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result1</span> <span class="o">==</span> <span class="n">expected1</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected1</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result1</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// After sorting: [2, 3, 4, 5]</span>
        <span class="c1">// We can form 1 pair: (2,5) where 2*2 &lt;= 5, marking 2 indices</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result2</span> <span class="o">==</span> <span class="n">expected2</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected2</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result2</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// After sorting: [2, 4, 5, 9]</span>
        <span class="c1">// We can form 2 pairs: (2,5) and (4,9), marking 4 indices</span>

        <span class="c1">// Test Case 3</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result3</span> <span class="o">==</span> <span class="n">expected3</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected3</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result3</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// After sorting: [6, 7, 8]</span>
        <span class="c1">// We can't form any valid pairs because 2*6 &gt; 8, so 0 indices are marked</span>

        <span class="c1">// Test Case 4: Longer array example to illustrate the pairing strategy</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">expected4</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result4</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="na">maxNumOfMarkedIndices</span><span class="o">(</span><span class="n">nums4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">result4</span> <span class="o">==</span> <span class="n">expected4</span> <span class="o">?</span> <span class="s">"PASSED"</span> <span class="o">:</span> <span class="s">"FAILED"</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">" (Expected: "</span> <span class="o">+</span> <span class="n">expected4</span> <span class="o">+</span> <span class="s">", Got: "</span> <span class="o">+</span> <span class="n">result4</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
        <span class="c1">// In this case (already sorted): [2, 3, 5, 7, 10, 12]</span>
        <span class="c1">// We can form 3 pairs: (2,7), (3,10), and (5,12), marking 6 indices</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode BinarySearch.FindMaximum"/><category term="Medium"/><category term="BinarySearch"/><summary type="html"><![CDATA[You are given a 0-indexed integer array nums. Initially, all of the indices are unmarked. You are allowed to make this operation any number of times: Pick two different unmarked indices i and j such that 2 * nums[i] &lt;= nums[j], then mark i and j. Return the maximum possible number of marked indices in nums using the above operation any number of times.]]></summary></entry><entry><title type="html">Best Practices for Incident Response</title><link href="https://zhengstar94.github.io//blog/2025/BestPracticesForIncidentResponse/" rel="alternate" type="text/html" title="Best Practices for Incident Response"/><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2025/BestPracticesForIncidentResponse</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2025/BestPracticesForIncidentResponse/"><![CDATA[<p>In complex products and systems, failures are inevitable. When incidents occur, we must not only act swiftly to restore business continuity but also continually improve and extract lessons to prevent recurrence. This article summarizes a practical “best response strategy” aimed at providing actionable emergency handling and post-mortem frameworks for development teams.</p> <h2 id="1-golden-rules-of-incident-handling">1. Golden Rules of Incident Handling</h2> <h3 id="11-stopping-the-bleeding-takes-top-priority">1.1 Stopping the Bleeding Takes Top Priority</h3> <p>In emergency response, the primary goal is to restore product functionality as quickly as possible—similar to the “stop the bleeding” principle in first aid. Root cause analysis can wait; the priority is immediate recovery.</p> <h3 id="12-identify-the-triggering-variables">1.2 Identify the Triggering Variables</h3> <p>Response measures must <strong>support phased rollouts</strong> to avoid expanding the scope of the problem. The execution of the plan should be <strong>efficient yet cautious</strong>, ensuring no additional risks are introduced.</p> <ul> <li><strong>Variables are often the trigger point of failures</strong>: These are typically the first suspects and relatively easy to spot.</li> <li><strong>Analyze variables for quick containment</strong>: Focus your investigation on the variables to locate the issue and take immediate action.</li> </ul> <h3 id="13-careful-and-efficient-execution-of-containment-plans">1.3 Careful and Efficient Execution of Containment Plans</h3> <p>While executing containment measures, avoid making the situation worse. Balance speed with thoroughness.</p> <h2 id="2-strengthening-incident-response-capabilities">2. Strengthening Incident Response Capabilities</h2> <h3 id="21-effective-communication">2.1 Effective Communication</h3> <p>During emergency handling, the <strong>product owner should oversee the entire situation</strong>, while team members must quickly synchronize their findings and <strong>divide responsibilities to narrow down the problem scope</strong>.</p> <h3 id="22-sharpen-the-basics">2.2 Sharpen the Basics</h3> <ul> <li>Improve familiarity with business logic</li> <li>Build a toolkit of handy scripts and utilities</li> <li>Establish streamlined troubleshooting processes</li> </ul> <h3 id="23-proactive-measures-in-feature-development">2.3 Proactive Measures in Feature Development</h3> <p>It’s essential to enforce the following during development:</p> <ul> <li><strong>Gray release support</strong></li> <li><strong>Monitoring capability</strong></li> <li><strong>Rollback readiness</strong></li> </ul> <p>Avoid “wishful thinking” and “low-value tasks”; even if it requires extra effort, product quality and safety must not be compromised.</p> <h3 id="24-learn-from-excellent-postmortems">2.4 Learn from Excellent Postmortems</h3> <p>Study <strong>postmortems from leading companies like Cloudflare</strong>, to inspire fresh thinking and continuous improvement.</p> <h3 id="25-mindset-adjustment">2.5 Mindset Adjustment</h3> <p>Incident response <strong>is not an exam</strong>. Teams should maintain a constructive mindset, focusing on problem-solving and learning valuable lessons from each event.</p> <h2 id="3-postmortem-analysis">3. Postmortem Analysis</h2> <h3 id="31-core-objectives">3.1 Core Objectives</h3> <ul> <li>Prevent recurrence of the incident</li> </ul> <h3 id="32-key-considerations">3.2 Key Considerations</h3> <ul> <li>Ensure thorough resolution of the issue</li> <li>Document the incident timeline and root causes</li> <li>Implement targeted improvement actions</li> <li>Establish guidelines and systems to guard against similar problems</li> <li>Maintain a holistic view</li> <li>Ensure high-quality execution of action items</li> <li>Integrate temporary fixes into long-term improvements</li> </ul> <h2 id="4-accountability">4. Accountability</h2> <h3 id="41-attending-the-incident-review-meeting">4.1 Attending the Incident Review Meeting</h3> <p>The purpose of the review is to acknowledge issues and extract lessons—not simply to assign blame. <strong>Taking responsibility is both a duty and a growth opportunity</strong>.</p> <h3 id="42-mindset-adjustment">4.2 Mindset Adjustment</h3> <p>The team should maintain a proactive attitude, learn from mistakes, and avoid repeating them. And if worst comes to worst and the issue proves unsolvable—well, sometimes you have to “grab your bucket and leave” (just kidding!).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025/05/FaultResponse-480.webp 480w,/assets/img/2025/05/FaultResponse-800.webp 800w,/assets/img/2025/05/FaultResponse-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025/05/FaultResponse.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="Work"/><summary type="html"><![CDATA[In complex products and systems, failures are inevitable. When incidents occur, we must not only act swiftly to restore business continuity but also continually improve and extract lessons to prevent recurrence. This article summarizes a practical “best response strategy” aimed at providing actionable emergency handling and post-mortem frameworks for development teams.]]></summary></entry></feed>