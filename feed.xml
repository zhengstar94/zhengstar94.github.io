<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-01T03:27:17+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">zhengxingxing</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">51. N-Queens</title><link href="https://zhengstar94.github.io//blog/2024/NQueens/" rel="alternate" type="text/html" title="51. N-Queens"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NQueens</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NQueens/"><![CDATA[<ul> <li>The <strong>n-queens</strong> puzzle is the problem of placing <code class="language-plaintext highlighter-rouge">n</code> queens on an <code class="language-plaintext highlighter-rouge">n x n</code> chessboard such that no two queens attack each other.</li> <li>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</li> <li>Each solution contains a distinct board configuration of the n-queens’ placement, where <code class="language-plaintext highlighter-rouge">'Q'</code> and <code class="language-plaintext highlighter-rouge">'.'</code> both indicate a queen and an empty space, respectively.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 4
Output: [ [ ".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.." ] ]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: n = 1
Output: [ [ "Q" ] ]
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n!) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/12/01
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NQueens</span> <span class="o">{</span>
    <span class="cm">/**
     * Main method to solve the N-Queens problem for a given board size.
     *
     * This method initializes the solving process and returns all valid queen arrangements.
     *
     * @param n The size of the chessboard (number of queens to place)
     * @return A list of all possible queen arrangements, where each arrangement
     *         is represented as a list of string representations of board rows
     *
     * Key Steps:
     * 1. Create an empty result list to store solutions
     * 2. Initialize a queens array to track queen positions
     * 3. Start the backtracking process from the first row
     * 4. Return all found solutions
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// List to store all valid solutions</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Array to track queen positions (index = row, value = column)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// Initialize all positions as unoccupied</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Start backtracking from the first row</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Recursive backtracking method to explore all possible queen placements.
     *
     * This is the core algorithm that systematically tries to place queens
     * on the board while maintaining the N-Queens constraints.
     *
     * @param queens Array representing current queen positions
     * @param row Current row being processed
     * @param n Total board size
     * @param result List to store all valid solutions
     *
     * Detailed Algorithm:
     * 1. Base Case: If all rows are processed, add current solution to results
     * 2. For each column in the current row:
     *    - Check if placing a queen is valid
     *    - If valid, place the queen
     *    - Recursively process the next row
     *    - Implicitly backtrack by trying next column positions
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If we've successfully placed queens in all rows, we've found a solution</span>
        <span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">constructSolution</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">n</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Try placing a queen in each column of the current row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check if placing a queen at this position is valid</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">)){</span>
                <span class="c1">// Place the queen</span>
                <span class="n">queens</span><span class="o">[</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>

                <span class="c1">// Recursively process the next row</span>
                <span class="n">backtrack</span><span class="o">(</span><span class="n">queens</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="cm">/**
     * Validates whether a queen can be placed at the given position.
     *
     * Checks two key constraints:
     * 1. No queen in the same column
     * 2. No queen on the same diagonal
     *
     * @param queens Current queen positions
     * @param row Row of the new queen
     * @param col Column of the new queen
     * @return true if queen placement is valid, false otherwise
     *
     * Validation Logic:
     * - Column Check: Ensure no queen in the same column
     * - Diagonal Check: Use absolute value difference to detect diagonal conflicts
     *   - Diagonal conflict occurs when |row1 - row2| == |col1 - col2|
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check all previous rows</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Check column conflict</span>
            <span class="k">if</span><span class="o">(</span><span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">col</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Check diagonal conflicts using absolute value difference</span>
            <span class="c1">// If |row distance| == |column distance|, queens are on the same diagonal</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Converts the internal queens array representation to a visual board layout.
     *
     * Transforms the queens array into a list of strings where:
     * - 'Q' represents a queen
     * - '.' represents an empty square
     *
     * @param queens Array representing queen positions
     * @param n Board size
     * @return A list of strings representing the board configuration
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">constructSolution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Create a row filled with '.' initially</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="sc">'.'</span><span class="o">);</span>

            <span class="c1">// Place queen at the correct column</span>
            <span class="n">row</span><span class="o">[</span><span class="n">queens</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="o">;</span>

            <span class="c1">// Convert row to string and add to solution</span>
            <span class="n">solution</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">row</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">solution</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test cases for different board sizes</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">testCases</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"N = "</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">" Queens Problem Solutions:"</span><span class="o">);</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">solutions</span> <span class="o">=</span> <span class="n">solveNQueens</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

            <span class="c1">// Print number of solutions</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of Solutions: "</span> <span class="o">+</span> <span class="n">solutions</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

            <span class="c1">// Print each solution's board layout</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">solutions</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Solution "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">":"</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">row</span> <span class="o">:</span> <span class="n">solutions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span> <span class="c1">// Separator between solutions</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-------------------"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><category term="Hard"/><summary type="html"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.]]></summary></entry><entry><title type="html">71. Simplify Path</title><link href="https://zhengstar94.github.io//blog/2024/SimplifyPath/" rel="alternate" type="text/html" title="71. Simplify Path"/><published>2024-11-29T00:00:00+00:00</published><updated>2024-11-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/SimplifyPath</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/SimplifyPath/"><![CDATA[<ul> <li>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code class="language-plaintext highlighter-rouge">'/'</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</li> <li>The <em>rules</em> of a Unix-style file system are as follows: <ul> <li>A single period <code class="language-plaintext highlighter-rouge">'.'</code> represents the current directory.</li> <li>A double period <code class="language-plaintext highlighter-rouge">'..'</code> represents the previous/parent directory.</li> <li>Multiple consecutive slashes such as <code class="language-plaintext highlighter-rouge">'//'</code> and <code class="language-plaintext highlighter-rouge">'///'</code> are treated as a single slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file</strong> <strong>name</strong>. For example, <code class="language-plaintext highlighter-rouge">'...' </code>and <code class="language-plaintext highlighter-rouge">'....'</code> are valid directory or file names.</li> </ul> </li> <li>The simplified canonical path should follow these <em>rules</em>: <ul> <li>The path must start with a single slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>Directories within the path must be separated by exactly one slash <code class="language-plaintext highlighter-rouge">'/'</code>.</li> <li>The path must not end with a slash <code class="language-plaintext highlighter-rouge">'/'</code>, unless it is the root directory.</li> <li>The path must not have any single or double periods (<code class="language-plaintext highlighter-rouge">'.'</code> and <code class="language-plaintext highlighter-rouge">'..'</code>) used to denote current or parent directories.</li> </ul> </li> <li>Return the <strong>simplified canonical path</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home/"
Output: "/home"
Explanation:
The trailing slash should be removed.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home//foo/"
Output: "/home/foo"
Explanation:
Multiple consecutive slashes are replaced by a single one.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/home/user/Documents/../Pictures"
Output: "/home/user/Pictures"
Explanation:
A double period ".." refers to the directory up a level (the parent directory).
</code></pre></div></div> <p><strong>Example 4</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/../"
Output: "/"
Explanation:
Going one level up from the root directory is not possible.
</code></pre></div></div> <p><strong>Example 5</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: path = "/.../a/../b/c/../d/./"
Output: "/.../b/d"
Explanation:
"..." is a valid name for a directory in this problem.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimplifyPath</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">simplifyPath</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a double-ended queue (stack) to store valid directory components</span>
        <span class="c1">// Using ArrayDeque provides more efficient stack operations compared to traditional Stack</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Split the path into components using "/" as the delimiter</span>
        <span class="c1">// This handles multiple scenarios like consecutive slashes, leading/trailing slashes</span>
        <span class="c1">// Example: "/a//b" → ["", "a", "", "b"]</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">components</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>

        <span class="c1">// Iterate through each path component to process and simplify</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">component</span> <span class="o">:</span> <span class="n">components</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Skip empty strings and current directory markers (".")</span>
            <span class="c1">// This handles cases like "//" or "./"</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">component</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">component</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"."</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Handle parent directory navigation ("..")</span>
            <span class="c1">// If the stack is not empty, remove the last directory (go up one level)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">component</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">".."</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Prevents going above root directory</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Add valid directory names to the stack</span>
            <span class="c1">// This includes special directory names like "..."</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Reconstruct the simplified canonical path</span>
        <span class="c1">// Start with a root slash "/"</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>

        <span class="c1">// Append each directory from the stack</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">dir</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Remove the trailing slash for non-root paths</span>
        <span class="c1">// Ensures the path follows canonical format</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic path with trailing slash</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"/home/"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 1: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Multiple consecutive slashes</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"/home//foo/"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 2: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Path with parent directory navigation</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"/home/user/Documents/../Pictures"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 3: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Trying to navigate above root directory</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"/../"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 4: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Complex path with multiple scenarios</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"/.../a/../b/c/../d/./"</span><span class="o">;;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 5: "</span> <span class="o">+</span> <span class="n">simplifyPath</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path. The rules of a Unix-style file system are as follows: A single period '.' represents the current directory. A double period '..' represents the previous/parent directory. Multiple consecutive slashes such as '//' and '///' are treated as a single slash '/'. Any sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, '...' and '....' are valid directory or file names. The simplified canonical path should follow these rules: The path must start with a single slash '/'. Directories within the path must be separated by exactly one slash '/'. The path must not end with a slash '/', unless it is the root directory. The path must not have any single or double periods ('.' and '..') used to denote current or parent directories. Return the simplified canonical path.]]></summary></entry><entry><title type="html">1209. Remove All Adjacent Duplicates in String II</title><link href="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesinStringII/" rel="alternate" type="text/html" title="1209. Remove All Adjacent Duplicates in String II"/><published>2024-11-29T00:00:00+00:00</published><updated>2024-11-29T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesinStringII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesinStringII/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, a <code class="language-plaintext highlighter-rouge">k</code> <strong>duplicate removal</strong> consists of choosing <code class="language-plaintext highlighter-rouge">k</code> adjacent and equal letters from <code class="language-plaintext highlighter-rouge">s</code> and removing them, causing the left and the right side of the deleted substring to concatenate together.</li> <li>We repeatedly make <code class="language-plaintext highlighter-rouge">k</code> <strong>duplicate removals</strong> on <code class="language-plaintext highlighter-rouge">s</code> until we no longer can.</li> <li>Return <em>the final string after all such duplicate removals have been made</em>. It is guaranteed that the answer is <strong>unique</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: 
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/30
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveAllAdjacentDuplicatesinStringII</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="no">K</span> <span class="n">key</span><span class="o">;</span>
        <span class="kd">private</span> <span class="no">V</span> <span class="n">value</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">key</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="no">V</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize a stack to store characters and their frequencies</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each character in the input string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Check if the stack is not empty and the current character matches the top of the stack</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">getKey</span><span class="o">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Get the current frequency of the character</span>
                <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">getValue</span><span class="o">();</span>

                <span class="c1">// If the frequency is k-1, remove the entire block of k characters</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">// Otherwise, increment the frequency</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">c</span><span class="o">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// If it's a new character or different from the top of the stack</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Push the character with initial frequency of 1</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">c</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Rebuild the final string from the remaining characters in the stack</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Use Collections.nCopies to repeat the character based on its frequency</span>
            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">nCopies</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">getValue</span><span class="o">(),</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Original example with multiple removals</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"deeedbbcccbdaa"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: No characters to remove</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: Multiple removal scenarios</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"pbbcggttciiippooaais"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">s3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.]]></summary></entry><entry><title type="html">1047. Remove All Adjacent Duplicates In String</title><link href="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesInString/" rel="alternate" type="text/html" title="1047. Remove All Adjacent Duplicates In String"/><published>2024-11-28T00:00:00+00:00</published><updated>2024-11-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesInString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/RemoveAllAdjacentDuplicatesInString/"><![CDATA[<ul> <li>You are given a string <code class="language-plaintext highlighter-rouge">s</code> consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>adjacent</strong> and <strong>equal</strong> letters and removing them.</li> <li>We repeatedly make <strong>duplicate removals</strong> on <code class="language-plaintext highlighter-rouge">s</code> until we no longer can.</li> <li>Return <em>the final string after all such duplicate removals have been made</em>. It can be proven that the answer is <strong>unique</strong>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "azxxzy"
Output: "ay"
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Stack</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoveAllAdjacentDuplicatesInString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Use StringBuilder as a stack to track characters</span>
        <span class="nc">StringBuilder</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()){</span>
            <span class="c1">// If stack is not empty and current char matches the top of the stack</span>
            <span class="k">if</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">c</span><span class="o">){</span>
                <span class="c1">// Remove the top character (eliminate adjacent duplicates)</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Otherwise, add the current character to the stack</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Return the final processed string</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Original example</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"abbaca"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 1: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test case 2: Another original example</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"azxxzy"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 2: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test case 3: All same characters</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"aaaaaa"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 3: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test case 4: No duplicate characters</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 4: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test case 5: Complex repeated pattern</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"aaabbccddee"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result 5: "</span> <span class="o">+</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Stack"/><summary type="html"><![CDATA[You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.]]></summary></entry><entry><title type="html">266. Palindrome Permutation</title><link href="https://zhengstar94.github.io//blog/2024/PalindromePermutation/" rel="alternate" type="text/html" title="266. Palindrome Permutation"/><published>2024-11-27T00:00:00+00:00</published><updated>2024-11-27T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/PalindromePermutation</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/PalindromePermutation/"><![CDATA[<ul> <li>Given a string, determine if a permutation of the string could form a palindrome.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: "code"
Output: false
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: "aab"
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: "carerac"
Output: true
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/27
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PalindromePermutation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canPermutePalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a HashSet to track character occurrences</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Iterate through each character in the string</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// If the character is already in the set, remove it</span>
            <span class="c1">// If not, add it to the set</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// A palindrome can have at most one character with odd occurrence</span>
        <span class="c1">// So the set size should be 0 or 1</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: String that cannot form a palindrome</span>
        <span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="s">"code"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>

        <span class="c1">// Test case 2: String that can form a palindrome (odd length)</span>
        <span class="nc">String</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">"aab"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>

        <span class="c1">// Test case 3: String that can form a palindrome (even length)</span>
        <span class="nc">String</span> <span class="n">test3</span> <span class="o">=</span> <span class="s">"carerac"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>

        <span class="c1">// Test case 4: Empty string</span>
        <span class="nc">String</span> <span class="n">test4</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>

        <span class="c1">// Test case 5: Single character</span>
        <span class="nc">String</span> <span class="n">test5</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can form palindrome permutation: "</span> <span class="o">+</span> <span class="n">canPermutePalindrome</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given a string, determine if a permutation of the string could form a palindrome.]]></summary></entry><entry><title type="html">447. Number of Boomerangs</title><link href="https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs/" rel="alternate" type="text/html" title="447. Number of Boomerangs"/><published>2024-11-26T00:00:00+00:00</published><updated>2024-11-26T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NumberOfBoomerangs/"><![CDATA[<ul> <li>You are given <code class="language-plaintext highlighter-rouge">n</code> <code class="language-plaintext highlighter-rouge">points</code> in the plane that are all <strong>distinct</strong>, where <code class="language-plaintext highlighter-rouge">points[i] = [xi, yi]</code>. A <strong>boomerang</strong> is a tuple of points <code class="language-plaintext highlighter-rouge">(i, j, k)</code> such that the distance between <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> equals the distance between <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">k</code> <strong>(the order of the tuple matters)</strong>.</li> <li>Return <em>the number of boomerangs</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [0,0],[1,0],[2,0] ]
Output: 2
Explanation: The two boomerangs are [ [1,0],[0,0],[2,0] ] and [ [1,0],[2,0],[0,0] ].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [1,1],[2,2],[3,3] ]
Output: 2
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: points = [ [ 1,1 ] ]
Output: 0
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>2) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfBoomerangs</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfBoomerangs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Variable to store the total boomerang count</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through each point as the potential central point</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// HashMap to store distances and their point frequencies</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">distanceMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// Calculate distances from current point to all other points</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// Skip calculating distance to the same point</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Calculate squared distance between points</span>
                    <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">calculateDistance</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>

                    <span class="c1">// Update frequency of this distance in the map</span>
                    <span class="c1">// If distance not exists, set count to 1; otherwise, increment</span>
                    <span class="n">distanceMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">distanceMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Calculate boomerang combinations for each distance group</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="n">distanceMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                <span class="cm">/*
                 * Boomerang Calculation Logic:
                 * - 'count' represents points at the same distance from central point
                 * - For each distance group, calculate possible boomerang arrangements
                 *
                 * Mathematical Combination Explanation:
                 * 1. Total points at same distance: count
                 * 2. Choose first point: count options
                 * 3. Choose second point: (count - 1) options
                 * 4. Calculation: count * (count - 1)
                 *
                 * Example:
                 * If 4 points are at same distance:
                 * - First point selection: 4 ways
                 * - Second point selection: 3 ways
                 * - Total boomerang arrangements: 4 * 3 = 12
                 */</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculateDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">point1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">point2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Calculate x and y coordinate differences</span>
        <span class="kt">int</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">point1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">point2</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">point1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">point2</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// Return squared distance (Pythagorean theorem without square root)</span>
        <span class="k">return</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Points in a diagonal line</span>
        <span class="c1">// Expected to have some boomerang arrangements</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Points in a horizontal line</span>
        <span class="c1">// High likelihood of boomerang formations</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Single point</span>
        <span class="c1">// No boomerangs possible</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">points3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span> <span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 Result: "</span> <span class="o">+</span> <span class="n">numberOfBoomerangs</span><span class="o">(</span><span class="n">points3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Return the number of boomerangs.]]></summary></entry><entry><title type="html">1010. Pairs of Songs With Total Durations Divisible by 60</title><link href="https://zhengstar94.github.io//blog/2024/NumPairsDivisibleBy60/" rel="alternate" type="text/html" title="1010. Pairs of Songs With Total Durations Divisible by 60"/><published>2024-11-25T00:00:00+00:00</published><updated>2024-11-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NumPairsDivisibleBy60</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NumPairsDivisibleBy60/"><![CDATA[<ul> <li>You are given a list of songs where the <code class="language-plaintext highlighter-rouge">ith</code> song has a duration of <code class="language-plaintext highlighter-rouge">time[i]</code> seconds.</li> <li>Return <em>the number of pairs of songs for which their total duration in seconds is divisible by</em> <code class="language-plaintext highlighter-rouge">60</code>. Formally, we want the number of indices <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">j</code> such that <code class="language-plaintext highlighter-rouge">i &lt; j</code> with <code class="language-plaintext highlighter-rouge">(time[i] + time[j]) % 60 == 0</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumPairsDivisibleBy60</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numPairsDivisibleBy60</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Array to store the count of remainders when divided by 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">remainders</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">60</span><span class="o">];</span>
        <span class="c1">// Counter for valid pairs</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">t:</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Calculate the remainder of current number when divided by 60</span>
            <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">60</span><span class="o">;</span>

            <span class="c1">// Calculate the complementary remainder</span>
            <span class="c1">// If remainder is 0, complement should be 0</span>
            <span class="c1">// If remainder is 30, complement should be 30</span>
            <span class="c1">// For all other cases, complement is (60 - remainder)</span>
            <span class="c1">// Using % 60 to handle the case when remainder is 0</span>
            <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="o">(</span><span class="mi">60</span> <span class="o">-</span> <span class="n">remainder</span><span class="o">)</span> <span class="o">%</span> <span class="mi">60</span><span class="o">;</span>

            <span class="c1">// Key logic explanation:</span>
            <span class="c1">// 1. remainders[complement] stores the count of numbers previously seen</span>
            <span class="c1">//    that have a remainder equal to complement when divided by 60</span>
            <span class="c1">// 2. Current number t can form a valid pair with any number that has</span>
            <span class="c1">//    a remainder of complement, as their sum will be divisible by 60</span>
            <span class="c1">// 3. Therefore, add remainders[complement] to count, representing</span>
            <span class="c1">//    the number of valid pairs that can be formed with current number</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">remainders</span><span class="o">[</span><span class="n">complement</span><span class="o">];</span>

            <span class="c1">// Update the count of current remainder</span>
            <span class="c1">// This prepares for future numbers that might pair with this one</span>
            <span class="n">remainders</span><span class="o">[</span><span class="n">remainder</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Regular case with multiple possible pairs</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">30</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">150</span><span class="o">,</span><span class="mi">100</span><span class="o">,</span><span class="mi">40</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: [ 30,20,150,100,40 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: All numbers are multiples of 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">60</span><span class="o">,</span><span class="mi">60</span><span class="o">,</span><span class="mi">60</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: [ 60,60,60 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: No pairs sum up to multiple of 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3: [ 1,2,3,4 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 0"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Contains 0 and multiples of 60</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">60</span><span class="o">,</span><span class="mi">120</span><span class="o">,</span><span class="mi">180</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4: [ 0,60,120,180 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 6"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: Testing complementary remainders</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">50</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">40</span><span class="o">};</span>  <span class="c1">// 10+50=60, 20+40=60</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5: [ 10,50,20,40 ] "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected Result: 2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Actual Result: "</span> <span class="o">+</span> <span class="n">numPairsDivisibleBy60</span><span class="o">(</span><span class="n">test5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60== 0.]]></summary></entry><entry><title type="html">523. Continuous Subarray Sum</title><link href="https://zhengstar94.github.io//blog/2024/ContinuousSubarraySum/" rel="alternate" type="text/html" title="523. Continuous Subarray Sum"/><published>2024-11-24T00:00:00+00:00</published><updated>2024-11-24T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ContinuousSubarraySum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ContinuousSubarraySum/"><![CDATA[<ul> <li>Given an integer array nums and an integer k, return <code class="language-plaintext highlighter-rouge">true</code> <em>if</em> <code class="language-plaintext highlighter-rouge">nums</code> <em>has a <strong>good subarray</strong> or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> <li>A <strong>good subarray</strong> is a subarray where: <ul> <li>its length is <strong>at least two</strong>, and</li> <li>the sum of the elements of the subarray is a multiple of <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> </li> <li><strong>Note</strong> that: <ul> <li>A <strong>subarray</strong> is a contiguous part of the array.</li> <li>An integer <code class="language-plaintext highlighter-rouge">x</code> is a multiple of <code class="language-plaintext highlighter-rouge">k</code> if there exists an integer <code class="language-plaintext highlighter-rouge">n</code> such that <code class="language-plaintext highlighter-rouge">x = n * k</code>. <code class="language-plaintext highlighter-rouge">0</code> is <strong>always</strong> a multiple of <code class="language-plaintext highlighter-rouge">k</code>.</li> </ul> </li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [23,2,6,4,7], k = 13
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(min(n, k)) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContinuousSubarraySum</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkSubarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// HashMap to store remainder as key and index as value</span>
        <span class="c1">// Key: running sum % k, Value: index where this remainder was first seen</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">preSumMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Initialize map with 0 remainder at index -1</span>
        <span class="c1">// This handles the case where the subarray starts from index 0</span>
        <span class="n">preSumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Running sum variable to keep track of cumulative sum % k</span>
        <span class="kt">int</span> <span class="n">curSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Iterate through the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update running sum and take modulo to keep remainder</span>
            <span class="c1">// Using property: (a + b) % k = ((a % k) + (b % k)) % k</span>
            <span class="n">curSum</span> <span class="o">=</span> <span class="o">(</span><span class="n">curSum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">%</span> <span class="n">k</span><span class="o">;</span>

            <span class="c1">// If we've seen this remainder before</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">preSumMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">curSum</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Check if the subarray length is at least 2</span>
                <span class="c1">// Current index - Previous index where we saw the same remainder</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">preSumMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curSum</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// Found a valid subarray whose sum is divisible by k</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// First time seeing this remainder, store it with current index</span>
                <span class="n">preSumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">curSum</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// No valid subarray found</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Expected output: true</span>
        <span class="c1">// Subarray [2,4] has sum 6, which is divisible by 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">k1</span><span class="o">));</span>

        <span class="c1">// Test Case 2: Expected output: true</span>
        <span class="c1">// The entire array sum is 42, which is divisible by 6</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k2</span><span class="o">));</span>

        <span class="c1">// Test Case 3: Expected output: false</span>
        <span class="c1">// No subarray with sum divisible by 13</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">13</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums3</span><span class="o">,</span> <span class="n">k3</span><span class="o">));</span>

        <span class="c1">// Test Case 4: Edge case - single element array</span>
        <span class="c1">// Expected output: false (subarray must have length &gt;= 2)</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums4</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k4</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 4: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums4</span><span class="o">,</span> <span class="n">k4</span><span class="o">));</span>

        <span class="c1">// Test Case 5: Expected output: true</span>
        <span class="c1">// Contains subarray with sum divisible by 7</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums5</span> <span class="o">=</span> <span class="o">{</span><span class="mi">23</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 5: "</span> <span class="o">+</span> <span class="n">checkSubarraySum</span><span class="o">(</span><span class="n">nums5</span><span class="o">,</span> <span class="n">k5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise. A good subarray is a subarray where: its length is at least two, and the sum of the elements of the subarray is a multiple of k. Note that: A subarray is a contiguous part of the array. An integer x is a multiple of k if there exists an integer n such that x=n * k. 0 is always a multiple of k.]]></summary></entry><entry><title type="html">791. Custom Sort String</title><link href="https://zhengstar94.github.io//blog/2024/CustomSortString/" rel="alternate" type="text/html" title="791. Custom Sort String"/><published>2024-11-23T00:00:00+00:00</published><updated>2024-11-23T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CustomSortString</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CustomSortString/"><![CDATA[<ul> <li>You are given two strings <code class="language-plaintext highlighter-rouge">order</code> and <code class="language-plaintext highlighter-rouge">s</code>. All the characters of <code class="language-plaintext highlighter-rouge">order</code> are <strong>unique</strong> and were sorted in some custom order previously.</li> <li>Permute the characters of <code class="language-plaintext highlighter-rouge">s</code> so that they match the order that <code class="language-plaintext highlighter-rouge">order</code> was sorted. More specifically, if a character <code class="language-plaintext highlighter-rouge">x</code> occurs before a character <code class="language-plaintext highlighter-rouge">y</code> in <code class="language-plaintext highlighter-rouge">order</code>, then <code class="language-plaintext highlighter-rouge">x</code> should occur before <code class="language-plaintext highlighter-rouge">y</code> in the permuted string.</li> <li>Return <em>any permutation of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>that satisfies this property</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: order = "cba", s = "abcd"

Output: "cbad"

Explanation: "a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a".

Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: order = "bcafg", s = "abcd"

Output: "bcad"

Explanation: The characters "b", "c", and "a" from order dictate  the order for the characters in s. The character "d" in s does not appear in order, so its position is flexible.

Following the order of appearance in order, "b", "c", and "a" from s should be arranged as "b", "c", "a". "d" can be placed at any position since it's not in order. The output "bcad" correctly follows this rule. Other arrangements like "dbca" or "bcda" would also be valid, as long as "b", "c", "a" maintain their order.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n + m) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/23
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomSortString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">customSortString</span><span class="o">(</span><span class="nc">String</span> <span class="n">order</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Create a frequency array to store count of each character in s</span>
        <span class="c1">// Index 0 represents 'a', 1 represents 'b', and so on</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="c1">// Count frequency of each character in string s</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">// StringBuilder to construct the result efficiently</span>
        <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="c1">// First, append characters according to the order string</span>
        <span class="c1">// For each character in order, append it to result as many times as it appears in s</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">order</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="c1">// Decrement count after appending each character</span>
                <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Finally, append any remaining characters that weren't in order</span>
        <span class="c1">// This ensures all characters from s are included in the result</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span> <span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert StringBuilder to String and return</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test Case 1: Basic test</span>
        <span class="nc">String</span> <span class="n">order1</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order1</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order1</span><span class="o">,</span> <span class="n">s1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 2: Order string longer than s</span>
        <span class="nc">String</span> <span class="n">order2</span> <span class="o">=</span> <span class="s">"bcafg"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order2</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order2</span><span class="o">,</span> <span class="n">s2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 3: String s contains duplicate characters</span>
        <span class="nc">String</span> <span class="n">order3</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"aabcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 3 (contains duplicate characters):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order3</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order3</span><span class="o">,</span> <span class="n">s3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 4: Order contains characters not in s</span>
        <span class="nc">String</span> <span class="n">order4</span> <span class="o">=</span> <span class="s">"cbafg"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 4 (order contains characters not in s):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order4</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order4</span><span class="o">,</span> <span class="n">s4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">// Test Case 5: String s contains characters not in order</span>
        <span class="nc">String</span> <span class="n">order5</span> <span class="o">=</span> <span class="s">"cb"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 5 (s contains characters not in order):"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input: order = "</span> <span class="o">+</span> <span class="n">order5</span> <span class="o">+</span> <span class="s">", s = "</span> <span class="o">+</span> <span class="n">s5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output: "</span> <span class="o">+</span> <span class="n">customSortString</span><span class="o">(</span><span class="n">order5</span><span class="o">,</span> <span class="n">s5</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously. Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string. Return any permutation of s that satisfies this property.]]></summary></entry><entry><title type="html">525. Contiguous Array</title><link href="https://zhengstar94.github.io//blog/2024/ContiguousArray/" rel="alternate" type="text/html" title="525. Contiguous Array"/><published>2024-11-22T00:00:00+00:00</published><updated>2024-11-22T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/ContiguousArray</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/ContiguousArray/"><![CDATA[<ul> <li>Given a binary array <code class="language-plaintext highlighter-rouge">nums</code>, return <em>the maximum length of a contiguous subarray with an equal number of</em> <code class="language-plaintext highlighter-rouge">0</code> <em>and</em> <code class="language-plaintext highlighter-rouge">1</code>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.HashTable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengxingxing
 * @date 2024/11/22
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContiguousArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMaxLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Map to store the first occurrence of each count</span>
        <span class="c1">// Key: running sum (count), Value: index where this count first appeared</span>
        <span class="c1">// Initialize with 0 at index -1 to handle cases where valid subarray starts from index 0</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// maxLen: tracks the length of the longest valid subarray found so far</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// count: running sum (treating 0 as -1 and 1 as 1)</span>
        <span class="c1">// When count remains unchanged between two positions, the subarray between them has equal 0s and 1s</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Update running sum: add 1 for 1s, subtract 1 for 0s</span>
            <span class="c1">// This helps track the balance between 0s and 1s</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

            <span class="c1">// If we've seen this count before, we've found a valid subarray</span>
            <span class="c1">// Example: if count becomes 0 again, it means we have equal 0s and 1s from the start</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">count</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Calculate length of current valid subarray (current position - previous position with same count)</span>
                <span class="c1">// Update maxLen if current valid subarray is longer</span>
                <span class="c1">// Example: if count = 1 appears at index 2 and 5, then indexes 3,4,5 form a valid subarray</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLen</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">count</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// If this is the first time we see this count, record its position</span>
                <span class="c1">// We only store the first occurrence to find the longest possible subarray</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Basic case with alternating values</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 1: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test1</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 2: Minimal case</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 2: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test2</span><span class="o">));</span> <span class="c1">// Expected output: 2</span>

        <span class="c1">// Test case 3: Grouped zeros and ones</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">test3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test case 3: "</span> <span class="o">+</span> <span class="n">findMaxLength</span><span class="o">(</span><span class="n">test3</span><span class="o">));</span> <span class="c1">// Expected output: 4</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode HashTable"/><summary type="html"><![CDATA[Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.]]></summary></entry></feed>