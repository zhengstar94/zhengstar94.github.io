<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://zhengstar94.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://zhengstar94.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-07-11T11:19:42+00:00</updated><id>https://zhengstar94.github.io//feed.xml</id><title type="html">blank</title><subtitle>Welcome to Xingxing&apos;s blog, where I share my thoughts and experiences on various topics. </subtitle><entry><title type="html">133.Clone Graph</title><link href="https://zhengstar94.github.io//blog/2024/CloneGraph/" rel="alternate" type="text/html" title="133.Clone Graph"/><published>2024-07-11T00:00:00+00:00</published><updated>2024-07-11T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CloneGraph</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CloneGraph/"><![CDATA[<h1 id="133-clone-graph">133. Clone Graph</h1> <ul> <li>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph">connected</a></strong> undirected graph.</li> <li>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> (clone) of the graph.</li> <li>Each node in the graph contains a value (<code class="language-plaintext highlighter-rouge">int</code>) and a list (<code class="language-plaintext highlighter-rouge">List[Node]</code>) of its neighbors.</li> </ul> <blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Node {
    public int val;
    public List&lt;Node&gt; neighbors;
}
</code></pre></div> </div> </blockquote> <p><strong>Test case format:</strong></p> <p>For simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with <code class="language-plaintext highlighter-rouge">val == 1</code>, the second node with <code class="language-plaintext highlighter-rouge">val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p> <p><strong>An adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p> <p>The given node will always be the first node with <code class="language-plaintext highlighter-rouge">val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: adjList = [ [2,4],[1,3],[2,4],[1,3]]
Output: [ [2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: adjList = [ []]
Output: [ []]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/07/11
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CloneGraph</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">cloneGraph</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">return</span> <span class="nf">cloneGraphDFS</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">cloneGraphDFS</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">neighbors</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">newNode</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cloneGraphDFS</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span> <span class="n">map</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">CloneGraph</span> <span class="n">cg</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CloneGraph</span><span class="o">();</span>

        <span class="c1">// 创建一个测试用例</span>
        <span class="nc">Node</span> <span class="n">node1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">node4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

        <span class="n">node1</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node2</span><span class="o">);</span>
        <span class="n">node1</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node4</span><span class="o">);</span>
        <span class="n">node2</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node1</span><span class="o">);</span>
        <span class="n">node2</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node3</span><span class="o">);</span>
        <span class="n">node3</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node2</span><span class="o">);</span>
        <span class="n">node3</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node4</span><span class="o">);</span>
        <span class="n">node4</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node1</span><span class="o">);</span>
        <span class="n">node4</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node3</span><span class="o">);</span>

        <span class="c1">// 克隆图</span>
        <span class="nc">Node</span> <span class="n">clone</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="na">cloneGraph</span><span class="o">(</span><span class="n">node1</span><span class="o">);</span>

        <span class="c1">// 简单打印克隆结果</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original and Clone are the same structure: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">clone</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">node1</span><span class="o">.</span><span class="na">val</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">neighbors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><summary type="html"><![CDATA[133. Clone Graph]]></summary></entry><entry><title type="html">200.Number of Islands</title><link href="https://zhengstar94.github.io//blog/2024/NumberOfIslands/" rel="alternate" type="text/html" title="200.Number of Islands"/><published>2024-07-10T00:00:00+00:00</published><updated>2024-07-10T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/NumberOfIslands</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/NumberOfIslands/"><![CDATA[<h1 id="200-number-of-islands">200. Number of Islands</h1> <ul> <li>Given an <code class="language-plaintext highlighter-rouge">m x n</code> 2D binary grid <code class="language-plaintext highlighter-rouge">grid</code> which represents a map of <code class="language-plaintext highlighter-rouge">'1'</code>s (land) and <code class="language-plaintext highlighter-rouge">'0'</code>s (water), return <em>the number of islands</em>.</li> <li>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(m * n) time | O(m * n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Graphs</span><span class="o">;</span>

<span class="cm">/**
 * Calculates the number of islands in a 2D grid.
 *
 * @author zhengstars
 * @date 2024/07/10
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberOfIslands</span> <span class="o">{</span>
    <span class="cm">/**
     * Main function to calculate the number of islands.
     * @param grid the 2D grid representing land and water
     * @return the number of islands
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numIslands</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Exception handling</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">grid</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">numIslands</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Traverse the entire grid</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// If encounter '1', it means finding a new island</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">numIslands</span><span class="o">++;</span>
                    <span class="c1">// Use DFS to mark all land of the current island</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">numIslands</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Depth-first search to mark visited land as '0'.
     * @param grid the 2D grid representing land and water
     * @param i the row index
     * @param j the column index
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Exception handling: check boundary condition and whether the current grid is '1'</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">||</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Mark the current land as '0' to indicate visited</span>
        <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'0'</span><span class="o">;</span>

        <span class="c1">// Recursively process the adjacent positions of the current land</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span> <span class="c1">// Up</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span> <span class="c1">// Down</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// Left</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// Right</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">char</span><span class="o">[][]</span> <span class="n">grid1</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">},</span>
                <span class="o">{</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">},</span>
                <span class="o">{</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">},</span>
                <span class="o">{</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIslands</span><span class="o">(</span><span class="n">grid1</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="kt">char</span><span class="o">[][]</span> <span class="n">grid2</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">},</span>
                <span class="o">{</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">},</span>
                <span class="o">{</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">},</span>
                <span class="o">{</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numIslands</span><span class="o">(</span><span class="n">grid2</span><span class="o">));</span> <span class="c1">// Output: 3</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Graphs"/><summary type="html"><![CDATA[200. Number of Islands]]></summary></entry><entry><title type="html">79.Word Search</title><link href="https://zhengstar94.github.io//blog/2024/WordSearch/" rel="alternate" type="text/html" title="79.Word Search"/><published>2024-07-09T00:00:00+00:00</published><updated>2024-07-09T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/WordSearch</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/WordSearch/"><![CDATA[<h1 id="79-word-search">79. Word Search</h1> <ul> <li>Given an <code class="language-plaintext highlighter-rouge">m x n</code> grid of characters <code class="language-plaintext highlighter-rouge">board</code> and a string <code class="language-plaintext highlighter-rouge">word</code>, return <code class="language-plaintext highlighter-rouge">true</code> <em>if</em> <code class="language-plaintext highlighter-rouge">word</code> <em>exists in the grid</em>.</li> <li>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(4<span class="p">^</span>k * m * n) time | O(k) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="cm">/**
 * This class implements the Word Search problem using backtracking algorithm.
 *
 * Given an m x n grid of characters board and a string word, this algorithm returns true if word exists in the grid.
 * The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.
 * The same letter cell may not be used more than once.
 *
 * @author zhengstars
 * @date 2024/07/09
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordSearch</span> <span class="o">{</span>

    <span class="cm">/**
     * Check if the given word exists in the board.
     *
     * @param board the character grid
     * @param word the target word
     * @return true if the word exists in the grid, false otherwise
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">exist</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Iterate through each cell in the board</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Depth-first search to find the word in the board.
     *
     * @param board the character grid
     * @param word the target word
     * @param i the row index of the current cell
     * @param j the column index of the current cell
     * @param k the index of the current character in the word
     * @return true if the word is found, false otherwise
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">||</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Check if the end of the word is reached</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
        <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">' '</span><span class="o">;</span> <span class="c1">// Mark as visited</span>

        <span class="c1">// Explore adjacent cells recursively</span>
        <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> <span class="c1">// Restore original value</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the Word Search algorithm.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span> <span class="o">=</span> <span class="o">{</span>
                <span class="o">{</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'B'</span><span class="o">,</span><span class="sc">'C'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">},</span>
                <span class="o">{</span><span class="sc">'S'</span><span class="o">,</span><span class="sc">'F'</span><span class="o">,</span><span class="sc">'C'</span><span class="o">,</span><span class="sc">'S'</span><span class="o">},</span>
                <span class="o">{</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'D'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">String</span> <span class="n">word1</span> <span class="o">=</span> <span class="s">"ABCCED"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"SEE"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">word3</span> <span class="o">=</span> <span class="s">"ABCB"</span><span class="o">;</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">exist</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word1</span><span class="o">));</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">exist</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word2</span><span class="o">));</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">exist</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">word3</span><span class="o">));</span> <span class="c1">// false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><summary type="html"><![CDATA[79. Word Search]]></summary></entry><entry><title type="html">39.Combination Sum</title><link href="https://zhengstar94.github.io//blog/2024/CombinationSum/" rel="alternate" type="text/html" title="39.Combination Sum"/><published>2024-07-08T00:00:00+00:00</published><updated>2024-07-08T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/CombinationSum</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/CombinationSum/"><![CDATA[<h1 id="39-combination-sum">39. Combination Sum</h1> <ul> <li>Given an array of <strong>distinct</strong> integers <code class="language-plaintext highlighter-rouge">candidates</code> and a target integer <code class="language-plaintext highlighter-rouge">target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code class="language-plaintext highlighter-rouge">candidates</code> <em>where the chosen numbers sum to</em> <code class="language-plaintext highlighter-rouge">target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</li> <li>The <strong>same</strong> number may be chosen from <code class="language-plaintext highlighter-rouge">candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</li> <li>The test cases are generated such that the number of unique combinations that sum up to <code class="language-plaintext highlighter-rouge">target</code> is less than <code class="language-plaintext highlighter-rouge">150</code> combinations for the given input.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: candidates = [2], target = 1
Output: []
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n<span class="p">^</span>t) time | O(t) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Backtracking</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * This class implements the combination sum problem using backtracking algorithm.
 *
 * For given distinct integers and a target sum, it finds all unique combinations
 * where the chosen numbers sum to the target. The same number can be chosen
 * from candidates an unlimited number of times.
 *
 * @author zhengstars
 * @date 2024/07/08
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinationSum</span> <span class="o">{</span>

    <span class="cm">/**
     * Finds all unique combinations that sum up to the target.
     *
     * @param candidates an array of distinct integers
     * @param target the target sum
     * @return a list of all unique combinations that sum up to the target
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span> <span class="n">result</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * The backtracking function to search for combinations.
     *
     * @param candidates an array of distinct integers
     * @param target the remaining target sum
     * @param start the starting index of the search
     * @param current the current combination being constructed
     * @param result the list to store valid combinations
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">current</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">current</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">current</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// Recursive call to search for combinations</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">,</span> <span class="n">current</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>

            <span class="c1">// Backtrack by removing the last element</span>
            <span class="n">current</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Main method to test the combinationSum function.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">combinationSum</span><span class="o">(</span><span class="n">candidates1</span><span class="o">,</span> <span class="n">target1</span><span class="o">));</span> <span class="c1">// [ [2, 2, 3], [7]]</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">combinationSum</span><span class="o">(</span><span class="n">candidates2</span><span class="o">,</span> <span class="n">target2</span><span class="o">));</span> <span class="c1">// [ [2, 2, 2, 2], [2, 3, 3], [3, 5]]</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates3</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">target3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">combinationSum</span><span class="o">(</span><span class="n">candidates3</span><span class="o">,</span> <span class="n">target3</span><span class="o">));</span> <span class="c1">// []</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Backtracking"/><summary type="html"><![CDATA[39. Combination Sum]]></summary></entry><entry><title type="html">253.Meeting Rooms II</title><link href="https://zhengstar94.github.io//blog/2024/MeetingRoomsII/" rel="alternate" type="text/html" title="253.Meeting Rooms II"/><published>2024-07-07T00:00:00+00:00</published><updated>2024-07-07T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MeetingRoomsII</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MeetingRoomsII/"><![CDATA[<h1 id="253-meeting-rooms-ii">253. Meeting Rooms II</h1> <ul> <li>Given an array of meeting time intervals consisting of start and end times<code class="language-plaintext highlighter-rouge">[[s1,e1],[s2,e2],...]</code>(si&lt; ei), find the minimum number of conference rooms required.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
[[0, 30],[5, 10],[15, 20]]
Output:
 2
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
 [[7,10],[2,4]]

Output:
 1
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>

<span class="cm">/**
 * Given an array of meeting time intervals consisting of start and end times, find the minimum number of conference rooms required.
 *
 * @author zhengstars
 * @date 2024/07/07
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MeetingRoomsII</span> <span class="o">{</span>
    <span class="cm">/**
     * Calculate the minimum number of conference rooms required for the given meeting time intervals.
     *
     * @param intervals an array of meeting time intervals
     * @return the minimum number of conference rooms required
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minMeetingRooms</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort the intervals by start time</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">minHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
        <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">minHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MeetingRoomsII</span> <span class="n">meetingRoomsII</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MeetingRoomsII</span><span class="o">();</span>

        <span class="c1">// Test Case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">30</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span><span class="mi">20</span><span class="o">}};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 1: "</span> <span class="o">+</span> <span class="n">meetingRoomsII</span><span class="o">.</span><span class="na">minMeetingRooms</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="c1">// Test Case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">}};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Test Case 2: "</span> <span class="o">+</span> <span class="n">meetingRoomsII</span><span class="o">.</span><span class="na">minMeetingRooms</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Output: 1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[253. Meeting Rooms II]]></summary></entry><entry><title type="html">435.Non-overlapping Intervals</title><link href="https://zhengstar94.github.io//blog/2024/Non-OverlappingIntervals/" rel="alternate" type="text/html" title="435.Non-overlapping Intervals"/><published>2024-06-28T00:00:00+00:00</published><updated>2024-06-28T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/Non-OverlappingIntervals</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/Non-OverlappingIntervals/"><![CDATA[<h1 id="435-non-overlapping-intervals">435. Non-overlapping Intervals</h1> <ul> <li>Given an array of intervals <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
</code></pre></div></div> <p><strong>Example 3</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengstars
 * Date: 2024/06/28
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NonOverlappingIntervals</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Sort the intervals by their ending times</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>

        <span class="c1">// Initialize the count of non-overlapping intervals</span>
        <span class="kt">int</span> <span class="n">nonOverlapCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// Record the end time of the first interval</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the start time of the current interval is greater than or equal to</span>
            <span class="c1">// the end time of the last recorded non-overlapping interval</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nonOverlapCount</span><span class="o">++;</span>
                <span class="c1">// Update the end time to the end time of the current interval</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// The number of intervals to be removed is the total number of intervals</span>
        <span class="c1">// minus the count of non-overlapping intervals</span>
        <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">nonOverlapCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">eraseOverlapIntervals</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Output: 1</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">eraseOverlapIntervals</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Output: 2</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals3</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">eraseOverlapIntervals</span><span class="o">(</span><span class="n">intervals3</span><span class="o">));</span> <span class="c1">// Output: 0</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[435. Non-overlapping Intervals]]></summary></entry><entry><title type="html">56.Merge Intervals</title><link href="https://zhengstar94.github.io//blog/2024/MergeIntervals/" rel="alternate" type="text/html" title="56.Merge Intervals"/><published>2024-06-25T00:00:00+00:00</published><updated>2024-06-25T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MergeIntervals</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MergeIntervals/"><![CDATA[<h1 id="56-merge-intervals">56. Merge Intervals</h1> <ul> <li>Given an array of <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlogn) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * This class provides functionality to merge overlapping intervals.
 * Given a collection of intervals, it merges all overlapping intervals and
 * returns the result as a list of non-overlapping intervals.
 *
 * Author: zhengstars
 * Date: 2024/06/25
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeIntervals</span> <span class="o">{</span>
    <span class="cm">/**
     * Merges overlapping intervals in the given array.
     *
     * @param intervals The array of intervals to merge.
     * @return A 2D array of merged intervals.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Check for the special case where the intervals array is empty</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// Sort the intervals based on their start times</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

        <span class="c1">// List to store the merged intervals</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Initialize the current interval to be merged</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">currentInterval</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentInterval</span><span class="o">);</span>

        <span class="c1">// Iterate over the sorted intervals and merge where necessary</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">currentEnd</span> <span class="o">=</span> <span class="n">currentInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// If the current interval overlaps with the next interval</span>
            <span class="k">if</span><span class="o">(</span><span class="n">currentEnd</span> <span class="o">&gt;=</span> <span class="n">interval</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="c1">// Update the end of the current interval to the maximum end time</span>
                <span class="n">currentInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">currentEnd</span><span class="o">,</span> <span class="n">interval</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// There is no overlap, so add the next interval as a new entry</span>
                <span class="n">currentInterval</span> <span class="o">=</span> <span class="n">interval</span><span class="o">;</span>
                <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentInterval</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Convert the list of merged intervals to a 2D array and return</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">merged</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Example 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">18</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals1: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">merge</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 6], [8, 10], [15, 18]]</span>

        <span class="c1">// Example 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals2: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">merge</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 5]]</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to print a 2D array of intervals.
     *
     * @param intervals The array of intervals to print.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printResult</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"] "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[56. Merge Intervals]]></summary></entry><entry><title type="html">57.Insert Interval</title><link href="https://zhengstar94.github.io//blog/2024/InsertInterval/" rel="alternate" type="text/html" title="57.Insert Interval"/><published>2024-06-16T00:00:00+00:00</published><updated>2024-06-16T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/InsertInterval</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/InsertInterval/"><![CDATA[<h1 id="57-insert-interval">57. Insert Interval</h1> <ul> <li>You are given an array of non-overlapping intervals <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code> represent the start and the end of the <code class="language-plaintext highlighter-rouge">ith</code> interval and <code class="language-plaintext highlighter-rouge">intervals</code> is sorted in ascending order by <code class="language-plaintext highlighter-rouge">starti</code>. You are also given an interval <code class="language-plaintext highlighter-rouge">newInterval = [start, end]</code> that represents the start and end of another interval.</li> <li>Insert <code class="language-plaintext highlighter-rouge">newInterval</code> into <code class="language-plaintext highlighter-rouge">intervals</code> such that <code class="language-plaintext highlighter-rouge">intervals</code> is still sorted in ascending order by <code class="language-plaintext highlighter-rouge">starti</code> and <code class="language-plaintext highlighter-rouge">intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</li> <li>Return <code class="language-plaintext highlighter-rouge">intervals</code> <em>after the insertion</em>.</li> <li><strong>Note</strong> that you don’t need to modify <code class="language-plaintext highlighter-rouge">intervals</code> in-place. You can make a new array and return it.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(n) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * Author: zhengstars
 * Date: 2024/06/16
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InsertInterval</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// List to store the final result after merging intervals</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// Length of the input intervals array</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// Index for iterating through the intervals array</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Add all intervals that end before the new interval starts</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>  <span class="c1">// These intervals do not overlap with the new interval</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Merge all intervals that overlap with the new interval</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="c1">// Update the new interval to encompass the overlapping intervals</span>
            <span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
            <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Add the merged new interval to the result</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newInterval</span><span class="o">);</span>

        <span class="c1">// Add all remaining intervals that start after the new interval ends</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// Convert the result list to a two-dimensional array</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals1: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">insert</span><span class="o">(</span><span class="n">intervals1</span><span class="o">,</span> <span class="n">newInterval1</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 5], [6, 9]]</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">16</span><span class="o">}</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result for intervals2: "</span><span class="o">);</span>
        <span class="n">printResult</span><span class="o">(</span><span class="n">insert</span><span class="o">(</span><span class="n">intervals2</span><span class="o">,</span> <span class="n">newInterval2</span><span class="o">));</span> <span class="c1">// Expected output: [[1, 2], [3, 10], [12, 16]]</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Helper method to print a two-dimensional array of intervals.
     *
     * @param intervals The array of intervals to be printed.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printResult</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"] "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[57. Insert Interval]]></summary></entry><entry><title type="html">252.Meeting Rooms</title><link href="https://zhengstar94.github.io//blog/2024/MeetingRooms/" rel="alternate" type="text/html" title="252.Meeting Rooms"/><published>2024-06-15T00:00:00+00:00</published><updated>2024-06-15T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/MeetingRooms</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/MeetingRooms/"><![CDATA[<h1 id="252-meeting-rooms">252. Meeting Rooms</h1> <ul> <li>Given an array of meeting time intervals consisting of start and end times<code class="language-plaintext highlighter-rouge">[[s1,e1],[s2,e2],...]</code>(si&lt; ei), determine if a person could attend all meetings.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
[[0,30],[5,10],[15,20]]
Output:
 false
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
 [[7,10],[2,4]]

Output:
 true
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(nlog(n)) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Intervals</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/15
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MeetingRooms</span> <span class="o">{</span>
    <span class="cm">/**
     * Method to check if a person can attend all given meetings without any overlap.
     *
     * @param intervals 2D array where each sub-array contains two integers denoting the start and end time of a meeting.
     * @return boolean value - true if a person can attend all meetings, false otherwise.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canAttendMeetings</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Sort the meeting intervals based on their start time.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

        <span class="c1">// Iterate through the sorted intervals to check for any overlaps.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the start time of the current meeting is less than the end time of the previous meeting,</span>
            <span class="c1">// there is an overlap, and it's not possible to attend all meetings.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Found an overlapping meeting, return false</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// If no overlaps found, return true meaning all meetings can be attended.</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1: Overlapping meetings</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals1</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">30</span><span class="o">},</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">15</span><span class="o">,</span> <span class="mi">20</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can attend all meetings for intervals1: "</span> <span class="o">+</span> <span class="n">canAttendMeetings</span><span class="o">(</span><span class="n">intervals1</span><span class="o">));</span> <span class="c1">// Expected output: false</span>

        <span class="c1">// Test case 2: No overlapping meetings</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals2</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">10</span><span class="o">},</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">}</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can attend all meetings for intervals2: "</span> <span class="o">+</span> <span class="n">canAttendMeetings</span><span class="o">(</span><span class="n">intervals2</span><span class="o">));</span> <span class="c1">// Expected output: true</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Intervals"/><summary type="html"><![CDATA[252. Meeting Rooms]]></summary></entry><entry><title type="html">55.Jump Game</title><link href="https://zhengstar94.github.io//blog/2024/JumpGame/" rel="alternate" type="text/html" title="55.Jump Game"/><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://zhengstar94.github.io//blog/2024/JumpGame</id><content type="html" xml:base="https://zhengstar94.github.io//blog/2024/JumpGame/"><![CDATA[<h1 id="55-jump-game">55. Jump Game</h1> <ul> <li>You are given an integer array <code class="language-plaintext highlighter-rouge">nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</li> <li>Return <code class="language-plaintext highlighter-rouge">true</code> <em>if you can reach the last index, or</em> <code class="language-plaintext highlighter-rouge">false</code> <em>otherwise</em>.</li> </ul> <p><strong>Example 1</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre></div></div> <p><strong>Example 2</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
</code></pre></div></div> <h2 id="method-1">Method 1</h2> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>【O(n) time | O(1) space】
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Leetcode.Greedy</span><span class="o">;</span>

<span class="cm">/**
 * @author zhengstars
 * @date 2024/06/14
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JumpGame</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Initialize the farthest position that can be reached</span>
        <span class="kt">int</span> <span class="n">maxReach</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Traverse the array</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// If the current position is beyond the maxReach, it is not possible to continue</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">maxReach</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// Update maxReach</span>
            <span class="n">maxReach</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxReach</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// If maxReach is enough to reach the last position or beyond, return true</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">maxReach</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// After traversing, if still not able to reach the last position, return false</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Test case 1</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can jump for nums1: "</span> <span class="o">+</span> <span class="n">canJump</span><span class="o">(</span><span class="n">nums1</span><span class="o">));</span> <span class="c1">// Expected output: true</span>

        <span class="c1">// Test case 2</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can jump for nums2: "</span> <span class="o">+</span> <span class="n">canJump</span><span class="o">(</span><span class="n">nums2</span><span class="o">));</span> <span class="c1">// Expected output: false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode Greedy"/><summary type="html"><![CDATA[55. Jump Game]]></summary></entry></feed>