---
toc:
  beginning: true
giscus_comments: true
layout: post
title: "分布式事务解决方案Part1"
date: "2022-02-01"
categories: 
  - "分布式"
---


# 2PC

有一个事务管理器，负责协调多个数据库（资源管理器）的事务

1. 事务管理器先问各个数据库预提交 ok 吗？
2. 如果每个数据库都回复ok，即预提交成功，就正式提交事务，在各个数据库开始执行操作，这里失败会有失败异常重试，日志分析，人工重试。

**缺点：**
1. 同步阻塞问题
2. 单点故障
3. 同步阻塞问题


# TCC
- Try<br>
  对各个服务的资源做检测,对资源进行提前锁定或者预留
- Confirm<br>
  在各个服务中执行实际的操作
- Cancel<br>
  如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，即执行已操作成功的业务逻辑的回滚操作

> 一般来说和钱相关的支付、交易等相关的场景，我们会用TCC，严格严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性!

{% include figure.liquid loading="eager" path="assets/img/2022/02/image-79a7a0a641664ad4b0e5087fefd95172.png" class="img-fluid rounded z-depth-1" zoomable=true width="70%"%}


# 本地消息

- A系统在本地一个事务里操作的同时，插入一条数据到消息表
- 接着A系统将这个消息发送到MQ
- B系统接收到消息后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息
- B系统执行成功后，就会更新自己本地消息表的状态以及A系统消息表的状态
- 如果B系统处理失败，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再处理

**优点：**<br>
这个方案保证了最终一致性<br>
哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止


**缺点：**<br>
最大的问题就在于严重依赖于数据库的消息表来管理事务,这个会导致高并发场景无力,难以扩展呢,一般确实很少用

{% include figure.liquid loading="eager" path="assets/img/2022/02/image-450de6af0755471a896965ca00178b4a.png" class="img-fluid rounded z-depth-1" zoomable=true width="70%"%}

# 最终一致性
- A系统先发送一个prepared消息到MQ，如果这个prepared消息发送失败,那么就直接取消操作,不执行了
- 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉MQ发送确认消息，如果失败就告诉MQ回滚消息
- 如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地的事务
- MQ会自动定时轮询所有prepared消息回调你的接口，问你这个消息是不是本地事务处理失败了，所有没发送确认的消息,是继续重试还是回滚？
- 这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，别确认消息发送失败了。
- 如果系统B的事务失败了咋办？<br>
  重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿.

{% include figure.liquid loading="eager" path="assets/img/2022/02/image-34bf0d9a13ae4893be3ef0913284eb15.png" class="img-fluid rounded z-depth-1" zoomable=true width="70%"%}


# 最大努力通知方案
- 系统A本地事务执行完后，发送一个消息到MQ
- 有一专门消费MQ的最大努力通知服务，会消费MQ,然后写入数据库中记录下来，亦可是放入内存队列，接着调用系统B的接口
- 若系统B执行成功就ok；若系统B执行失败，那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行才放弃

{% include figure.liquid loading="eager" path="assets/img/2022/02/image-2184e38c44a84cc5b4c595daa995b9ac.png" class="img-fluid rounded z-depth-1" zoomable=true width="70%"%}

> 你找一个严格资金要求绝对不能错的场景，你可以说你是用的TCC方案<br>
> 如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案